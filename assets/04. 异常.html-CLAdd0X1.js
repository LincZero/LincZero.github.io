import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as i,a as t}from"./app-Bmv5Ekr9.js";const n={},c=t(`<h1 id="异常" tabindex="-1"><a class="header-anchor" href="#异常"><span>异常</span></a></h1><h2 id="异常处理方式" tabindex="-1"><a class="header-anchor" href="#异常处理方式"><span>异常处理方式</span></a></h2><h3 id="调用abort-或exit" tabindex="-1"><a class="header-anchor" href="#调用abort-或exit"><span>调用<code>abort()</code>或<code>exit()</code></span></a></h3><ul><li><code>abort()</code>函数 <ul><li>是</li></ul></li><li><code>exit()</code>函数 <ul><li>基本同上</li></ul></li><li><code>abort()</code>与<code>exit()</code>区别 <ul><li><code>abort()</code><ul><li>是否刷新<code>文件缓冲区</code>取决于实现</li><li>会向标准错误流</li></ul></li><li><code>exit()</code><ul><li>会刷新<code>文件缓冲区</code></li><li>不会显示信息</li></ul></li></ul></li><li>一些额外补充 <ul><li><code>标准错误流</code>：即<code>cerr</code>使用的错误流</li><li><code>文件缓冲区</code>：用于存储读写到文件中的数据的内存区域</li></ul></li></ul><h3 id="返回错误码" tabindex="-1"><a class="header-anchor" href="#返回错误码"><span>返回错误码</span></a></h3><p>通过函数的返回值来指出问题，该方式更灵活</p><h3 id="异常机制-throw-catch" tabindex="-1"><a class="header-anchor" href="#异常机制-throw-catch"><span>异常机制（<code>throw-catch</code>）</span></a></h3><p>通过抛出异常</p><ul><li><p>使用</p><ul><li><p>举例</p><div class="language-C++ line-numbers-mode" data-ext="C++" data-title="C++"><pre class="language-C++"><code>try {
    throw &quot;error1&quot;;  // 异常类型可以是字符串或其他C++类型，通常为类类型
}
catch (const char *s) {
    // ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>原理</p><ul><li><code>throw</code>语句导致程序<strong>沿函数调用序列后退</strong>，即栈解退，直到找到包含try块的函数</li><li><code>栈解退</code>（<em>unwinding the stack</em>） <ul><li>与函数调用的返回有点像但并不同</li><li>返回值会返回到调用它的函数，这个过程会释放函数有关的栈（如自动变量），以此类推</li><li>栈解退也释放栈，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块中的返回地址 随后，控制权将转到块尾的异常处理程序，而不是后面的第一条语句 如果没有找到这样的处理程序（try块），默认情况下程序将异常终止</li></ul></li><li>临时拷贝 <ul><li>引发异常时总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用</li><li>catch块一般使用引用类型的原因并非提高效率（无法做到），而是让其可以执行派生类对象</li></ul></li></ul></li></ul><h2 id="异常类" tabindex="-1"><a class="header-anchor" href="#异常类"><span>异常类</span></a></h2><h3 id="传递对象好处" tabindex="-1"><a class="header-anchor" href="#传递对象好处"><span>传递对象好处</span></a></h3><p>通常引发异常的函数会传递一个对象，优点：</p><ul><li><p>可以使用不同的异常类型区分不同的异常</p></li><li><p>对象可以携带信息，程序员可以根据这些信息来判断异常原因</p></li><li><p>对象可以携带信息，catch块可以根据这些信息来决定采取什么样的措施</p><ul><li><p>比如</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>try {
    // ...
}
catch (Error1 &amp;e){
    // ...
}
catch (Error2 &amp;e){
    // ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="exception类-exception头文件" tabindex="-1"><a class="header-anchor" href="#exception类-exception头文件"><span>exception类（exception头文件）</span></a></h3><h4 id="头文件exception-异常类" tabindex="-1"><a class="header-anchor" href="#头文件exception-异常类"><span>头文件exception（异常类）</span></a></h4><p>头文件<code>exception</code>/<code>exception.h</code>或<code>except.h</code>，定义了<code>exception</code>类</p><p>C++可以把它用作其他异常类的基类，C++库也定义了很多基于exception的异常类型（派生类）</p><h4 id="头文件stdexcept-标准异常类" tabindex="-1"><a class="header-anchor" href="#头文件stdexcept-标准异常类"><span>头文件stdexcept（标准异常类）</span></a></h4><p>头文件stdexcept定义了其他几个异常类</p><ul><li><code>logic_error</code>，逻辑错误，描述典型的逻辑错误 （基于exception类的派生类，其又派生出许多其他类） <ul><li><code>domain_error</code>，定义域错误，可以让函数在参数不再定义域之间是返回<code>domain_error</code>异常</li><li><code>invalid_argument</code>，无效的参数，可以指出给函数传递了一个意料外的值</li><li><code>length_error</code>，空间不足，可以指出没有足够的空间来执行所需的操作</li><li><code>out_of_bounds</code>，索引错误，可以用于指示索引错误</li></ul></li><li><code>runtime_error</code>，运行阶段错误，通常是可能在运行期间发生但难以预计和防范的错误 （基于exception类的派生类，其又派生出许多其他类） <ul><li><code>range_error</code>，非上下的溢出错误</li><li><code>overflow_error</code>，上溢出错误</li><li><code>underflow_error</code>，下溢出错误</li></ul></li></ul><h4 id="bad-alloc异常和头文件new" tabindex="-1"><a class="header-anchor" href="#bad-alloc异常和头文件new"><span>bad_alloc异常和头文件new</span></a></h4><p>对于使用new导致的内存分配问题，C++最新处理方式是让new引发<code>bad_alloc</code>异常</p><p>头文件<code>new</code>包含<code>bad_alloc</code>类的声明（定位new也是这个头文件），该异常类也是从exception类公有派生而来的</p><h4 id="空指针和new" tabindex="-1"><a class="header-anchor" href="#空指针和new"><span>空指针和new</span></a></h4><p>很多代码都是在new在失败时返回空指针时编写的，C++标准也提供了一种在失败时返回空指针的new</p><ul><li>使用： <ul><li>例如<code>int *pi = new (std::nothrow) int;</code></li><li>例如<code>int *pa = new (std::nothrow) int[500];</code></li></ul></li></ul><h2 id="异常规范和c-11" tabindex="-1"><a class="header-anchor" href="#异常规范和c-11"><span><s>异常规范和C++11</s></span></a></h2><ul><li>简概 <ul><li><code>异常规范</code>（<em>exception specification</em>）是C++98新增的一项功能，但C++11摒弃了</li><li>异常规范有些缺点，比如函数引发了异常规范中没有的异常时，其机制会导致处理起来比较麻烦</li></ul></li><li>作用 <ul><li>告诉用户可能需要使用try块。然而这项工作也可以使用注释轻松完成</li><li>让编译器添加执行运行阶段检查的代码，检查是否违反了异常规则。但这很难检查得到</li></ul></li><li>使用 <ul><li>例如<code>double harm(double a) throw(bad_thing);</code>，表示可能会抛出bad_thing类型的错误</li><li>例如<code>double marm(double) throw();</code>，表示不会抛出错误</li></ul></li></ul><p><code>noexcept</code></p><ul><li>作用 <ul><li>虽然C++11抛弃了异常规范，但还支持另一种异常规范：<code>noexcept</code>关键字能指出某函数不会引发异常</li></ul></li><li>写法 <ul><li>例如：<code>double marm() noexcept;</code></li></ul></li></ul><h2 id="意外异常、未捕获异常、默认行为" tabindex="-1"><a class="header-anchor" href="#意外异常、未捕获异常、默认行为"><span>意外异常、未捕获异常、默认行为</span></a></h2><h3 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h3><p>异常被引发后，在两种情况下回引发问题</p><ul><li>在带异常规范的函数中引发，则必须与规范列表中的某种异常匹配，否则称为<code>意外异常</code></li><li>如果异常不是在函数中引发（或则没有异常规范），则必须捕获它，否则该异常被称为<code>未捕获异常</code></li></ul><h3 id="未捕获异常" tabindex="-1"><a class="header-anchor" href="#未捕获异常"><span>未捕获异常</span></a></h3><p>未捕获异常会调用函数<code>terminate()</code>，默认情况下，<code>terminate()</code>调用<code>abort()</code>导致程序<strong>异常终止</strong></p><p>但可以用<code>set_terminate()</code>修改<code>terminate()</code>的默认行为（这两个函数都在头文件<code>exception</code>中被声明）</p><ul><li><p>方法</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>  typedef void (*terminate_handler)();
  terminate_handler set_terminate(terminate_handler f) throw(); 		// C++98，异常规范语法
  terminate_handler set_terminate(terminate_handler f) noexcept; 		// C++11，另一种异常规范
  void terminate();													// C++98
  void terminate() noexcept;											// C++11，另一种异常规范
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="意外异常" tabindex="-1"><a class="header-anchor" href="#意外异常"><span>意外异常</span></a></h3><p>情况与未捕获异常相似，会先调<code>unexpected()</code>函数，默认行为为<strong>程序异常终止</strong></p><p>但可以用<code>set_unexpected()</code>修改<code>unexpected()</code>的默认行为（这两个函数都在头文件<code>exception</code>中被声明）</p><ul><li><p>方法</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>  typedef void (*unexpected_handler)();
  unexpected_handler set_unexpected(unexpected_handler f) throw(); 	// C++98，异常规范语法
  unexpected_handler set_unexpected(unexpected_handler f) noexcept; 	// C++11，另一种异常规范
  void unexpected();													// C++98
  void unexpected() noexcept;											// C++11，另一种异常规范
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="功能扩展" tabindex="-1"><a class="header-anchor" href="#功能扩展"><span>功能扩展</span></a></h2><h3 id="异常-x-new类成员" tabindex="-1"><a class="header-anchor" href="#异常-x-new类成员"><span>异常 x new类成员</span></a></h3>`,44),a=[c];function d(o,r){return l(),i("div",null,a)}const h=e(n,[["render",d],["__file","04. 异常.html.vue"]]),u=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/04.%20%E5%BC%82%E5%B8%B8.html","title":"异常","lang":"zh-CN","frontmatter":{"description":"异常 异常处理方式 调用abort()或exit() abort()函数 是 exit()函数 基本同上 abort()与exit()区别 abort() 是否刷新文件缓冲区取决于实现 会向标准错误流 exit() 会刷新文件缓冲区 不会显示信息 一些额外补充 标准错误流：即cerr使用的错误流 文件缓冲区：用于存储读写到文件中的数据的内存区域 返回错...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/04.%20%E5%BC%82%E5%B8%B8.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"异常"}],["meta",{"property":"og:description","content":"异常 异常处理方式 调用abort()或exit() abort()函数 是 exit()函数 基本同上 abort()与exit()区别 abort() 是否刷新文件缓冲区取决于实现 会向标准错误流 exit() 会刷新文件缓冲区 不会显示信息 一些额外补充 标准错误流：即cerr使用的错误流 文件缓冲区：用于存储读写到文件中的数据的内存区域 返回错..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"异常\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"异常","slug":"异常","link":"#异常","children":[{"level":2,"title":"异常处理方式","slug":"异常处理方式","link":"#异常处理方式","children":[{"level":3,"title":"调用abort()或exit()","slug":"调用abort-或exit","link":"#调用abort-或exit","children":[]},{"level":3,"title":"返回错误码","slug":"返回错误码","link":"#返回错误码","children":[]},{"level":3,"title":"异常机制（throw-catch）","slug":"异常机制-throw-catch","link":"#异常机制-throw-catch","children":[]}]},{"level":2,"title":"异常类","slug":"异常类","link":"#异常类","children":[{"level":3,"title":"传递对象好处","slug":"传递对象好处","link":"#传递对象好处","children":[]},{"level":3,"title":"exception类（exception头文件）","slug":"exception类-exception头文件","link":"#exception类-exception头文件","children":[{"level":4,"title":"头文件exception（异常类）","slug":"头文件exception-异常类","link":"#头文件exception-异常类","children":[]},{"level":4,"title":"头文件stdexcept（标准异常类）","slug":"头文件stdexcept-标准异常类","link":"#头文件stdexcept-标准异常类","children":[]},{"level":4,"title":"bad_alloc异常和头文件new","slug":"bad-alloc异常和头文件new","link":"#bad-alloc异常和头文件new","children":[]},{"level":4,"title":"空指针和new","slug":"空指针和new","link":"#空指针和new","children":[]}]}]},{"level":2,"title":"异常规范和C++11","slug":"异常规范和c-11","link":"#异常规范和c-11","children":[]},{"level":2,"title":"意外异常、未捕获异常、默认行为","slug":"意外异常、未捕获异常、默认行为","link":"#意外异常、未捕获异常、默认行为","children":[{"level":3,"title":"简概","slug":"简概","link":"#简概","children":[]},{"level":3,"title":"未捕获异常","slug":"未捕获异常","link":"#未捕获异常","children":[]},{"level":3,"title":"意外异常","slug":"意外异常","link":"#意外异常","children":[]}]},{"level":2,"title":"功能扩展","slug":"功能扩展","link":"#功能扩展","children":[{"level":3,"title":"异常 x new类成员","slug":"异常-x-new类成员","link":"#异常-x-new类成员","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.13,"words":1539},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/04. 优化/04. 异常.md","autoDesc":true}');export{h as comp,u as data};
