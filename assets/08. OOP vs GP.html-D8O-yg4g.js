import{_ as t,c as a,e as l,a as n,b as i,o as r,r as o}from"./app-CgN_bpaE.js";const d="/assets/20210319000028665-BTc30K0m.png",c={};function p(m,e){const s=o("Mermaid");return r(),a("div",null,[e[2]||(e[2]=l(`<h1 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C++</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="oop-vs-gp" tabindex="-1"><a class="header-anchor" href="#oop-vs-gp"><span>OOP vs GP</span></a></h1><h2 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较</span></a></h2><h3 id="数据和方法的区别" tabindex="-1"><a class="header-anchor" href="#数据和方法的区别"><span>数据和方法的区别</span></a></h3><ul><li><p>OOP的目的是将<strong>数据</strong>和<strong>方法</strong>绑定在一起</p><ul><li>例如对<code>std::list</code>容器进行排序要调用<code>std::list::sort</code>方法</li></ul></li><li><p>GP的目的是将<strong>数据</strong>和<strong>方法</strong>分离开来</p><ul><li>例如对<code>std::vector</code>容器进行排序要调用<code>std::sort</code>方法</li></ul></li></ul><h3 id="oop-object-oriented-programming" tabindex="-1"><a class="header-anchor" href="#oop-object-oriented-programming"><span>OOP（Object-Oriented Programming）</span></a></h3><p><mark>OOP企图将 datas 和 methods 关联在一起</mark></p><p>类定义</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>/* list类 */
template &lt;class T, class Alloc=alloc&gt;
class list {
    //...
    void sort();
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Q：引申问题：为什么list不能用<code>::sort</code>排序</li><li>A：<code>std::sort</code>的实现使用了随机访问，而list不能随机访问，不能用<code>::sort</code>排序</li></ul><h3 id="gp-generic-programming" tabindex="-1"><a class="header-anchor" href="#gp-generic-programming"><span>GP（Generic Programming）</span></a></h3><p>标准库使用GP编程</p><p><mark>GP却是将 datas 和 methods 分开来</mark></p><p>类定义（这两个容器都提供 RandomAccessIterator 随机遍历器）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>/* vector类 */
template &lt;class T, class Alloc=alloc&gt;
class vector {
    //...
    //（没有sort方法）
};

/* deque类 */
template &lt;class T, class Alloc=alloc, size_t BufSiz=0&gt;
class deque {
    //...
    //（没有sort方法）
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>算法 Algorithms（排序）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>template&lt;typename _RandomAccessIterator&gt;
inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
    // std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
}

template&lt;typename _RandomAccessIterator, typename _Compare&gt;
inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
    if (__first != __last) {
        std::__introsort_loop(__first, __last,
                              std::__lg(__last - __first) * 2,		// 对iterator进行减运算,std::list的iterator没有实现该运算
                              __comp);
        std::__final_insertion_sort(__first, __last, __comp);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="gp-补充" tabindex="-1"><a class="header-anchor" href="#gp-补充"><span>GP 补充</span></a></h2><h3 id="好处" tabindex="-1"><a class="header-anchor" href="#好处"><span>好处</span></a></h3><ul><li>Containers 和 Algorithms 团队可以各自开发，其间以Iterator沟通即可</li><li>Algorithms 通过 Iterator 确定操作范围，并通过Iterator取用Container元素</li></ul><h3 id="组件结构" tabindex="-1"><a class="header-anchor" href="#组件结构"><span>组件结构</span></a></h3>`,22)),n("ul",null,[n("li",null,[e[0]||(e[0]=n("p",null,"图示",-1)),i(s,{id:"mermaid-106",code:"eJxLL0osyFAIceJ6snv/0/a9z6ZuiHcrzUsuyS8qjn+yrzs5P7cALqOra8f1fN30Z5unxjvmpOcXZZZk5IJVFecXlTybthMooav3Yv/aJ7sXP525It6zJLUoEWSQnh5Q49N1O0GCzvl5JYmZeakQ48tSQTY965iWklpYmgpRwgUAR9tM7w=="})]),n("li",null,[e[1]||(e[1]=n("p",null,"复习下六组件结构",-1)),i(s,{id:"mermaid-112",code:"eJxLL0osyFDwCeIqLk2CsF/sX/tk9+KnM1e8bGh62doLZHBxwsW4UvNSEEqfrtuJqg4igKroye79T9v3Ppu6AUkdXAys9GlHG0RCV9cOagJcAVDo+brpzzZP1dXTtYM7A8SBqgQAhp9q3Q=="})])]),e[3]||(e[3]=l('<h2 id="操作符重载-vs-模板-泛化、全特化、偏特化" tabindex="-1"><a class="header-anchor" href="#操作符重载-vs-模板-泛化、全特化、偏特化"><span>操作符重载 vs 模板（泛化、全特化、偏特化）</span></a></h2><p><img src="'+d+'" alt="请添加图片描述" loading="lazy"></p><h3 id="operator-overloading-操作符重载" tabindex="-1"><a class="header-anchor" href="#operator-overloading-操作符重载"><span>Operator Overloading 操作符重载</span></a></h3><p>略</p><h3 id="templates-模板" tabindex="-1"><a class="header-anchor" href="#templates-模板"><span>Templates 模板</span></a></h3><p>略</p>',6))])}const g=t(c,[["render",p],["__file","08. OOP vs GP.html.vue"]]),u=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/STL/08.%20OOP%20vs%20GP.html","title":"C++","lang":"zh-CN","frontmatter":{"description":"C++ 目录 OOP vs GP 比较 数据和方法的区别 OOP的目的是将数据和方法绑定在一起 例如对std::list容器进行排序要调用std::list::sort方法 GP的目的是将数据和方法分离开来 例如对std::vector容器进行排序要调用std::sort方法 OOP（Object-Oriented Programming） OOP企图...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/STL/08.%20OOP%20vs%20GP.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"C++"}],["meta",{"property":"og:description","content":"C++ 目录 OOP vs GP 比较 数据和方法的区别 OOP的目的是将数据和方法绑定在一起 例如对std::list容器进行排序要调用std::list::sort方法 GP的目的是将数据和方法分离开来 例如对std::vector容器进行排序要调用std::sort方法 OOP（Object-Oriented Programming） OOP企图..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"C++","slug":"c","link":"#c","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"OOP vs GP","slug":"oop-vs-gp","link":"#oop-vs-gp","children":[{"level":2,"title":"比较","slug":"比较","link":"#比较","children":[{"level":3,"title":"数据和方法的区别","slug":"数据和方法的区别","link":"#数据和方法的区别","children":[]},{"level":3,"title":"OOP（Object-Oriented Programming）","slug":"oop-object-oriented-programming","link":"#oop-object-oriented-programming","children":[]},{"level":3,"title":"GP（Generic Programming）","slug":"gp-generic-programming","link":"#gp-generic-programming","children":[]}]},{"level":2,"title":"GP 补充","slug":"gp-补充","link":"#gp-补充","children":[{"level":3,"title":"好处","slug":"好处","link":"#好处","children":[]},{"level":3,"title":"组件结构","slug":"组件结构","link":"#组件结构","children":[]}]},{"level":2,"title":"操作符重载 vs 模板（泛化、全特化、偏特化）","slug":"操作符重载-vs-模板-泛化、全特化、偏特化","link":"#操作符重载-vs-模板-泛化、全特化、偏特化","children":[{"level":3,"title":"Operator Overloading 操作符重载","slug":"operator-overloading-操作符重载","link":"#operator-overloading-操作符重载","children":[]},{"level":3,"title":"Templates 模板","slug":"templates-模板","link":"#templates-模板","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.65,"words":496},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/STL/08. OOP vs GP.md","excerpt":"\\n<h1>目录</h1>\\n<h1>OOP vs GP</h1>\\n<h2>比较</h2>\\n<h3>数据和方法的区别</h3>\\n<ul>\\n<li>\\n<p>OOP的目的是将<strong>数据</strong>和<strong>方法</strong>绑定在一起</p>\\n<ul>\\n<li>例如对<code>std::list</code>容器进行排序要调用<code>std::list::sort</code>方法</li>\\n</ul>\\n</li>\\n<li>\\n<p>GP的目的是将<strong>数据</strong>和<strong>方法</strong>分离开来</p>\\n<ul>\\n<li>例如对<code>std::vector</code>容器进行排序要调用<code>std::sort</code>方法</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{g as comp,u as data};
