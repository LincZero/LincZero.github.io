import{_ as e,e as i,g as t,o as a}from"./app-HvNDXJEG.js";const n="/assets/2b7231b6aabb9a9a2e2390ab3a280b2d-CXvjVdaB.png",l="/assets/26f88373d8454682b9e0c1d4fd1611b4-DFb7QQN8.png",p="/assets/redis%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%98%A0%E5%B0%84%E5%88%86%E5%B8%83%E5%85%B3%E7%B3%BB-iqeT-X5i.jpg",r={};function o(d,s){return a(),i("div",null,s[0]||(s[0]=[t('<h1 id="redis-高可用与集群" tabindex="-1"><a class="header-anchor" href="#redis-高可用与集群"><span>Redis 高可用与集群</span></a></h1><h2 id="redis-集群" tabindex="-1"><a class="header-anchor" href="#redis-集群"><span>Redis 集群</span></a></h2><h3 id="redis-实现服务高可用" tabindex="-1"><a class="header-anchor" href="#redis-实现服务高可用"><span>Redis 实现服务<strong>高可用</strong></span></a></h3><p>所谓的<strong>高可用</strong>Redis 服务，一定要从 Redis 的<em>多服务节点</em>来考虑，比如 Redis 的主从复制、哨兵模式、切片集群</p><p>“高可用” 为什么就是多服务节点呢？</p><blockquote><p>GPT：</p><p><strong>“高可用”</strong>，通常缩写为<strong>HA（High Availability）</strong>，在计算机领域，特别是分布式系统中，指的是系统能够尽可能长时间地提供服务的能力。换句话说，就是系统在<em>面对硬件故障、软件错误、网络中断等各种异常情况</em>时，能够自动恢复并继续提供服务，以保证业务的连续性。</p><p><strong>高可用性</strong>，简单来说就是保证服务在大部分情况下都能正常运行，即使出现故障也能快速恢复。而<strong>多服务节点</strong>或<strong>集群</strong>是实现这种高可用性的常见手段。</p></blockquote><h4 id="提前总结" tabindex="-1"><a class="header-anchor" href="#提前总结"><span>提前总结</span></a></h4><ul><li>主从复制 <ul><li>缺点：无强一致性问题、故障需要手动恢复</li></ul></li><li>哨兵模式 <ul><li>优点：能故障转移</li></ul></li><li>切片集群模式 <ul><li>特点：分布式数据 (前两个都是备份的方式)</li></ul></li></ul><h4 id="_1-主从复制" tabindex="-1"><a class="header-anchor" href="#_1-主从复制"><span>(1) 主从复制</span></a></h4><p>主从复制是 Redis 高可用服务的最基础的保证</p><p>实现方案</p><blockquote><p>将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即<em>一主多从</em>的模式，且主从服务器之间采用的是「<em>读写分离</em>」的方式。</p><p><em>主服务器可以进行读写</em>操作，当发生写操作时自动将写操作同步给从服务器。</p><p><em>从服务器一般是只读</em>，并接受主服务器同步过来写操作命令，然后执行这条命令。</p><p><img src="'+n+'" alt="img" loading="lazy"></p><p>也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。</p></blockquote><p>缺点 - 一致性问题</p><blockquote><p>一致性问题</p><p>注意，主从服务器之间的命令复制是<strong>异步</strong>进行的。</p><p>具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。</p><p>所以，<strong>无法实现强一致性保证</strong>（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p></blockquote><p>缺点 - 故障问题</p><blockquote><p>在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。</p></blockquote><p>TIP</p><blockquote><p>想更详细了解 Redis 主从复制的工作原理，可以详细看这篇：<a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html" target="_blank" rel="noopener noreferrer">主从复制是怎么实现的？</a></p></blockquote><h4 id="_2-哨兵模式-redis-sentinel" tabindex="-1"><a class="header-anchor" href="#_2-哨兵模式-redis-sentinel"><span>(2) 哨兵模式（Redis Sentinel）</span></a></h4><p>为了解决主从服务的故障问题，Redis 增加了哨兵模式，因为哨兵模式做到了可以监控主从服务器，并且提供<strong>主从节点故障转移的功能。</strong></p><p><img src="'+l+'" alt="img" loading="lazy"></p><p>TIP</p><blockquote><p>想更详细了解 Redis 哨兵的工作原理，可以详细看这篇：<a href="https://xiaolincoding.com/redis/cluster/sentinel.html" target="_blank" rel="noopener noreferrer">哨兵是怎么实现的？</a></p></blockquote><h4 id="_3-切片集群模式-redis-cluster" tabindex="-1"><a class="header-anchor" href="#_3-切片集群模式-redis-cluster"><span>(3) 切片集群模式（Redis Cluster ）</span></a></h4><p>特点</p><blockquote><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群（Redis Cluster ）方案，它将<strong>数据分布</strong>在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p></blockquote><p>原理</p><blockquote><p>哈希槽（Hash Slot）</p><p>数量和算法：</p><p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p><ol><li><p>根据键值对的 key，按照 <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener noreferrer">CRC16 算法</a>计算一个 16 bit 的值。</p></li><li><p>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</p></li></ol><p>映射到节点：</p><p>接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p><ul><li><strong>平均分配</strong>： 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。</li><li><strong>手动分配</strong>： 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li></ul><p>为了方便你的理解，我通过一张图来解释数据、哈希槽，以及节点三者的映射分布关系。</p><p><img src="'+p+`" alt="img" loading="lazy"></p><p>上图中的切片集群一共有 2 个节点，假设有 4 个哈希槽（Slot 0～Slot 3）时，我们就可以通过命令手动分配哈希槽，比如节点 1 保存哈希槽 0 和 1，节点 2 保存哈希槽 2 和 3。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">redis</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">cli </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">h </span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">192.168.1.10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> –p </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cluster addslots </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">redis</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">cli </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">h </span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">192.168.1.11</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> –p </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cluster addslots </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到哈希槽 1（对应节点1） 和 哈希槽 2（对应节点2）。</p><p>需要注意的是，在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</p></blockquote><h3 id="集群脑裂导致数据丢失怎么办" tabindex="-1"><a class="header-anchor" href="#集群脑裂导致数据丢失怎么办"><span>集群脑裂导致数据丢失怎么办？</span></a></h3><h4 id="什么是脑裂" tabindex="-1"><a class="header-anchor" href="#什么是脑裂"><span>什么是脑裂？</span></a></h4><p>先来理解集群的脑裂现象，这就好比一个人有两个大脑，那么到底受谁控制呢？</p><p>那么在 Redis 中，集群脑裂产生数据丢失的现象是怎样的呢？</p><p>在 Redis 主从架构中，部署方式一般是「<strong>一主多从</strong>」，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p><p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在「从节点」中选举出一个 leader 作为主节点，<strong>这时集群就有两个主节点了 —— 脑裂出现了</strong></p><h4 id="为什么脑裂导致数据丢失" tabindex="-1"><a class="header-anchor" href="#为什么脑裂导致数据丢失"><span>为什么脑裂导致数据丢失</span></a></h4><p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题。</p><p>总结一句话就是：</p><ol><li>由于网络问题，导致集群节点之间<em>失去联系</em>，导致主从数据不同步；</li><li>重新平衡选举，导致<em>产生两个主服务</em>；</li><li>等网络恢复，<em>旧主节点会降级为从节点</em>，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</li></ol><h4 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h4><p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p><p>在 Redis 的配置文件中有两个参数我们可以设置：</p><ul><li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li><li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li></ul><p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p><p>这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</p><p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p><p><strong>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。</strong></p><p>再来举个例子：</p><p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。</p><p>同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。</p><p>这样一来，主从切换完成后，也只有新主库能接收请求，<em>不会发生脑裂，也就不会发生数据丢失的问题了</em>。</p>`,50)]))}const g=e(r,[["render",o],["__file","04. 高可用与集群.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/04.%20%E5%9B%BE%E8%A7%A3Redis/01.%20%E9%9D%A2%E8%AF%95%E7%AF%87/04.%20%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4.html","title":"Redis 高可用与集群","lang":"zh-CN","frontmatter":{"description":"Redis 高可用与集群 Redis 集群 Redis 实现服务高可用 所谓的高可用Redis 服务，一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群 “高可用” 为什么就是多服务节点呢？ GPT： “高可用”，通常缩写为HA（High Availability），在计算机领域，特别是分布式系统中，指的是系统能...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/04.%20%E5%9B%BE%E8%A7%A3Redis/01.%20%E9%9D%A2%E8%AF%95%E7%AF%87/04.%20%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Redis 高可用与集群"}],["meta",{"property":"og:description","content":"Redis 高可用与集群 Redis 集群 Redis 实现服务高可用 所谓的高可用Redis 服务，一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群 “高可用” 为什么就是多服务节点呢？ GPT： “高可用”，通常缩写为HA（High Availability），在计算机领域，特别是分布式系统中，指的是系统能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 高可用与集群\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":8.92,"words":2677},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/04. 图解Redis/01. 面试篇/04. 高可用与集群.md","excerpt":"\\n<h2>Redis 集群</h2>\\n<h3>Redis 实现服务<strong>高可用</strong></h3>\\n<p>所谓的<strong>高可用</strong>Redis 服务，一定要从 Redis 的<em>多服务节点</em>来考虑，比如 Redis 的主从复制、哨兵模式、切片集群</p>\\n<p>“高可用” 为什么就是多服务节点呢？</p>\\n<blockquote>\\n<p>GPT：</p>\\n<p><strong>“高可用”</strong>，通常缩写为<strong>HA（High Availability）</strong>，在计算机领域，特别是分布式系统中，指的是系统能够尽可能长时间地提供服务的能力。换句话说，就是系统在<em>面对硬件故障、软件错误、网络中断等各种异常情况</em>时，能够自动恢复并继续提供服务，以保证业务的连续性。</p>\\n<p><strong>高可用性</strong>，简单来说就是保证服务在大部分情况下都能正常运行，即使出现故障也能快速恢复。而<strong>多服务节点</strong>或<strong>集群</strong>是实现这种高可用性的常见手段。</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/04. 图解Redis/01. 面试篇/04. 高可用与集群.md","value":{"title":"04. 高可用与集群","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/04. 图解Redis/01. 面试篇/04. 高可用与集群.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{g as comp,c as data};
