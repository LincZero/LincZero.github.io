import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as p,c as o,b as n,e as s,d as e,a as t}from"./app-BDO1bFk4.js";const c={},u=t(`<h1 id="different" tabindex="-1"><a class="header-anchor" href="#different"><span>Different</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="函数式编程" tabindex="-1"><a class="header-anchor" href="#函数式编程"><span>函数式编程</span></a></h1><h2 id="函数的使用" tabindex="-1"><a class="header-anchor" href="#函数的使用"><span>函数的使用</span></a></h2><h3 id="java-c" tabindex="-1"><a class="header-anchor" href="#java-c"><span>Java &amp; C++</span></a></h3><p>在类外定义方法</p><ul><li>Java / C# <ul><li>Java函数都在类中</li><li>这是<strong>纯面向对象</strong>语言的通用标准，C#也是如此： 不允许在类外定义变量、方法、事件等，强调一切皆是对象的思想。 即便是主函数的main，也必须定义在某个类里面。</li></ul></li><li>C++ <ul><li>允许在类外定义变量、方法、事件等</li></ul></li></ul><h3 id="python-c" tabindex="-1"><a class="header-anchor" href="#python-c"><span>Python &amp; C++</span></a></h3><p><strong>自定义函数写法</strong></p><ul><li><code>C语言</code>：<code>(类型)函数名() {}</code>，有主函数</li><li><code>Python</code>：<code>def 函数名():</code>，无需主函数/用init</li><li><code>Js</code>：无需主函数/用init <ul><li>普通形式：<code>function 函数名() {} </code></li><li>匿名函数：<code>function () {}</code>，立即执行：<code>;(function () {})()</code></li><li>箭头函数：<code>()=&gt;{}</code>，立即执行：<code>;(()=&gt;{})()</code></li></ul></li></ul><p><strong>是否声明形参类型</strong></p><ul><li><code>C、Java、Ts</code>：声明形参类型</li><li><code>Python、Js</code>：不声明形参类型</li></ul><p><strong>是否声明返回值</strong></p><ul><li><code>C、Java、Ts</code>：需定义函数时声明：是否有返回值、和返回值类型</li><li><code>Python、Js</code>：无需定义函数时声明：是否有返回值、和返回值类型</li></ul><p><strong>预声明函数原型</strong></p><ul><li><code>C、C++</code>：需要先声明函数原型（参数类型+返回值类型） <ul><li>函数原型声明（<em>Function Prototype</em>）原理 <ul><li>让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它</li><li>有了函数声明，函数定义就可以出现在任何地方了，甚至是其他文件、静态链接库、动态链接库等。</li></ul></li></ul></li><li><code>Python、Js</code>：不需要先声明函数原型</li></ul><p><strong>函数定义位置</strong></p><ul><li><p><code>C、C++</code>：函数定义在前还是在后都无所谓，但函数原型声明需要放在使用前</p></li><li><p><code>Python</code>：解释型语言函数定义必须放在前面，解释型语言不需要声明函数原型</p></li><li><p><code>Js</code>：解释型语言函数定义必须放在前面，，解释型语言不需要声明函数原型，<mark>变量提升例外</mark></p><ul><li><p>变量提升</p><ul><li>函数字面量声明式<code>function f(){}</code>的可以在函数定义前调用</li><li>定义变量式的<code>var f = function (){}</code>、<code>var f = new Function()</code>则不能</li><li>var定义的方式也是变量提升，但提升的是var而不是function。提前使用则是声明但未赋值的状态</li></ul></li><li><p>原理</p><ul><li>JavaScript 会<code>提升变量声明</code>（Hoisting），即<code>变量提升</code></li><li>意味着 var 表达式和 function 声明都将会被提升到当前作用域的顶部（var只声明不定义，提前使用时是<code>undefined</code>）</li></ul></li><li><p>变量提升 / 函数提升原理</p><ul><li>js是从上往下的顺序执行代码的。在一个作用域中，js会先进入“进入执行上下文阶段”。这个阶段分两步</li><li>第一步是创建用var关键字创建的变量（只是创建，不做其它操作）</li><li>第二步创建函数声明，也就是<code>function f() {}</code></li><li>之后js会进入“执行代码阶段”，也就是执行函数的计算或赋值等操作。所以<code>function f() {}</code>会在执行前就定义好了。</li></ul></li></ul></li></ul><h2 id="可变参数类型" tabindex="-1"><a class="header-anchor" href="#可变参数类型"><span>可变参数类型</span></a></h2><ul><li><p>Java</p><ul><li><p>可变参数类型，有时称为“变参”方法</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">PrintStream</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">String</span> fmt<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>TypeScript</p><ul><li><p>叫剩余参数，参考 https://www.tslang.cn/docs/handbook/functions.html</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>restOfName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> restOfName<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> employeeName <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Joseph&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Samuel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Lucas&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;MacKinzie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>Python</p><ul><li><p>Python的可变参数有两种，一种是列表类型，一种是字典类型</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># a接受一个常规参数，*args 接收的是一个tuple，**kwargs 接收一个dict</span>
<span class="token keyword">def</span> <span class="token function">ff</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token operator">*</span>b<span class="token punctuation">,</span><span class="token operator">**</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment"># 1232</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment"># (4, 5, 6, 7, 8)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment"># {&#39;ss&#39;: &#39;sadf&#39;, &#39;xx&#39;: &#39;fff&#39;, &#39;ww&#39;: &#39;asdf&#39;}</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&#39;__main__&#39;</span><span class="token punctuation">:</span>
    ff<span class="token punctuation">(</span><span class="token number">1232</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span>ss<span class="token operator">=</span><span class="token string">&quot;sadf&quot;</span><span class="token punctuation">,</span>xx<span class="token operator">=</span><span class="token string">&quot;fff&quot;</span><span class="token punctuation">,</span>ww<span class="token operator">=</span><span class="token string">&quot;asdf&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>C++</p><ul><li><p>参考</p><ul><li>https://blog.csdn.net/qychjj/article/details/98532841（含原理）</li><li>https://www.bilibili.com/read/cv13120050</li></ul></li><li><p>可变参数函数 - <code>...</code>，也叫 VA函数（variable argument function）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void func1(unsigned int argsNum, ...) {}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>可变参数宏 - <code> __VA_ARGS__</code></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// 略
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>可变参数模板 - <code>initializer_list</code></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// 略
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li></ul><h1 id="lambda" tabindex="-1"><a class="header-anchor" href="#lambda"><span>Lambda</span></a></h1><p>Lambda表达式【区别还挺大的】</p><h2 id="传递代码段的方式" tabindex="-1"><a class="header-anchor" href="#传递代码段的方式"><span>传递代码段的方式</span></a></h2><ul><li>Java <ul><li><strong>Java很难传递代码段</strong></li><li>在Java中传递一个代码段并不容易，不能直接传递代码段。 Java是一种纯面向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。</li><li>问题已经不是是否增强Java来支持函数式编程，而是要如何做到这一点。 设计者们做了多年的尝试，终于找到一种适合Java的设计 —— Lambda表达式（Java SE 8引入）</li></ul></li><li>其他语言 <ul><li>在其他语言中可以直接处理代码块。</li><li>Java设计者很长时间以来一直拒绝增加这个特性。Java非常重视其简单性和一致性。 他们认为如果只要一个特性能够让代码稍简洁一些，就把这个特性增加到语言中，这个语言很快就会变得一团糟，无法管理。</li></ul></li></ul><h2 id="概念上" tabindex="-1"><a class="header-anchor" href="#概念上"><span>概念上</span></a></h2><ul><li>Java <ul><li>lambda表达式所能做的也只是能转换为函数式接口。函数式接口这个概念其他语言也似乎是没有的</li></ul></li><li>其他语言 <ul><li>（这里指其他支持<strong>函数字面量</strong>的程序设计语言）</li><li>可以声明函数类型（如<code>(String, String) -&gt; int</code>）、声明这些类型的变量，还可以使用变量保存函数表达式。 不过，Java设计者还是决定保持我们熟悉的接口概念，<strong>没有为Java语言增加函数类型</strong>。</li></ul></li></ul><h2 id="写法上" tabindex="-1"><a class="header-anchor" href="#写法上"><span>写法上</span></a></h2><ul><li><p>Java</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 这里用了类型自动推导。另外，最重要的一点是：</span>
<span class="token comment">// 这里表示可以用来代替函数式接口来使用，而不是真的赋值、保存Lambda表达式</span>
<span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
<span class="token punctuation">{</span>
    first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用BiFunction倒是可以保存一个Lambda表达式到BiFunction变量中，但这没有什么用</span>
<span class="token comment">// 例如：没有哪个Arrays.sort方法想要接收一个BiFunction</span>
<span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Sting</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> comp
    <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// 语法
[捕获列表] (形参列表) mutable 异常列表-&gt; 返回类型
{
    函数体
}

/*
    捕获列表：捕获外部变量，捕获的变量可以在函数体中使用，可以省略，即不捕获外部变量。
    形参列表：和普通函数的形参列表一样。可省略，即无参数列表
    mutable：mutable 关键字，如果有，则表示在函数体中可以修改捕获变量，根据具体需求决定是否需要省略。
    异常列表：noexcept / throw(...),和普通函数的异常列表一样，可省略，即代表可能抛出任何类型的异常。
    返回类型：和函数的返回类型一样。可省略，如省略，编译器将自动推导返回类型。
    函数体：代码实现。可省略，但是没意义。
*/

// 举例
auto l = [](int x) -&gt; bool {
	// ...  
};

auto lambda = [a, b](int x, int y)mutable throw() -&gt; bool
{
    return a + b &gt; x + y;
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Python</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>self<span class="token punctuation">.</span>aboutAct <span class="token operator">=</span> QAction<span class="token punctuation">(</span><span class="token string">&quot;关于&quot;</span><span class="token punctuation">,</span> self<span class="token punctuation">,</span> statusTip<span class="token operator">=</span><span class="token string">&quot;关于界面&quot;</span>
                        <span class="token punctuation">,</span> triggered<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> QMessageBox<span class="token punctuation">.</span>about<span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">&quot;About MDI&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;WWWWWWWWWWWWW&quot;</span><span class="token punctuation">)</span>
                        <span class="token punctuation">)</span>  <span class="token comment"># def about(self);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>JavaScript</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token function-variable function">max</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token operator">&gt;</span>b<span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">;</span>
<span class="token comment">// 也可用es6的箭头写</span>
<span class="token keyword">let</span> <span class="token function-variable function">max</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> a<span class="token operator">&gt;</span>b<span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="闭包与变量捕获" tabindex="-1"><a class="header-anchor" href="#闭包与变量捕获"><span>闭包与变量捕获</span></a></h2><p>首先，**闭包 (closure）**是什么？</p>`,30),r=n("p",null,"参考：",-1),d={href:"https://zh.m.wikipedia.org/zh-hans/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)",target:"_blank",rel:"noopener noreferrer"},k={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures",target:"_blank",rel:"noopener noreferrer"},v={href:"https://baike.baidu.com/item/%E9%97%AD%E5%8C%85/10908873?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},m=t("<p>百度百科解释：</p><p>**（功能上.）**闭包就是能够读取其他函数内部变量的函数。</p><p>**（使用上.）**例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。</p><p>**（本质上.）**在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><hr><p>mozilla解释：</p><p>**（组成上.）**闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。</p><p>**（功能上.）**换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。</p><p>**（使用上.）**在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p><hr><p>Wiki：</p><p><strong>（概念上.）<strong>在计算机科学中，<strong>闭包（Closure）</strong>，又称</strong>词法闭包（Lexical Closure）<strong>或</strong>函数闭包（function closures）</strong>。 是在支持头等函数的编程语言中实现词法绑定的一种技术。</p><p><strong>（组成/实现上.）<strong>闭包是一个结构体，它存储了一个</strong>函数</strong>（通常是其入口地址）和一个关联的<strong>环境</strong>（相当于一个符号查找表）。 环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。</p><p>**（语言上.）**最早实现闭包的程序语言是Scheme。 之后，闭包被广泛使用于函数式编程语言 (如ML语言和LISP)，很多命令式程序语言也开始支持闭包。</p><p>**（区分闭包和　函数　.）**它们最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。 捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）。</p><p>**（区分闭包和匿名函数.）**它们经常被用作同义词。但严格来说，匿名函数就是字面意义上没有被赋予名称的函数，而闭包则实际上是一个函数的实例，也就是说它是存在于内存里的某个结构体。</p>",16),b=t(`<p>各种语言中（类似）闭包的结构</p><ul><li><h4 id="c语言" tabindex="-1"><a class="header-anchor" href="#c语言"><span>C语言</span></a></h4><ul><li><p>C语言的回调函数</p><blockquote><p>在C语言中，支持回调函数的库有时在注册时需要两个参数：一个函数指针，一个独立的<code>void*</code>指针用以保存用户数据。 这样的做法允许回调函数恢复其调用时的状态。这样的惯用法在功能上类似于闭包，但语法上有所不同。</p></blockquote></li><li><p>gcc对C语言的扩展</p><blockquote><p>gcc编译器对C语言实现了一种闭包的程序特性。</p></blockquote></li><li><p>C语言扩展：Blocks</p><blockquote><p>略</p></blockquote></li></ul></li><li><h4 id="c-函数对象" tabindex="-1"><a class="header-anchor" href="#c-函数对象"><span>C++函数对象</span></a></h4><ul><li><p>早期标准</p><blockquote><p>早期标准允许通过重载<code>operator()</code>来定义函数对象。这种对象的行为在某种程度上与函数式编程语言中的函数类似。</p><p>它们可以在运行时动态创建、保存状态，但是不能如闭包一般方便地隐式获取局部变量，并且有“专物专用”的繁琐问题——对于每一段闭包代码都要单独写一个函数对象类。</p></blockquote></li><li><p>C++11</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// C++11标准已经支持了闭包，这是一种特殊的函数对象，由特殊的语言结构——lambda表达式自动构建
void foo(string myname) {
	typedef vector&lt;string&gt; names;
	int y;
	names n;
	// ...
	names::iterator i =
	 find_if(n.begin(), n.end(), [&amp;](const string&amp; s){return s != myname &amp;&amp; s.size() &gt; y;});	
	// &#39;i&#39; 现在是&#39;n.end()&#39;或指向&#39;n&#39;中第一个
	// 不等于&#39;myname&#39;且长度大于&#39;y&#39;的字符串
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><h4 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h4><ul><li><p>Java SE 8 引入Lambda，可以用Lambda来实现闭包</p></li><li><p>注意事项</p><ul><li>① 只能引用值不会改变的变量</li><li>② 不能引用可能在外部被改变的变量</li><li>③ 不能声明同名变量</li><li>④ this的含义</li></ul></li><li><p>代码举例</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 这里捕获了text变量。不怕函数结束时该变量被销毁</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印：Hello every 1,000 milliseconds</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><h4 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript"><span>JavaScript</span></a></h4><ul><li><p>JavaScript 在闭包上要简单许多 Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量 JavaScript 变量可以是局部变量或全局变量。私有变量可以用到闭包。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 实例1，a 是一个 局部 变量</span>
<span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实例2，a 是一个 全局 变量</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>`,2);function g(h,f){const a=i("ExternalLinkIcon");return p(),o("div",null,[u,n("blockquote",null,[r,n("ul",null,[n("li",null,[n("a",d,[s("【Wiki】闭包 (计算机科学)"),e(a)])]),n("li",null,[n("a",k,[s("【Mozilla】闭包"),e(a)])]),n("li",null,[n("a",v,[s("【百度百科】闭包"),e(a)])])]),m]),b])}const E=l(c,[["render",g],["__file","01. 函数式编程.html.vue"]]),C=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Different/05.%20%E5%B0%81%E8%A3%85/01.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html","title":"Different","lang":"zh-CN","frontmatter":{"description":"Different 目录 函数式编程 函数的使用 Java & C++ 在类外定义方法 Java / C# Java函数都在类中 这是纯面向对象语言的通用标准，C#也是如此： 不允许在类外定义变量、方法、事件等，强调一切皆是对象的思想。 即便是主函数的main，也必须定义在某个类里面。 C++ 允许在类外定义变量、方法、事件等 Python & C++...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Different/05.%20%E5%B0%81%E8%A3%85/01.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Different"}],["meta",{"property":"og:description","content":"Different 目录 函数式编程 函数的使用 Java & C++ 在类外定义方法 Java / C# Java函数都在类中 这是纯面向对象语言的通用标准，C#也是如此： 不允许在类外定义变量、方法、事件等，强调一切皆是对象的思想。 即便是主函数的main，也必须定义在某个类里面。 C++ 允许在类外定义变量、方法、事件等 Python & C++..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Different\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Different","slug":"different","link":"#different","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"函数式编程","slug":"函数式编程","link":"#函数式编程","children":[{"level":2,"title":"函数的使用","slug":"函数的使用","link":"#函数的使用","children":[{"level":3,"title":"Java & C++","slug":"java-c","link":"#java-c","children":[]},{"level":3,"title":"Python & C++","slug":"python-c","link":"#python-c","children":[]}]},{"level":2,"title":"可变参数类型","slug":"可变参数类型","link":"#可变参数类型","children":[]}]},{"level":1,"title":"Lambda","slug":"lambda","link":"#lambda","children":[{"level":2,"title":"传递代码段的方式","slug":"传递代码段的方式","link":"#传递代码段的方式","children":[]},{"level":2,"title":"概念上","slug":"概念上","link":"#概念上","children":[]},{"level":2,"title":"写法上","slug":"写法上","link":"#写法上","children":[]},{"level":2,"title":"闭包与变量捕获","slug":"闭包与变量捕获","link":"#闭包与变量捕获","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":10.1,"words":3030},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Different/05. 封装/01. 函数式编程.md","autoDesc":true}');export{E as comp,C as data};
