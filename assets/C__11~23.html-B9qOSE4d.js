import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as t}from"./app-5ajJQ-aM.js";const e={},o=t(`<ol><li>C++11: <ol><li>(1) 可变参数模板：可以使模板函数接受任意数量的参数。</li><li>(2) 智能指针：std::unique_ptr、std::shared_ptr和std::weak_ptr。</li><li>(3) 移动语义：可以更有效地使用内存和处理器资源。</li><li>(4) lambda函数：提供了一种更加简洁和高效的方式来定义本地函数。</li><li>(5) 并行算法：可以在多核处理器上更有效地运行算法。</li></ol></li><li>C++14: <ol><li>(1) 泛型lambda：可以使用模板参数的lambda函数。</li><li>(2) 可选参数和可变参数模板：可以更灵活地定义函数的参数。</li><li>(3) 常量表达式：可以使用常量值来定义对象。</li><li>(4) 初始化列表的繁琐：可以简化初始化列表的语法。</li></ol></li><li>C++17: <ol><li>(1) 新的for循环：可以使用新的范围for循环以更简洁的方式遍历容器。</li><li>(2) 泛型算法：可以使用泛型算法来完成更复杂的任务。</li><li>(3) 并发库：提供了一组API来支持并发编程。</li><li>(4) 面向对象编程：引入了一组新的特性，如虚函数、抽象类、继承等，来支持面向对象编程。</li></ol></li><li>C++20: <ol><li>(1) 运算符重载：可以重载运算符以定义类型的新操作。</li><li>(2) 模板字面量：可以定义模板字面量来表示常量值。</li><li>(3) 模板别名：可以使用简单的语法来定义模板别名。</li><li>(4) 模板参数包：可以使用参数包来传递任意数量的参数。</li><li>(5) 内联变量：可以定义内联变量，其值可以在编译时被确定。</li></ol></li></ol><hr><p>Q：用代码示例说明模板元编程和模板编程的区别</p><p>A：下面是一个简单的代码示例，演示了模板编程和模板元编程的区别：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>

<span class="token comment">// 模板编程示例</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">add</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 模板元编程示例</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> N <span class="token operator">*</span> factorial<span class="token operator">&lt;</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模板编程示例</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 模板元编程示例</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> factorial<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> factorial<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> factorial<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// std::cout &lt;&lt; factorial&lt;-1&gt;::value &lt;&lt; std::endl; // 编译时错误：无法实例化负数的阶乘</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，<code>add</code> 是一个模板函数，可以接受任意类型的参数。这个函数主要关注于代码的通用性和重用性，通过模板实现了对不同类型的支持。</p><p>而 <code>factorial</code> 是一个模板类，用于计算阶乘。在这个模板类中，使用了递归和静态成员变量的方式来计算阶乘。这个模板类的计算是在编译期间完成的，因此可以在运行时节省计算时间。这个示例主要关注于在编译期间进行元编程和优化。</p><p>因此，模板编程和模板元编程的区别在于：模板编程主要关注代码的通用性和重用性，而模板元编程则更注重在编译期间对程序进行优化和计算。</p><hr>`,9),p=[o];function l(c,i){return s(),a("div",null,p)}const d=n(e,[["render",l],["__file","C__11~23.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/08.%20%E6%96%B0%E7%89%B9%E6%80%A7/C__11~23.html","title":"","lang":"zh-CN","frontmatter":{"description":"C++11: (1) 可变参数模板：可以使模板函数接受任意数量的参数。 (2) 智能指针：std::unique_ptr、std::shared_ptr和std::weak_ptr。 (3) 移动语义：可以更有效地使用内存和处理器资源。 (4) lambda函数：提供了一种更加简洁和高效的方式来定义本地函数。 (5) 并行算法：可以在多核处理器上更有效...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/08.%20%E6%96%B0%E7%89%B9%E6%80%A7/C__11~23.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:description","content":"C++11: (1) 可变参数模板：可以使模板函数接受任意数量的参数。 (2) 智能指针：std::unique_ptr、std::shared_ptr和std::weak_ptr。 (3) 移动语义：可以更有效地使用内存和处理器资源。 (4) lambda函数：提供了一种更加简洁和高效的方式来定义本地函数。 (5) 并行算法：可以在多核处理器上更有效..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.74,"words":823},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/08. 新特性/C++11~23.md","autoDesc":true}');export{d as comp,k as data};
