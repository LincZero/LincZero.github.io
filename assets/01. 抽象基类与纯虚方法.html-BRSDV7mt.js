import{_ as l,c as i,e as n,o as t}from"./app-BG6lKC-Y.js";const p={};function a(o,e){return t(),i("div",null,e[0]||(e[0]=[n('<h1 id="抽象基类与纯虚方法" tabindex="-1"><a class="header-anchor" href="#抽象基类与纯虚方法"><span>抽象基类与纯虚方法</span></a></h1><h2 id="抽象基类" tabindex="-1"><a class="header-anchor" href="#抽象基类"><span>抽象基类</span></a></h2><h3 id="抽象基类-1" tabindex="-1"><a class="header-anchor" href="#抽象基类-1"><span>抽象基类</span></a></h3><ul><li><p>简概</p><ul><li><p>这是一种理念。具系统性，更规范</p><p>（一种学院派思想认为，如果涉及基础层次，则只能将那些不会被用作基类的类设计为具体类）</p></li></ul></li><li><p>好处</p><ul><li><p>可以将ABC看作是一种必须实施的接口，要求派生类覆盖其纯虚函数，迫使派生类遵循ABC设计的接口规则</p><p>（因为纯虚函数没有定义，如果派生类没有覆盖其纯虚函数，则会报错）</p></li><li><p>使用ABC使得组件设计人员能够制定“接口约定”</p></li></ul></li><li><p>特点</p><ul><li><p>抽象基类（<em>abstract base class</em>，ABC）</p><p>抽象基类的命名可以以ABC作为结尾标注</p></li><li><p>抽象基类不能创建对象</p><p>与之相反的，其派生类可为具体类（<em>concrete class</em>），这表示可以创建这些类型的对象</p></li></ul></li><li><p>使用场景</p><ul><li>比如圆和椭圆可以继承一个抽象基类，而不是让圆去继承椭圆</li><li>抽象基类为原和椭圆共性的抽象</li></ul></li></ul><h4 id="纯虚函数" tabindex="-1"><a class="header-anchor" href="#纯虚函数"><span>纯虚函数</span></a></h4><ul><li><p>简概</p><ul><li>纯虚函数（<em>pure virtual function</em>）提供未实现的函数</li></ul></li><li><p>使用</p><ul><li>定义方法：虚函数，且在函数原型声明的结尾处加<code>=0</code></li><li>例如：<code>virtual double Area() const = 0;</code></li></ul></li><li><p>特点</p><ul><li><p>当类声明中包含纯虚函数时，指出类是一个抽象基类，即不能创建该类的对象</p><p>这样设计的理念是：<strong>要称为真正的ABC，必须至少包含一个纯虚函数</strong></p></li><li><p>在类中可以不定义该纯虚函数（只用原型声明就行，定义让派生类去实现）</p></li></ul></li></ul><h4 id="override-c-11-重写" tabindex="-1"><a class="header-anchor" href="#override-c-11-重写"><span>override（C++11）重写</span></a></h4><ul><li>参考：https://www.cnblogs.com/xinxue/p/5471708.html</li><li>使用 <ul><li>在继承抽象基类的头文件处重写函数后面加上该关键字</li><li>如：<code>virtual QString name() override;</code></li><li>用内联函数的方式重写时：<code>virtual QString name() override {/**/};</code>（override不是放在最后面）</li></ul></li><li>作用 <ul><li>可以避免派生类中忘记重写虚函数的错误</li><li>C++11 中的 override 关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错</li><li>这样，即使不小心漏写了虚函数重写的某个苛刻条件，也可以通过编译器的报错，快速改正错误</li><li>举例 <ul><li>基类定义一个虚基类<code>virtual fn1</code>，派生类要重写他时可能会打错字<code>virtual fn2</code>， 这时如果没有override关键字他会认为你要重新定义一个新的虚基类而不是实现虚基类，不报错！ 但要是加了override关键字他会发现你想覆盖的虚基类并不存在，就会给你报错！</li></ul></li></ul></li></ul><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h4><ol><li><strong>公有继承</strong></li></ol><p>纯虚函数 =&gt; 继承的是：<strong>接口 (interface)</strong></p><p>普通虚函数 =&gt; 继承的是：<strong>接口 + 缺省实现 (default implementation)</strong></p><p>非虚成员函数 =&gt;继承的是：<strong>接口 + 强制实现 (mandatory implementation)</strong></p><ol start="2"><li><p>不要重新定义一个继承自基类的非虚函数( <strong>never redefine</strong> an inherited non-virtual function)</p></li><li><p>在声明需要重写的函数后，加关键字 <em><strong>override</strong></em></p></li></ol>',14)]))}const c=l(p,[["render",a],["__file","01. 抽象基类与纯虚方法.html.vue"]]),s=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/04.%20%E7%89%B9%E6%AE%8A%E7%B1%BB/01.%20%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%8E%E7%BA%AF%E8%99%9A%E6%96%B9%E6%B3%95.html","title":"抽象基类与纯虚方法","lang":"zh-CN","frontmatter":{"description":"抽象基类与纯虚方法 抽象基类 抽象基类 简概 这是一种理念。具系统性，更规范 （一种学院派思想认为，如果涉及基础层次，则只能将那些不会被用作基类的类设计为具体类） 好处 可以将ABC看作是一种必须实施的接口，要求派生类覆盖其纯虚函数，迫使派生类遵循ABC设计的接口规则 （因为纯虚函数没有定义，如果派生类没有覆盖其纯虚函数，则会报错） 使用ABC使得组件...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/04.%20%E7%89%B9%E6%AE%8A%E7%B1%BB/01.%20%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%8E%E7%BA%AF%E8%99%9A%E6%96%B9%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"抽象基类与纯虚方法"}],["meta",{"property":"og:description","content":"抽象基类与纯虚方法 抽象基类 抽象基类 简概 这是一种理念。具系统性，更规范 （一种学院派思想认为，如果涉及基础层次，则只能将那些不会被用作基类的类设计为具体类） 好处 可以将ABC看作是一种必须实施的接口，要求派生类覆盖其纯虚函数，迫使派生类遵循ABC设计的接口规则 （因为纯虚函数没有定义，如果派生类没有覆盖其纯虚函数，则会报错） 使用ABC使得组件..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"抽象基类与纯虚方法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"抽象基类与纯虚方法","slug":"抽象基类与纯虚方法","link":"#抽象基类与纯虚方法","children":[{"level":2,"title":"抽象基类","slug":"抽象基类","link":"#抽象基类","children":[{"level":3,"title":"抽象基类","slug":"抽象基类-1","link":"#抽象基类-1","children":[{"level":4,"title":"纯虚函数","slug":"纯虚函数","link":"#纯虚函数","children":[]},{"level":4,"title":"override（C++11）重写","slug":"override-c-11-重写","link":"#override-c-11-重写","children":[]},{"level":4,"title":"小结","slug":"小结","link":"#小结","children":[]}]}]}]}],"git":{},"readingTime":{"minutes":2.59,"words":777},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/04. 特殊类/01. 抽象基类与纯虚方法.md","excerpt":"\\n<h2>抽象基类</h2>\\n<h3>抽象基类</h3>\\n<ul>\\n<li>\\n<p>简概</p>\\n<ul>\\n<li>\\n<p>这是一种理念。具系统性，更规范</p>\\n<p>（一种学院派思想认为，如果涉及基础层次，则只能将那些不会被用作基类的类设计为具体类）</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>好处</p>\\n<ul>\\n<li>\\n<p>可以将ABC看作是一种必须实施的接口，要求派生类覆盖其纯虚函数，迫使派生类遵循ABC设计的接口规则</p>\\n<p>（因为纯虚函数没有定义，如果派生类没有覆盖其纯虚函数，则会报错）</p>\\n</li>\\n<li>\\n<p>使用ABC使得组件设计人员能够制定“接口约定”</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>特点</p>\\n<ul>\\n<li>\\n<p>抽象基类（<em>abstract base class</em>，ABC）</p>\\n<p>抽象基类的命名可以以ABC作为结尾标注</p>\\n</li>\\n<li>\\n<p>抽象基类不能创建对象</p>\\n<p>与之相反的，其派生类可为具体类（<em>concrete class</em>），这表示可以创建这些类型的对象</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>使用场景</p>\\n<ul>\\n<li>比如圆和椭圆可以继承一个抽象基类，而不是让圆去继承椭圆</li>\\n<li>抽象基类为原和椭圆共性的抽象</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/04. 特殊类/01. 抽象基类与纯虚方法.md","value":{"title":"01. 抽象基类与纯虚方法","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/04. 特殊类/01. 抽象基类与纯虚方法.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{c as comp,s as data};
