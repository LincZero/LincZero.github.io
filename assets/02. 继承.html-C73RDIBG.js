import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,e}from"./app-Bl6HAa8e.js";const l={},t=e(`<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="类的重用-继承-inheritance" tabindex="-1"><a class="header-anchor" href="#类的重用-继承-inheritance"><span>类的重用 - 继承（inheritance）</span></a></h1><h2 id="继承-类继承-类、超类和子类" tabindex="-1"><a class="header-anchor" href="#继承-类继承-类、超类和子类"><span>继承 - 类继承（类、超类和子类）</span></a></h2><h3 id="一些概念" tabindex="-1"><a class="header-anchor" href="#一些概念"><span>一些概念</span></a></h3><ul><li>已存在的类：称为超类（superclass）、基类（base class）或父类（parent class）</li><li>新类：称为子类（subclass）、派生类（derived class）或孩子类（child class）</li><li>术语习惯：Java通用术语 超类和子类，C++通常用术语 父类和子类</li><li>继承层次 <ul><li>在继承层次中，从某个特定的类到其祖先的路径被称为该类的<strong>继承链（inheritance chain）</strong></li><li>通常，一个祖先类可以拥有多个子孙继承链</li></ul></li><li>is-a <ul><li>有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则</li><li>“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。 例如，可以将一个子类的对象赋给超类变量</li></ul></li></ul><h3 id="定义子类" tabindex="-1"><a class="header-anchor" href="#定义子类"><span>定义子类</span></a></h3><ul><li><p>java <mark>（在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承）</mark></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class A : public APerent {}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="多继承-不支持" tabindex="-1"><a class="header-anchor" href="#多继承-不支持"><span><s>多继承（不支持）</s></span></a></h3><p>Java不支持多继承</p><h3 id="多态-替换原则" tabindex="-1"><a class="header-anchor" href="#多态-替换原则"><span>多态（替换原则）</span></a></h3><p>在Java程序设计语言中，对象变量是多态的。 一个父类变量既可以引用一个父类对象，也可以引用一个该类的任何一个子类对象</p><p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</p><p>可能引起的bug：注意要规避以下写法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Manager</span><span class="token punctuation">[</span><span class="token punctuation">]</span> managers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 经理列表</span>
<span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> managers<span class="token punctuation">;</span>			<span class="token comment">// 普通雇员列表</span>
staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Harry Hacker&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 不报错，但危险</span>
<span class="token comment">// 在这里，staff[0]与manager[0]引用的是同一个对象，也就是说staff[0]经理列表中居然混杂了一个普通雇员</span>
<span class="token comment">// 经验：所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="继承-方法继承" tabindex="-1"><a class="header-anchor" href="#继承-方法继承"><span>继承 - 方法继承</span></a></h2><h3 id="覆盖方法、选择方法版本" tabindex="-1"><a class="header-anchor" href="#覆盖方法、选择方法版本"><span>覆盖方法、选择方法版本</span></a></h3><ul><li><p>继承（inheritance）：子类自动地继承了父类中的方法</p></li><li><p>覆盖（Override）：提供一个新的方法来覆盖（Override）超类中的原方法</p><ul><li><p>如果希望调用超类而不是子类的方法</p><ul><li><p>Java：使用特定的关键字super解决这个问题</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>C++：使用<code>::</code></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>父类名::getSalary()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>注意：有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字</p></li><li><p>注意：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public</p></li></ul></li></ul><h3 id="子类构造器-super关键字" tabindex="-1"><a class="header-anchor" href="#子类构造器-super关键字"><span>子类构造器（super关键字）</span></a></h3><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>A::A():PerentA(){}
// 一般使用成员初始化列表语法（效率高）来调用基类构造函数
// 缺省时：
//     如果省略基类的构造函数，则程序自动使用默认的基类构造函数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salarym<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用super调用构造器的语句必须是子类构造器的【第一条】语句</span>
    <span class="token comment">// 这里的关键字super具有不同的含义</span>
    <span class="token comment">// 是“调用超类Employee中含有n、s、year、month和day参数的构造器”的简写形式</span>
    bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 缺省时：</span>
<span class="token comment">//     如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器</span>
<span class="token comment">//     如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="动态性" tabindex="-1"><a class="header-anchor" href="#动态性"><span>动态性</span></a></h3><h4 id="动态绑定" tabindex="-1"><a class="header-anchor" href="#动态绑定"><span>动态绑定</span></a></h4><ul><li>一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为<strong>多态（polymorphism）</strong></li><li>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定（dynamic binding）</strong></li><li>C：默认是<strong>静态绑定</strong></li><li>Java：不需要将方法声明为虚拟方法。<strong>动态绑定是默认的处理方式</strong>。如果不希望让一个方法具有虚拟特征，可以将它标记为final</li></ul><p>动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary（）的代码进行重新编译</p><h4 id="方法调用的原理" tabindex="-1"><a class="header-anchor" href="#方法调用的原理"><span>方法调用的原理</span></a></h4><p>理论解析</p><p>调用过程的详细描述：</p><ul><li><p>1）编译器查看对象的声明类型和方法名 编译器获得所有可能被调用的候选方法</p><blockquote><p>假设调用<code>x.f(param)</code>，且隐式参数x声明为C类的对象 需要注意的是：<strong>有可能存在多个名字为f，但参数类型不一样的方法</strong>。例如，可能存在方法f(int)和方法f(String) 编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。</p></blockquote></li><li><p>2）编译器查看调用方法时提供的参数类型 重载解析（overloading resolution） 编译器获得需要调用的方法名字和参数类型</p><blockquote><p>如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<strong>重载解析（overloading resolution）</strong> 例如，对于调用 x.f(“Hello”) 来说，编译器将会挑选 f(String) ，而不是 f(int) 。由于允许类型转换（int可以转换成double，Manager可以转换成Employee，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p></blockquote></li><li><p>3）静态绑定或动态绑定（static binding / dynamic binding）</p><blockquote><p>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为<strong>静态绑定（static binding）</strong>。</p><p>与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。例如编译器采用**动态绑定（dynamic binding）**的方式生成一条调用 f(String) 的指令。</p></blockquote></li><li><p>4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</p><blockquote><p>假设x的实际类型是D，它是C类的子类。如果D类定义了方法 f(String) ，就直接调用它；否则，将在D类的超类中寻找 f(String) ，以此类推。</p><p>每次调用方法都要进行搜索，时间开销相当大。因此，<strong>虚拟机</strong>预先为每个类创建了一个<strong>方法表（method table）</strong>，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索D类的方法表，以便寻找与调用 f(Sting) 相匹配的方法。这个方法既有可能是 D.f(String) ，也有可能是 X.f(String) ，这里的X是D的超类。这里需要提醒一点，如果调用 super.f(param) ，编译器将对隐式参数超类的方法表进行搜索。</p></blockquote></li></ul><hr><p>实战举例</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token class-name">Employee</span> e<span class="token punctuation">;</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span> <span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span> <span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在运行时，调用 e.getSalary() 的解析过程为：</p><p>1）首先，虚拟机提取e的实际类型的方法表。既可能是Employee、Manager的方法表，也可能是Employee类的其他子类的方法表。</p><p>2）接下来，虚拟机搜索定义getSalary签名的类。此时，虚拟机已经知道应该调用哪个方法。</p><p>3）最后，虚拟机调用方法。</p><h4 id="关闭动态性-final" tabindex="-1"><a class="header-anchor" href="#关闭动态性-final"><span>关闭动态性（final）</span></a></h4><p>多态性的默认</p><ul><li>Java：默认所有方法具有多态性，方法默认为动态绑定</li><li>C++：默认所有方法不具有多态性，方法默认为静态绑定</li><li>所以除了禁止类或类方法被继承或重写外，Java中使用final还有一个功能是<strong>关闭动态绑定</strong> 在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字 内联优化：并且如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为内联（inlining）</li></ul><h2 id="继承-其他" tabindex="-1"><a class="header-anchor" href="#继承-其他"><span>继承 - 其他</span></a></h2><h3 id="阻止继承-final类和方法" tabindex="-1"><a class="header-anchor" href="#阻止继承-final类和方法"><span>阻止继承：final类和方法</span></a></h3><p>Java</p><ul><li><p>作用1：不允许类被继承 例如，假设希望阻止人们定义Executive类的子类，就可以在定义这个类的时候，使用final修饰符声明</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Executive</span> <span class="token keyword">extends</span> <span class="token class-name">Manager</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>作用2：不允许类方法被复写 类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Emplyee</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>C++11，final关键字</p><ul><li><p>作用1：不允许类被继承</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>struct Basel final{};		// 不让别人继承自己
struct Derived1:Base1 {};	// 此时会报错
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>作用2：不允许类方法被复写</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>struct Base2{
    virtual void f() final;	// 不允许被复写
};
struct Derived2:Base2{
    void f();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>用途：将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。例如在Java中：</p><ul><li>Calendar类中的getTime和setTime方法都声明为final 这表明Calendar类的设计者负责实现Date类与日历状态之间的转换，而不允许子类处理这些问题</li><li>String类也是final类 这意味着不允许任何人定义String的子类。 换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。</li></ul><h3 id="方法-域的访问权限-保护访问" tabindex="-1"><a class="header-anchor" href="#方法-域的访问权限-保护访问"><span>方法/域的访问权限（保护访问）</span></a></h3><p>保护访问：</p><ul><li>人们希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为protected</li><li>在实际应用中，要谨慎使用protected属性。假设需要将设计的类提供给其他程序员使用，而在这个类中设置了一些受保护域，由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下，如果需要对这个类的实现进行修改，就必须通知所有使用这个类的程序员。这违背了OOP提倡的数据封装原则。</li><li>示例：Object类中的clone方法</li></ul><hr><p><mark>与C++不同</mark></p><ul><li><p>Java</p><ul><li><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 【四个访问修饰符】</span>
priveate	<span class="token comment">// 仅对本类可见</span>
<span class="token keyword">public</span>		<span class="token comment">// 对所有类可见</span>
<span class="token keyword">protected</span>	<span class="token comment">// 对本包和所有子类可见</span>
默认	   	   <span class="token comment">// 对本包可见</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>C++</p><ul><li>基本同上</li></ul></li><li><p>总结</p><ul><li>Java中的受保护部分对所有子类<strong>及同一个包中的所有其他类</strong>都可见。这与C++中的保护机制稍有不同</li><li>Java中的protected概念要比C++中的<strong>安全性差</strong></li></ul></li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h2><h3 id="this和super的小总结" tabindex="-1"><a class="header-anchor" href="#this和super的小总结"><span>this和super的小总结</span></a></h3><ul><li>关键字this有两个用途 <ul><li>一是引用隐式参数</li><li>二是调用该类其他的构造器</li></ul></li><li>super关键字也有两个用途 <ul><li>一是调用超类的方法</li><li>二是调用超类的构造器</li></ul></li><li>在调用构造器的时候，这两个关键字的使用方式很相似。 调用构造器的语句只能作为另一个构造器的第一条语句出现。 构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。</li></ul><h2 id="【功能扩展】继承" tabindex="-1"><a class="header-anchor" href="#【功能扩展】继承"><span>【功能扩展】继承</span></a></h2><h3 id="【功能扩展】继承-x-转换-强制类型转换" tabindex="-1"><a class="header-anchor" href="#【功能扩展】继承-x-转换-强制类型转换"><span>【功能扩展】继承 x 转换，强制类型转换</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">3.405</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> nx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> boss<span class="token punctuation">;</span>	<span class="token comment">// 代换原则</span>

<span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应该养成这样一个良好的程序设计习惯：在进行类型转换之前，先查看一下是否能够成功地转换</p><p>在一般情况下，应该尽量少用类型转换和instanceof运算符</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span>	<span class="token comment">// 查看是否能成功类型转换</span>
<span class="token punctuation">{</span>
    boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p><mark>与C++不同</mark></p><ul><li><p>类型转换 Java使用的类型转换语法来源于C语言，但处理过程却有些像C++的dynamic_cast操作。以下两种写法等价</p><ul><li><p>Java</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">// Java</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>Manager* boss = dynamic_cast&lt;Manager*&gt;(staff[1]);	// C++
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>判断是否能转换</p><ul><li><p>Java：<strong>当类型转换失败时，抛出一个异常</strong>（有点像C++中的引用（reference）转换）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span>					<span class="token comment">// Java，需要将instanceof运算符和类型转换组合起来使用</span>
<span class="token punctuation">{</span>
    boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++：<strong>当类型转换失败时，生成一个null对象</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>Manager* boss = dynamic_cast&lt;Manager*&gt;(staff[1]);	// C++，直接转换
if (boss != NULL) ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>`,69),i=[t];function p(c,o){return n(),s("div",null,i)}const d=a(l,[["render",p],["__file","02. 继承.html.vue"]]),v=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/02.%20%E7%BB%A7%E6%89%BF.html","title":"Java","lang":"zh-CN","frontmatter":{"description":"Java 目录 类的重用 - 继承（inheritance） 继承 - 类继承（类、超类和子类） 一些概念 已存在的类：称为超类（superclass）、基类（base class）或父类（parent class） 新类：称为子类（subclass）、派生类（derived class）或孩子类（child class） 术语习惯：Java通用术语 ...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/02.%20%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Java"}],["meta",{"property":"og:description","content":"Java 目录 类的重用 - 继承（inheritance） 继承 - 类继承（类、超类和子类） 一些概念 已存在的类：称为超类（superclass）、基类（base class）或父类（parent class） 新类：称为子类（subclass）、派生类（derived class）或孩子类（child class） 术语习惯：Java通用术语 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Java","slug":"java","link":"#java","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"类的重用 - 继承（inheritance）","slug":"类的重用-继承-inheritance","link":"#类的重用-继承-inheritance","children":[{"level":2,"title":"继承 - 类继承（类、超类和子类）","slug":"继承-类继承-类、超类和子类","link":"#继承-类继承-类、超类和子类","children":[{"level":3,"title":"一些概念","slug":"一些概念","link":"#一些概念","children":[]},{"level":3,"title":"定义子类","slug":"定义子类","link":"#定义子类","children":[]},{"level":3,"title":"多继承（不支持）","slug":"多继承-不支持","link":"#多继承-不支持","children":[]},{"level":3,"title":"多态（替换原则）","slug":"多态-替换原则","link":"#多态-替换原则","children":[]}]},{"level":2,"title":"继承 - 方法继承","slug":"继承-方法继承","link":"#继承-方法继承","children":[{"level":3,"title":"覆盖方法、选择方法版本","slug":"覆盖方法、选择方法版本","link":"#覆盖方法、选择方法版本","children":[]},{"level":3,"title":"子类构造器（super关键字）","slug":"子类构造器-super关键字","link":"#子类构造器-super关键字","children":[]},{"level":3,"title":"动态性","slug":"动态性","link":"#动态性","children":[{"level":4,"title":"动态绑定","slug":"动态绑定","link":"#动态绑定","children":[]},{"level":4,"title":"方法调用的原理","slug":"方法调用的原理","link":"#方法调用的原理","children":[]},{"level":4,"title":"关闭动态性（final）","slug":"关闭动态性-final","link":"#关闭动态性-final","children":[]}]}]},{"level":2,"title":"继承 - 其他","slug":"继承-其他","link":"#继承-其他","children":[{"level":3,"title":"阻止继承：final类和方法","slug":"阻止继承-final类和方法","link":"#阻止继承-final类和方法","children":[]},{"level":3,"title":"方法/域的访问权限（保护访问）","slug":"方法-域的访问权限-保护访问","link":"#方法-域的访问权限-保护访问","children":[]}]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[{"level":3,"title":"this和super的小总结","slug":"this和super的小总结","link":"#this和super的小总结","children":[]}]},{"level":2,"title":"【功能扩展】继承","slug":"【功能扩展】继承","link":"#【功能扩展】继承","children":[{"level":3,"title":"【功能扩展】继承 x 转换，强制类型转换","slug":"【功能扩展】继承-x-转换-强制类型转换","link":"#【功能扩展】继承-x-转换-强制类型转换","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":11.4,"words":3420},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Java/06. 面向对象/03. 类的重用/02. 继承.md","excerpt":"\\n<h1>目录</h1>\\n<h1>类的重用 - 继承（inheritance）</h1>\\n<h2>继承 - 类继承（类、超类和子类）</h2>\\n<h3>一些概念</h3>\\n<ul>\\n<li>已存在的类：称为超类（superclass）、基类（base class）或父类（parent class）</li>\\n<li>新类：称为子类（subclass）、派生类（derived class）或孩子类（child class）</li>\\n<li>术语习惯：Java通用术语 超类和子类，C++通常用术语 父类和子类</li>\\n<li>继承层次\\n<ul>\\n<li>在继承层次中，从某个特定的类到其祖先的路径被称为该类的<strong>继承链（inheritance chain）</strong></li>\\n<li>通常，一个祖先类可以拥有多个子孙继承链</li>\\n</ul>\\n</li>\\n<li>is-a\\n<ul>\\n<li>有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则</li>\\n<li>“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。\\n例如，可以将一个子类的对象赋给超类变量</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{d as comp,v as data};
