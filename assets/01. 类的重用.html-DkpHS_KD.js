import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as e,a}from"./app-5ajJQ-aM.js";const t={},s=a('<h1 id="类的重用-包含、嵌套、继承" tabindex="-1"><a class="header-anchor" href="#类的重用-包含、嵌套、继承"><span>类的重用（包含、嵌套、继承）</span></a></h1><h2 id="思想" tabindex="-1"><a class="header-anchor" href="#思想"><span>思想</span></a></h2><h3 id="继承关系" tabindex="-1"><a class="header-anchor" href="#继承关系"><span>继承关系</span></a></h3><h4 id="is-a-是-is-a-kind-of-是一种" tabindex="-1"><a class="header-anchor" href="#is-a-是-is-a-kind-of-是一种"><span>is-a（是）/is-a-kind-of（是一种）</span></a></h4><ul><li>描述：is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作也可以对派生类对象执行</li><li>举例：香蕉是水果</li><li>实现：is-a最常用，也是使用最常用的公有继承实现</li><li>补充：这种关系称为<code>is-a-kind-of</code>更准确，但通常使用属于<code>is-a</code></li></ul><h4 id="has-a-包括有" tabindex="-1"><a class="header-anchor" href="#has-a-包括有"><span>has-a（包括有）</span></a></h4><ul><li>举例：午餐中包括米饭，但米饭不是午餐</li><li>实现：一般将一个对象作为另一个的数据成员（包含），或使用私有继承</li><li>不能实现：公有继承<strong>不能</strong>建立这种关系</li></ul><h4 id="is-like-a-像一种" tabindex="-1"><a class="header-anchor" href="#is-like-a-像一种"><span>is-like-a（像一种）</span></a></h4><ul><li>举例：律师像鲨鱼，但律师不是鲨鱼</li><li>不能实现：公有继承<strong>不能</strong>建立这种关系</li></ul><h4 id="is-implemented-as-a-作为-来实现" tabindex="-1"><a class="header-anchor" href="#is-implemented-as-a-作为-来实现"><span>is-implemented-as-a（作为...来实现）</span></a></h4><ul><li>举例：可以用数组来实现栈，但栈不是数组</li><li>不能实现：公有继承<strong>不能</strong>建立这种关系</li></ul><h4 id="uses-a-使用" tabindex="-1"><a class="header-anchor" href="#uses-a-使用"><span>uses-a（使用）</span></a></h4><ul><li>举例：计算机可以使用激光打印机</li><li>实现：可以使用友元函数或友元类</li><li>不能实现：公有继承<strong>不能</strong>建立这种关系</li></ul><h3 id="比较-has-a关系-包含和私有继承区别与选择" tabindex="-1"><a class="header-anchor" href="#比较-has-a关系-包含和私有继承区别与选择"><span>比较（has-a关系，包含和私有继承区别与选择）</span></a></h3><p>区别</p><ul><li>初始化基类组件 <ul><li>包含：创建类的<strong>实例对象</strong></li><li>私有继承：构造函数需要使用<strong>成员初始化列表</strong>来构造基类对象</li></ul></li><li>访问基类的方法 <ul><li>包含：使用<strong>对象名和句点运算符</strong>调用方法，如<code>m_a.fn();</code></li><li>私有继承：使用<strong>类名和作用域解析运算符</strong>来调用方法，如<code>A::fn();</code></li></ul></li><li>访问基类对象（使用基类对象本身） <ul><li>包含：返回<strong>对象成员</strong>即可，如<code>return m_a;</code></li><li>私有继承：使用<strong>强制类型转换</strong>（派生类转换为基类）再返回，如<code>return (const APerent &amp;) *this;</code></li></ul></li><li>访问基类的友元函数 <ul><li>包含：<strong>直接使用</strong>，如<code>cout m_a;</code></li><li>私有继承：使用<strong>强制类型转换</strong>（派生类转换为基类）再使用，如<code>cout &lt;&lt; (const APerent &amp;) a;</code></li></ul></li></ul><p>选择</p><ul><li>总结 <ul><li>通常使用包含来建立has-a关系</li><li>如果新类需要访问原有类的保护成员，或需要重新定义虚函数时，使用私有继承</li></ul></li><li>选用包含：大多数C++程序员倾向于使用包含 <ul><li>包含易于理解、而继承较为抽象</li><li>继承会引发很多问题，比如多重继承的一些问题</li><li>包含能包括多个同类的子对象，而继承只能使用一个这样的对象</li></ul></li><li>选用私有继承：私有继承提供的特性更多 <ul><li>私有继承可以访问保护成员</li><li>可以重新定义基类中的虚函数（非虚函数也能定义，但如果通过引用来调用则会引发问题，不建议修改非虚函数）</li></ul></li></ul><h3 id="嵌套类-类-x-类" tabindex="-1"><a class="header-anchor" href="#嵌套类-类-x-类"><span>嵌套类（类 x 类）</span></a></h3><ul><li><p>简概</p><ul><li>通过新的类型类作用域类避免名称混乱</li><li>旧版本的C++不允许嵌套类或无法完全实现这种概念</li></ul></li><li><p>嵌套类与包含类区别</p><ul><li>包含：将类对象作为另一个类的成员</li><li>嵌套：不创建类成员，而是定义一种类型，而且该类型仅在包含嵌套类声明的类中有效</li></ul></li><li><p>使用场景</p><ul><li>通常是为了帮助实现另一个类，并避免名称冲突</li></ul></li><li><p>使用</p><ul><li>声明：class中正常嵌套另一个class声明即可</li><li>定义：使用两次作用域解析运算符，如<code>Queue::Node::Node() {}</code>为嵌套类的构造函数的定义</li></ul></li><li><p>访问权限与作用域（和普通变量一样）</p><ul><li><table><thead><tr><th>声明位置</th><th>包含它的类是否可以使用它</th><th>从包含它的类派生的类是否可以使用它</th><th>在外部是否可以使用它</th></tr></thead><tbody><tr><td>私有部分</td><td>是</td><td>否</td><td>否</td></tr><tr><td>保护部分</td><td>是</td><td>是</td><td>否</td></tr><tr><td>公有部分</td><td>是</td><td>是</td><td>是，通过类限定符来使用</td></tr></tbody></table></li></ul></li></ul>',20),n=[s];function o(r,d){return i(),e("div",null,n)}const u=l(t,[["render",o],["__file","01. 类的重用.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/01.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8.html","title":"类的重用（包含、嵌套、继承）","lang":"zh-CN","frontmatter":{"description":"类的重用（包含、嵌套、继承） 思想 继承关系 is-a（是）/is-a-kind-of（是一种） 描述：is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作也可以对派生类对象执行 举例：香蕉是水果 实现：is-a最常用，也是使用最常用的公有继承实现 补充：这种关系称为is-a-kind-of更准确，但通常使用属于is-a has-a...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/01.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"类的重用（包含、嵌套、继承）"}],["meta",{"property":"og:description","content":"类的重用（包含、嵌套、继承） 思想 继承关系 is-a（是）/is-a-kind-of（是一种） 描述：is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作也可以对派生类对象执行 举例：香蕉是水果 实现：is-a最常用，也是使用最常用的公有继承实现 补充：这种关系称为is-a-kind-of更准确，但通常使用属于is-a has-a..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类的重用（包含、嵌套、继承）\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"类的重用（包含、嵌套、继承）","slug":"类的重用-包含、嵌套、继承","link":"#类的重用-包含、嵌套、继承","children":[{"level":2,"title":"思想","slug":"思想","link":"#思想","children":[{"level":3,"title":"继承关系","slug":"继承关系","link":"#继承关系","children":[{"level":4,"title":"is-a（是）/is-a-kind-of（是一种）","slug":"is-a-是-is-a-kind-of-是一种","link":"#is-a-是-is-a-kind-of-是一种","children":[]},{"level":4,"title":"has-a（包括有）","slug":"has-a-包括有","link":"#has-a-包括有","children":[]},{"level":4,"title":"is-like-a（像一种）","slug":"is-like-a-像一种","link":"#is-like-a-像一种","children":[]},{"level":4,"title":"is-implemented-as-a（作为...来实现）","slug":"is-implemented-as-a-作为-来实现","link":"#is-implemented-as-a-作为-来实现","children":[]},{"level":4,"title":"uses-a（使用）","slug":"uses-a-使用","link":"#uses-a-使用","children":[]}]},{"level":3,"title":"比较（has-a关系，包含和私有继承区别与选择）","slug":"比较-has-a关系-包含和私有继承区别与选择","link":"#比较-has-a关系-包含和私有继承区别与选择","children":[]},{"level":3,"title":"嵌套类（类 x 类）","slug":"嵌套类-类-x-类","link":"#嵌套类-类-x-类","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.33,"words":999},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/06. 面向对象/03. 类的重用/01. 类的重用.md","autoDesc":true}');export{u as comp,p as data};
