import{_ as s,e as a,g as n,o as e}from"./app-EuS-Ookm.js";const t={};function l(p,i){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="typoreplugin" tabindex="-1"><a class="header-anchor" href="#typoreplugin"><span>TyporePlugin</span></a></h1><p>参考：https://github.com/obgnail/typora_plugin</p><h2 id="有哪些插件" tabindex="-1"><a class="header-anchor" href="#有哪些插件"><span>有哪些插件</span></a></h2><p>见：https://github.com/obgnail/typora_plugin</p><p>标签栏功能感觉不错</p><h2 id="插件是如何实现的" tabindex="-1"><a class="header-anchor" href="#插件是如何实现的"><span>插件是如何实现的？</span></a></h2><p>这个就比较有意思了，我之前 Typora 转 Obsidian 的一个原因是因为 Obsidian 有插件，可以更好地自定义</p><p>Typora 相较 Obsidian 并没有官方提供的一个 插件API，并不能很好地实现插件。那上面那些插件是怎么实现的？</p><p>链接中也说明了实现方法：https://github.com/obgnail/typora_plugin?tab=readme-ov-file#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</p><p>这里转一下：</p><h3 id="前端" tabindex="-1"><a class="header-anchor" href="#前端"><span>前端</span></a></h3><p><code>window.html</code> 是 Typora 的初始文件，可以写入一个 <code>&lt;script&gt;</code> 标签实现功能，就和 Tampermonkey 脚本一样。</p><h3 id="后端" tabindex="-1"><a class="header-anchor" href="#后端"><span>后端</span></a></h3><ol><li>因为 Typora 暴露了 <code>reqnode</code> 函数（require 的别名），所以可以使用 CommonJS 的 <code>reqnode(&#39;path&#39;)</code> 导入 Node.js 的 path 库，其他库同理。</li><li>因为 Typora 使用了 electron 不太安全的 <code>executeJavaScript</code> 功能，所以可以用此注入 JS 代码，从而劫持后端关键对象，进而实现 electron 的后端功能注入。理论上劫持了 electron 对象，你甚至可以在 Typora 里斗地主。</li></ol><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 控制台输入下面命令:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 让第二个窗口打印消息</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">JSBridge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;executeJavaScript&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`console.log(&quot;i am logging&quot;)\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 让所有窗口打印消息</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">ClientCommand</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execForAll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`console.log(&quot;i am logging&quot;)\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 获取到本窗口的BrowserWindow对象</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">global</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">reqnode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;electron&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">remote</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">require</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;electron&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">BrowserWindow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 获取到所有窗口的BrowserWindow对象</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">ClientCommand</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execForAll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`console.log(global.reqnode(&#39;electron&#39;).remote.require(&#39;electron&#39;).BrowserWindow)\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 让窗口1执行语句_myValue=123，然后将变量_myValue传给窗口2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">JSBridge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;executeJavaScript&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;_myValue=123; JSBridge.invoke(&#39;executeJavaScript&#39;, 2, \`console.log(\${_myValue})\`)&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="补充" tabindex="-1"><a class="header-anchor" href="#补充"><span>补充</span></a></h2><p>虽然通过这种方法可以实现 typora 插件，但总感觉开发起来会比较麻烦，也会比较容易踩坑。</p><p>开发难度和开发插件的社区氛围依然不能达到 Obsidian 的地步</p>`,18)]))}const o=s(t,[["render",l],["__file","TyporePlugin.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Type/Doc/MarkdwonAbout/01.%20Soft%20And%20Frame/Typora/TyporePlugin.html","title":"TyporePlugin","lang":"zh-CN","frontmatter":{"description":"TyporePlugin 参考：https://github.com/obgnail/typora_plugin 有哪些插件 见：https://github.com/obgnail/typora_plugin 标签栏功能感觉不错 插件是如何实现的？ 这个就比较有意思了，我之前 Typora 转 Obsidian 的一个原因是因为 Obsidian 有...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Type/Doc/MarkdwonAbout/01.%20Soft%20And%20Frame/Typora/TyporePlugin.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"TyporePlugin"}],["meta",{"property":"og:description","content":"TyporePlugin 参考：https://github.com/obgnail/typora_plugin 有哪些插件 见：https://github.com/obgnail/typora_plugin 标签栏功能感觉不错 插件是如何实现的？ 这个就比较有意思了，我之前 Typora 转 Obsidian 的一个原因是因为 Obsidian 有..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TyporePlugin\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.49,"words":448},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Type/Doc/MarkdwonAbout/01. Soft And Frame/Typora/TyporePlugin.md","excerpt":"\\n<p>参考：https://github.com/obgnail/typora_plugin</p>\\n<h2>有哪些插件</h2>\\n<p>见：https://github.com/obgnail/typora_plugin</p>\\n<p>标签栏功能感觉不错</p>\\n<h2>插件是如何实现的？</h2>\\n<p>这个就比较有意思了，我之前 Typora 转 Obsidian 的一个原因是因为 Obsidian 有插件，可以更好地自定义</p>\\n<p>Typora 相较 Obsidian 并没有官方提供的一个 插件API，并不能很好地实现插件。那上面那些插件是怎么实现的？</p>\\n<p>链接中也说明了实现方法：https://github.com/obgnail/typora_plugin?tab=readme-ov-file#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Type/Doc/MarkdwonAbout/01. Soft And Frame/Typora/TyporePlugin.md","value":{"title":"TyporePlugin","path":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Type/Doc/MarkdwonAbout/01. Soft And Frame/Typora/TyporePlugin.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{o as comp,r as data};
