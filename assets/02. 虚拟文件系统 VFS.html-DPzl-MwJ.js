import{_ as t,c as i,e as n,o}from"./app-CcegWvWz.js";const l="/assets/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-BWBmuESh.png",a="/assets/745e8d5e70cc476ebf3ae8610459b88a-B_PWtHgC.png",r="/assets/ff08a528130548be958bba19cf82b72f-nY7UBCgA.png",p="/assets/64bc07044cac46d294b4e8d1fac8cde8-B63DMjq8.png",s={};function d(c,e){return o(),i("div",null,e[0]||(e[0]=[n('<h1 id="虚拟文件系统-vfs" tabindex="-1"><a class="header-anchor" href="#虚拟文件系统-vfs"><span>虚拟文件系统 (<em>VFS</em>)</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p><strong>文件系统的种类众多</strong>，而操作系统希望 <strong>对用户提供一个统一的接口</strong>，于是在用户层与文件系统层引入了中间层，这个中间层就称为 <strong>虚拟文件系统（<em>Virtual File System，VFS</em>）。</strong></p><p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p><p>在 Linux 文件系统中，用户空间、系统调用、虚拟文件系统、缓存、文件系统以及存储之间的关系如下图：</p><p><img src="'+l+'" alt="img" loading="lazy"></p><p><img src="'+a+'" alt="在这里插入图片描述" loading="lazy"></p><p>（第二张图来自：https://xiaolizai.blog.csdn.net/article/details/133993884）</p><h2 id="文件系统分类-按存储位置" tabindex="-1"><a class="header-anchor" href="#文件系统分类-按存储位置"><span>文件系统分类 - 按存储位置</span></a></h2><p>Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：</p><ul><li>磁盘的文件系统： 它是直接把数据存储在磁盘中，比如 <code>Ext 2/3/4</code>、<code>XFS</code> 等都是这类文件系统</li><li>内存的文件系统： 这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据</li><li>网络的文件系统： 用来访问其他计算机主机数据的文件系统，比如 <code>NFS</code>、<code>SMB</code> 等等</li></ul><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><h2 id="vfs四大struct" tabindex="-1"><a class="header-anchor" href="#vfs四大struct"><span>VFS四大struct</span></a></h2><p>参考：https://blog.csdn.net/bandaoyu/article/details/125375996</p><p>VFS有四大对象：</p><ul><li>超级块 super_block</li><li>索引节点 inode</li><li>目录项 dentry</li><li>文件对象 file</li></ul><p><img src="'+r+'" alt="img" loading="lazy"></p><h3 id="_1-索引节点-inode" tabindex="-1"><a class="header-anchor" href="#_1-索引节点-inode"><span>(1) 索引节点 inode</span></a></h3><p>文件是由 inode 以及 inode指向的数据块构成，Inode记录了文件的管理信息，数据块记录文件的具体内容。</p><h3 id="_2-目录项-dentry" tabindex="-1"><a class="header-anchor" href="#_2-目录项-dentry"><span>(2) 目录项 dentry</span></a></h3><ul><li><p>目录：也是由 inode 以及inode指向的数据块构成 ，但目录的数据块 记录的是该目录下的 子目录/文件的 inode 以及 子目录名/文件名 等信息。</p></li><li><p>目录项 dentry：目录项是描述文件的逻辑属性（dentry中包含了文件名，文件的inode号等信息。），只存在于内存中，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计。注意不管是<strong>文件夹</strong>还是最终的文件，都是属于目录项，所有的目录项在一起构成一颗庞大的<strong>目录树</strong>。</p><p>例如：open一个文件 /home/xxx/yyy.txt，那么 /、home、xxx、yyy.txt 都是一个目录项，VFS在查找的时候，根据一层一层的目录项找到对应的每个目录项的inode，那么沿着目录项进行操作就可以找到最终的文件。</p></li></ul><p>dentry结构是一种含有指向父节点和子节点指针的双向结构，多个这样的双向结构构成一个内存里面的树状结构，也就是文件系统的目录结构在内存中的缓存了。有了这个缓存，我们在访问文件系统时，通常都非常快捷。</p><p>注意：<strong>目录也是一种文件(所以也存在对应的inode)</strong>。打开目录，实际上就是打开目录文件</p><p>举个文件的例子：/home/user/Desktop/bilibili.txt ，假设 bilibili.txt和 / 在同一个文件系统，那么，只需要读 <code>/的inode</code> 读到 home 并找到找到 <code>home的inode</code> 并读取，这样步步跳转，最后会读取 bilibili.txt 这文件对应的 inode ,好了，你打开 bilibili.txt 这个文件并读取内容时，VFS 会调用 ext3 的 read()（在5中的安装 ，函数已经向VFS注册过）去读此inode对应的数据块。</p><h3 id="_3-文件对象" tabindex="-1"><a class="header-anchor" href="#_3-文件对象"><span>(3) 文件对象</span></a></h3><p>文件对象：注意文件对象描述的是进程已经打开的文件。因为一个文件可以被多个进程打开，所以一个文件可以存在多个文件对象。但是由于文件是唯一的，那么inode就是唯一的，目录项也是定的！</p><p>进程其实是通过文件描述符来操作文件的，注意每个文件都有一个32位的数字来表示下一个读写的字节位置，这个数字叫做文件位置。一般情况下打开文件后，打开位置都是从0开始，除非一些特殊情况。Linux用file结构体来保存打开的文件的位置，所以file称为打开的文件描述。这个需要好好理解一下！file结构形成一个双链表，称为系统打开文件表。</p><p>Superblock, Inode, Dentry 和 File 都属于元数据(Metadata)，</p><p>Linux系统从ext2开始，是将文件属性和文件内容分开存储,inode 用于存储文件的各属性,block 用来存储文件的内容。inode指向block（至少一个）。</p><h3 id="超级块" tabindex="-1"><a class="header-anchor" href="#超级块"><span>超级块</span></a></h3><p>Super block即为超级块，它是硬盘分区开头，超级块中的数据是卷资源表，有关文件卷的大部分信息都保存在这里。</p><p>例如：硬盘分区中每个block的大小、硬盘分区上一共有多少个block group、以及每个block group中有多少个inode。它定义了文件系统的类似、大小、状态，和其他元数据结构的信息（元数据的元数据）。</p><p><img src="'+p+'" alt="img" loading="lazy"></p><p>读linux下文件---&gt;陷入kernel--&gt;VFS系统--&gt;文件系统(例如ext3)--&gt;访问物理硬件；</p><p>Superblock, Inode, Dentry 和 File 都属于元数据(Metadata)</p>',35)]))}const E=t(s,[["render",d],["__file","02. 虚拟文件系统 VFS.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/07.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/02.%20%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20VFS.html","title":"虚拟文件系统 (VFS)","lang":"zh-CN","frontmatter":{"description":"虚拟文件系统 (VFS) 概念 文件系统的种类众多，而操作系统希望 对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为 虚拟文件系统（Virtual File System，VFS）。 VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/07.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/02.%20%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20VFS.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"虚拟文件系统 (VFS)"}],["meta",{"property":"og:description","content":"虚拟文件系统 (VFS) 概念 文件系统的种类众多，而操作系统希望 对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为 虚拟文件系统（Virtual File System，VFS）。 VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"虚拟文件系统 (VFS)\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"虚拟文件系统 (VFS)","slug":"虚拟文件系统-vfs","link":"#虚拟文件系统-vfs","children":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"文件系统分类 - 按存储位置","slug":"文件系统分类-按存储位置","link":"#文件系统分类-按存储位置","children":[]},{"level":2,"title":"VFS四大struct","slug":"vfs四大struct","link":"#vfs四大struct","children":[{"level":3,"title":"(1) 索引节点 inode","slug":"_1-索引节点-inode","link":"#_1-索引节点-inode","children":[]},{"level":3,"title":"(2) 目录项 dentry","slug":"_2-目录项-dentry","link":"#_2-目录项-dentry","children":[]},{"level":3,"title":"(3) 文件对象","slug":"_3-文件对象","link":"#_3-文件对象","children":[]},{"level":3,"title":"超级块","slug":"超级块","link":"#超级块","children":[]}]}]}],"git":{},"readingTime":{"minutes":4.83,"words":1449},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/07. 文件系统/02. 虚拟文件系统 VFS.md","excerpt":"\\n<h2>概念</h2>\\n<p><strong>文件系统的种类众多</strong>，而操作系统希望 <strong>对用户提供一个统一的接口</strong>，于是在用户层与文件系统层引入了中间层，这个中间层就称为 <strong>虚拟文件系统（<em>Virtual File System，VFS</em>）。</strong></p>\\n<p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p>\\n<p>在 Linux 文件系统中，用户空间、系统调用、虚拟文件系统、缓存、文件系统以及存储之间的关系如下图：</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/07. 文件系统/02. 虚拟文件系统 VFS.md","value":{"title":"02. 虚拟文件系统 VFS","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/07. 文件系统/02. 虚拟文件系统 VFS.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{E as comp,h as data};
