import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as d,a as l}from"./app-CsHIiQ5U.js";const r={},a=l(`<h1 id="computersystems" tabindex="-1"><a class="header-anchor" href="#computersystems"><span>ComputerSystems</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="汇编原理" tabindex="-1"><a class="header-anchor" href="#汇编原理"><span>汇编原理</span></a></h1><h2 id="汇编原理-1" tabindex="-1"><a class="header-anchor" href="#汇编原理-1"><span>汇编原理</span></a></h2><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例</span></a></h3><h4 id="制定一些简单指令" tabindex="-1"><a class="header-anchor" href="#制定一些简单指令"><span>制定一些简单指令</span></a></h4><table><thead><tr><th>指令</th><th>代码</th><th>功能</th></tr></thead><tbody><tr><td>LOAD_A</td><td>0000</td><td>将指定内存地址数据加载至寄存器A</td></tr><tr><td>LOAD_B</td><td>0001</td><td>将指定内存地址数据加载至寄存器B</td></tr><tr><td>ADD</td><td>0100</td><td>将指定两个寄存器数据相加</td></tr><tr><td>STORE_A</td><td>1000</td><td>将寄存器数据存储至制定内存地址</td></tr></tbody></table><h4 id="汇编代码" tabindex="-1"><a class="header-anchor" href="#汇编代码"><span>汇编代码</span></a></h4><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>LOAD_A 7	0000 0111
LOAD_B 8	0001 1000
ADD A B 	0100 0001
STORE_A 15	1000 1111
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="内存状态" tabindex="-1"><a class="header-anchor" href="#内存状态"><span>内存状态</span></a></h4><p>冯诺依曼架构计算机（存储程序计算机），指令和数据都放在内存中</p><table><thead><tr><th>地址</th><th>内容</th><th>二进制地址</th></tr></thead><tbody><tr><td>0</td><td>LOAD_A 7</td><td>0000</td></tr><tr><td>1</td><td>LOAD_B 8</td><td>0001</td></tr><tr><td>2</td><td>ADD A B</td><td>0010</td></tr><tr><td>3</td><td>STORE_A F</td><td>0011</td></tr><tr><td>4</td><td></td><td></td></tr><tr><td>5</td><td></td><td></td></tr><tr><td>6</td><td></td><td></td></tr><tr><td>7</td><td>8</td><td>0111</td></tr><tr><td>8</td><td>6</td><td>1000</td></tr><tr><td>……</td><td></td><td></td></tr><tr><td>F</td><td>(14)</td><td>1111</td></tr></tbody></table><h4 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤"><span>步骤</span></a></h4><p><code>指令流水线</code>整体步骤：取指 -&gt; 解码 -&gt; 执行（循环）。有的CPU的流水线可能不止三级</p><p>分步步骤（补充：每一行指令完成后IC自动+1，下表中不再赘述这点）</p><table><thead><tr><th>IC</th><th>取指令</th><th>解码</th><th>执行</th></tr></thead><tbody><tr><td>0，CPU初始化完成后置为0</td><td>控制单元到内存地址为0的位置取指令</td><td>0000 0111</td><td>执行加载指令，地址中的内容 (8) 到寄存器A</td></tr><tr><td>1</td><td>LOAD_B 8</td><td>0001 1000</td><td>执行加载指令，地址中的内容 (6) 到寄存器B</td></tr><tr><td>2</td><td>ADD A B</td><td>0100 0001</td><td>6和8送往ALU的两端，产生结果14后存回寄存器A</td></tr><tr><td>3</td><td>STORE_A F</td><td>1000 1111</td><td>执行存储指令，将寄存器A的内容存向指定地址</td></tr></tbody></table><h3 id="指令集架构" tabindex="-1"><a class="header-anchor" href="#指令集架构"><span>指令集架构</span></a></h3><ul><li><p>历史扩展</p><ul><li><p>x86</p><p>指令集架构起初都是CPU的制造厂商制定的，经典的是Intel提出的x86 Intel制定指令集、设计CPU电路、制造CPU均能自己</p></li><li><p>公版ARM</p><p>后来英国ARM公司推出ARM指令集架构 但是ARM不制造CPU，授权产商可以根据他们提供的电路执行制造CPU。</p><ul><li><p>定制ARM</p><p>有能力生产CPU的产商：化为、低通、挨炮、三桑等公司 他们会根据自己的需求，改进公版的设计，集成更多模块（如5G基带、图像处理模块等），产出：麒麟、骁龙、A系列、猎户座等产品</p></li><li><p>SoC</p><p>这些集成度很高的产品，称为SoC，超出了传统CPU的定义 像台积电这种产商专注于这些产品的代工 Intel、AMD等产生也在x86架构中集成GPU或IO模块，向着SoC的方向发展。CPU和SoC的界限逐渐变得模糊</p></li></ul></li><li><p>RISC-V开源指令集 前面的都是要钱的，这个可以使用该指令集自行设计电路，不需要钱 但如果使用RISC-V官方给出的具体电路设计，这个是要钱的</p></li></ul></li></ul><h3 id="历史原理" tabindex="-1"><a class="header-anchor" href="#历史原理"><span>历史原理</span></a></h3><p>bug计算机缺陷、patch补丁 的由来</p><ul><li>逻辑电路：开关机</li><li>机器语言：高低电压 + 打孔纸带</li><li>汇编语言：用单词来代替一串01序列</li><li>高级语言</li></ul>`,21),i=[a];function n(s,h){return e(),d("div",null,i)}const c=t(r,[["render",n],["__file","01. 汇编原理.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/01.%20%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/01.%20%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.html","title":"ComputerSystems","lang":"zh-CN","frontmatter":{"description":"ComputerSystems 目录 汇编原理 汇编原理 举例 制定一些简单指令 汇编代码 内存状态 冯诺依曼架构计算机（存储程序计算机），指令和数据都放在内存中 步骤 指令流水线整体步骤：取指 -> 解码 -> 执行（循环）。有的CPU的流水线可能不止三级 分步步骤（补充：每一行指令完成后IC自动+1，下表中不再赘述这点） 指令集架构 历史扩展 x8...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/01.%20%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/01.%20%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"ComputerSystems"}],["meta",{"property":"og:description","content":"ComputerSystems 目录 汇编原理 汇编原理 举例 制定一些简单指令 汇编代码 内存状态 冯诺依曼架构计算机（存储程序计算机），指令和数据都放在内存中 步骤 指令流水线整体步骤：取指 -> 解码 -> 执行（循环）。有的CPU的流水线可能不止三级 分步步骤（补充：每一行指令完成后IC自动+1，下表中不再赘述这点） 指令集架构 历史扩展 x8..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ComputerSystems\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"ComputerSystems","slug":"computersystems","link":"#computersystems","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"汇编原理","slug":"汇编原理","link":"#汇编原理","children":[{"level":2,"title":"汇编原理","slug":"汇编原理-1","link":"#汇编原理-1","children":[{"level":3,"title":"举例","slug":"举例","link":"#举例","children":[{"level":4,"title":"制定一些简单指令","slug":"制定一些简单指令","link":"#制定一些简单指令","children":[]},{"level":4,"title":"汇编代码","slug":"汇编代码","link":"#汇编代码","children":[]},{"level":4,"title":"内存状态","slug":"内存状态","link":"#内存状态","children":[]},{"level":4,"title":"步骤","slug":"步骤","link":"#步骤","children":[]}]},{"level":3,"title":"指令集架构","slug":"指令集架构","link":"#指令集架构","children":[]},{"level":3,"title":"历史原理","slug":"历史原理","link":"#历史原理","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.46,"words":739},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/02. 计算机指令/01. 汇编基础/01. 汇编原理.md","autoDesc":true}');export{c as comp,m as data};
