import{_ as s,e,g as a,o as l}from"./app-BapqMaOt.js";const t={};function n(h,i){return l(),e("div",null,i[0]||(i[0]=[a(`<h1 id="异常" tabindex="-1"><a class="header-anchor" href="#异常"><span>异常</span></a></h1><h2 id="异常处理方式" tabindex="-1"><a class="header-anchor" href="#异常处理方式"><span>异常处理方式</span></a></h2><h3 id="调用abort-或exit" tabindex="-1"><a class="header-anchor" href="#调用abort-或exit"><span>调用<code>abort()</code>或<code>exit()</code></span></a></h3><ul><li><code>abort()</code>函数 <ul><li>是</li></ul></li><li><code>exit()</code>函数 <ul><li>基本同上</li></ul></li><li><code>abort()</code>与<code>exit()</code>区别 <ul><li><code>abort()</code><ul><li>是否刷新<code>文件缓冲区</code>取决于实现</li><li>会向标准错误流</li></ul></li><li><code>exit()</code><ul><li>会刷新<code>文件缓冲区</code></li><li>不会显示信息</li></ul></li></ul></li><li>一些额外补充 <ul><li><code>标准错误流</code>：即<code>cerr</code>使用的错误流</li><li><code>文件缓冲区</code>：用于存储读写到文件中的数据的内存区域</li></ul></li></ul><h3 id="返回错误码" tabindex="-1"><a class="header-anchor" href="#返回错误码"><span>返回错误码</span></a></h3><p>通过函数的返回值来指出问题，该方式更灵活</p><h3 id="异常机制-throw-catch" tabindex="-1"><a class="header-anchor" href="#异常机制-throw-catch"><span>异常机制（<code>throw-catch</code>）</span></a></h3><p>通过抛出异常</p><ul><li><p>使用</p><ul><li><p>举例</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    throw</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;error1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 异常类型可以是字符串或其他C++类型，通常为类类型</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">s) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>原理</p><ul><li><code>throw</code>语句导致程序<strong>沿函数调用序列后退</strong>，即栈解退，直到找到包含try块的函数</li><li><code>栈解退</code>（<em>unwinding the stack</em>） <ul><li>与函数调用的返回有点像但并不同</li><li>返回值会返回到调用它的函数，这个过程会释放函数有关的栈（如自动变量），以此类推</li><li>栈解退也释放栈，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块中的返回地址<br> 随后，控制权将转到块尾的异常处理程序，而不是后面的第一条语句<br> 如果没有找到这样的处理程序（try块），默认情况下程序将异常终止</li></ul></li><li>临时拷贝 <ul><li>引发异常时总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用</li><li>catch块一般使用引用类型的原因并非提高效率（无法做到），而是让其可以执行派生类对象</li></ul></li></ul></li></ul><h2 id="异常类" tabindex="-1"><a class="header-anchor" href="#异常类"><span>异常类</span></a></h2><h3 id="传递对象好处" tabindex="-1"><a class="header-anchor" href="#传递对象好处"><span>传递对象好处</span></a></h3><p>通常引发异常的函数会传递一个对象，优点：</p><ul><li><p>可以使用不同的异常类型区分不同的异常</p></li><li><p>对象可以携带信息，程序员可以根据这些信息来判断异常原因</p></li><li><p>对象可以携带信息，catch块可以根据这些信息来决定采取什么样的措施</p><ul><li><p>比如</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (Error1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e){</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (Error2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e){</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="exception类-exception头文件" tabindex="-1"><a class="header-anchor" href="#exception类-exception头文件"><span>exception类（exception头文件）</span></a></h3><h4 id="头文件exception-异常类" tabindex="-1"><a class="header-anchor" href="#头文件exception-异常类"><span>头文件exception（异常类）</span></a></h4><p>头文件<code>exception</code>/<code>exception.h</code>或<code>except.h</code>，定义了<code>exception</code>类</p><p>C++可以把它用作其他异常类的基类，C++库也定义了很多基于exception的异常类型（派生类）</p><h4 id="头文件stdexcept-标准异常类" tabindex="-1"><a class="header-anchor" href="#头文件stdexcept-标准异常类"><span>头文件stdexcept（标准异常类）</span></a></h4><p>头文件stdexcept定义了其他几个异常类</p><ul><li><code>logic_error</code>，逻辑错误，描述典型的逻辑错误<br> （基于exception类的派生类，其又派生出许多其他类） <ul><li><code>domain_error</code>，定义域错误，可以让函数在参数不再定义域之间是返回<code>domain_error</code>异常</li><li><code>invalid_argument</code>，无效的参数，可以指出给函数传递了一个意料外的值</li><li><code>length_error</code>，空间不足，可以指出没有足够的空间来执行所需的操作</li><li><code>out_of_bounds</code>，索引错误，可以用于指示索引错误</li></ul></li><li><code>runtime_error</code>，运行阶段错误，通常是可能在运行期间发生但难以预计和防范的错误<br> （基于exception类的派生类，其又派生出许多其他类） <ul><li><code>range_error</code>，非上下的溢出错误</li><li><code>overflow_error</code>，上溢出错误</li><li><code>underflow_error</code>，下溢出错误</li></ul></li></ul><h4 id="bad-alloc异常和头文件new" tabindex="-1"><a class="header-anchor" href="#bad-alloc异常和头文件new"><span>bad_alloc异常和头文件new</span></a></h4><p>对于使用new导致的内存分配问题，C++最新处理方式是让new引发<code>bad_alloc</code>异常</p><p>头文件<code>new</code>包含<code>bad_alloc</code>类的声明（定位new也是这个头文件），该异常类也是从exception类公有派生而来的</p><h4 id="空指针和new" tabindex="-1"><a class="header-anchor" href="#空指针和new"><span>空指针和new</span></a></h4><p>很多代码都是在new在失败时返回空指针时编写的，C++标准也提供了一种在失败时返回空指针的new</p><ul><li>使用： <ul><li>例如<code>int *pi = new (std::nothrow) int;</code></li><li>例如<code>int *pa = new (std::nothrow) int[500];</code></li></ul></li></ul><h2 id="异常规范和c-11" tabindex="-1"><a class="header-anchor" href="#异常规范和c-11"><span><s>异常规范和C++11</s></span></a></h2><ul><li>简概 <ul><li><code>异常规范</code>（<em>exception specification</em>）是C++98新增的一项功能，但C++11摒弃了</li><li>异常规范有些缺点，比如函数引发了异常规范中没有的异常时，其机制会导致处理起来比较麻烦</li></ul></li><li>作用 <ul><li>告诉用户可能需要使用try块。然而这项工作也可以使用注释轻松完成</li><li>让编译器添加执行运行阶段检查的代码，检查是否违反了异常规则。但这很难检查得到</li></ul></li><li>使用 <ul><li>例如<code>double harm(double a) throw(bad_thing);</code>，表示可能会抛出bad_thing类型的错误</li><li>例如<code>double marm(double) throw();</code>，表示不会抛出错误</li></ul></li></ul><p><code>noexcept</code></p><ul><li>作用 <ul><li>虽然C++11抛弃了异常规范，但还支持另一种异常规范：<code>noexcept</code>关键字能指出某函数不会引发异常</li></ul></li><li>写法 <ul><li>例如：<code>double marm() noexcept;</code></li></ul></li></ul><h2 id="意外异常、未捕获异常、默认行为" tabindex="-1"><a class="header-anchor" href="#意外异常、未捕获异常、默认行为"><span>意外异常、未捕获异常、默认行为</span></a></h2><h3 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h3><p>异常被引发后，在两种情况下回引发问题</p><ul><li>在带异常规范的函数中引发，则必须与规范列表中的某种异常匹配，否则称为<code>意外异常</code></li><li>如果异常不是在函数中引发（或则没有异常规范），则必须捕获它，否则该异常被称为<code>未捕获异常</code></li></ul><h3 id="未捕获异常" tabindex="-1"><a class="header-anchor" href="#未捕获异常"><span>未捕获异常</span></a></h3><p>未捕获异常会调用函数<code>terminate()</code>，默认情况下，<code>terminate()</code>调用<code>abort()</code>导致程序<strong>异常终止</strong></p><p>但可以用<code>set_terminate()</code>修改<code>terminate()</code>的默认行为（这两个函数都在头文件<code>exception</code>中被声明）</p><ul><li><p>方法</p><ul><li><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">terminate_handler</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  terminate_handler</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> set_terminate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">terminate_handler</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> 		// C++98，异常规范语法</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  terminate_handler</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> set_terminate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">terminate_handler</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> 		// C++11，另一种异常规范</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> terminate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">													// C++98</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> terminate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">											// C++11，另一种异常规范</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="意外异常" tabindex="-1"><a class="header-anchor" href="#意外异常"><span>意外异常</span></a></h3><p>情况与未捕获异常相似，会先调<code>unexpected()</code>函数，默认行为为<strong>程序异常终止</strong></p><p>但可以用<code>set_unexpected()</code>修改<code>unexpected()</code>的默认行为（这两个函数都在头文件<code>exception</code>中被声明）</p><ul><li><p>方法</p><ul><li><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">unexpected_handler</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  unexpected_handler</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> set_unexpected</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unexpected_handler</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> 	// C++98，异常规范语法</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  unexpected_handler</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> set_unexpected</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unexpected_handler</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> 	// C++11，另一种异常规范</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> unexpected</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">													// C++98</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> unexpected</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">											// C++11，另一种异常规范</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="功能扩展" tabindex="-1"><a class="header-anchor" href="#功能扩展"><span>功能扩展</span></a></h2><h3 id="异常-x-new类成员" tabindex="-1"><a class="header-anchor" href="#异常-x-new类成员"><span>异常 x new类成员</span></a></h3>`,44)]))}const p=s(t,[["render",n],["__file","04. 异常.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/04.%20%E5%BC%82%E5%B8%B8.html","title":"异常","lang":"zh-CN","frontmatter":{"description":"异常 异常处理方式 调用abort()或exit() abort()函数 是 exit()函数 基本同上 abort()与exit()区别 abort() 是否刷新文件缓冲区取决于实现 会向标准错误流 exit() 会刷新文件缓冲区 不会显示信息 一些额外补充 标准错误流：即cerr使用的错误流 文件缓冲区：用于存储读写到文件中的数据的内存区域 返回错...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/04.%20%E5%BC%82%E5%B8%B8.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"异常"}],["meta",{"property":"og:description","content":"异常 异常处理方式 调用abort()或exit() abort()函数 是 exit()函数 基本同上 abort()与exit()区别 abort() 是否刷新文件缓冲区取决于实现 会向标准错误流 exit() 会刷新文件缓冲区 不会显示信息 一些额外补充 标准错误流：即cerr使用的错误流 文件缓冲区：用于存储读写到文件中的数据的内存区域 返回错..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"异常\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":5.13,"words":1539},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/04. 异常.md","excerpt":"\\n<h2>异常处理方式</h2>\\n<h3>调用<code>abort()</code>或<code>exit()</code></h3>\\n<ul>\\n<li><code>abort()</code>函数\\n<ul>\\n<li>是</li>\\n</ul>\\n</li>\\n<li><code>exit()</code>函数\\n<ul>\\n<li>基本同上</li>\\n</ul>\\n</li>\\n<li><code>abort()</code>与<code>exit()</code>区别\\n<ul>\\n<li><code>abort()</code>\\n<ul>\\n<li>是否刷新<code>文件缓冲区</code>取决于实现</li>\\n<li>会向标准错误流</li>\\n</ul>\\n</li>\\n<li><code>exit()</code>\\n<ul>\\n<li>会刷新<code>文件缓冲区</code></li>\\n<li>不会显示信息</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>一些额外补充\\n<ul>\\n<li><code>标准错误流</code>：即<code>cerr</code>使用的错误流</li>\\n<li><code>文件缓冲区</code>：用于存储读写到文件中的数据的内存区域</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/04. 异常.md","value":{"title":"04. 异常","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/04. 异常.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{p as comp,r as data};
