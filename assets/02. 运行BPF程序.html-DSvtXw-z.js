import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,a as e}from"./app-Ld2qzqw_.js";const p={},t=e(`<h1 id="《linux内核观测技术bpf》" tabindex="-1"><a class="header-anchor" href="#《linux内核观测技术bpf》"><span>《Linux内核观测技术BPF》</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="运行bpf程序" tabindex="-1"><a class="header-anchor" href="#运行bpf程序"><span>运行BPF程序</span></a></h1><h2 id="llvm-编译器" tabindex="-1"><a class="header-anchor" href="#llvm-编译器"><span>LLVM 编译器</span></a></h2><h3 id="llvm编译器" tabindex="-1"><a class="header-anchor" href="#llvm编译器"><span>LLVM编译器</span></a></h3><blockquote><p>最常见方住是使用 C 语言子集编写 BPF 程序，之后使用 LLVM 编译器进行编译。 <strong>LLVM 编译器</strong> 是一种通用编译器，可以编译成不同类型的<strong>字节码</strong> 。</p></blockquote><h3 id="字节码" tabindex="-1"><a class="header-anchor" href="#字节码"><span>字节码</span></a></h3><blockquote><p>针对 BPF 程序， LLVM 能够编译出加载到内核中执行的汇编代码。本书不会过多地介绍 BPF 汇编。经过慎重考虑，我们决定本书主要介绍在具体情景下如何使用 BDF，关于 BPF 汇编，你可以在网上轻松地找到-些参考或者通过 BPF 手册得到帮助。不过，之后的章节会有 BPF 汇编代码的简短示例，你会发现在某些情景下使用汇编比 C 语言更合适，例如，使用 Seccomp 过滤器控制内核的系统调用。我们将在第 8 章中详细讨论 Seccompo。</p></blockquote><h3 id="加载字节码" tabindex="-1"><a class="header-anchor" href="#加载字节码"><span>加载字节码</span></a></h3><blockquote><p>BPF 程序编译后，内核通过 bpf 系统调用将程序字节码加载到 BPF 虚拟机中 。 除加载程序外， bpf 系统调用还可用于其他操作，我们将在后续章节中看到更多的示例。内核还提供了一些工具 (帮助函数) 协助加载 BPF 程序。</p></blockquote><h3 id="许可证-gpl" tabindex="-1"><a class="header-anchor" href="#许可证-gpl"><span>许可证（GPL）</span></a></h3><blockquote><p>在下面示例的最后，我们还需要指定程序许可证。因为 Linux 内核采用 GPL 许可证，所以它只能加载 GPL 许可证的程序。如果将程序设置为其他许可证，内核将拒绝加载该程序。</p><p>我们使用函数 bpf_trace_printk 在内核跟踪日志中打印消息，你可以在文件 /syslkernel/debug/tracing/traceyipe 中查看。</p></blockquote><h2 id="第一个代码" tabindex="-1"><a class="header-anchor" href="#第一个代码"><span>第一个代码</span></a></h2><h3 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span>代码</span></a></h3><p>在第一个代码示例中，我们将使用这些帮助函数来实现 BPF 的&quot; Hello World&quot;：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/bpf.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SEC</span><span class="token expression"><span class="token punctuation">(</span>NAME<span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span><span class="token punctuation">(</span>NAME<span class="token punctuation">)</span> <span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token function">SEC</span><span class="token punctuation">(</span><span class="token string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 使用SEC属性告知BPF虚拟机何时运行此程序。当检测到 execve 系统调用跟踪点被执行时，BPF 程序将运行，我们会看到消息输出 “Hello，BPF World!”。 </span>
<span class="token keyword">int</span> <span class="token function">bpf_prog</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> msg<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">&quot;Hello, BPF World!&quot;</span><span class="token punctuation">;</span>
    <span class="token function">bpf_trace_printk</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">char</span> _license<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">SEC</span><span class="token punctuation">(</span><span class="token string">&quot;license&quot;</span><span class="token punctuation">)</span> <span class="token string">&quot;GPL&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码来检查内核的执行。我们将在第 4 章中详细讨论跟踪点。</p><h3 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h3><p>我们可以使用 clang 将第 一 个程序编译成内核可加载的 ELF (Executable and Linkable Format) 格式的二进制文件。我们将第一个 BPF 程序保存为 bpf_program.c ，使用下面的命令进行编译:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>clang <span class="token parameter variable">-O2</span> <span class="token parameter variable">-target</span> bpf <span class="token parameter variable">-c</span> bpf_program.c <span class="token parameter variable">-o</span> bpf_program.o
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="运行" tabindex="-1"><a class="header-anchor" href="#运行"><span>运行</span></a></h3><p>现在，我们已经编译了第一个 BPF 程序，我们需要将它加载到内核中运行 。如前所述，我们使用内核提供的特定帮助函数，该帮助函数会对编译和加载程序按模板抽象进行处理。这个帮助函数叫<code> load_bp_file</code> ，它将获取一 个二进制文件将它加载到内核中。 如下所示:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h &gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;uapi/linux/bpf.h &gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;bpf_load.h&quot;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc <span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">load_bpf_file</span><span class="token punctuation">(</span><span class="token string">&quot;hello_world_kern.o&quot;</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// load_bpf_file 帮助函数</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;The kernel didn&#39;t load the BPF program\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token function">read_trace_pipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以使用脚本编译和链接该程序生成 ELF 二进制文件 。 这里，我们不需要指定编译后的目标文件，因为该程序不会加载到 BPF 虚拟机中。编译程序需要一些依赖库，编写如下脚本会更容易将外部依赖库放在一起:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>TOOLS<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>tools
INCLUDE<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>libbpf<span class="token operator">/</span>include
HEADERS<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>libbpf<span class="token operator">/</span>src
clang <span class="token operator">-</span>o loader <span class="token operator">-</span>l elf \\
    <span class="token operator">-</span>I$<span class="token punctuation">{</span>INCLUDE<span class="token punctuation">}</span> \\
    <span class="token operator">-</span>I$<span class="token punctuation">{</span>HEADERS<span class="token punctuation">}</span> \\
    <span class="token operator">-</span>I$<span class="token punctuation">{</span>TOOLS<span class="token punctuation">}</span> \\
    $<span class="token punctuation">{</span>TOOLS<span class="token punctuation">}</span><span class="token operator">/</span>bpf_load<span class="token punctuation">.</span>c \\
    loader<span class="token punctuation">.</span>c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你要运行该程序，可以使用 sudo 执行此二进制文件 sudo ./loader。</p><p>sudo 是一个 Linux 命令，为你提供计算机的 root 特权。如果你不使用 sudo 运行该程序，将会返回错误消息，因为对于大多数 BPF 程序而言，只能由root 特权用户加载到内核中。</p><p>运行该程序，即使计算机不进行任何操作，几秒钟后你也将会看到 &quot;Hello ，BPF World !&quot;。这是因为计算机是一个井行的系统，其他程序在后台执行，可能正在执行其他程序。</p><p>程序停止后，消息将不在终端上显示。 一旦程序终止，加载的 BPF 程序将从BPF 虚拟机中卸载。在后续的章节中，我们将讨论如何使 B PF 程序持久化，BPF 程序甚至可以在加载器终止后继续运行，但现在，我们不想引人太多概念。请牢记这一重要概念，因为在许多情况下，你将在后台运行 BPF 程序，从系统中收集数据，不管其他进程是否正在运行。</p><h2 id="bpf程序类型" tabindex="-1"><a class="header-anchor" href="#bpf程序类型"><span>BPF程序类型</span></a></h2><p>虽然 BPF 程序没有明确的分类，但本节根据其主要目的，可以将 BPF 程序分为两类：</p><ol><li>跟踪 <ul><li>你能编写程序来更好地了解系统正在发生什么。这类程序提供了系统行为及系统硬件的直接信息。 例如： <ul><li>访问特定程序的内存区域，从运行进程中提取执行跟踪信息</li><li>直接访问为每个特定进程分配的资源，包括文件描述符、 CPU 和内存</li></ul></li></ul></li><li>网络 <ul><li>这类程序可以检测和控制系统的网络流量。可以对网络接口的数据包进行过滤，甚至可以完全拒绝数据包。我们可以使用不同的程序类型，将程序附加到内核网络处理的不同阶段上，这样做各有利弊。 例如： <ul><li>将 BPF 程序附加到网络驱动程序接收数据包的网络事件上，此时，由于内核没有提供足够的信息，程序也只能访问较少的数据包信息。另 一方面，你可以将 BPF 程序附加到数据包传递给用户空间的网络事件。在这种情况下，你可以获得更多的数据包信息，这将有助于你做出更明智的决策，但是完整地处理这些数据包信息需要付出更高的代价。</li></ul></li></ul></li></ol><h3 id="套接字过滤器程序" tabindex="-1"><a class="header-anchor" href="#套接字过滤器程序"><span>套接字过滤器程序</span></a></h3><p>（我们将在第 6 章中详细介绍套接宇过滤程序和其他网络程序）</p><p><code>BPF PROG TYPE SOCKET FILTER</code> 类型是添加到 Linux 内核的第一个程序类型。套接字过滤器程序会附加到原始套接字上，用于访问所有套接字处理的数据包。套接宇过滤器程序只能用于对套接字的观测，不允许修改数据包内容或更改其目的地。 BPF 程序会接收与网络协议桔信息相关的元数据，例如，发送数据包的协议类型。</p><h3 id="kprobe-程序" tabindex="-1"><a class="header-anchor" href="#kprobe-程序"><span>kprobe 程序</span></a></h3><p>kprobe 是动态附加到内核调用点的函数，我们将在第 4 章介绍跟踪时对kprobe 进行详细介绍。 BPF kprobe 程序类型允许使用 BPF 程序作为 kprobe的处理程序。程序类型被定义为 BPF_PROG_TYPE_KPROBE o BPF 虚拟机确保 kprobe 程序总是可以安全运行 ， 这是传统 kprobe 模块的优势。但需要注意，在内核中 kprobe 被认为是不稳定的入口点，因此你需要确定 kprobe BPF 程序是否与正在使用的特定内核版本兼容。</p><p>编写附加到 kprobe 模块上的 BPF 程序，我们需要确定 BPF 程序是在函数调用的第一条指令执行还是函数调用完成时执行。我们需要在 BPF 程序的 SEC头部声明行为。例如，如果你想在内核 exec 系统调用前检查参数，则需要在系统调用开始时附加 BPF 程序。</p><p>这里，你需要在 BPF 程序设置 SEC 头部: <code>SEC(&quot;kprobe/sys_exec&quot;) </code>。 如果你想检查 exec 系统调用的返回值，需要在 BPF 程序设置 SEC 头部 <code>SEC(&quot;kretprobe/sys_exec&quot;) </code></p><h3 id="跟踪点程序" tabindex="-1"><a class="header-anchor" href="#跟踪点程序"><span>跟踪点程序</span></a></h3><h3 id="xdp-程序" tabindex="-1"><a class="header-anchor" href="#xdp-程序"><span>XDP 程序</span></a></h3><h3 id="perf-事件程序" tabindex="-1"><a class="header-anchor" href="#perf-事件程序"><span>Perf 事件程序</span></a></h3><h3 id="cgroup-套接字程序" tabindex="-1"><a class="header-anchor" href="#cgroup-套接字程序"><span>cgroup 套接字程序</span></a></h3><h3 id="cgroup-打开套接字程序" tabindex="-1"><a class="header-anchor" href="#cgroup-打开套接字程序"><span>cgroup 打开套接字程序</span></a></h3><h3 id="套接字选项程序" tabindex="-1"><a class="header-anchor" href="#套接字选项程序"><span>套接字选项程序</span></a></h3><h3 id="套接字映射程序" tabindex="-1"><a class="header-anchor" href="#套接字映射程序"><span>套接字映射程序</span></a></h3><h3 id="cgroup-设备程序" tabindex="-1"><a class="header-anchor" href="#cgroup-设备程序"><span>cgroup 设备程序</span></a></h3><h3 id="套接字消息传递程序" tabindex="-1"><a class="header-anchor" href="#套接字消息传递程序"><span>套接字消息传递程序</span></a></h3><h3 id="原始跟踪点程序" tabindex="-1"><a class="header-anchor" href="#原始跟踪点程序"><span>原始跟踪点程序</span></a></h3><h3 id="cgroup-套接字地址程序" tabindex="-1"><a class="header-anchor" href="#cgroup-套接字地址程序"><span>cgroup 套接字地址程序</span></a></h3><h3 id="套接字重用端口程序" tabindex="-1"><a class="header-anchor" href="#套接字重用端口程序"><span>套接字重用端口程序</span></a></h3><h3 id="流量解析程序" tabindex="-1"><a class="header-anchor" href="#流量解析程序"><span>流量解析程序</span></a></h3><h3 id="其他-bpf-程序" tabindex="-1"><a class="header-anchor" href="#其他-bpf-程序"><span>其他 BPF 程序</span></a></h3><h2 id="bpf-验证器" tabindex="-1"><a class="header-anchor" href="#bpf-验证器"><span>BPF 验证器</span></a></h2><h2 id="bpf-类型格式" tabindex="-1"><a class="header-anchor" href="#bpf-类型格式"><span>BPF 类型格式</span></a></h2><h2 id="尾部调用" tabindex="-1"><a class="header-anchor" href="#尾部调用"><span>尾部调用</span></a></h2>`,56),l=[t];function o(c,i){return a(),s("div",null,l)}const d=n(p,[["render",o],["__file","02. 运行BPF程序.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/02.%20%E8%BF%90%E8%A1%8CBPF%E7%A8%8B%E5%BA%8F.html","title":"《Linux内核观测技术BPF》","lang":"zh-CN","frontmatter":{"description":"《Linux内核观测技术BPF》 目录 运行BPF程序 LLVM 编译器 LLVM编译器 最常见方住是使用 C 语言子集编写 BPF 程序，之后使用 LLVM 编译器进行编译。 LLVM 编译器 是一种通用编译器，可以编译成不同类型的字节码 。 字节码 针对 BPF 程序， LLVM 能够编译出加载到内核中执行的汇编代码。本书不会过多地介绍 BPF 汇...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/02.%20%E8%BF%90%E8%A1%8CBPF%E7%A8%8B%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《Linux内核观测技术BPF》"}],["meta",{"property":"og:description","content":"《Linux内核观测技术BPF》 目录 运行BPF程序 LLVM 编译器 LLVM编译器 最常见方住是使用 C 语言子集编写 BPF 程序，之后使用 LLVM 编译器进行编译。 LLVM 编译器 是一种通用编译器，可以编译成不同类型的字节码 。 字节码 针对 BPF 程序， LLVM 能够编译出加载到内核中执行的汇编代码。本书不会过多地介绍 BPF 汇..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《Linux内核观测技术BPF》\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《Linux内核观测技术BPF》","slug":"《linux内核观测技术bpf》","link":"#《linux内核观测技术bpf》","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"运行BPF程序","slug":"运行bpf程序","link":"#运行bpf程序","children":[{"level":2,"title":"LLVM 编译器","slug":"llvm-编译器","link":"#llvm-编译器","children":[{"level":3,"title":"LLVM编译器","slug":"llvm编译器","link":"#llvm编译器","children":[]},{"level":3,"title":"字节码","slug":"字节码","link":"#字节码","children":[]},{"level":3,"title":"加载字节码","slug":"加载字节码","link":"#加载字节码","children":[]},{"level":3,"title":"许可证（GPL）","slug":"许可证-gpl","link":"#许可证-gpl","children":[]}]},{"level":2,"title":"第一个代码","slug":"第一个代码","link":"#第一个代码","children":[{"level":3,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":3,"title":"编译","slug":"编译","link":"#编译","children":[]},{"level":3,"title":"运行","slug":"运行","link":"#运行","children":[]}]},{"level":2,"title":"BPF程序类型","slug":"bpf程序类型","link":"#bpf程序类型","children":[{"level":3,"title":"套接字过滤器程序","slug":"套接字过滤器程序","link":"#套接字过滤器程序","children":[]},{"level":3,"title":"kprobe 程序","slug":"kprobe-程序","link":"#kprobe-程序","children":[]},{"level":3,"title":"跟踪点程序","slug":"跟踪点程序","link":"#跟踪点程序","children":[]},{"level":3,"title":"XDP 程序","slug":"xdp-程序","link":"#xdp-程序","children":[]},{"level":3,"title":"Perf 事件程序","slug":"perf-事件程序","link":"#perf-事件程序","children":[]},{"level":3,"title":"cgroup 套接字程序","slug":"cgroup-套接字程序","link":"#cgroup-套接字程序","children":[]},{"level":3,"title":"cgroup 打开套接字程序","slug":"cgroup-打开套接字程序","link":"#cgroup-打开套接字程序","children":[]},{"level":3,"title":"套接字选项程序","slug":"套接字选项程序","link":"#套接字选项程序","children":[]},{"level":3,"title":"套接字映射程序","slug":"套接字映射程序","link":"#套接字映射程序","children":[]},{"level":3,"title":"cgroup 设备程序","slug":"cgroup-设备程序","link":"#cgroup-设备程序","children":[]},{"level":3,"title":"套接字消息传递程序","slug":"套接字消息传递程序","link":"#套接字消息传递程序","children":[]},{"level":3,"title":"原始跟踪点程序","slug":"原始跟踪点程序","link":"#原始跟踪点程序","children":[]},{"level":3,"title":"cgroup 套接字地址程序","slug":"cgroup-套接字地址程序","link":"#cgroup-套接字地址程序","children":[]},{"level":3,"title":"套接字重用端口程序","slug":"套接字重用端口程序","link":"#套接字重用端口程序","children":[]},{"level":3,"title":"流量解析程序","slug":"流量解析程序","link":"#流量解析程序","children":[]},{"level":3,"title":"其他 BPF 程序","slug":"其他-bpf-程序","link":"#其他-bpf-程序","children":[]}]},{"level":2,"title":"BPF 验证器","slug":"bpf-验证器","link":"#bpf-验证器","children":[]},{"level":2,"title":"BPF 类型格式","slug":"bpf-类型格式","link":"#bpf-类型格式","children":[]},{"level":2,"title":"尾部调用","slug":"尾部调用","link":"#尾部调用","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.06,"words":2119},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/02. 运行BPF程序.md","autoDesc":true}');export{d as comp,k as data};
