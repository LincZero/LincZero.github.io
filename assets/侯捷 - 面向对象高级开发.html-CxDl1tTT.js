import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as t,c as r,b as i,d as e,e as c,a as n}from"./app-CsHIiQ5U.js";const d={},p=n(`<p>参考：侯捷 - 面向对象高级开发 系列视频</p><h1 id="_1-c-编程简介" tabindex="-1"><a class="header-anchor" href="#_1-c-编程简介"><span>1.C++编程简介</span></a></h1><h2 id="书录" tabindex="-1"><a class="header-anchor" href="#书录"><span>书录</span></a></h2><p>C++</p><ul><li>C++ Primer</li><li>The C++ Programming Language</li></ul><p>建议经验</p><ul><li>Effective C++</li></ul><p>标准库</p><ul><li>The C++ Standard Library（标准库的学习）</li><li>STL源码解析（再深入的话，关于STL源码的）</li></ul><h1 id="_2-头文件与类的声明" tabindex="-1"><a class="header-anchor" href="#_2-头文件与类的声明"><span>2.头文件与类的声明</span></a></h1><h1 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数"><span>构造函数</span></a></h1><p>构造函数的 initialization list，列表初始化</p><h1 id="参数传递和返回值" tabindex="-1"><a class="header-anchor" href="#参数传递和返回值"><span>参数传递和返回值</span></a></h1><p>单例模式</p><p>常量成员函数</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>double real() const {return re;}
xxx (const complex&amp;);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>d(complex* ths, const complex&amp; r){
    this-&gt;re += r.re;
    this-&gt;im += r.im;
    return *ths;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>值传递和引用传递</p><p>友元 —— “相同class的各个objects互为firends”</p><h1 id="操作符重载与临时对象" tabindex="-1"><a class="header-anchor" href="#操作符重载与临时对象"><span>操作符重载与临时对象</span></a></h1><p>未</p><h1 id="复习complex的实现过程" tabindex="-1"><a class="header-anchor" href="#复习complex的实现过程"><span>复习Complex的实现过程</span></a></h1><p>未</p><h1 id="三大函数-拷贝构造-拷贝复制-析构" tabindex="-1"><a class="header-anchor" href="#三大函数-拷贝构造-拷贝复制-析构"><span>三大函数：拷贝构造，拷贝复制，析构</span></a></h1><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>int main()
{
    String s1();
    String s2(&quot;hello&quot;);
    
    String s3(s1);	// 拷贝构造
    
    s3 = s2;		// 拷贝复制
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果类包含指针，<strong>必须</strong>要自己写拷贝构造，否则两个指针会指向同一个东西</p>`,26),o={href:"https://gcallah.github.io/OOP2/big3.html",target:"_blank",rel:"noopener noreferrer"},m=n(`<div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class String
{
public:
    String(const char* cstr = 0);
    String(const String&amp; str);
    String&amp; operator=(const String&amp; str);
    ~String();
    char* get_c_str() const {return m_data;}
private:
    char* m_data;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ctor 和 dtor（构造函数和析构函数，constructor 和 destructor）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>inline
string: : String (const char* cstr = 0)
{
	if (cstr) {
		m _data =new char [strlen (cstr)+1];strepy (m_data, cstr);
	}
	else {	//未指定初值
		m_data = new char[1];*m data = &#39;\\0&#39; ;
	}
}

inline
string: :~String ()
{
	delete[] m_data;
}

// 
{
    String s1();
    String s2(&quot;Hello&quot;);
    
    String* p = new String(&quot;hello&quot;);
    delete p;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="class-with-pointer-members-必须有-copy-ctor-和-copy-op-析构也要吧" tabindex="-1"><a class="header-anchor" href="#class-with-pointer-members-必须有-copy-ctor-和-copy-op-析构也要吧"><span>class with pointer members 必须有 copy ctor 和 copy op=（析构也要吧）</span></a></h2><p>还需要检测自我赋值，不然可能有bug（不只是为了效率）</p><p>![image-20230302051826719](侯捷 - 面向对象高级开发.assets/image-20230302051826719.png)</p><h1 id="堆-栈与内存管理" tabindex="-1"><a class="header-anchor" href="#堆-栈与内存管理"><span><mark>堆，栈与内存管理</mark></span></a></h1><h2 id="堆-栈" tabindex="-1"><a class="header-anchor" href="#堆-栈"><span>堆，栈</span></a></h2><p>Stack，是存在与某作用域（scope）的一块内存空间（memory space）。例如当你调用函数，函数本身即会形成一个stack用来防止它所接受的参数，以及返回地址 在函数本体（fucntion body）内声明的任何变量，其所使用的内存块都取自上述stack</p><p>Heap，或谓system heap，是指由操作系统提供的一块global内存空间，程序可动态分配（dynamic allocaed）从某中获得若干区块（blocks） （new 出来是heap）</p><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><ul><li>stack objects 的生命周期、也叫 auto object（离开大括号自动释放）</li><li>static local objects 的生命周期，直到整个程序结束</li><li>global objects 的生命周期，在整个程序结束后才结束，也可以把它视为一种static object，其作用域是整个程序</li></ul><h2 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h2><p>![image-20230302055145589](侯捷 - 面向对象高级开发.assets/image-20230302055145589.png)</p><h2 id="new-delete的底层原理" tabindex="-1"><a class="header-anchor" href="#new-delete的底层原理"><span>new/delete的底层原理</span></a></h2><p>![image-20230302055343858](侯捷 - 面向对象高级开发.assets/image-20230302055343858.png)</p><p>![image-20230302055709496](侯捷 - 面向对象高级开发.assets/image-20230302055709496.png)</p><h2 id="动态分配所得的内存块-vc" tabindex="-1"><a class="header-anchor" href="#动态分配所得的内存块-vc"><span>动态分配所得的内存块（VC）</span></a></h2><p>左侧两个是复数，右侧两个是String。 左列是调试模式，调试模式分配的内存会大很多</p><ul><li>红色的叫cookie（内容是16进制指示的大小：40就是64，10就是16，30就是48。而+1表示这个内存是给出去的）</li><li>深绿色的是填补（这里是填补成2的幂次方大小）</li><li>亮绿色是给对象实际的内存（例如这里的complex里的内容，其实就是两个double的大小=8h=8字节。h表示的是hex16进制的字节数）</li></ul><p>![image-20230302061852875](侯捷 - 面向对象高级开发.assets/image-20230302061852875.png)</p><h2 id="动态分配所得的array" tabindex="-1"><a class="header-anchor" href="#动态分配所得的array"><span>动态分配所得的array</span></a></h2><p>![image-20230302063838050](侯捷 - 面向对象高级开发.assets/image-20230302063838050.png)</p><p>![image-20230302064056605](侯捷 - 面向对象高级开发.assets/image-20230302064056605.png)</p><h1 id="复习string类的实现过程" tabindex="-1"><a class="header-anchor" href="#复习string类的实现过程"><span>复习String类的实现过程</span></a></h1><p>![image-20230302065045243](侯捷 - 面向对象高级开发.assets/image-20230302065045243.png)</p><p>![image-20230302080433021](侯捷 - 面向对象高级开发.assets/image-20230302080433021.png)</p><h1 id="扩展补充-类模板-函数模板-及其他" tabindex="-1"><a class="header-anchor" href="#扩展补充-类模板-函数模板-及其他"><span>扩展补充：类模板，函数模板，及其他</span></a></h1><p>补充：static</p><p>成员变量 <code>this-&gt;</code> 的省略，static没有this</p><p>调用static函数的两种方法：通过object或class name调用</p><p>cout</p><p>calss template，类模板</p><p>namespace，命名空间</p><p>![image-20230302102205604](侯捷 - 面向对象高级开发.assets/image-20230302102205604.png)</p><p>![image-20230302102937597](侯捷 - 面向对象高级开发.assets/image-20230302102937597.png)</p>`,36);function h(v,u){const a=s("ExternalLinkIcon");return t(),r("div",null,[p,i("p",null,[e("三个特殊函数（"),i("a",o,[e("The Big Three"),c(a)]),e("，指 拷贝构造函数、赋值操作符、析构函数。另外，当您需要编写其中任何一个时，您很可能需要编写另外两个）")]),m])}const E=l(d,[["render",h],["__file","侯捷 - 面向对象高级开发.html.vue"]]),_=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/08.%20C__%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E4%BE%AF%E6%8D%B7%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/%E4%BE%AF%E6%8D%B7%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91.html","title":"1.C++编程简介","lang":"zh-CN","frontmatter":{"description":"参考：侯捷 - 面向对象高级开发 系列视频 1.C++编程简介 书录 C++ C++ Primer The C++ Programming Language 建议经验 Effective C++ 标准库 The C++ Standard Library（标准库的学习） STL源码解析（再深入的话，关于STL源码的） 2.头文件与类的声明 构造函数 构造...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/08.%20C__%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E4%BE%AF%E6%8D%B7%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/%E4%BE%AF%E6%8D%B7%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"1.C++编程简介"}],["meta",{"property":"og:description","content":"参考：侯捷 - 面向对象高级开发 系列视频 1.C++编程简介 书录 C++ C++ Primer The C++ Programming Language 建议经验 Effective C++ 标准库 The C++ Standard Library（标准库的学习） STL源码解析（再深入的话，关于STL源码的） 2.头文件与类的声明 构造函数 构造..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.C++编程简介\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"1.C++编程简介","slug":"_1-c-编程简介","link":"#_1-c-编程简介","children":[{"level":2,"title":"书录","slug":"书录","link":"#书录","children":[]}]},{"level":1,"title":"2.头文件与类的声明","slug":"_2-头文件与类的声明","link":"#_2-头文件与类的声明","children":[]},{"level":1,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[]},{"level":1,"title":"参数传递和返回值","slug":"参数传递和返回值","link":"#参数传递和返回值","children":[]},{"level":1,"title":"操作符重载与临时对象","slug":"操作符重载与临时对象","link":"#操作符重载与临时对象","children":[]},{"level":1,"title":"复习Complex的实现过程","slug":"复习complex的实现过程","link":"#复习complex的实现过程","children":[]},{"level":1,"title":"三大函数：拷贝构造，拷贝复制，析构","slug":"三大函数-拷贝构造-拷贝复制-析构","link":"#三大函数-拷贝构造-拷贝复制-析构","children":[{"level":2,"title":"class with pointer members 必须有 copy ctor 和 copy op=（析构也要吧）","slug":"class-with-pointer-members-必须有-copy-ctor-和-copy-op-析构也要吧","link":"#class-with-pointer-members-必须有-copy-ctor-和-copy-op-析构也要吧","children":[]}]},{"level":1,"title":"堆，栈与内存管理","slug":"堆-栈与内存管理","link":"#堆-栈与内存管理","children":[{"level":2,"title":"堆，栈","slug":"堆-栈","link":"#堆-栈","children":[]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]},{"level":2,"title":"new/delete的底层原理","slug":"new-delete的底层原理","link":"#new-delete的底层原理","children":[]},{"level":2,"title":"动态分配所得的内存块（VC）","slug":"动态分配所得的内存块-vc","link":"#动态分配所得的内存块-vc","children":[]},{"level":2,"title":"动态分配所得的array","slug":"动态分配所得的array","link":"#动态分配所得的array","children":[]}]},{"level":1,"title":"复习String类的实现过程","slug":"复习string类的实现过程","link":"#复习string类的实现过程","children":[]},{"level":1,"title":"扩展补充：类模板，函数模板，及其他","slug":"扩展补充-类模板-函数模板-及其他","link":"#扩展补充-类模板-函数模板-及其他","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.45,"words":1036},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/08. C++高级编程/侯捷 - 面向对象高级开发/侯捷 - 面向对象高级开发.md","autoDesc":true}');export{E as comp,_ as data};
