import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as s,c as t,b as l,e,d,a as i}from"./app-Ld2qzqw_.js";const r={},o=i('<h1 id="_02-模块系统" tabindex="-1"><a class="header-anchor" href="#_02-模块系统"><span>02. 模块系统</span></a></h1><h2 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h2><h3 id="概念、底层原理-c" tabindex="-1"><a class="header-anchor" href="#概念、底层原理-c"><span>概念、底层原理（C++）</span></a></h3>',3),u=l("li",null,[l("p",null,[l("strong",null,"C++库函数")]),l("ul",null,[l("li",null,"C++库函数存储在库文件中，编译程序时会自动在库文件搜索你使用的函数（但好像还是要写头文件？）"),l("li",null,"即库文件包括很多头文件咯。库文件是工具仓库，头文件（库）是工具箱，头文件函数是工具")])],-1),p={href:"https://www.runoob.com/w3cnote/cpp-header.html",target:"_blank",rel:"noopener noreferrer"},h=l("strong",null,"头文件",-1),v=l("strong",null,"作用",-1),m=i("<ul><li><p>模块系统的作用：</p></li><li><p>提供函数原型的作用：简单来讲，头文件包括了库的函数原型的声明</p></li><li><p><strong>为什么C/C++中有标准库头文件</strong></p><ul><li><p>这也是由于C/C++相较于其他一些语言的一个不同所导致的，C/C++使用函数前需要先声明函数原型</p><p>而头文件除了提供模块以外，另一个作用是提高声明函数原型</p></li><li><p>而像Python这种不需要写函数原型声明的语言，其直接使用解释器内嵌的内置函数，就不需要标准库的存在了</p><p>只有使用非内置函数、使用其他模块时，才需要声明</p></li><li><p>C/C++没有编译时自动加入标准库的操作，说是“标准库”，但其实不存在真正意义上的标准库</p><p>stdio/iostream里最重要的其实还是输入输出流，但并不必须。有的文件并不需要引入</p></li></ul></li><li><p><strong>C++中不使用头文件cmath，也能运行sqrt函数？</strong></p><ul><li>MSVC STL在实现iostream的数值输入/输出时用了<code>&lt;cmath&gt;</code>中的一些函数（比如<code>ldexp</code>），所以<code>&lt;iostream&gt;</code>间接包含了<code>&lt;cmath&gt;</code></li><li>不过这是实现细节，随时可能会改</li></ul></li></ul>",1),g=i(`<h2 id="头文件" tabindex="-1"><a class="header-anchor" href="#头文件"><span>头文件</span></a></h2><h3 id="头文件声明" tabindex="-1"><a class="header-anchor" href="#头文件声明"><span>头文件声明</span></a></h3><p>有两种</p><ul><li>使用<code>&lt;&gt;</code>包裹，如<code>&lt;coo din.h&gt;</code><ul><li>编译器会在存储标准头文件的主机系统的文件系统中查找</li></ul></li><li>使用<code>&quot;&quot;</code>包裹，如<code>&quot;&lt;coordin.h&quot;</code><ul><li>编译器首先查找当前的工作目录或源代码目录（或编译器指定其他目录） 如果没有找到头文件，则编译器再在标准位置查找</li><li>在包含自己的头文件时，应使用引号而不是尖括号</li></ul></li></ul><h3 id="头文件内容" tabindex="-1"><a class="header-anchor" href="#头文件内容"><span>头文件内容</span></a></h3><h4 id="头文件可以放的东西" tabindex="-1"><a class="header-anchor" href="#头文件可以放的东西"><span>头文件可以放的东西</span></a></h4><ul><li>可放 <ul><li>结构声明</li><li>函数模板声明</li><li>内联函数定义：原因：会被预处理掉</li><li>类声明中的函数定义：原因：就算不加<code>inline</code>也会被视作内联函数</li><li>const常量：原因详见内存管理一章的底层原理，其第一次使用时才分配内存</li><li>enum枚举：原因：未知</li><li>priveta中函数定义（不用加inline为内联函数）：原因：这种函数并不会在客户程序中定义，当多个文件引用一个头文件时当然也并不会起冲突</li></ul></li><li>不可放 <ul><li>普通函数定义</li><li>变量声明（定义）</li></ul></li></ul><h4 id="应该放的东西" tabindex="-1"><a class="header-anchor" href="#应该放的东西"><span>应该放的东西</span></a></h4><ul><li>类声明头文件 <ul><li>函数/类模板声明：不能放实现文件，其不能被独立编译</li><li>内联函数定义：不能放实现文件，其不能被独立编译</li></ul></li><li>类实现文件</li><li>客户代码文件</li></ul><h4 id="不可放的原因" tabindex="-1"><a class="header-anchor" href="#不可放的原因"><span>不可放的原因</span></a></h4><ul><li>头文件的引用<code>#include</code>使用的是预处理机制</li><li>在头文件中定义会导致多个文件定义同一样东西，违反C++的单一定义原则</li></ul><h3 id="类与头文件" tabindex="-1"><a class="header-anchor" href="#类与头文件"><span>类与头文件</span></a></h3><ul><li><p>常见问题：</p><ul><li><p>可以在实现代码中定义变量而不在头文件中声明吗？</p></li><li><p>可以，但这样定义出来的变量的作用域是局部的，即无法被其他类函数使用，只能使用函数传参（使用起来不方便，放了相当于有全局变量方便点）</p><p>一般临时变量可以这样做。即使是new出来的变量，指向他的指针也会在头文件中声明</p></li></ul></li></ul><h2 id="头文件-——-宏" tabindex="-1"><a class="header-anchor" href="#头文件-——-宏"><span>头文件 —— 宏</span></a></h2><h3 id="常用宏" tabindex="-1"><a class="header-anchor" href="#常用宏"><span>常用宏</span></a></h3><p>其他</p><ul><li>宏定义 #define</li><li>文件包含 #include</li><li>条件编译 #if</li></ul><p>QT的宏</p><ul><li><p>Q_OBJECT，Qt元对象系统</p></li><li><p>QT_BEGIN_NAMESPACE，命名空间</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>QT_FORWARD_DECLARE_CLASS，和头文件#include作用类似</p></li></ul><p>C++常用宏</p><ul><li><code>#undef XXX</code>为解除定义</li><li><code>#error XXXX </code></li></ul><h3 id="条件编译宏" tabindex="-1"><a class="header-anchor" href="#条件编译宏"><span>条件编译宏</span></a></h3><p>条件编译宏</p><ul><li><code>#ifdef XXX - #endif</code>，如果定义</li><li><code>#ifndef XXX - #endif</code>，如果没定义，if not defined的缩写。用途：避免重复包含头文件</li><li><code>#if !defined XXX - #endif</code>，如果没定义</li><li><code>#if defined XXX - #endif </code>，如果定义。用途：是根据你是否定义了XXX这个宏，而使用不同的代码</li><li><code>#elif</code></li><li><code>#else</code></li><li>区别 <ul><li>#ifdef只能判断单一的宏是否定义，而#if defined()可以组成复杂的判别条件</li><li>对于单一的宏AAA来说，#ifdef AAA和#if defined(AAA)是<strong>完全相同</strong>的</li><li>而要组成复杂的判别条件，用#if defined()就灵活方便了，比如：<code>#if defined(AAA) &amp;&amp; (BBB &gt;= 10)</code></li></ul></li></ul><hr><p>以<code>#ifndef</code>为例</p><ul><li><p>简概</p><ul><li>同一个文件中只能将同一个头文件包含一次</li><li>但对于嵌套包含头文件或者其他情况，可能会包含多次</li><li>标准C/C++的一种技术可以避免多次包含同一头文件，其基于预处理编译指令<code>#ifndef</code>（<em>if not defined</em>）</li></ul></li><li><p>使用</p><ul><li><p>举例：（写在头文件中，而不是引用头文件的调用函数中）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#ifndef COORDIN_H_ // 如果没有定义
#define COORDIN_H_ // 那么就定义（预编译定义常量）
// ...
#endif // 否则跳到此处、编译器不读取中间的内容（已经定义的话）

/* ...
 * ...
 * ... 
 */

#ifndef COORDIN_H_ // 当定义两次时，这里因为前面已经定义了，所以跳过这一块
#define COORDIN_H_
// ...
#endif
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>原理</p><ul><li><p>编译器过程</p><ul><li><p>编译器首次遇到该文件时，名称<code>COORDIN_H_</code>没有定义 （根据include文件名来选择名称，并加上一些下划线，以创建一个其他地方不会被定义的名称）</p><p>在这种情况下，编译器将查看<code>#ifndef</code>和<code>#endif</code>之间的内容，并读取定义<code>COORDIN_H_</code>的一行</p></li><li><p>如果在同一个文件遇到其他包含coordin.h的代码，编译器将知道<code>COORDIN_H_</code>已经被定义了，从而跳到<code>#endif</code>后面的一行上</p></li></ul></li><li><p>原理总结</p><ul><li>这种方法不防止编译器将文件包含两次，只是让它忽略除第一次包含之外的所有内容 （大多数标准C和C++头文件使用这种防护方案，在同一个文件中定义同一个结构两次不会导致编译错误）</li></ul></li></ul></li></ul><h3 id="两种防止头文件重复包含的方式" tabindex="-1"><a class="header-anchor" href="#两种防止头文件重复包含的方式"><span>两种防止头文件重复包含的方式</span></a></h3><p>为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式</p><p>#ifndef方式</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#ifndef MAINWINDOW_H
#define MAINWINDOW_H
// ...
#endif // MAINWINDOW_H
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>#pragma once方式</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#pragma once
// ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>区别：在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别</p><ul><li>#ifndef <ul><li>#ifndef的方式受C/C++语言标准支持。它不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含</li><li>缺点：如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷</li></ul></li><li>#pragma once <ul><li>一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件</li><li>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件</li><li>好处：你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些</li><li>缺点：如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包含很容易被发现并修正</li><li>缺点2：这种方式不支持跨平台</li></ul></li></ul><h2 id="模块设计" tabindex="-1"><a class="header-anchor" href="#模块设计"><span>模块设计</span></a></h2><p>编译和链接</p><ul><li>C++孤立将组建单独编译，然后在链接成可执行的程序（C++编译器既编译程序，也管理链接器）</li><li>这种做法的优点：如果只修改了一个文件，只需要重新编译该文件再链接。而无需所有文件一起重新编译</li></ul><p>程序结构：可以分成三部分（原型、定义、调用，三者分离），<strong>这种组织方法模块设计与OOP设计一致</strong></p><ul><li>头文件：包含<strong>结构声明</strong>和使用这些结构的函数的<strong>原型</strong></li><li>源代码文件1：包含与结构有关的函数的<strong>定义</strong>代码</li><li>源代码文件2：包含<strong>调用</strong>与结构相关的函数的代码</li></ul><h2 id="名称空间" tabindex="-1"><a class="header-anchor" href="#名称空间"><span>名称空间</span></a></h2><h3 id="名称空间-1" tabindex="-1"><a class="header-anchor" href="#名称空间-1"><span>名称空间</span></a></h3><h4 id="简概-1" tabindex="-1"><a class="header-anchor" href="#简概-1"><span>简概</span></a></h4><ul><li>名称空间原理：通过定义一种新的声明区域（声明区域详见内存管理思想一章）来创建命名的名称空间</li><li>名称空间与文件的关系 <ul><li>文件中可有不同的名称空间</li><li>不同文件可以有相同的名称空间</li><li>即两者没有定性的包含关系</li></ul></li><li>叫法 <ul><li>未被装饰的名称称为<code>未限定的名称</code>（<em>unqualified name</em>），如<code>cout</code></li><li>包含名称空间名的名称称为<code>限定的名称</code>（<em>qualigied name</em>），如<code>std::cout</code></li></ul></li></ul><h4 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h4><ul><li><p>声明</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>namespace Jack{
    int n;
    // ...
}
namespace Jill {
    // ...
}

/* 与类结合使用 */
namespace VECTOR
{
    class Vector
    {
        // 与类的使用
    }
}
/* 在QT中的使用 */
QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用（三种方法）</p><ul><li><strong>作用域解析运算符</strong>：<code>名称空间名</code>+<code>作用域解析运算符::</code>+<code>里面的成员</code>，举例：<code>Jack::n;</code>、<code>std::cout &lt;&lt;</code></li><li><strong>using编译指令</strong>：<code>using namespace 名称空间名;</code>，举例：<code>usign namespace std;</code></li><li><strong>using声明方法</strong>：<code>using namespace</code></li></ul></li></ul><h4 id="其他特性" tabindex="-1"><a class="header-anchor" href="#其他特性"><span>其他特性</span></a></h4><ul><li><p>注意项</p><ul><li>导入名称是，首选作用域解析运算符和using声明方法</li><li>而对于using声明，首选使用将其作用域设置为局部而不是全局</li><li>不要在头文件中使用using编译指令，否则可能会掩盖了要让那些名称可用，而且包含头文件的顺序可能会影响程序行为</li></ul></li><li><p>名称空间可以嵌套：例如<code>namespace nna{namespace nnb{int n;}}</code>，<code>nna::nnb::n;</code></p></li><li><p>可以使用匿名名称空间：例如<code>namespace {int spn;}</code></p><ul><li>这种用法等价于后面跟着using指令一样</li><li>原理：其潜在作用域为：从声明点到声明区域结尾</li><li>使用场景：提供了<strong>链接性为内部的静态变量</strong>的代替品（可以批量定义静态变量），其他文件无法连接访问</li></ul></li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><ul><li>取代静态全局变量、以及外部全局变量的用法</li><li>如果开发了一个函数库或者类库，应该放在一个名称空间中</li><li>作为将旧代码转换为使用名称空间代码的权宜之计</li></ul><h2 id="单独编译" tabindex="-1"><a class="header-anchor" href="#单独编译"><span>单独编译</span></a></h2><h3 id="先单独编译-后链接" tabindex="-1"><a class="header-anchor" href="#先单独编译-后链接"><span>先单独编译，后链接</span></a></h3><ul><li>C++提倡这种做法，能节省编译的效率。但这会引发一些问题（多个库的链接）</li></ul><h3 id="多个库的链接" tabindex="-1"><a class="header-anchor" href="#多个库的链接"><span>多个库的链接</span></a></h3><p>多个库链接 x 名称修饰（可能存在的问题）</p><ul><li>名称修饰对于二进制模块链接的影响 <ul><li>C++标准运行每个<code>编译器设计人员</code>以他认为的何时方式实现名称修饰，两个编译器将为同一个函数生成不同的修饰名</li><li>所以它们各自编译的二进制模块可能无法正确链接</li></ul></li><li>解决方案 <ul><li>确保所有对象文件或库都是同一个编译器生成的</li><li>如果有源代码，则可以用自己的编译器重新编译源代码来消除链接错误</li></ul></li></ul><h1 id="特殊操作" tabindex="-1"><a class="header-anchor" href="#特殊操作"><span>特殊操作</span></a></h1><h2 id="跨工程-调用头文件" tabindex="-1"><a class="header-anchor" href="#跨工程-调用头文件"><span>“跨工程”调用头文件</span></a></h2>`,58),f={href:"https://blog.csdn.net/shupan001/article/details/6436133",target:"_blank",rel:"noopener noreferrer"},b=i("<p>问题描述</p><blockquote><p>在Qt中实验时发现了一个问题 两个项目：A.h、A.cpp、B.h、B.cpp，其中项目B要使用项目A中的类 _ B.h：#include A.h 报错：error: LNK2019: 无法解析的外部符号......中引用了该符号 _ B.h：#include A.h、#include A.cpp 报错 _ B.h：#include A.h B.cpp：#include A.cpp 正确运行 _ 然后我懵了......这是种什么操作？我都不知道怎么在搜索引擎描述这个问题了</p></blockquote><p>原理</p><blockquote><p>首先，#include是“预处理机制”机制对吧，除去条件编译等操作，大概相当于把被include的头文件拷贝了一份到当前头文件 那么，#include cpp他也是同理的</p><p>如果是在同一个工程内，不需要include cpp这一步。是否可以理解为，如果是分别在两个工程内，两个工程已经被分别编译了，你B工程没办法知道A工程的源代码，所以include头文件无效</p><p>而include cpp的工程相当于是将A工程的源代码拷贝到B工程里面</p><p>然后看上去B工程使用了A工程里面的类，但事实上只是一份拷贝</p></blockquote><p>总结</p><blockquote><p>这种操作也就实验一下，耦合很高</p></blockquote>",6);function _(E,A){const n=c("ExternalLinkIcon");return s(),t("div",null,[o,l("ul",null,[u,l("li",null,[l("p",null,[l("a",p,[e("理解 C++ 中的"),h,e("和源文件的"),v,d(n)])]),m])]),g,l("p",null,[e("参考："),l("a",f,[e("【CSDN】error LNK2019: 无法解析的外部符号....该符号在函数 ...中被引用 "),d(n)])]),b])}const k=a(r,[["render",_],["__file","02. 模块系统.html.vue"]]),x=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/02.%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F.html","title":"02. 模块系统","lang":"zh-CN","frontmatter":{"description":"02. 模块系统 简概 概念、底层原理（C++） C++库函数 C++库函数存储在库文件中，编译程序时会自动在库文件搜索你使用的函数（但好像还是要写头文件？） 即库文件包括很多头文件咯。库文件是工具仓库，头文件（库）是工具箱，头文件函数是工具 理解 C++ 中的头文件和源文件的作用 模块系统的作用： 提供函数原型的作用：简单来讲，头文件包括了库的函数原...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/02.%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"02. 模块系统"}],["meta",{"property":"og:description","content":"02. 模块系统 简概 概念、底层原理（C++） C++库函数 C++库函数存储在库文件中，编译程序时会自动在库文件搜索你使用的函数（但好像还是要写头文件？） 即库文件包括很多头文件咯。库文件是工具仓库，头文件（库）是工具箱，头文件函数是工具 理解 C++ 中的头文件和源文件的作用 模块系统的作用： 提供函数原型的作用：简单来讲，头文件包括了库的函数原..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"02. 模块系统\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"02. 模块系统","slug":"_02-模块系统","link":"#_02-模块系统","children":[{"level":2,"title":"简概","slug":"简概","link":"#简概","children":[{"level":3,"title":"概念、底层原理（C++）","slug":"概念、底层原理-c","link":"#概念、底层原理-c","children":[]}]},{"level":2,"title":"头文件","slug":"头文件","link":"#头文件","children":[{"level":3,"title":"头文件声明","slug":"头文件声明","link":"#头文件声明","children":[]},{"level":3,"title":"头文件内容","slug":"头文件内容","link":"#头文件内容","children":[{"level":4,"title":"头文件可以放的东西","slug":"头文件可以放的东西","link":"#头文件可以放的东西","children":[]},{"level":4,"title":"应该放的东西","slug":"应该放的东西","link":"#应该放的东西","children":[]},{"level":4,"title":"不可放的原因","slug":"不可放的原因","link":"#不可放的原因","children":[]}]},{"level":3,"title":"类与头文件","slug":"类与头文件","link":"#类与头文件","children":[]}]},{"level":2,"title":"头文件 —— 宏","slug":"头文件-——-宏","link":"#头文件-——-宏","children":[{"level":3,"title":"常用宏","slug":"常用宏","link":"#常用宏","children":[]},{"level":3,"title":"条件编译宏","slug":"条件编译宏","link":"#条件编译宏","children":[]},{"level":3,"title":"两种防止头文件重复包含的方式","slug":"两种防止头文件重复包含的方式","link":"#两种防止头文件重复包含的方式","children":[]}]},{"level":2,"title":"模块设计","slug":"模块设计","link":"#模块设计","children":[]},{"level":2,"title":"名称空间","slug":"名称空间","link":"#名称空间","children":[{"level":3,"title":"名称空间","slug":"名称空间-1","link":"#名称空间-1","children":[{"level":4,"title":"简概","slug":"简概-1","link":"#简概-1","children":[]},{"level":4,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":4,"title":"其他特性","slug":"其他特性","link":"#其他特性","children":[]},{"level":4,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]}]},{"level":2,"title":"单独编译","slug":"单独编译","link":"#单独编译","children":[{"level":3,"title":"先单独编译，后链接","slug":"先单独编译-后链接","link":"#先单独编译-后链接","children":[]},{"level":3,"title":"多个库的链接","slug":"多个库的链接","link":"#多个库的链接","children":[]}]}]},{"level":1,"title":"特殊操作","slug":"特殊操作","link":"#特殊操作","children":[{"level":2,"title":"“跨工程”调用头文件","slug":"跨工程-调用头文件","link":"#跨工程-调用头文件","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":11.13,"words":3338},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/07. 模块库/02. 模块系统.md","autoDesc":true}');export{k as comp,x as data};
