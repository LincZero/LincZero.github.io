import{_ as e,c as t,e as l,b as n,a as s,o as h,r as p}from"./app-BgHc8lP1.js";const k={};function r(d,i){const a=p("Mermaid");return h(),t("div",null,[i[4]||(i[4]=l(`<h2 id="二叉树-bt-btree-binarytree" tabindex="-1"><a class="header-anchor" href="#二叉树-bt-btree-binarytree"><span>二叉树 (BT, BTree, BinaryTree)</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><h4 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h4><p>二叉树节点结构</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    V value;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Node left;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Node right;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来讲在面试场上不会考你二叉树coding的难度，或者说很少，但应该要会。他是让你考具体的题目还是考算法居多啊</p><h4 id="打印" tabindex="-1"><a class="header-anchor" href="#打印"><span>打印</span></a></h4><p>如何直观的打印一颗二叉树。这个一般也会考和自己写，自己准备一个方便打印debug就行</p><h4 id="树的边界" tabindex="-1"><a class="header-anchor" href="#树的边界"><span>树的边界</span></a></h4><p>左边界和右边界，就是一个节点不断往左/右节点往下形成的一条路径。</p><p>后面讲非递归遍历的中序遍历时，会再提到这个概念</p><h3 id="遍历" tabindex="-1"><a class="header-anchor" href="#遍历"><span>遍历</span></a></h3><p>用递归和非递归两种方式实现二叉树的先序、中序、后序遍历</p><h4 id="深度遍历概念-递归序-先序-中序-后序" tabindex="-1"><a class="header-anchor" href="#深度遍历概念-递归序-先序-中序-后序"><span>深度遍历概念：递归序，先序/中序/后序</span></a></h4><p>例如：</p>`,15)),n(a,{id:"mermaid-43",code:"eJxLL0osyFAIceIy1NW1M+IyApImXApAYAJiGSKYEDlTLk5TEGUIpY3A+oy5jIGkGZg05wIAqZAPCg=="}),i[5]||(i[5]=l(`<p><strong>递归序</strong>为：1 2 4 4 4 2 5 5 5 2 1 3 6 3 7 3 1 (我们可以发现每个节点都会经过三次)</p><p>根据递归序加工的不同，分为：</p><ul><li><strong>先序</strong>：对于所有子树，都是依次打印 头-&gt;左-&gt;右。递归序中，第一次到节点打印，第二、三次到这个节点不打印</li><li><strong>中序</strong>：对于所有子树，都是依次打印 左-&gt;头-&gt;右。递归序中，第二次到节点打印，第一、三次到这个节点不打印</li><li><strong>后序</strong>：对于所有子树，都是依次打印 左-&gt;右-&gt;头。递归序中，第三次到节点打印，第一、二次到这个节点不打印</li></ul><h4 id="深度优先遍历-递归遍历" tabindex="-1"><a class="header-anchor" href="#深度优先遍历-递归遍历"><span>深度优先遍历 - 递归遍历</span></a></h4><p>递归的先序/中序/后序的代码实现上非常简单，在不同的时机打印就行了</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">public 递归函数 (Node head) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (head </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> null) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // System.out.print(head.value+&quot; &quot;); // 先序打印</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    递归函数(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // System.out.print(head.value+&quot; &quot;); // 中序打印</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    递归函数(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // System.out.print(head.value+&quot; &quot;); // 后序打印</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="深度优先遍历-非递归遍历" tabindex="-1"><a class="header-anchor" href="#深度优先遍历-非递归遍历"><span>深度优先遍历 - 非递归遍历</span></a></h4><p>任何递归一定都可以改成非递归。（不让系统压栈，自己压）</p><p>有时面试会考这个，就是看你理不理解压栈这个过程</p><h5 id="前序-先序-pre-order-traversal" tabindex="-1"><a class="header-anchor" href="#前序-先序-pre-order-traversal"><span>前序/先序 (Pre-order Traversal)</span></a></h5><p>准备一个栈，放入头节点，然后进行以下流程：</p><ol><li>弹出一个节点Current</li><li>打印/处理Current</li><li>以此分别压入右节点和左节点 (如果有) (先压右再压左是为了先左出栈，先处理左)</li><li>循环处理</li></ol><h5 id="后序" tabindex="-1"><a class="header-anchor" href="#后序"><span>后序</span></a></h5><p>准备两个栈（主栈和收集栈），主栈放入头节点，然后进行以下流程：</p><ol><li>主栈弹出一个节点Current</li><li>节点放入收集栈</li><li>以此分别压入右节点和左节点</li><li>循环处理</li><li>当全部完成后，收集栈的出栈顺序就是中序遍历处理的顺序（收集栈的入栈顺序是头-&gt;右-&gt;左，出栈顺序自然是左-&gt;右-&gt;头）</li></ol><h5 id="中序" tabindex="-1"><a class="header-anchor" href="#中序"><span>中序</span></a></h5><p>类似先序打印。左-&gt;右-&gt;头，思路：子树中整个左树进栈（整个左边界进栈），出栈时对弹出节点的右树进行相同的处理</p><p>例如在下面这个图中：</p>`,18)),n(a,{id:"mermaid-153",code:"eJxLL0osyFAIceIy1NW1M+IyApImYNKUy1RX1wfIMOMygzDMwWqMuYyBpAWXha5uEJBhaMBlaACRNzQES1lyAQDntRBk"}),i[6]||(i[6]=s("p",null,"先进124，然后4出栈打印2，看2有右节点5，就压入右节点5和他的整个左树。循环",-1)),i[7]||(i[7]=s("h4",{id:"广度优先遍历",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#广度优先遍历"},[s("span",null,"广度优先遍历")])],-1)),i[8]||(i[8]=s("p",null,"如何完成二叉树的宽度优先遍历 (常见题目：求一棵二叉树的宽度)",-1)),i[9]||(i[9]=s("p",null,"用队列（队列先进先出，这次不用栈了。深度用栈，广度用队列）",-1)),n(a,{id:"mermaid-166",code:"eJxLL0osyFAIceIy1NW1M+Iy0tUNAjJMuEyApBmYNAdLGXMZ6+r6ABmmXKZA0gJMWnIBALVgDHo="}),i[10]||(i[10]=l(`<p>方法：放入头节点然后执行：</p><ol><li>头弹出就打印，并且以此将左节点和右节点入队列</li></ol><p>最后打印就是：头-&gt;左-&gt;右，先序遍历。简单理解：[1]-&gt;[32|1]-&gt;[32]-&gt;[54|32]-&gt;[54]-&gt;[9876|54]-&gt;[9876] (右头左尾) （注意：这里简化了一些延长了出队列的时间，实际内存不是这样）</p><p>实现细节：</p><p>先序/中序/后序的切换比较简单。并且这里用队列而非栈，也就是不需要手动递归，只需要 <code>while(!queue.isEmpty())</code> 就行，当作普通循环，较好理解</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Queue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> queue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LinkedList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // Java的队列</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(head);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cur </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">poll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // System.out.println(cur.value): // 先序</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    	queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // System.out.println(cur.value): // 中序</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">	    queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // System.out.println(cur.value): // 后序</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="题-求一棵二叉树的宽度" tabindex="-1"><a class="header-anchor" href="#题-求一棵二叉树的宽度"><span>题：求一棵二叉树的宽度</span></a></h5>`,7)),n(a,{id:"mermaid-190",code:"eJxLL0osyFAIceIy1NW1M+IyApImYNKUy1RX1wfIMAdLGXMZQ7hmXGa6ukFAhgUXAI5cDBA="}),i[11]||(i[11]=l('<p>例如这里的最大宽度是3，在第三层出现</p><p>答案：</p><p>要知道最大宽度，还需要知道各个节点分别存在第几层，需要统计每一层的节点数是几。</p><p>那么我们可以用 <code>HashMap&lt;Node, Interget&gt; levelMap = new HashMap&lt;&gt;()</code> 的哈希表，来记录每个节点在第几层。</p><p>遍历打印时去看是第几层（广度深度都有解法），然后分别累加就行</p><p>答案：（无hash表方案）</p><p>这个说是难很多，但我感觉可以用我前面那个简化版的流程是非常好理解的：[1]-&gt;[32|1]-&gt;[32]-&gt;[54|32]-&gt;[54]-&gt;[9876|54]-&gt;[9876] (右头左尾)</p><p>只要几个变量：</p><ul><li>nodeCurEnd 当前层的最后一个节点</li><li>nodeNextEnd 下一层的最后一个节点</li><li>curLevel 当前层的最大宽度</li><li>maxLevel 最大宽度</li></ul><p>LeetCode102、LeetCode104，弹幕说那里的解法简单些</p><h3 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索"><span>搜索</span></a></h3><h4 id="广搜" tabindex="-1"><a class="header-anchor" href="#广搜"><span>广搜</span></a></h4><h3 id="题-二叉树常见题" tabindex="-1"><a class="header-anchor" href="#题-二叉树常见题"><span>题 (二叉树常见题)</span></a></h3><p>下面几个概念可以缝合的，例如：平衡二叉查找树 (Balanced Binary Search Tree)</p><h4 id="判断-搜索二叉树-bst-binary-search-tree" tabindex="-1"><a class="header-anchor" href="#判断-搜索二叉树-bst-binary-search-tree"><span>判断 搜索二叉树 (BST, Binary Search Tree)</span></a></h4><p>也叫二叉查找树 (Binary Search Tree)，更符合英文翻译</p><p>搜索二叉树特点：左树小于右树、且没有重复值</p><p>方法：中序遍历（深度遍历，是否递归都行），一定是升序输出</p><h4 id="判断-完全二叉树-fbt-cbt" tabindex="-1"><a class="header-anchor" href="#判断-完全二叉树-fbt-cbt"><span>判断 完全二叉树 (FBT/CBT)</span></a></h4><p>完全二叉树特点：按顺序从左到右铺（堆就是一棵完全二叉树，不一定是满二叉树）</p><p>方法：广度遍历，遍历的过程中。刚开始时的节点，均有左右节点</p><ol><li><p>如果发现一个节点有右孩子但没左孩子，返回false</p></li><li><p>如果遇到第一个节点有左孩子但无右孩子，那么后面遇到的所有节点都应该是叶子节点（均无左右孩子），否则返回false</p><p>（例如在下图中，节点6就是往后遍历的所有节点都是叶子节点）</p></li></ol>',22)),n(a,{id:"mermaid-288",code:"eJxLL0osyFAIceIy1NW1M+IyApImXApAYAJiGSKYEDlTLk5TEGUIpY3A+oy5jIGkGZeZrq4PiGEI5ptzAQBMCxDv"}),i[12]||(i[12]=l('<h4 id="判断-满二叉树" tabindex="-1"><a class="header-anchor" href="#判断-满二叉树"><span>判断 满二叉树</span></a></h4><p>满二叉树特点：（满二叉树是特殊的完全二叉树）</p><p>方法：在判断完全二叉树的基础上微改一下就行。广度遍历，遍历的过程中。刚开始时的节点，均有左右节点</p><ol><li>如果发现一个节点只有一个孩子，返回false</li><li>如果遇到第一个节点均无左右孩子，那么后面遇到的所有节点都应该是叶子节点（均无左右孩子），否则返回false</li></ol><p>另一个比较麻烦但好理解的方法</p><ol><li>分别统计最大深度L和节点个数N，那么满足公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>L</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=2^L-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> (等倍数列求和)</li></ol><h4 id="判断-平衡二叉树-二叉树套路" tabindex="-1"><a class="header-anchor" href="#判断-平衡二叉树-二叉树套路"><span>判断 平衡二叉树 (二叉树套路)</span></a></h4><p>平衡二叉树特点：对于任何子树，左树高度与右树高度不相差超过一</p><p>二叉树做题套路：基于我可以向我左数要某些信息，右数要某些信息的情况下，我怎么罗列这个可能性。</p><p>例如在平衡二叉树的题目中，如果：左树是平衡二叉树、右树是平衡二叉树，且两者高度差不超过一，则通过。</p><p>那么就可以想到递归，每个递归返回两个信息：是否平衡、高度多少</p><h4 id="寻找-公共祖先节点-二叉树套路" tabindex="-1"><a class="header-anchor" href="#寻找-公共祖先节点-二叉树套路"><span>寻找 公共祖先节点 (二叉树套路)</span></a></h4><p>题：给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点</p><p>例如下图中，D和F的最低公共祖先是B</p>',14)),n(a,{id:"mermaid-344",code:"eJxLL0osyFAIceJy1NW1c+JyApIuYNKVy1VXNwjIcANLOXM5Q7jeXN5A0h1MenIBANCjDY4="}),i[13]||(i[13]=l(`<p>解题：</p><ul><li><p>找类似题的思路 —— 链表。我开始想到的是链表找相交节点的那个题目，或者有点有向无环图的感觉。链表找相交节点麻烦的做法是逆序，方便点就是快慢指针判断末尾节点，同时加有环判断。但这里有些区别，因为是头节点相同而不是尾节点相同，那么理论上可以逆序然后再求链表相交节点，但很麻烦。</p></li><li><p>遍历方式思路 —— 看能不能从递归序中提取出来。</p></li><li><p>空间 O(n) 哈希表解法思路。D和F节点都存储自己的路径（相当于用哈希表模拟了一条虚拟的倒序链表），再对比</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HashMap</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fathreMap </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 存储每个节点的父节点</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">......</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HashSet</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> set01 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 存储节点一的整条路径，然后再去看另一条节点的路径</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>解题套路解法尝试递归</p><ul><li>往子树需要要的信息：o1和o2在不在你那？然后就有了下面的 O(1) 解法（这个解图思路确实好用）</li><li>另外需要注意一下边界问题 <ul><li>情况一：O1是O2的LCA或O2是O1的LCA</li><li>情况二：O1和O2不彼此为LCA</li></ul></li><li>答案：</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> lowestAncestor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o2) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 情况一的到达条件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (head </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o2) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 情况二的到达条件</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">	Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> lowestAncestor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o2)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">	Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> right </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> lowestAncestor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> o2)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">		return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 递归条件，继续递归</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ?</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="寻找-后继节点-简单" tabindex="-1"><a class="header-anchor" href="#寻找-后继节点-简单"><span>寻找 后继节点 (简单)</span></a></h4><p>在二叉树中找到一个节点的后继节点</p><p>现在有一种新的二叉树节点类型如下</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> left</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// 该结构比普通二叉树节点结构多了一个指向父节点的parent指针</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    					// 假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	    value </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> val;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的<strong>中序遍历的序列中， node的下一个节点叫作node的后继节点</strong>。</p><p>答案：</p><ul><li>最简单的肯定是中序遍历后，将输出保存起来。缺点是空间和时间复杂度O(n)，代价大</li><li>但这里我们有父指针这个新特征，也很简单。思考情况： <ul><li>情况一：该节点有右孩子，则是右孩子的最左节点</li><li>情况二：该节点无右孩子，则找一直往上找自己不是右节点的父节点X</li><li>情况三：没有后继节点，情况二最后找到根节点也不符合</li><li>（最左节点：再不断往下找左节点，直到没有左节点则输出）</li><li>空间复杂度O(1)，时间复杂度为两个节点的最短路径O(k)</li></ul></li></ul><h4 id="二叉树的序列化和反序列化" tabindex="-1"><a class="header-anchor" href="#二叉树的序列化和反序列化"><span>二叉树的序列化和反序列化</span></a></h4><p>（LeetCode 297）</p><p>就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树</p><p>答案：</p><ul><li>序列化 <ul><li>不同于遍历打印的一点是，还要求是一一对应关系。但其实大同小异，只要把”空“也用特殊字符打印出来，其实就可以了</li><li>用先中后序序列化都是同理的，以先序为例：例如输出结果为：[1,#,2,4,#,#,#]</li></ul></li><li>反序列化 <ul><li>也简单，这里是先序遍历所以先建头节点，再建左/右节点。</li><li>先加载头节点，遇到空的就往左/右节点插入空，否则插入对应节点并进入该节点中继续插值。 左右节点都插满后返回上节点，继续插</li></ul></li><li>二叉树这个很简单清晰，也不需要序列化得像标签语言一样的那种形式，而是更扁平的存储方式。但如果B+树就不能用这种方式序列化了</li></ul><h4 id="判断-一颗二叉树是不是另一棵二叉树的子树" tabindex="-1"><a class="header-anchor" href="#判断-一颗二叉树是不是另一棵二叉树的子树"><span>判断 一颗二叉树是不是另一棵二叉树的子树</span></a></h4><p>略</p><h4 id="折纸问题-简单" tabindex="-1"><a class="header-anchor" href="#折纸问题-简单"><span>折纸问题 (简单)</span></a></h4><p>题：(一个微软的题，也不难)</p><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。</p><p>如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p><p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。</p><p>例如：N=1时，打印: down，N=2时，打印: down down up</p><p>解题：</p>`,23)),s("ul",null,[i[3]||(i[3]=s("li",null,[s("p",null,"先找规律然后总结规律，数学方式打印。实际解决是可行的，不过如果禁止用数学思维而强制用计算机模拟")],-1)),s("li",null,[i[2]||(i[2]=s("p",null,"应该是能用树表示，一棵满二叉树来的，每次对折就深度加一（规定左节点是上面的，右节点是下面的）",-1)),s("ul",null,[s("li",null,[i[0]||(i[0]=s("p",null,"特征：每个节点的凹凸状态不会变，每次对折增加左右节点，这新增的两个节点必定左凹右突",-1)),n(a,{id:"mermaid-551",code:"eJxLL0osyFAIceIyfNq+U1fXzghCGQMpLgR7B5L0Dqh0PEgeytkRzwUAVpIerQ=="})]),i[1]||(i[1]=s("li",null,[s("p",null,"最后构造完后，中序遍历输出就行了")],-1))])])]),i[14]||(i[14]=l('<h3 id="解题思维总结-递归所需信息" tabindex="-1"><a class="header-anchor" href="#解题思维总结-递归所需信息"><span><strong>解题思维总结</strong> (递归所需信息)</span></a></h3><p>二叉树做题套路：基于我可以向我左数要某些信息，右数要某些信息的情况下，我怎么罗列这个可能性。</p><ul><li><p>例如在平衡二叉树的题目中，如果：左树是平衡二叉树、右树是平衡二叉树，且两者高度差不超过一，则通过。</p><p>以此写递归：每个递归返回两个信息：是否平衡、高度多少</p></li><li><p>例如在搜索二叉树题目中，如果：左树是搜索树、右树是搜索树、且左Max&lt;头节点&lt;右min，则通过。</p><p>以此写递归：每个递归返回两个信息：是否搜索二叉树、最大值与最小值多少</p></li></ul><p>这个递归套路非常之好用，可以解决你们面试中一切<strong>树形DP</strong> (树上动态规划) 的问题，树形DP是面试中最难的问题</p>',4))])}const A=e(k,[["render",r],["__file","14. 结构 - 二叉树.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Program_Algorithm/%E9%80%9A%E7%94%A8%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B%20-%20%E5%B7%A6%E7%A8%8B%E4%BA%91/01.%20%E5%9F%BA%E7%A1%80%E7%8F%AD/14.%20%E7%BB%93%E6%9E%84%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91.html","title":"14. 结构 - 二叉树","lang":"zh-CN","frontmatter":{"description":"二叉树 (BT, BTree, BinaryTree) 概念 结构 二叉树节点结构 一般来讲在面试场上不会考你二叉树coding的难度，或者说很少，但应该要会。他是让你考具体的题目还是考算法居多啊 打印 如何直观的打印一颗二叉树。这个一般也会考和自己写，自己准备一个方便打印debug就行 树的边界 左边界和右边界，就是一个节点不断往左/右节点往下形成的...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Program_Algorithm/%E9%80%9A%E7%94%A8%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B%20-%20%E5%B7%A6%E7%A8%8B%E4%BA%91/01.%20%E5%9F%BA%E7%A1%80%E7%8F%AD/14.%20%E7%BB%93%E6%9E%84%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:description","content":"二叉树 (BT, BTree, BinaryTree) 概念 结构 二叉树节点结构 一般来讲在面试场上不会考你二叉树coding的难度，或者说很少，但应该要会。他是让你考具体的题目还是考算法居多啊 打印 如何直观的打印一颗二叉树。这个一般也会考和自己写，自己准备一个方便打印debug就行 树的边界 左边界和右边界，就是一个节点不断往左/右节点往下形成的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":2,"title":"二叉树 (BT, BTree, BinaryTree)","slug":"二叉树-bt-btree-binarytree","link":"#二叉树-bt-btree-binarytree","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[{"level":4,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":4,"title":"打印","slug":"打印","link":"#打印","children":[]},{"level":4,"title":"树的边界","slug":"树的边界","link":"#树的边界","children":[]}]},{"level":3,"title":"遍历","slug":"遍历","link":"#遍历","children":[{"level":4,"title":"深度遍历概念：递归序，先序/中序/后序","slug":"深度遍历概念-递归序-先序-中序-后序","link":"#深度遍历概念-递归序-先序-中序-后序","children":[]},{"level":4,"title":"深度优先遍历 - 递归遍历","slug":"深度优先遍历-递归遍历","link":"#深度优先遍历-递归遍历","children":[]},{"level":4,"title":"深度优先遍历 - 非递归遍历","slug":"深度优先遍历-非递归遍历","link":"#深度优先遍历-非递归遍历","children":[{"level":5,"title":"前序/先序 (Pre-order Traversal)","slug":"前序-先序-pre-order-traversal","link":"#前序-先序-pre-order-traversal","children":[]},{"level":5,"title":"后序","slug":"后序","link":"#后序","children":[]},{"level":5,"title":"中序","slug":"中序","link":"#中序","children":[]}]},{"level":4,"title":"广度优先遍历","slug":"广度优先遍历","link":"#广度优先遍历","children":[{"level":5,"title":"题：求一棵二叉树的宽度","slug":"题-求一棵二叉树的宽度","link":"#题-求一棵二叉树的宽度","children":[]}]}]},{"level":3,"title":"搜索","slug":"搜索","link":"#搜索","children":[{"level":4,"title":"广搜","slug":"广搜","link":"#广搜","children":[]}]},{"level":3,"title":"题 (二叉树常见题)","slug":"题-二叉树常见题","link":"#题-二叉树常见题","children":[{"level":4,"title":"判断 搜索二叉树 (BST, Binary Search Tree)","slug":"判断-搜索二叉树-bst-binary-search-tree","link":"#判断-搜索二叉树-bst-binary-search-tree","children":[]},{"level":4,"title":"判断 完全二叉树 (FBT/CBT)","slug":"判断-完全二叉树-fbt-cbt","link":"#判断-完全二叉树-fbt-cbt","children":[]},{"level":4,"title":"判断 满二叉树","slug":"判断-满二叉树","link":"#判断-满二叉树","children":[]},{"level":4,"title":"判断 平衡二叉树 (二叉树套路)","slug":"判断-平衡二叉树-二叉树套路","link":"#判断-平衡二叉树-二叉树套路","children":[]},{"level":4,"title":"寻找 公共祖先节点 (二叉树套路)","slug":"寻找-公共祖先节点-二叉树套路","link":"#寻找-公共祖先节点-二叉树套路","children":[]},{"level":4,"title":"寻找 后继节点 (简单)","slug":"寻找-后继节点-简单","link":"#寻找-后继节点-简单","children":[]},{"level":4,"title":"二叉树的序列化和反序列化","slug":"二叉树的序列化和反序列化","link":"#二叉树的序列化和反序列化","children":[]},{"level":4,"title":"判断 一颗二叉树是不是另一棵二叉树的子树","slug":"判断-一颗二叉树是不是另一棵二叉树的子树","link":"#判断-一颗二叉树是不是另一棵二叉树的子树","children":[]},{"level":4,"title":"折纸问题 (简单)","slug":"折纸问题-简单","link":"#折纸问题-简单","children":[]}]},{"level":3,"title":"解题思维总结 (递归所需信息)","slug":"解题思维总结-递归所需信息","link":"#解题思维总结-递归所需信息","children":[]}]}],"git":{},"readingTime":{"minutes":12.39,"words":3718},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Program_Algorithm/通用算法/算法教程 - 左程云/01. 基础班/14. 结构 - 二叉树.md","excerpt":"<h2>二叉树 (BT, BTree, BinaryTree)</h2>\\n<h3>概念</h3>\\n<h4>结构</h4>\\n<p>二叉树节点结构</p>\\n<div class=\\"language-cpp line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"cpp\\" data-title=\\"cpp\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">class</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> Node</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">&lt;</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\">V</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">&gt; {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    V value;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    Node left;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    Node right;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Program_Algorithm/通用算法/算法教程 - 左程云/01. 基础班/14. 结构 - 二叉树.md","value":{"title":"14. 结构 - 二叉树","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Program_Algorithm/通用算法/算法教程 - 左程云/01. 基础班/14. 结构 - 二叉树.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{A as comp,c as data};
