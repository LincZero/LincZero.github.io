import{_ as l,c as o,b as s,d as a,e as t,a as p,o as c,r as i}from"./app-rdPRYmDk.js";const u={},r={href:"http://senlinzhan.github.io/2017/08/12/libevent/",target:"_blank",rel:"noopener noreferrer"},d={href:"https://aceld.gitbooks.io/libevent/content/",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.bilibili.com/video/BV1ER4y1D73b",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.bilibili.com/video/BV1rG411h738",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.bilibili.com/video/BV1jV4y1H7nj",target:"_blank",rel:"noopener noreferrer"};function m(h,n){const e=i("ExternalLinkIcon");return c(),o("div",null,[n[10]||(n[10]=s("h1",{id:"libevent-编程指南",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#libevent-编程指南"},[s("span",null,"Libevent 编程指南")])],-1)),s("p",null,[n[1]||(n[1]=a("参考：")),s("a",r,[n[0]||(n[0]=a("【个人博客】Libevent 编程指南")),t(e)])]),n[11]||(n[11]=p(`<h2 id="事件-基本概念" tabindex="-1"><a class="header-anchor" href="#事件-基本概念"><span>事件 基本概念</span></a></h2><p>Libevent是基于 Reactor 模式的网络库，在 Reactor 模式中，通常都有一个<strong>事件循环(Event Loop)</strong>，在 Libevent 中，这个事件循环就是 <code>event_base</code> 结构体：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span><span class="token function">event_base_new</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 创建事件循环</span>
<span class="token keyword">void</span> <span class="token function">event_base_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 销毁事件循环</span>
<span class="token keyword">int</span> <span class="token function">event_base_dispatch</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 运行事件循环</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常来说，事件循环主要有两个作用：</p><ul><li>用来管理事件，比如说添加我们感兴趣的事件，修改事件或删除事件。</li><li>用来轮询它管理的所有事件，如果发现有事件活跃 (avtive)，就调用相应的回调函数去处理事件。</li></ul><p>Libevent 使用 <code>event</code> 结构体来代表<strong>事件</strong>，可以使用 <code>event_new()</code> 创建一个事件</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">event</span> <span class="token operator">*</span><span class="token function">event_new</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token comment">// 事件循环</span>
						evutil_socket_t fd<span class="token punctuation">,</span> <span class="token comment">// 文件描述符</span>
						<span class="token keyword">short</span> what<span class="token punctuation">,</span> <span class="token comment">// 事件类型</span>
						event_callback_fn cb<span class="token punctuation">,</span> <span class="token comment">// 回调函数</span>
						<span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传递给回调函数的参数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个事件之后，要怎么把<strong>事件加入到事件循环</strong>呢？可以使用 <code>event_add()</code> 函数</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">event_add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event</span> <span class="token operator">*</span>ev<span class="token punctuation">,</span> <span class="token comment">// 事件</span>
			<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 超时时间</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，当一个事件变得活跃时，Libevent 会执行这个事件的回调函数，但同时也会将这个事件从事件循环中移除， 例如，下面的程序，定时器只会触发一次：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;event2/event.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">timer_cb</span><span class="token punctuation">(</span>evutil_socket_t fd<span class="token punctuation">,</span> <span class="token keyword">short</span> what<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> str <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>str <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token operator">*</span>base <span class="token operator">=</span> <span class="token function">event_base_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事件循环</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> five_seconds <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token operator">*</span>ev <span class="token operator">=</span> <span class="token function">event_new</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> EV_TIMEOUT<span class="token punctuation">,</span> timer_cb<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事件</span>
    <span class="token function">event_add</span><span class="token punctuation">(</span>ev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>five_seconds<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事件加入到事件循环</span>
    <span class="token function">event_base_dispatch</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">event_free</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">event_base_free</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那要怎么样才能让事件不被移除呢？当创建事件时，在事件类型加上 <code>EV_PERSIST</code> 就可以。让我们修改上面的程序，让定时器每秒就触发一次</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> <span class="token operator">*</span>ev <span class="token operator">=</span> <span class="token function">event_new</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> EV_TIMEOUT<span class="token operator">|</span>EV_PERSIST<span class="token punctuation">,</span> timer_cb<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="tcp-server" tabindex="-1"><a class="header-anchor" href="#tcp-server"><span>TCP Server</span></a></h2><p>Libevent 使用 <code>evconnlistener</code> 结构来表示 <strong>TCP Server</strong>，创建 TCP Server 的做法很简单：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span> <span class="token operator">*</span><span class="token function">evconnlistener_new_bind</span><span class="token punctuation">(</span>
    <span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">,</span>        <span class="token comment">// 事件循环</span>
    evconnlistener_cb cb<span class="token punctuation">,</span>           <span class="token comment">// 回调函数，当 accept() 成功时会被调用</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span>                      <span class="token comment">// 传递给回调函数的参数</span>
    <span class="token keyword">unsigned</span> flags<span class="token punctuation">,</span>                 <span class="token comment">// 选项</span>
    <span class="token keyword">int</span> backlog<span class="token punctuation">,</span>                    <span class="token comment">// tcp backlog 参数</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>sa<span class="token punctuation">,</span>      <span class="token comment">// 地址</span>
    <span class="token keyword">int</span> socklen
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">evconnlistener_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span> <span class="token operator">*</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用 <code>evconnlistener_new_bind()</code> 函数之后，listening socket 会自动被设置成非阻塞的。我们还通过 <code>flags</code> 参数设置一些有用的选项，例如：</p><ul><li><code>LEV_OPT_CLOSE_ON_FREE</code> 表示当调用 <code>evconnlistener_free()</code> 时，相应的 listening socket 也会被 <code>close()</code> 掉。</li><li><code>LEV_OPT_REUSEABLE</code> 表示会自动对 listening socket 设置 <code>SO_REUSEADDR</code> 这个 TCP 选项。</li></ul><p>下面的程序创建了一个简单的 TCP Server：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;event2/listener.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">accept_conn_cb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span> <span class="token operator">*</span>listener<span class="token punctuation">,</span> evutil_socket_t fd<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>address<span class="token punctuation">,</span> <span class="token keyword">int</span> socklen<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> addr<span class="token punctuation">[</span>INET_ADDRSTRLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token operator">*</span>sin <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>sockaddr_in <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inet_ntop</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sin<span class="token operator">-&gt;</span>sin_addr<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> INET_ADDRSTRLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Accept TCP connection from: &quot;</span> <span class="token operator">&lt;&lt;</span> addr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">accept_error_cb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span> <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> <span class="token operator">*</span>base <span class="token operator">=</span> <span class="token function">evconnlistener_get_base</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 跨平台的错误处理</span>
    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">EVUTIL_SOCKET_ERROR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Got an error on the listener: &quot;</span>
              <span class="token operator">&lt;&lt;</span> <span class="token function">evutil_socket_error_to_string</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
              <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    
    <span class="token function">event_base_loopexit</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">short</span> port <span class="token operator">=</span> <span class="token number">8000</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> sin<span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sin<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sin<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    sin<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sin<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">auto</span> <span class="token operator">*</span>base <span class="token operator">=</span> <span class="token function">event_base_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token operator">*</span>listener <span class="token operator">=</span> <span class="token function">evconnlistener_new_bind</span><span class="token punctuation">(</span>
        base<span class="token punctuation">,</span> accept_conn_cb<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>
        LEV_OPT_CLOSE_ON_FREE<span class="token operator">|</span>LEV_OPT_REUSEABLE<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sin<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sin<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>listener <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Couldn&#39;t create listener&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">evconnlistener_set_error_cb</span><span class="token punctuation">(</span>listener<span class="token punctuation">,</span> accept_error_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">event_base_dispatch</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="libevent-深入浅出" tabindex="-1"><a class="header-anchor" href="#libevent-深入浅出"><span>Libevent 深入浅出</span></a></h1>`,21)),s("p",null,[n[3]||(n[3]=a("参考：")),s("a",d,[n[2]||(n[2]=a("【Gitbook】libevent深入浅出")),t(e)]),n[4]||(n[4]=a("，本书要求有一定的服务并发编程基础"))]),n[12]||(n[12]=p(`<p>本教程要求有一定的服务并发编程基础，了解select和epoll等多路I/O复用机制。 教程目的主要是快速建立libevent的认知，了解libevent的常用数据结构和编程方法。 达到可以使用libevent写出自己的高并发服务器处理模型。</p><h2 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll"><span>epoll</span></a></h2><h3 id="流-io操作-阻塞" tabindex="-1"><a class="header-anchor" href="#流-io操作-阻塞"><span>流 - IO操作 - 阻塞</span></a></h3><p>Page not found</p><h3 id="解决阻塞死等待的方法" tabindex="-1"><a class="header-anchor" href="#解决阻塞死等待的方法"><span>解决阻塞死等待的方法</span></a></h3><p>Page not found</p><h3 id="什么是epoll" tabindex="-1"><a class="header-anchor" href="#什么是epoll"><span>什么是epoll</span></a></h3><p>Page not found</p><h3 id="epollapi" tabindex="-1"><a class="header-anchor" href="#epollapi"><span>epollAPI</span></a></h3><p>创建EPOLL</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">/**
 * @param size 告诉内核监听的数目
 *
 * @returns 返回一个epoll句柄（即一个文件描述符）
 */</span>
<span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">int</span> epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![](Pasted%20image%2020230427173405.png)</p><p>控制EPOLL</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">/**
 * @param epfd 用epoll_create所创建的epoll句柄
 * @param op 表示对epoll监控描述符控制的动作
 *
 * EPOLL_CTL_ADD(注册新的fd到epfd)
 * EPOLL_CTL_MOD(修改已经注册的fd的监听事件)
 * EPOLL_CTL_DEL(epfd删除一个fd)
 *
 * @param fd 需要监听的文件描述符
 * @param event 告诉内核需要监听的事件
 *
 * @returns 成功返回0，失败返回-1, errno查看错误信息
 */</span>
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> 
            <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>
 __uint32_t events<span class="token punctuation">;</span> <span class="token comment">/* epoll 事件 */</span>
 epoll_data_t data<span class="token punctuation">;</span> <span class="token comment">/* 用户传递的数据 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * events : {EPOLLIN, EPOLLOUT, EPOLLPRI, 
            EPOLLHUP, EPOLLET, EPOLLONESHOT}
 */</span>

<span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">uint32_t</span> u32<span class="token punctuation">;</span>
    <span class="token keyword">uint64_t</span> u64<span class="token punctuation">;</span>
<span class="token punctuation">}</span> epoll_data_t<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> new_event<span class="token punctuation">;</span>

new_event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLOUT<span class="token punctuation">;</span>
new_event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_event<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![](Pasted%20image%2020230427173452.jpg)</p><h3 id="触发模式" tabindex="-1"><a class="header-anchor" href="#触发模式"><span>触发模式</span></a></h3><h4 id="水平触发" tabindex="-1"><a class="header-anchor" href="#水平触发"><span>水平触发</span></a></h4><p>水平触发的主要特点是，如果用户在监听epoll事件，当内核有事件的时候，会拷贝给用户态事件，但是如果用户只处理了一次，那么剩下没有处理的会在下一次epoll_wait再次返回该事件。</p><p>这样如果用户永远不处理这个事件，就导致每次都会有该事件从内核到用户的拷贝，耗费性能，但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕。</p><h4 id="边缘触发" tabindex="-1"><a class="header-anchor" href="#边缘触发"><span>边缘触发</span></a></h4><p>边缘触发，相对跟水平触发相反，当内核有事件到达， 只会通知用户一次，至于用户处理还是不处理，以后将不会再通知。这样减少了拷贝过程，增加了性能，但是相对来说，如果用户马虎忘记处理，将会产生事件丢的情况。</p><h3 id="简单的epoll服务器" tabindex="-1"><a class="header-anchor" href="#简单的epoll服务器"><span>简单的epoll服务器</span></a></h3><h2 id="epoll-和-reactor" tabindex="-1"><a class="header-anchor" href="#epoll-和-reactor"><span>epoll 和 reactor</span></a></h2><h2 id="event-base" tabindex="-1"><a class="header-anchor" href="#event-base"><span>event_base</span></a></h2><h3 id="创建默认的event-base" tabindex="-1"><a class="header-anchor" href="#创建默认的event-base"><span>创建默认的event_base</span></a></h3><p><strong>event_base_new()</strong> 函数分配并且返回一个新的具有默认设置的 event_base。函数会检测环境变量,返回一个到 event_base 的指针。如果发生错误,则返回 NULL。选择各种方法时,函数会选择 OS 支持的最快方法。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span><span class="token function">event_base_new</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>大多数程序使用这个函数就够了。</p></blockquote><p>event_base_new()函数声明在中,首次出现在 libevent 1.4.3版。</p><h3 id="创建复杂的event-base" tabindex="-1"><a class="header-anchor" href="#创建复杂的event-base"><span>创建复杂的event_base</span></a></h3><p>略</p><h2 id="事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#事件循环-event-loop"><span>事件循环 event_loop</span></a></h2><h3 id="运行循环" tabindex="-1"><a class="header-anchor" href="#运行循环"><span>运行循环</span></a></h3><p>一旦有了一个已经注册了某些事件的 event_base(关于如何创建和注册事件请看下一节 ), 就需要让 libevent 等待事件并且通知事件的发生。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EVLOOP_ONCE</span>             <span class="token expression"><span class="token number">0x01</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EVLOOP_NONBLOCK</span>         <span class="token expression"><span class="token number">0x02</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EVLOOP_NO_EXIT_ON_EMPTY</span> <span class="token expression"><span class="token number">0x04</span></span></span>

<span class="token keyword">int</span> <span class="token function">event_base_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>……</p><h1 id="libevent-视频" tabindex="-1"><a class="header-anchor" href="#libevent-视频"><span>libevent - 视频</span></a></h1>`,38)),s("p",null,[n[6]||(n[6]=a("参考： ")),s("a",k,[n[5]||(n[5]=a("libevent 解决了网络编程中哪些痛点？|libevent 是什么？libevent 解决问题的逻辑？io 和事件的关系？libevent 实战中使...")),t(e)])]),n[13]||(n[13]=p(`<h2 id="libevent-解决了网络编程中的哪些痛点" tabindex="-1"><a class="header-anchor" href="#libevent-解决了网络编程中的哪些痛点"><span>libevent 解决了网络编程中的哪些痛点</span></a></h2><h3 id="faq" tabindex="-1"><a class="header-anchor" href="#faq"><span>FAQ</span></a></h3><ul><li>libevent 是什么？</li><li>libevent 解决问题的逻辑？io 和事件的关系 <ul><li>将一些东西当作事件来处理，如： <ul><li>C--connect--&gt;S</li><li>C--send--&gt;S</li><li>S--connect--&gt;DB</li><li>C&lt;--send--&gt;S&lt;--send--&gt;DB</li></ul></li></ul></li><li>libevent 实战使用层次</li><li>代码编写：连接处理，数据发送，接收处理，连接断开处理</li></ul><p>FAQ</p><ul><li>Q libevent 解决问题的逻辑？</li><li>A libevent 是一个事件通知库，事件指的是：网络事件、超时时间、信号处理</li><li>Q 网络io 和 事件的关系</li><li>A libevent 也需要IO操作，分阻塞io 和 非阻塞io两种情况 <ul><li>阻塞IO：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> clientfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通常看这里的fd，如果fd是阻塞的则这里会阻塞</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>非阻塞IO： libevent使用的非阻塞IO</li><li>两者的区别 如果IO就绪，行为一样。非阻塞IO如果未就绪，立即返回。 阻塞IO会阻塞一个线程，一个线程只能监听一个。而非阻塞IO一个线程能多个。 至于如何监听事件，由libevent的 <code>IO多路复用</code> 技术来做</li><li>事件处理流程 <ul><li>注册事件</li><li>检测事件，通过 <code>IO多路复用</code> 检测</li><li>触发执行事件，通过 callback，来处理 IO</li></ul></li><li>经常要处理的是种fd：listenFd、clientFd、connectFd</li></ul></li></ul><h3 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span>代码</span></a></h3><p>无事件demo</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base <span class="token operator">=</span> <span class="token function">event_base_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事件</span>
	<span class="token function">event_base_loop</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> EVLOOP_NO_EXIT_ON_EMPTY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事件循环 (没有事件)</span>
	<span class="token function">event_base_free</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放事件</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加个事件，经常要处理3种fd</p><ul><li>listenfd</li><li>clientfd</li><li>connectfd</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;event.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;event2/listener.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">listener_cb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span> <span class="token operator">*</span> lis<span class="token punctuation">,</span> 
					   evutil_socket_t fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span> sock<span class="token punctuation">,</span> <span class="token keyword">int</span> socklen<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;recv a connection\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base <span class="token operator">=</span> <span class="token function">event_base_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事件管理器</span>
	
	<span class="token comment">// socket -&gt; bind -&gt; listen -&gt; 注册读事件 提供回调函数</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> sin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	sin<span class="token punctuation">.</span>sin_	family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
	sin<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span> <span class="token operator">*</span>listener <span class="token operator">=</span> <span class="token function">evconnlistener_new_bind</span><span class="token punctuation">(</span> <span class="token comment">// listenfd的事件</span>
		base<span class="token punctuation">,</span>
		listener_cb<span class="token punctuation">,</span> 
		base<span class="token punctuation">,</span> 
		LEV_OPT_REUSEABLE<span class="token operator">|</span>LEV_OPT_CLOSE_ON_FREE<span class="token punctuation">,</span> 
		<span class="token number">256</span><span class="token punctuation">,</span> 
		<span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>sin<span class="token punctuation">,</span> 
		<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span><span class="token punctuation">)</span>
	<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">event_base_loop</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> EVLOOP_NO_EXIT_ON_EMPTY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事件循环</span>
	<span class="token function">event_base_free</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放事件</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="视频2" tabindex="-1"><a class="header-anchor" href="#视频2"><span>视频2</span></a></h1>`,12)),s("p",null,[n[8]||(n[8]=a("参考：")),s("a",v,[n[7]||(n[7]=a("【B站】高并发+高可用+高负载 C++企业级网络开发实战 Libevent C＋＋跨平台高级实战技术[2022]")),t(e)])]),n[14]||(n[14]=p('<h2 id="前面" tabindex="-1"><a class="header-anchor" href="#前面"><span>前面</span></a></h2><p>略</p><h2 id="select、epoll、icop-区别" tabindex="-1"><a class="header-anchor" href="#select、epoll、icop-区别"><span>select、epoll、icop 区别</span></a></h2><ul><li>多路复用 <ul><li>select <ul><li>平台：跨平台</li><li>每次都要从用户空间拷贝到内核空间</li><li>遍历整个fd_set, 0(n)</li><li>最大可监听的fd数量不能超过FD_SETSIZE</li></ul></li><li>poll <ul><li>平台：跨平台</li><li>类似于select，无FD_SETSISE限制</li></ul></li><li>epoll <ul><li>平台：Windows不支持</li><li>内核态、红黑树</li><li>内存共享交互mmap</li><li>不需要全部复制、返回双向链表</li><li>LT(level triggered) 水平触发。事件没有处理，一直触发。epoll_wiat</li><li>ET(edge triggered) 边缘触发。每当状态变化时触发一个事件</li></ul></li><li>icop <ul><li>平台：Linux不支持</li><li>线程池</li></ul></li></ul></li></ul><p>libevent是根据优先级来选用的，epoll -&gt; poll -&gt; select -&gt; iocp</p><h2 id="服务端接收连接的代码示例" tabindex="-1"><a class="header-anchor" href="#服务端接收连接的代码示例"><span>服务端接收连接的代码示例</span></a></h2><h1 id="视频3" tabindex="-1"><a class="header-anchor" href="#视频3"><span>视频3</span></a></h1>',7)),s("p",null,[s("a",b,[n[9]||(n[9]=a("【B站】【阶段四：Linux高并发服务器开发】2-5 libevent")),t(e)])]),n[15]||(n[15]=p(`<h2 id="event-base-1" tabindex="-1"><a class="header-anchor" href="#event-base-1"><span>event_base</span></a></h2><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">/**
 * @param flags:
 *     EVLOOP_ONCE 0x01，只触发一次，阻塞等待
 *     EVLOOP_NOBLOCK 0x02，非阻塞检测，立即返回
 */</span>
<span class="token keyword">int</span> <span class="token function">event_base_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 更常用的一个api，相当于没有标志位的event_base_loop，相当于 \`while(1){epoll_wait}\`
 * 程序会一直执行直到没有要检测的api
 */</span>
<span class="token keyword">int</span> <span class="token function">event_base_dispatch</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 退出循环监听（等待固定时间后）
 */</span>
<span class="token keyword">int</span> <span class="token function">event_base_loopexit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>tv<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 退出循环监听（立即）
 */</span>
<span class="token keyword">int</span> <span class="token function">event_base_loopbreak</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span> <span class="token operator">*</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="libevent" tabindex="-1"><a class="header-anchor" href="#libevent"><span>libevent</span></a></h2><h3 id="libeventapi" tabindex="-1"><a class="header-anchor" href="#libeventapi"><span>libeventAPI</span></a></h3><p>详见 看源码 一章</p><h3 id="实战-tcp服务器" tabindex="-1"><a class="header-anchor" href="#实战-tcp服务器"><span>实战 - tcp服务器</span></a></h3><p>这个是简化版，难一点的可以看官方sample文件夹里的demo <code>event_tcp_server_array.c</code> 简化版的流程一览：</p><ol><li>套接字准备 <ol><li>创建套接字</li><li>绑定</li><li>监听</li></ol></li><li>使用libevent <ol><li>初始化event_base根节点</li><li>初始化上树节点</li><li>节点上树</li><li>监听</li></ol></li></ol><p>这个视频老师太喜欢简写了，我个人其实不是太喜欢简写过度</p><ul><li>l: listen 迎接套接字对应的</li><li>c: client 服务套接字对应的（不是客户端套接字）</li><li>fd：file descriptor</li><li>cb：callback</li><li>lfdcb: &quot;l fd cb&quot;</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">cfdcb</span><span class="token punctuation">(</span><span class="token keyword">int</span> cfd<span class="token punctuation">,</span> <span class="token keyword">short</span> event<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1500</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">Read</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;err close\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// event_del(); // 下树，但这里会有问题，不知道树节点</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">lfdcb</span><span class="token punctuation">(</span><span class="token keyword">int</span> lfd<span class="token punctuation">,</span> <span class="token keyword">short</span> event<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 回调</span>
	<span class="token keyword">struct</span> <span class="token class-name">event_base</span><span class="token operator">*</span> base <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evnet_base</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
	<span class="token keyword">int</span> cfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 提取新的cfd</span>
	<span class="token keyword">struct</span> <span class="token class-name">event</span> <span class="token operator">*</span>ev <span class="token operator">=</span> <span class="token function">event_new</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> lfd<span class="token punctuation">,</span> EV_READ<span class="token operator">|</span>EV_PERSIS<span class="token punctuation">,</span> lfdcb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化上树节点</span>
	<span class="token function">event_add</span><span class="token punctuation">(</span>ev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将cfd上树</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 创建套接字</span>
	<span class="token comment">// 绑定</span>
	<span class="token keyword">int</span> lfd <span class="token operator">=</span> <span class="token function">tcp4bind</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 监听</span>
	<span class="token function">Listen</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 创建event_base根节点</span>
	<span class="token keyword">struct</span> <span class="token class-name">event_base</span><span class="token operator">*</span> base <span class="token operator">=</span> <span class="token function">event_base_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化lfd上树节点</span>
	<span class="token keyword">struct</span> <span class="token class-name">event</span><span class="token operator">*</span> ev <span class="token operator">=</span> <span class="token function">event_new</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> lfd<span class="token punctuation">,</span> EV_READ<span class="token operator">|</span>EV_PERSIST<span class="token punctuation">,</span> lfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 上树</span>
	<span class="token function">event_add</span><span class="token punctuation">(</span>ev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 循环监听</span>
	<span class="token function">event_base_dispatch</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞</span>
	
	<span class="token comment">// 收尾</span>
	<span class="token function">close</span><span class="token punctuation">(</span>lfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">event_free</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这行在视频代码里是没有的，但GPT说要这一步，而且官方demo也是有这一步的</span>
	<span class="token function">event_base_free</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span>；
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实战-tcp服务器-官方数组版" tabindex="-1"><a class="header-anchor" href="#实战-tcp服务器-官方数组版"><span>实战 - tcp服务器（官方数组版）</span></a></h3><p>下树对应的客户fd的问题，在官方demo里是这样实现的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">// 下树时的操作</span>
<span class="token function">event_del</span><span class="token punctuation">(</span><span class="token function">getEventByFd</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从数组中找到对应的</span>

<span class="token comment">// 添加时的操作</span>
<span class="token keyword">struct</span> <span class="token class-name">event</span><span class="token operator">*</span> readev <span class="token operator">=</span> <span class="token function">event_mew</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> cfd<span class="token punctuation">,</span> EV_READ<span class="token operator">|</span>EV_PERSIST<span class="token punctuation">,</span> readcb<span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">event_add</span><span class="token punctuation">(</span>readev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">addEvent</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> readev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加到数组，该数组长度为 [_MAX_CLIENT_]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="buffevent" tabindex="-1"><a class="header-anchor" href="#buffevent"><span>buffevent</span></a></h2><h3 id="事件介绍" tabindex="-1"><a class="header-anchor" href="#事件介绍"><span>事件介绍</span></a></h3><p>普通event事件、高级event事件(buffevent)</p><p>核心：</p><ul><li>一个文件描述符</li><li>两个缓冲区</li><li>三个回调 <ul><li>事件回调</li><li>出错</li><li>断开连接</li></ul></li></ul><p>读回调：底层的读缓存区数据拷贝到应用层缓冲区，会触发读回调 写数据：从应用层缓冲区将数据写入底层缓冲区会出发写回调</p><h3 id="事件监听流程" tabindex="-1"><a class="header-anchor" href="#事件监听流程"><span>事件监听流程</span></a></h3><h3 id="buffeventapi" tabindex="-1"><a class="header-anchor" href="#buffeventapi"><span>buffeventAPI</span></a></h3><h1 id="新" tabindex="-1"><a class="header-anchor" href="#新"><span>新</span></a></h1><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">/**
 * 新增buffer事件
 * @param base，根节点
 * @param fd，文件描述符
 * @param options, bufferevent的选项
 *     BEV_OPT_CLOSE_ON_FREE，释放bufferevent自动关闭底层接口 (即close fd)
 *     BEV_OPT_THREADSAFE，使bufferevent能够在多线程下是安全的 (即自动加锁)
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">bufferevent</span><span class="token operator">*</span> <span class="token function">bufferevent_socket_new</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">event_base</span><span class="token operator">*</span> base<span class="token punctuation">,</span> evutil_socket_t fd<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>

回调函数原型：
<span class="token keyword">typedef</span>
wath代表的事件：
BEV_EVENT_EOF，对方关闭连接
BEV_EVENT_ERROR，错误
BEV_EVENT_TIMEOUT，超时
BEV_EVENT_CONNECTED，建立连接成功
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有三个回调函数：</p><ul><li>读回调，当bufferevent将底层缓冲区的数据读到自身读缓冲区时触发</li><li>写回调，当bufferevent将自身读缓冲区的数据写到底层缓冲区时触发</li><li>事件回调，当bufferevent绑定的socket连接，断开或异常时触发</li></ul><h2 id="链接监听器" tabindex="-1"><a class="header-anchor" href="#链接监听器"><span>链接监听器</span></a></h2><p>作用：创建、绑定、监听、提取 套接字</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">/**
 * @param base，base 根节点
 * @param cb，提取cfd后调用的回调
 * @param ptr，传给回调的参数
 * @param flags，标志，一般第一和第四个比较常用
 *     LEV_OPT_LEAVE_SOCKETS_BLOCKING，文件描述符为阻塞的
 *     LEV_OPT_CLOSE_ON_FREE，关闭时自动释放
 *     LEV_OPT_REUSEABLE，端口复用
 *     LEV_OPT_THREADSAFE，分配锁 线程安全
 * @param backlog，-1
 * @param sa，绑定的地址信息
 * @param socklen，sa的大小
 * @return 连接侦听器的地址
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span><span class="token operator">*</span> <span class="token function">evconnlistener_new_bind</span><span class="token punctuation">(</span>
	<span class="token keyword">struct</span> <span class="token class-name">event_base</span><span class="token operator">*</span> base<span class="token punctuation">,</span> 
	evconnlistener_cb cb<span class="token punctuation">,</span> 
	<span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span>
	<span class="token keyword">unsigned</span> flags<span class="token punctuation">,</span>
	<span class="token keyword">int</span> backlog<span class="token punctuation">,</span> 
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span>si sa<span class="token punctuation">,</span> 
	<span class="token keyword">int</span> socklen<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 与前一个函数的不同点在后两个参数，使用本函数时认为socket已经初始化、bind、listen好了
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span><span class="token operator">*</span> <span class="token function">evconnlistener_new</span><span class="token punctuation">(</span>
	<span class="token keyword">struct</span> <span class="token class-name">event_base</span><span class="token operator">*</span> base<span class="token punctuation">,</span> 
	evconnlistener_cb cb<span class="token punctuation">,</span> 
	<span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span>
	<span class="token keyword">unsigned</span> flags<span class="token punctuation">,</span>
	<span class="token keyword">int</span> backlog<span class="token punctuation">,</span>
	evutil_socket_t fd<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 回调函数
 * @param evl，链接侦听器的地址
 * @param fd，cfd
 * @param cliaddr，客户端的地址信息
 * @param ptr，evconnlistener_new_bind 传过来的参数
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>evconnlistener_cb<span class="token punctuation">)</span><span class="token punctuation">(</span>
	<span class="token keyword">struct</span> <span class="token class-name">evconnlistener</span><span class="token operator">*</span> evl<span class="token punctuation">,</span> 
	evutil_socket_t fd<span class="token punctuation">,</span> 
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> cliaddr<span class="token punctuation">,</span> 
	<span class="token keyword">int</span> socklen<span class="token punctuation">,</span> 
	<span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,29))])}const f=l(u,[["render",m],["__file","04. 实战.html.vue"]]),g=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E9%80%9A%E7%94%A8%E5%BA%93/Libevent/04.%20%E5%AE%9E%E6%88%98.html","title":"Libevent 编程指南","lang":"zh-CN","frontmatter":{"description":"Libevent 编程指南 参考：【个人博客】Libevent 编程指南 事件 基本概念 Libevent是基于 Reactor 模式的网络库，在 Reactor 模式中，通常都有一个事件循环(Event Loop)，在 Libevent 中，这个事件循环就是 event_base 结构体： 通常来说，事件循环主要有两个作用： 用来管理事件，比如说添加...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E9%80%9A%E7%94%A8%E5%BA%93/Libevent/04.%20%E5%AE%9E%E6%88%98.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Libevent 编程指南"}],["meta",{"property":"og:description","content":"Libevent 编程指南 参考：【个人博客】Libevent 编程指南 事件 基本概念 Libevent是基于 Reactor 模式的网络库，在 Reactor 模式中，通常都有一个事件循环(Event Loop)，在 Libevent 中，这个事件循环就是 event_base 结构体： 通常来说，事件循环主要有两个作用： 用来管理事件，比如说添加..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Libevent 编程指南\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Libevent 编程指南","slug":"libevent-编程指南","link":"#libevent-编程指南","children":[{"level":2,"title":"事件 基本概念","slug":"事件-基本概念","link":"#事件-基本概念","children":[]},{"level":2,"title":"TCP Server","slug":"tcp-server","link":"#tcp-server","children":[]}]},{"level":1,"title":"Libevent 深入浅出","slug":"libevent-深入浅出","link":"#libevent-深入浅出","children":[{"level":2,"title":"epoll","slug":"epoll","link":"#epoll","children":[{"level":3,"title":"流 - IO操作 - 阻塞","slug":"流-io操作-阻塞","link":"#流-io操作-阻塞","children":[]},{"level":3,"title":"解决阻塞死等待的方法","slug":"解决阻塞死等待的方法","link":"#解决阻塞死等待的方法","children":[]},{"level":3,"title":"什么是epoll","slug":"什么是epoll","link":"#什么是epoll","children":[]},{"level":3,"title":"epollAPI","slug":"epollapi","link":"#epollapi","children":[]},{"level":3,"title":"触发模式","slug":"触发模式","link":"#触发模式","children":[{"level":4,"title":"水平触发","slug":"水平触发","link":"#水平触发","children":[]},{"level":4,"title":"边缘触发","slug":"边缘触发","link":"#边缘触发","children":[]}]},{"level":3,"title":"简单的epoll服务器","slug":"简单的epoll服务器","link":"#简单的epoll服务器","children":[]}]},{"level":2,"title":"epoll 和 reactor","slug":"epoll-和-reactor","link":"#epoll-和-reactor","children":[]},{"level":2,"title":"event_base","slug":"event-base","link":"#event-base","children":[{"level":3,"title":"创建默认的event_base","slug":"创建默认的event-base","link":"#创建默认的event-base","children":[]},{"level":3,"title":"创建复杂的event_base","slug":"创建复杂的event-base","link":"#创建复杂的event-base","children":[]}]},{"level":2,"title":"事件循环 event_loop","slug":"事件循环-event-loop","link":"#事件循环-event-loop","children":[{"level":3,"title":"运行循环","slug":"运行循环","link":"#运行循环","children":[]}]}]},{"level":1,"title":"libevent - 视频","slug":"libevent-视频","link":"#libevent-视频","children":[{"level":2,"title":"libevent 解决了网络编程中的哪些痛点","slug":"libevent-解决了网络编程中的哪些痛点","link":"#libevent-解决了网络编程中的哪些痛点","children":[{"level":3,"title":"FAQ","slug":"faq","link":"#faq","children":[]},{"level":3,"title":"代码","slug":"代码","link":"#代码","children":[]}]}]},{"level":1,"title":"视频2","slug":"视频2","link":"#视频2","children":[{"level":2,"title":"前面","slug":"前面","link":"#前面","children":[]},{"level":2,"title":"select、epoll、icop 区别","slug":"select、epoll、icop-区别","link":"#select、epoll、icop-区别","children":[]},{"level":2,"title":"服务端接收连接的代码示例","slug":"服务端接收连接的代码示例","link":"#服务端接收连接的代码示例","children":[]}]},{"level":1,"title":"视频3","slug":"视频3","link":"#视频3","children":[{"level":2,"title":"event_base","slug":"event-base-1","link":"#event-base-1","children":[]},{"level":2,"title":"libevent","slug":"libevent","link":"#libevent","children":[{"level":3,"title":"libeventAPI","slug":"libeventapi","link":"#libeventapi","children":[]},{"level":3,"title":"实战 - tcp服务器","slug":"实战-tcp服务器","link":"#实战-tcp服务器","children":[]},{"level":3,"title":"实战 - tcp服务器（官方数组版）","slug":"实战-tcp服务器-官方数组版","link":"#实战-tcp服务器-官方数组版","children":[]}]},{"level":2,"title":"buffevent","slug":"buffevent","link":"#buffevent","children":[{"level":3,"title":"事件介绍","slug":"事件介绍","link":"#事件介绍","children":[]},{"level":3,"title":"事件监听流程","slug":"事件监听流程","link":"#事件监听流程","children":[]},{"level":3,"title":"buffeventAPI","slug":"buffeventapi","link":"#buffeventapi","children":[]}]}]},{"level":1,"title":"新","slug":"新","link":"#新","children":[{"level":2,"title":"链接监听器","slug":"链接监听器","link":"#链接监听器","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":11.76,"words":3529},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/通用库/Libevent/04. 实战.md","excerpt":"\\n<p>参考：<a href=\\"http://senlinzhan.github.io/2017/08/12/libevent/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【个人博客】Libevent 编程指南</a></p>\\n<h2>事件 基本概念</h2>\\n<p>Libevent是基于 Reactor 模式的网络库，在 Reactor 模式中，通常都有一个<strong>事件循环(Event Loop)</strong>，在 Libevent 中，这个事件循环就是 <code>event_base</code> 结构体：</p>\\n<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">struct</span> <span class=\\"token class-name\\">event_base</span> <span class=\\"token operator\\">*</span><span class=\\"token function\\">event_base_new</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">void</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>           <span class=\\"token comment\\">// 创建事件循环</span>\\n<span class=\\"token keyword\\">void</span> <span class=\\"token function\\">event_base_free</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">struct</span> <span class=\\"token class-name\\">event_base</span> <span class=\\"token operator\\">*</span>base<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>     <span class=\\"token comment\\">// 销毁事件循环</span>\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">event_base_dispatch</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">struct</span> <span class=\\"token class-name\\">event_base</span> <span class=\\"token operator\\">*</span>base<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>  <span class=\\"token comment\\">// 运行事件循环</span>\\n</code></pre></div>","autoDesc":true}');export{f as comp,g as data};
