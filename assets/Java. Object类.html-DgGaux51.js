import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,e}from"./app-yixEWCFr.js";const t={},l=e(`<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="object类-所有类的超类" tabindex="-1"><a class="header-anchor" href="#object类-所有类的超类"><span>Object类 - 所有类的超类</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><ul><li><p>概念</p><ul><li><p>Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。但是并不需要这样写</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span>	<span class="token comment">// 如果没有明确地指出超类，Object就被认为是这个类的超类</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>范围</p><ul><li>在Java中，只有基本类型（primitive types）不是对象。例如：数值、字符和布尔类型的值都不是对象。</li><li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类</li></ul></li><li><p>用途</p><ul><li><p>可以使用Object类型的变量引用任何类型的对象</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Emplyee</span><span class="token punctuation">(</span><span class="token string">&quot;Harry Hacker&quot;</span><span class="token punctuation">,</span> <span class="token number">35000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>Object类内置了几个方法，以便所有类都能用这几个方法</p></li></ul></li></ul><hr><p><mark>与C++不同</mark></p><p>其他语言</p><ul><li>java：Object类是Java中所有类的始祖</li><li>js：原型链的终点是object</li><li>QT：QObject类是所有QT类的始祖</li><li>C++：没有所有类的根类，不过，每个指针都可以转换成void*指针</li></ul><h2 id="对象比较" tabindex="-1"><a class="header-anchor" href="#对象比较"><span>对象比较</span></a></h2><h3 id="常用方法" tabindex="-1"><a class="header-anchor" href="#常用方法"><span>常用方法</span></a></h3><h4 id="equals方法" tabindex="-1"><a class="header-anchor" href="#equals方法"><span>equals方法</span></a></h4><p>Object类中的equals方法用于检测一个对象是否等于另外一个对象</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token comment">// 在Object类中，这个方法将判断两个对象**是否具有相同的引用**。如果两个对象具有相同的引用，它们一定是相等的。</span>
<span class="token comment">// 然而，对于多数类来说，equals的默认判断没什么意义。经常需要检测两个对象**状态的相等性**，若状态相等，就认为这两个对象是相等的</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>==和equals区别：<code>==</code>比较的是内存地址，多用于值类型的比较</li><li>equals方法特性 Java语言规范要求equals方法具有下面的特性： <ul><li>1）自反性：对于任何非空引用x，x.equals（x）应该返回true。</li><li>2）对称性：对于任何引用x和y，当且仅当y.equals（x）返回true，x.equals（y）也应该返回true 从而避免了类库实现者在数据结构中定位一个元素时还要考虑调用x.equals（y），还是调用y.equals（x）的问题</li><li>3）传递性：对于任何引用x、y和z，如果x.equals（y）返回true，y.equals（z）返回true，x.equals（z）也应该返回true。</li><li>4）一致性：如果x和y引用的对象没有发生变化，反复调用x.equals（y）应该返回同样的结果。</li><li>5）对于任意非空引用x，x.equals（null）应该返回false。</li></ul></li></ul><h4 id="objects-equals-a-b-方法" tabindex="-1"><a class="header-anchor" href="#objects-equals-a-b-方法"><span>Objects.equals(a, b) 方法</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a，b<span class="token punctuation">)</span>
<span class="token comment">// 1. 如果两个参数都为null，返回true；</span>
<span class="token comment">// 2. 如果其中一个参数为null，返回false；</span>
<span class="token comment">// 3. 如果两个参数都不为null，则调用a.equals(b)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="getclass方法" tabindex="-1"><a class="header-anchor" href="#getclass方法"><span>getClass方法</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 返回一个对象所属的类</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="instanceof方法" tabindex="-1"><a class="header-anchor" href="#instanceof方法"><span>instanceof方法</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>？？？
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="应用举例-重写equals方法" tabindex="-1"><a class="header-anchor" href="#应用举例-重写equals方法"><span>应用举例 - 重写equals方法</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span>					<span class="token comment">// 重写equals方法</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>					<span class="token comment">// 引用是否相同</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>	<span class="token comment">// 类是否相同</span>
        <span class="token class-name">Employee</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>
        <span class="token comment">//return name.equals(other.name)						// 状态是否相同 - 有缺陷版本</span>
        <span class="token comment">//    &amp;&amp; salary == other.salary</span>
        <span class="token comment">//    &amp;&amp; hireDay.ewquals(other.hireDay);*/</span>
        
        <span class="token comment">// 提示：为了防备name或hireDay可能为null的情况，需要使用Objects.equals方法</span>
        <span class="token comment">// 因为null不是object，null不可调用equals方法</span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> other name<span class="token punctuation">)</span>					<span class="token comment">// 状态是否相同</span>
            <span class="token operator">&amp;&amp;</span> salary <span class="token operator">==</span> other<span class="token punctuation">.</span>salary
            <span class="token operator">&amp;&amp;</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>hireDay<span class="token punctuation">,</span> other<span class="token punctuation">.</span>hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="相等测试与继承-暂略-没懂" tabindex="-1"><a class="header-anchor" href="#相等测试与继承-暂略-没懂"><span>相等测试与继承 [暂略]，没懂</span></a></h3><p>API：<code>java.util.Arrays 1.2</code> API：<code>java.util.Objects 7</code></p><p>如果隐式和显式的参数不属于同一个类，equals方法将如何处理呢？</p><p>在前面的例子中，如果发现类不匹配，equals方法就返回false。但是，许多程序员却喜欢使用instanceof进行检测：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>otherObject <span class="token keyword">instanceof</span> <span class="token class-name">Employee</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样做不但没有解决otherObject是子类的情况，并且还有可能会招致一些麻烦。这就是建议不要使用这种处理方式的原因所在。</p><p>然而，就对称性来说，当参数不属于同一个类的时候需要仔细地思考一下。请看下面这个调用：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>e<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 返回true</span>
<span class="token comment">// e是一个Employee对象，m是一个Manager对象，并且两个对象具有相同的姓名、薪水和雇佣日期。</span>
<span class="token comment">// 如果在Employee.equals中用instanceof进行检测，则返回true。然而这意味着反过来调用</span>
m<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 返回true。对称性不允许这个方法调用返回false，或者抛出异常。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="hashcode方法-此略" tabindex="-1"><a class="header-anchor" href="#hashcode方法-此略"><span>hashCode方法 [此略]</span></a></h3><p>API：<code>java.util.Object 1.0</code> API：<code>java.util.Objects 7</code> API：<code>java.lang.（Integer|Long|Short|Byte|Double|Float|Character|Boolean）1.0</code> API：<code>java.util.Arrays 1.2</code></p><p>散列码（hash code）是由对象导出的一个整型值</p><p>散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode（）与y.hashCode（）基本上不会相同</p><h2 id="tostring方法-书略" tabindex="-1"><a class="header-anchor" href="#tostring方法-书略"><span>toString方法（书略）</span></a></h2><p>API：<code>java.lang.Object 1.0</code> API：<code>java.lang.Class 1.0</code></p><p>在Object中还有一个重要的方法，就是toString方法，它用于返回表示对象值的字符串</p>`,38),c=[l];function p(o,i){return n(),s("div",null,c)}const d=a(t,[["render",p],["__file","Java. Object类.html.vue"]]),v=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/04.%20%E7%89%B9%E6%AE%8A%E7%B1%BB/Java.%20Object%E7%B1%BB.html","title":"Java","lang":"zh-CN","frontmatter":{"description":"Java 目录 Object类 - 所有类的超类 概念 概念 Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。但是并不需要这样写 范围 在Java中，只有基本类型（primitive types）不是对象。例如：数值、字符和布尔类型的值都不是对象。 所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类 用...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/04.%20%E7%89%B9%E6%AE%8A%E7%B1%BB/Java.%20Object%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Java"}],["meta",{"property":"og:description","content":"Java 目录 Object类 - 所有类的超类 概念 概念 Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。但是并不需要这样写 范围 在Java中，只有基本类型（primitive types）不是对象。例如：数值、字符和布尔类型的值都不是对象。 所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类 用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Java","slug":"java","link":"#java","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"Object类 - 所有类的超类","slug":"object类-所有类的超类","link":"#object类-所有类的超类","children":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"对象比较","slug":"对象比较","link":"#对象比较","children":[{"level":3,"title":"常用方法","slug":"常用方法","link":"#常用方法","children":[{"level":4,"title":"equals方法","slug":"equals方法","link":"#equals方法","children":[]},{"level":4,"title":"Objects.equals(a, b) 方法","slug":"objects-equals-a-b-方法","link":"#objects-equals-a-b-方法","children":[]},{"level":4,"title":"getClass方法","slug":"getclass方法","link":"#getclass方法","children":[]},{"level":4,"title":"instanceof方法","slug":"instanceof方法","link":"#instanceof方法","children":[]}]},{"level":3,"title":"应用举例 - 重写equals方法","slug":"应用举例-重写equals方法","link":"#应用举例-重写equals方法","children":[]},{"level":3,"title":"相等测试与继承 [暂略]，没懂","slug":"相等测试与继承-暂略-没懂","link":"#相等测试与继承-暂略-没懂","children":[]},{"level":3,"title":"hashCode方法 [此略]","slug":"hashcode方法-此略","link":"#hashcode方法-此略","children":[]}]},{"level":2,"title":"toString方法（书略）","slug":"tostring方法-书略","link":"#tostring方法-书略","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.05,"words":1215},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Java/06. 面向对象/04. 特殊类/Java. Object类.md","autoDesc":true}');export{d as comp,v as data};
