import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,o as d,c,a as e,b as t,d as o,e as l}from"./app-CoO7IlkE.js";const s={},r=l(`<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="qt信号和槽机制-【重点】" tabindex="-1"><a class="header-anchor" href="#qt信号和槽机制-【重点】"><span>Qt信号和槽机制**【重点】**</span></a></h1><h2 id="简概-emit、信号、槽、connect" tabindex="-1"><a class="header-anchor" href="#简概-emit、信号、槽、connect"><span>简概（emit、信号、槽、Connect）</span></a></h2><ul><li>信号槽优点 / 特点 <ul><li><code>类型安全</code>。需要信号和槽的参数类型和个数相同，或后者少于前者的后几个参数</li><li><code>松散耦合</code>。即信号发送端换接收端本身没有关联，通过<code>connect</code>连接，将两端耦合在一起</li><li>connect只是对象发送信号和处理函数这两者，本质也是类似于<code>js/Android</code>的控件对象绑定方法，但写法不同</li></ul></li><li>使用 <ul><li>通用：<code>connect(信号的发送者, 发送的信号, 信号的接受者, 处理的槽函数);</code></li><li>举例：<code>connect(btn2, &amp;QPushButton::clicked, this, &amp;QWidget::close);</code></li><li>补充：发送的信号通过查手册的<code>Signals</code>，槽函数查手册的<code>Public Slots</code></li><li>补充：如果第三个参数是this，则可以省略</li><li>补充：注意参数是函数名而不是调用函数</li></ul></li><li>剖析 <ul><li>为什么第二个和第四个参数需要加<code>&amp;</code>符号和作用域解析运算符<code>::</code>？</li><li>connect的第二四个参数分别为<code>const char *signal</code>和<code>const char *member</code>，加&amp;以后为按引用传参，本质是传递指针！</li><li>当然还有令一种写法——传递函数指针（详见后面的 “信号和槽的重载”）</li></ul></li><li>性能 <ul><li>增强了对象间通信的灵活性，然而损失了一些性能，比直接调用非虚函数的运行速度慢10倍</li><li>慢的原因 <ul><li>需要定位接受信号的对象（动态使用）</li><li>安全地遍历所有关联（如一个信号关联多个槽的情况）</li><li>编组（marshal）/解组（unmarshal）传递的参数</li><li>在多线程时，信号可能需要排队等待</li></ul></li><li>然而与堆对象的new和delete操作相比，其代价很小。信号和槽导致的性能损失对于实时应用程序是可以忽略的</li></ul></li></ul><h2 id="自定义信号和槽" tabindex="-1"><a class="header-anchor" href="#自定义信号和槽"><span>自定义信号和槽</span></a></h2><ul><li><p>前提</p><ul><li>继承<code>QObject</code>类或其派生类</li></ul></li><li><p>写法</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>  class A : public QObject
  {
      Q_OBJECT
  public:
      // ...
  signals:				// 自定义信号
      void is_a_signal();	// 返回值是void、只需声明不需实现、可有参数、可以重载
  public slots:			// 早期Qt版本，必须要写到public slots，高级版本可以写到public或者全局下（即没有槽函数一说？）
      void is_a_slots();	// 返回值是void，需要声明并实现、可有参数、可以重载
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>触发信号：<code>emit a-&gt;is_a_signal();</code></p></li></ul></li><li><p>信号特点</p><ul><li>写到<code>signals</code>下</li><li>返回值是void</li><li>只需声明不需实现</li><li>可有参数、可以重载</li></ul></li><li><p>槽特点</p><ul><li>写到<code>public slots</code>下，高版本还可以写<code>public</code>下（<code>private slots</code>/<code>private</code>也行） （真的？但话说槽函数不是需要额外追踪以实现动态调用吗，本质上其实还是public slots吧）</li><li>返回值是void</li><li>需要声明并实现</li><li>可有参数、可以重载</li></ul></li></ul><h2 id="信号和槽的重载" tabindex="-1"><a class="header-anchor" href="#信号和槽的重载"><span>信号和槽的重载</span></a></h2><ul><li><p>和函数重载一样，需要注意的点：</p><ul><li><p><code>emit</code>触发不同版本的信号</p></li><li><p>连接时，信号的参数列表数量必须大于或等于槽的，类型必须匹配。一般添加重载方法是两边都添加</p></li><li><p><code>connect</code>连接时<mark>需要使用<strong>函数指针</strong>来区分不同版本的信号和槽</mark>（如果没有重载则不需要这一步）</p><p>函数指针定义方式：<code>函数返回类型(*指针变量名)(函数参数列表)</code></p><p>例如：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void(Widget:: *ptr_1)(QWidget*) = &amp;Widget::is_a_signal;
void(Widget:: *ptr_2)(QWidget*) = &amp;Widget::is_a_slots;
connect(this, ptr_1, this, ptr_2);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="常用信号和槽" tabindex="-1"><a class="header-anchor" href="#常用信号和槽"><span>常用信号和槽</span></a></h2><ul><li><code>clicked()</code>，点击</li><li><code>hover()</code>，悬浮</li><li><code>triggered()</code>，触发（点击菜单项）</li></ul><h2 id="lambda的槽函数妙用" tabindex="-1"><a class="header-anchor" href="#lambda的槽函数妙用"><span>Lambda的槽函数妙用</span></a></h2><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><blockquote><h4 id="使用-1" tabindex="-1"><a class="header-anchor" href="#使用-1"><span>使用</span></a></h4></blockquote><p>通用：<s><code>[=](){/**/}();</code></s></p><p>作为槽函数时不需要最后面的<code>()</code>，即<code>[=](){/**/}</code>即可</p><blockquote><h4 id="函数对象参数有以下形式" tabindex="-1"><a class="header-anchor" href="#函数对象参数有以下形式"><span>函数对象参数有以下形式</span></a></h4></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>空</td><td>没有使用任何函数对象参数</td></tr><tr><td><code>=</code></td><td>函数体内可以使用Lambda范围内所有可见的局部变量，并使用<strong>值传递方式</strong></td></tr><tr><td><code>&amp;</code></td><td>函数体内可以使用Lambda范围内所有可见的局部变量，并使用<strong>引用传递方式</strong></td></tr><tr><td><code>this</code></td><td>函数体内可以使用Lambda则在类的成员变量</td></tr><tr><td><code>a</code></td><td>按值传递变量a</td></tr><tr><td><code>&amp;a</code></td><td>按引用传递变量a</td></tr><tr><td><code>a, &amp;b</code></td><td>按值传递a，按引用传递b</td></tr><tr><td><code>=, &amp;a, &amp;b</code></td><td>按引用传递a和b，其他参数按值传递</td></tr><tr><td><code>&amp;, a, b</code></td><td>按值传递a和b，其他参数按引用传递</td></tr></tbody></table><blockquote><h4 id="mutable修饰符" tabindex="-1"><a class="header-anchor" href="#mutable修饰符"><span>mutable修饰符</span></a></h4></blockquote><p>通用：<code>[=]()mutable{/**/}();</code></p><p>作用：可以修改按值传递进去Lambda中的拷贝（修改拷贝而不是修改值本身）</p><blockquote><h4 id="函数返回值" tabindex="-1"><a class="header-anchor" href="#函数返回值"><span>函数返回值</span></a></h4></blockquote><p><code>-&gt;</code>返回值类型</p><p>通用：<code>[=]()-&gt;返回类型{/**/}();</code></p><h3 id="妙用" tabindex="-1"><a class="header-anchor" href="#妙用"><span>妙用</span></a></h3><p>可以让Lambda函数充当槽函数，太方便了！！！不需要另外定义信号接受者的槽函数</p><h3 id="qt4兼容问题" tabindex="-1"><a class="header-anchor" href="#qt4兼容问题"><span>Qt4兼容问题</span></a></h3><p>Qt4如果需要使用Lambda表达式，要在pro文件中写：<code>CONFIG += C++11</code></p><p>Qt5默认加了这行代码</p><h2 id="qt中sender-函数的用法" tabindex="-1"><a class="header-anchor" href="#qt中sender-函数的用法"><span>Qt中sender()函数的用法</span></a></h2><p>你在一个槽里面，调用这个函数，返回的就是你信号来源的对象；</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QPushButton *aaaa = new QPushButton(this); 
connect(aaaaa, SIGNAL(Click()), this, SLOT(Onaaaaa()); 

void Onaaaaa(){ 
	QPushButton *ccc = (QPushButton*) sender(); 
} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个CCC就是aaaa这个对象来的</p><h2 id="qt中parent-的用法" tabindex="-1"><a class="header-anchor" href="#qt中parent-的用法"><span>Qt中parent()的用法</span></a></h2><p>这个函数是</p><p><code>QObject *QObject::parent() const</code></p><p>作用：返回指向父对象的指针</p><h2 id="补充" tabindex="-1"><a class="header-anchor" href="#补充"><span>补充</span></a></h2><h3 id="信号和槽的关系与拓展" tabindex="-1"><a class="header-anchor" href="#信号和槽的关系与拓展"><span>信号和槽的关系与拓展</span></a></h3><ul><li>(1) 信号可以连接信号或槽函数</li><li>(2) 同一个信号可以连接多个槽函数</li><li>(3) 多个信号可以连接同一个槽函数</li><li>(4) 信号的参数个数等于或大于槽函数的参数个数，但类型必须一一对应</li></ul><h3 id="新旧版本的写法-qt4旧版本-qt5向下兼容" tabindex="-1"><a class="header-anchor" href="#新旧版本的写法-qt4旧版本-qt5向下兼容"><span>新旧版本的写法（Qt4旧版本，Qt5向下兼容）</span></a></h3>`,41),p={href:"https://blog.csdn.net/zqxdsy/article/details/89161065",target:"_blank",rel:"noopener noreferrer"},h=l(`<ul><li><p>Qt4</p><ul><li>通用：<code>connect(信号发送者, 发送的信号SINGNAL(信号), 信号接受者, 槽函数SLOT(槽函数));</code></li><li>举例：<code>connect(zt, SINGAL(hungry(QString)), st, SLOT(treat()));</code></li><li>优点：参数直观，需要将信号和槽进行明确的指定</li><li>缺点：类型不做检测</li></ul></li><li><p>Qt5</p><ul><li><p>通用：<code>connect(信号的发送者, 发送的信号, 信号的接受者, 处理的槽函数);</code></p></li><li><p>举例：<code>connect(btn2, &amp;QPushButton::clicked, this, &amp;QWidget::close);</code></p></li><li><p>缺点：这里可以看到不需要指定函数参数，这意味着当存在重载的信号槽函数时，需要使用函数指针来指定。例下使用了类型转换</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>connect(m_pBtn, static_cast&lt;void (MyButton::*)(bool)&gt;(&amp;MyButton::sigClicked), this, &amp;Widget::onClicked);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>主要：Qt4和Qt5的写法不能在同一条connect语法中混用</p></li><li><p>Lambda + 带参：</p><ul><li>https://blog.csdn.net/LittleLittleFish_xyg/article/details/118734081</li><li>https://blog.csdn.net/gz9456/article/details/108776642</li><li><code>connect(list,&amp;QListWidget::currentTextChanged,[&amp;](QString test){qDebug() &lt;&lt; &quot;xxxx&quot; &lt;&lt; test;});</code></li></ul></li></ul></li><li><p>Qt新</p><ul><li>通用：<code>connect(m_pBtn, QOverload&lt;bool&gt;::of(&amp;MyButton::sigClicked),this,&amp;Widget::onClicked);</code></li><li>优点：主要针对重载信号的连接做了调整</li></ul></li><li><p>Lambda 函数写法</p><ul><li>优点：如果槽函数中的内容比较简单的话，没必要再去单独定义一个槽来连接， 直接用Lambda 函数会更简单</li></ul></li></ul><h3 id="报错-lnk2019无法解析的外部符号" tabindex="-1"><a class="header-anchor" href="#报错-lnk2019无法解析的外部符号"><span>报错：lnk2019无法解析的外部符号</span></a></h3><ul><li>原因一 <ul><li>解决方法：重新构建 &gt; 执行qmark &gt; 清除 &gt; 运行</li></ul></li><li>原因二 <ul><li>声明了槽函数但是没有实现</li></ul></li></ul>`,3);function u(m,b){const i=n("ExternalLinkIcon");return d(),c("div",null,[r,e("p",null,[t("参考："),e("a",p,[t("【CSDN】Qt connect函数的几种用法"),o(i)])]),h])}const E=a(s,[["render",u],["__file","02. Qt信号和槽机制.html.vue"]]),Q=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/02.%20Qt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E6%9C%BA%E5%88%B6.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 Qt信号和槽机制**【重点】** 简概（emit、信号、槽、Connect） 信号槽优点 / 特点 类型安全。需要信号和槽的参数类型和个数相同，或后者少于前者的后几个参数 松散耦合。即信号发送端换接收端本身没有关联，通过connect连接，将两端耦合在一起 connect只是对象发送信号和处理函数这两者，本质也是类似于js/Android的...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/02.%20Qt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 Qt信号和槽机制**【重点】** 简概（emit、信号、槽、Connect） 信号槽优点 / 特点 类型安全。需要信号和槽的参数类型和个数相同，或后者少于前者的后几个参数 松散耦合。即信号发送端换接收端本身没有关联，通过connect连接，将两端耦合在一起 connect只是对象发送信号和处理函数这两者，本质也是类似于js/Android的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"Qt信号和槽机制**【重点】**","slug":"qt信号和槽机制-【重点】","link":"#qt信号和槽机制-【重点】","children":[{"level":2,"title":"简概（emit、信号、槽、Connect）","slug":"简概-emit、信号、槽、connect","link":"#简概-emit、信号、槽、connect","children":[]},{"level":2,"title":"自定义信号和槽","slug":"自定义信号和槽","link":"#自定义信号和槽","children":[]},{"level":2,"title":"信号和槽的重载","slug":"信号和槽的重载","link":"#信号和槽的重载","children":[]},{"level":2,"title":"常用信号和槽","slug":"常用信号和槽","link":"#常用信号和槽","children":[]},{"level":2,"title":"Lambda的槽函数妙用","slug":"lambda的槽函数妙用","link":"#lambda的槽函数妙用","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"妙用","slug":"妙用","link":"#妙用","children":[]},{"level":3,"title":"Qt4兼容问题","slug":"qt4兼容问题","link":"#qt4兼容问题","children":[]}]},{"level":2,"title":"Qt中sender()函数的用法","slug":"qt中sender-函数的用法","link":"#qt中sender-函数的用法","children":[]},{"level":2,"title":"Qt中parent()的用法","slug":"qt中parent-的用法","link":"#qt中parent-的用法","children":[]},{"level":2,"title":"补充","slug":"补充","link":"#补充","children":[{"level":3,"title":"信号和槽的关系与拓展","slug":"信号和槽的关系与拓展","link":"#信号和槽的关系与拓展","children":[]},{"level":3,"title":"新旧版本的写法（Qt4旧版本，Qt5向下兼容）","slug":"新旧版本的写法-qt4旧版本-qt5向下兼容","link":"#新旧版本的写法-qt4旧版本-qt5向下兼容","children":[]},{"level":3,"title":"报错：lnk2019无法解析的外部符号","slug":"报错-lnk2019无法解析的外部符号","link":"#报错-lnk2019无法解析的外部符号","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.78,"words":1734},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/02. Qt信号和槽机制.md","autoDesc":true}');export{E as comp,Q as data};
