import{_ as r,c as t,e as o,o as a}from"./app-BHdORQJ2.js";const c={};function l(n,e){return a(),t("div",null,e[0]||(e[0]=[o('<h1 id="reactor-vs-proactor模式1" tabindex="-1"><a class="header-anchor" href="#reactor-vs-proactor模式1"><span>Reactor vs Proactor模式1</span></a></h1><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_63566550/article/details/130479629" target="_blank" rel="noopener noreferrer">【操作系统】高性能网络模式：Reactor 和 Proactor</a><ul><li><a href="https://juejin.cn/post/7217267332658135100" target="_blank" rel="noopener noreferrer">高性能 RPC 通信的实现- 巧用 reactor 模式</a></li><li><a href="https://www.xiaolincoding.com/os/8_network_system/reactor.html#_9-3-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F-reactor-%E5%92%8C-proactor" target="_blank" rel="noopener noreferrer">高性能网络模式：Reactor 和 Proactor</a></li><li><a href="https://www.jianshu.com/p/38b56531565d" target="_blank" rel="noopener noreferrer">NIO Reactor模型 </a></li><li><a href="https://juejin.cn/post/7177175166638620730" target="_blank" rel="noopener noreferrer">Netty「基石」之Reactor模式</a></li><li><a href="https://zhuanlan.zhihu.com/p/95662364" target="_blank" rel="noopener noreferrer">高性能IO模型分析-Reactor模式和Proactor模式</a></li><li><a href="https://blog.csdn.net/weixin_63566550/article/details/129904389" target="_blank" rel="noopener noreferrer">【操作系统】IO模型篇之从BIO、NIO、AIO到内核select、epoll剖析</a></li></ul></li></ul><p>需要先读：5种IO模型</p><p>前面的模型根据线程数、是否异步、是否阻塞 来区分。这里根据更抽象的设计模式，或更具体的做法来分类</p><p>大纲：</p><ul><li>Reactor模式 <ul><li>单 Reactor 单进程/线程</li><li>单 Reactor 多进程/线程</li><li>多 Reactor 多进程/线程</li></ul></li><li>Proactor模式</li></ul><h2 id="reactor模式" tabindex="-1"><a class="header-anchor" href="#reactor模式"><span>Reactor模式</span></a></h2><p><code>Reactor</code>设计模式是一种事件处理模式，用于同时有一个或多个请求发送到事件处理器（service handler），这个事件处理器会采用多路分离（demultiplexes ）的方式，同步的将这些请求分发到请求处理器（request handlers）。</p><p>相应的, 在传统BIO服务上的<code>Reactor</code>模型的基本形态如下图所示：</p><p>![image-20230426142122940](Reactor vs Proactor模式1.assets/c6190812e48dcef2e86ada6cacd1d607.png)</p><p>事实上，Reactor 模式也叫 <code>Dispatcher</code> 模式，我觉得这个名字更贴合该模式的含义，即 <strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程</strong>。</p><h3 id="reactor模式思想-分而治之-事件驱动" tabindex="-1"><a class="header-anchor" href="#reactor模式思想-分而治之-事件驱动"><span><a href="https://so.csdn.net/so/search?q=Reactor%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">Reactor模式</a>思想：分而治之+事件驱动</span></a></h3><p>Reactor 模式主要由 Reactor 和处理资源池这两个<strong>核心组成部分</strong>，它俩负责的事情如下：</p><ul><li>事件驱动：Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li><li>分而治之：处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li></ul><p>Reactor 模式是<strong>灵活多变</strong>的，可以应对不同的业务场景，灵活在于：</p><ul><li>Reactor 的数量可以只有一个，也可以有多个；</li><li>处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；</li></ul><p>以下 <strong>3 个方案</strong>都是比较经典的，且都有应用在实际的项目中：</p><ul><li>单 Reactor 单进程 / 线程；</li><li>单 Reactor 多线程 / 进程；</li><li>多 Reactor 多进程 / 线程；</li></ul><p>方案具体使用<strong>进程还是线程</strong>，要看使用的编程语言以及平台有关：</p><ul><li>Java 语言一般使用线程，比如 Netty;</li><li>C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。</li></ul><p>接下来，分别介绍这三个经典的 Reactor 方案。</p><h3 id="单-reactor-单进程-线程" tabindex="-1"><a class="header-anchor" href="#单-reactor-单进程-线程"><span>单 Reactor 单进程 / 线程</span></a></h3><p>![img](Reactor vs Proactor模式1.assets/32c7300dca362d26e885b1e1a2cf917a.png)</p><h3 id="单-reactor-多线程-多进程" tabindex="-1"><a class="header-anchor" href="#单-reactor-多线程-多进程"><span>单 Reactor 多线程 / 多进程</span></a></h3><p>![img](Reactor vs Proactor模式1.assets/9b8bb8dbbec8c53d61ef621c72851de2.png)</p><h3 id="多-reactor-多进程-线程" tabindex="-1"><a class="header-anchor" href="#多-reactor-多进程-线程"><span>多 Reactor 多进程 / 线程</span></a></h3><p>![img](Reactor vs Proactor模式1.assets/6aa1bcbe6993075a4081f58ec628b6a0.png)</p><h2 id="proactor模式" tabindex="-1"><a class="header-anchor" href="#proactor模式"><span>Proactor模式</span></a></h2><p>Proactor 正是采用了异步 I/O 技术，所以被称为异步网络模型。</p><p>![img](Reactor vs Proactor模式1.assets/dac1e39170a05b2c5961c26fb0a111e3.png)</p><h2 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h2><p>现在我们再来理解 Reactor 和 Proactor 的区别，就比较清晰了。</p><ul><li><p>区别1</p><ul><li><p>Reactor 是<strong>非阻塞同步</strong>网络模式，感知的是就绪可读写事件。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</p></li><li><p>Proactor 是<strong>异步</strong>网络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p></li></ul></li><li><p>区别2 （这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。）</p><ul><li><p>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</p></li><li><p>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</p></li></ul></li><li><p>由例子说明区别</p><ul><li><p>Reactor 模式就是快递员在楼下，给你打电话告诉你快递到你家小区了，你需要自己下楼来拿快递</p></li><li><p>Proactor 模式就是快递员直接将快递送到你家门口，然后通知你。</p></li></ul></li><li><p>区别</p><ul><li><p>Reactor 模式：基于「事件分发」，但基于「待完成」的 I/O 事件，</p></li><li><p>Proactor 模式：基于「事件分发」，但基于「已完成」的 I/O 事件。</p></li></ul></li></ul>',34)]))}const p=r(c,[["render",l],["__file","Reactor vs Proactor模式1.html.vue"]]),s=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/Reactor%20vs%20Proactor%E6%A8%A1%E5%BC%8F1.html","title":"Reactor vs Proactor模式1","lang":"zh-CN","frontmatter":{"description":"Reactor vs Proactor模式1 参考： 【操作系统】高性能网络模式：Reactor 和 Proactor 高性能 RPC 通信的实现- 巧用 reactor 模式 高性能网络模式：Reactor 和 Proactor NIO Reactor模型 Netty「基石」之Reactor模式 高性能IO模型分析-Reactor模式和Proacto...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/Reactor%20vs%20Proactor%E6%A8%A1%E5%BC%8F1.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Reactor vs Proactor模式1"}],["meta",{"property":"og:description","content":"Reactor vs Proactor模式1 参考： 【操作系统】高性能网络模式：Reactor 和 Proactor 高性能 RPC 通信的实现- 巧用 reactor 模式 高性能网络模式：Reactor 和 Proactor NIO Reactor模型 Netty「基石」之Reactor模式 高性能IO模型分析-Reactor模式和Proacto..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Reactor vs Proactor模式1\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Reactor vs Proactor模式1","slug":"reactor-vs-proactor模式1","link":"#reactor-vs-proactor模式1","children":[{"level":2,"title":"Reactor模式","slug":"reactor模式","link":"#reactor模式","children":[{"level":3,"title":"Reactor模式思想：分而治之+事件驱动","slug":"reactor模式思想-分而治之-事件驱动","link":"#reactor模式思想-分而治之-事件驱动","children":[]},{"level":3,"title":"单 Reactor 单进程 / 线程","slug":"单-reactor-单进程-线程","link":"#单-reactor-单进程-线程","children":[]},{"level":3,"title":"单 Reactor 多线程 / 多进程","slug":"单-reactor-多线程-多进程","link":"#单-reactor-多线程-多进程","children":[]},{"level":3,"title":"多 Reactor 多进程 / 线程","slug":"多-reactor-多进程-线程","link":"#多-reactor-多进程-线程","children":[]}]},{"level":2,"title":"Proactor模式","slug":"proactor模式","link":"#proactor模式","children":[]},{"level":2,"title":"区别","slug":"区别","link":"#区别","children":[]}]}],"git":{},"readingTime":{"minutes":4.18,"words":1253},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络编程与网络模型与网络架构/Reactor vs Proactor模式1.md","excerpt":"\\n<p>参考：</p>\\n<ul>\\n<li><a href=\\"https://blog.csdn.net/weixin_63566550/article/details/130479629\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【操作系统】高性能网络模式：Reactor 和 Proactor</a>\\n<ul>\\n<li><a href=\\"https://juejin.cn/post/7217267332658135100\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">高性能 RPC 通信的实现- 巧用 reactor 模式</a></li>\\n<li><a href=\\"https://www.xiaolincoding.com/os/8_network_system/reactor.html#_9-3-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F-reactor-%E5%92%8C-proactor\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">高性能网络模式：Reactor 和 Proactor</a></li>\\n<li><a href=\\"https://www.jianshu.com/p/38b56531565d\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">NIO Reactor模型 </a></li>\\n<li><a href=\\"https://juejin.cn/post/7177175166638620730\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Netty「基石」之Reactor模式</a></li>\\n<li><a href=\\"https://zhuanlan.zhihu.com/p/95662364\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">高性能IO模型分析-Reactor模式和Proactor模式</a></li>\\n<li><a href=\\"https://blog.csdn.net/weixin_63566550/article/details/129904389\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【操作系统】IO模型篇之从BIO、NIO、AIO到内核select、epoll剖析</a></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络编程与网络模型与网络架构/Reactor vs Proactor模式1.md","value":{"title":"Reactor vs Proactor模式1","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络编程与网络模型与网络架构/Reactor vs Proactor模式1.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{p as comp,s as data};
