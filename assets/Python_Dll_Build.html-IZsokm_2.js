import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as i,c as o,a as n,b as s,d as e,e as t}from"./app-Bl6HAa8e.js";const c={},d=t('<h1 id="dll-compiled-by-all-language" tabindex="-1"><a class="header-anchor" href="#dll-compiled-by-all-language"><span>DLL Compiled By All Language</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="三种方法" tabindex="-1"><a class="header-anchor" href="#三种方法"><span>三种方法</span></a></h1><p>真的是都太麻烦了</p><p>参考：https://www.zhihu.com/question/604029921</p><p>将Python文件封装成dll文件的方法有多种，其中常用的有以下三种：</p>',6),r=n("p",null,"使用Cython将Python文件转换为C文件，再使用C编译器生成dll文件",-1),u=n("p",null,"这种方法需要安装Cython并学习其使用方法。Cython是一个将Python代码转换为C语言代码的工具，可以将Python函数转换为C函数，并生成包含函数定义和函数调用的C文件。然后使用C编译器将C文件编译为dll文件。",-1),h={href:"https://link.zhihu.com/?target=https%3A//blog.csdn.net/zsh19980724/article/details/115518485",target:"_blank",rel:"noopener noreferrer"},v={href:"https://link.zhihu.com/?target=https%3A//blog.csdn.net/xueyuxueyuxueyu/article/details/118392113",target:"_blank",rel:"noopener noreferrer"},y=n("p",null,"使用CPython API编写C/C++代码，调用Python函数并生成dll文件",-1),k=n("p",null,"这种方法需要熟悉C/C++和Python语言，并学习CPython API的使用方法。CPython是Python的一种实现，它提供了一些C/C++的API，可以在C/C++代码中调用Python函数和对象。",-1),m={href:"https://link.zhihu.com/?target=https%3A//blog.csdn.net/zmr1994/article/details/90703017",target:"_blank",rel:"noopener noreferrer"},b={href:"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_25368751/article/details/129088459",target:"_blank",rel:"noopener noreferrer"},g=n("p",null,"使用Cython和setup.py文件将Python文件打包成dll文件",-1),_=n("p",null,"这种方法需要安装Cython和setuptools，并学习如何编写setup.py文件。setuptools是Python的一个包管理工具，可以用来打包Python代码。",-1),P={href:"https://link.zhihu.com/?target=https%3A//blog.csdn.net/ahhhhhh520/article/details/111066334",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.zhihu.com/question/604029921",target:"_blank",rel:"noopener noreferrer"},L=n("li",null,[n("p",null,"ctypes"),n("p",null,"使用Python的ctypes库可以将Python代码封装为DLL。您可以使用ctypes.CDLL或ctypes.WinDLL来加载DLL，并使用它们调用在Python中定义的函数。具体用法可以查阅Python官方文档。")],-1),x=n("li",null,[n("p",null,"py2exe"),n("p",null,"py2exe是一个用于将Python脚本打包成可执行文件的工具。它可以将Python代码打包为独立的可执行文件，包括DLL和其他依赖项。可以通过pip安装py2exe，然后按照文档中的指导进行使用。")],-1),C=n("li",null,[n("p",null,"PyInstaller"),n("p",null,"PyInstaller也是一个用于将Python脚本打包成可执行文件的工具，类似于py2exe。它可以将Python代码打包为独立的可执行文件，包含所有必需的依赖项。可以通过pip安装PyInstaller，然后按照文档中的指导进行使用。")],-1),w=t(`<h1 id="python-dll-build" tabindex="-1"><a class="header-anchor" href="#python-dll-build"><span>Python_Dll_Build</span></a></h1><p>参考：https://www.cnblogs.com/xueliangliu/p/9375664.html</p><p>但是很麻烦，要写.pyx，非常难受</p><h2 id="cython-原理" tabindex="-1"><a class="header-anchor" href="#cython-原理"><span>cython 原理</span></a></h2><p>（人家不叫cpython而叫cython！javac倒是比java加了一个c，不要弄混了）</p><p>动态链接库（.dll，.so）是系统开发中一种非常重要的跨语言协作方式。</p><p>把python语言写成的算法编译成动态库，能够提供给其他语言调用，这能够在很大程度上提高算法的开发效率。</p><p>或者在python中某些时候需要C做效率上的补充</p><p><strong>但是，虽然python可以调用其他语言生成的动态库，python作为一种脚本语言，本身是不能直接编译生成动态库的。为了生成动态库，我们借助cython，将python脚本变成c语言文件。</strong></p><h2 id="pyx-工程" tabindex="-1"><a class="header-anchor" href="#pyx-工程"><span>pyx 工程</span></a></h2><p>pythonDll.py</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">str_add</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">:</span>  
        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">int</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><s>pythonDll.pyx</s></p><div class="language-cython line-numbers-mode" data-ext="cython" data-title="cython"><pre class="language-cython"><code># 和前面python版本的相比，cdef替换了def，并加了public关键字，表示这个函数要导出。将这个代码保存成pyx文件，比如run.pyx
cdef public str_add(str1,str2):
	return int(str1) + int(str2)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>pythonDll.pyx</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># 和前面python版本的相比：</span>
<span class="token comment"># 1. cdef替换了def，并加了public关键字，表示这个函数要导出</span>
<span class="token comment"># 2. 加入了参数和返回值的类型，否则虽然依然可以生成c文件，但后面不能生成dll，报错：返回值类型与函数类型不匹配（显示的类型是“PyObject*”）</span>
<span class="token comment"># 3. 将这个代码保存成pyx文件，比如run.pyx</span>
cdef public char<span class="token operator">*</span> get_wish<span class="token punctuation">(</span>const char<span class="token operator">*</span> url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> genshin_wish<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> result <span class="token operator">==</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token string">&quot;获取失败&quot;</span>
    <span class="token keyword">return</span> result
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="pyx-编译" tabindex="-1"><a class="header-anchor" href="#pyx-编译"><span>pyx 编译</span></a></h2><p>将cython变为c语言版本（cython命令工具好像是python自带的，我不记得我有下载过）</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>cython pythonDll.pyx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成文件：</p><ul><li><p>cythonDll.h</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* Generated by Cython 0.29.15 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__PYX_HAVE__cythonDll</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__PYX_HAVE__cythonDll</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;Python.h&quot;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__PYX_HAVE_API__cythonDll</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__PYX_EXTERN_C</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__PYX_EXTERN_C</span> <span class="token expression"><span class="token keyword">extern</span> </span><span class="token string">&quot;C&quot;</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__PYX_EXTERN_C</span> <span class="token expression"><span class="token keyword">extern</span></span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">DL_IMPORT</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DL_IMPORT</span><span class="token expression"><span class="token punctuation">(</span>_T<span class="token punctuation">)</span> _T</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

__PYX_EXTERN_C PyObject <span class="token operator">*</span><span class="token function">str_add</span><span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">,</span> PyObject <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* !__PYX_HAVE_API__cythonDll */</span></span>

<span class="token comment">/* WARNING: the interface of the module init function changed in CPython 3.5. */</span>
<span class="token comment">/* It now returns a PyModuleDef instance instead of a PyModule instance. */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">PY_MAJOR_VERSION <span class="token operator">&lt;</span> <span class="token number">3</span></span></span>
PyMODINIT_FUNC <span class="token function">initcythonDll</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
PyMODINIT_FUNC <span class="token function">PyInit_cythonDll</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* !__PYX_HAVE__cythonDll */</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>cythonDll.c</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// 有2523行之多，我就不复制了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h2 id="查看-c-工程-开头跳过" tabindex="-1"><a class="header-anchor" href="#查看-c-工程-开头跳过"><span>查看 c 工程（开头跳过）</span></a></h2><p>dllmain.c（动态库主文件，include生成的头文件并导出_str_add方法）</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Python.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;cythonDll.h&quot;</span></span>
 
<span class="token keyword">extern</span> <span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">int</span> __stdcall <span class="token function">_str_add</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">PyLong_AsLong</span><span class="token punctuation">(</span><span class="token function">str_add</span><span class="token punctuation">(</span><span class="token function">PyUnicode_FromString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">PyUnicode_FromString</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>br<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
 
BOOL WINAPI <span class="token function">DllMain</span><span class="token punctuation">(</span>HINSTANCE hinstDLL<span class="token punctuation">,</span>DWORD fdwReason<span class="token punctuation">,</span>LPVOID lpReserved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span> fdwReason <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> DLL_PROCESS_ATTACH<span class="token operator">:</span>
            <span class="token function">Py_Initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">PyInit_run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  #dll初始化的时候调用，这是python3的写法，python2改成，<span class="token function">initrun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。参见生成的run<span class="token punctuation">.</span>h
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> DLL_PROCESS_DETACH<span class="token operator">:</span>
            <span class="token function">Py_Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="c-编译" tabindex="-1"><a class="header-anchor" href="#c-编译"><span>c 编译</span></a></h2><h3 id="cl编译方案" tabindex="-1"><a class="header-anchor" href="#cl编译方案"><span>cl编译方案</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># -I表示链接你的python的头文件和静态链接的lib文件</span>
cl /LD dllmain.c cythonDll.c -IC:<span class="token punctuation">\\</span>python36<span class="token punctuation">\\</span>include C:<span class="token punctuation">\\</span>python36<span class="token punctuation">\\</span>libs<span class="token punctuation">\\</span>python36.lib
<span class="token comment"># 或</span>
cl /LD mhy.c  -IC:D:<span class="token punctuation">\\</span>Soft<span class="token punctuation">\\</span>Dev<span class="token punctuation">\\</span>All<span class="token punctuation">\\</span>Python_Anaconda<span class="token punctuation">\\</span>include D:<span class="token punctuation">\\</span>Soft<span class="token punctuation">\\</span>Dev<span class="token punctuation">\\</span>All<span class="token punctuation">\\</span>Python_Anaconda<span class="token punctuation">\\</span>libs<span class="token punctuation">\\</span>python37.lib
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过他这里说找不到cl命令，应该是我没安装。</p><p>python的pip包里有cl，但pip install cl 好像是cl.py而不是cl.exe</p><p>反正和c语言的dll编译是一样的，用vs编译也行</p><h3 id="vs编译方案" tabindex="-1"><a class="header-anchor" href="#vs编译方案"><span>VS编译方案</span></a></h3>`,31),D={href:"https://blog.csdn.net/zmr1994/article/details/90703017",target:"_blank",rel:"noopener noreferrer"},A=t(`<p>在得到了.c和.h文件后，我们需要为其创建一个VS DLL工程。打开VS软件，新建win32项目，其中应用程序类型选择DLL，附加选项选择空项目。</p><h4 id="默认项目" tabindex="-1"><a class="header-anchor" href="#默认项目"><span>默认项目</span></a></h4><p>dllmain.cpp，这是定义 DLL 应用程序的入口点</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &quot;pch.h&quot;

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="修改项目" tabindex="-1"><a class="header-anchor" href="#修改项目"><span>修改项目</span></a></h4><p>将刚刚的.c和.h文件复制到项目存放代码的文件夹并添加到项目中。在项目中添加一个空的dllmain.cpp，并添加如下代码</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Python.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;run.h&quot;</span></span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span>
<span class="token punctuation">{</span>
  <span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">int</span> __stdcall <span class="token function">_str_add</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> b<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">str_add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

BOOL WINAPI <span class="token function">DllMain</span><span class="token punctuation">(</span>HINSTANCE hinstDLL<span class="token punctuation">,</span> DWORD fdwReason<span class="token punctuation">,</span> LPVOID lpReserved<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>fdwReason<span class="token punctuation">)</span> 
  <span class="token punctuation">{</span>
    <span class="token keyword">case</span> DLL_PROCESS_ATTACH<span class="token operator">:</span>
      <span class="token function">Py_Initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//dll初始化的时候调用，这是python3的写法，python2改成，initrun()。参见生成的run.h</span>
      <span class="token function">PyInit_run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> DLL_PROCESS_DETACH<span class="token operator">:</span>
      <span class="token function">Py_Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例2</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &quot;pch.h&quot;
#include &quot;mhy.h&quot; 									// ADD

extern &quot;C&quot;											// ADD
{
    __declspec(dllexport) char* __stdcall _getwish(const char* url)
    {
        return get_wish(url);
    }
}

// ！！！注意
// 32位下__stdcall会让_ctest()变成__ctest@0，64位不会
// VS默认是__cdcel方式，而易语言是__stdcall。但实测其实都可以，加不加E语言都能调用
extern &quot;C&quot; __declspec(dllexport) int ctest()
{
    return 5;
}

extern &quot;C&quot; __declspec(dllexport) int __stdcall ctest2()
{
    return 6;
}

                      									// 修改。否则调用DLL时会报错：无法找到指定DLL库文件中的输出命令
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) 
{
  switch (fdwReason) 
  {
    case DLL_PROCESS_ATTACH:
      Py_Initialize();
      // dll初始化的时候调用，这是python3的写法，python2改成，initrun()。参见生成的mhy.h
      // 名称的命名规则为PyInit_+你的C文件的名称，此处也要注意修改
      PyInit_mhy();
      break;
    case DLL_PROCESS_DETACH:
      Py_Finalize();
      break;
  }
  return TRUE;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="vs项目设置-添加包含目录和库目录" tabindex="-1"><a class="header-anchor" href="#vs项目设置-添加包含目录和库目录"><span>VS项目设置（添加包含目录和库目录）</span></a></h4><p>复制.c和.h代码进去后会报错：无法打开源文件Python.h，需要添加库目录</p><p>右键项目 &gt; 属性 &gt; VC++目录 &gt; 常规 &gt; 包含目录 &gt; 添加Python的include路径，如“C:\\ProgramFiles\\Python36\\include” 库目录 &gt; 添加Python的lib，如“C:\\Program Files\\Python36\\libs”</p><p>注意编译的版本选择Release，根据Python版本选择x64平台或x32平台。 编译后可以得到dll文件。</p><h4 id="python版本的问题" tabindex="-1"><a class="header-anchor" href="#python版本的问题"><span>Python版本的问题</span></a></h4><p>Python的x64、x32平台应与VS保持一致</p><p>终极方法是是使用VS的环境编译一次Python源码，该方法详见Python笔记中的 “编译Python源码” 一章</p><h1 id="其他python编译方法" tabindex="-1"><a class="header-anchor" href="#其他python编译方法"><span>其他Python编译方法</span></a></h1><p>关键词：pyo、pyd、pyc</p>`,18),E={href:"https://blog.csdn.net/weixin_44493841/article/details/102747144",target:"_blank",rel:"noopener noreferrer"},q=t(`<h2 id="pyc、pyo、pyd" tabindex="-1"><a class="header-anchor" href="#pyc、pyo、pyd"><span>pyc、pyo、pyd</span></a></h2><ul><li><p>.pyinb</p><p>略</p></li><li><p>.py</p><p>略</p></li><li><p>.pyc</p><p>一种二进制文件，是由py文件经过编译后，生成的文件，是一种byte code。 pyc能提高模块的<strong>加载速度</strong>提高了，<strong>并没有提高代码的执行速度</strong>，一定意义上的<strong>保护源码</strong>不被泄露，通常情况下不用主动去编译pyc文件 而且pyc是一种<strong>跨平台的字节码</strong>，是由<strong>python的虚拟机</strong>来执行的，这个是<strong>类似于JAVA或者.NET的虚拟机</strong>的概念。 pyc的内容，是<strong>跟python的版本相关</strong>的，不同版本编译后的pyc文件是不同的，2.5编译的pyc文件，2.4版本的 python是无法执行的。</p></li><li><p>.pyo</p><p>pyo是优化编译后的程序 python -O 源文件即可将源程序编译为pyo文件</p></li><li><p>.pyd</p><p>pyo是python的动态链接库</p><ul><li><p>为什么需要pyc文件</p><p>这个需求太明显了，因为py文件是可以直接看到源码的，如果你是开发商业软件的话，不可能把源码也泄漏出去吧？所以就需要编译为pyc后，再发布出去。 当然，pyc文件也是可以反编译的，不同版本编译后的pyc文件是不同的，根据python源码中提供的opcode，可以根据pyc文件反编译出 py文件源码，网上可以找到一个反编译python2.3版本的pyc文件的工具，不过该工具从python2.4开始就要收费了，如果需要反编译出新版本的pyc文件的话，就需要自己动手了，不过你可以自己修改python的源代码中的opcode文件，重新编译 python，从而防止不法分子的破解。</p></li></ul></li><li><p>.pyz(w)</p><p>从Python 3.5开始，定义了.pyz和.pyzw分别作为“Python Zip应用”和“Windows下Python Zip应用”的扩展名。</p><p>新增了内置zipapp模块来进行简单的管理，可以用Zip打包Python程序到一个可执行.pyz文件。</p><p>使用也比较简单，但无法想pyinstaller等打包exe工具一样脱离python环境单独运行，而且这类文件往往拿文本编辑器就能看到它的源码信息，总体来说还是比较鸡肋。</p></li><li><p>.exe</p><p>为什么会再单独提到exe文件，因为python有很多可以将python源码打包成exe的工具，从而脱离python环境单独运行</p></li><li><p>.dll</p><p>见DLL笔记</p></li></ul><h2 id="把代码编译成pyc文件" tabindex="-1"><a class="header-anchor" href="#把代码编译成pyc文件"><span>把代码编译成pyc文件</span></a></h2><h3 id="python方式" tabindex="-1"><a class="header-anchor" href="#python方式"><span>python方式</span></a></h3><p>使用模块</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> py_compile
py_compile<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r&#39;文件路径&#39;</span><span class="token punctuation">)</span>
<span class="token comment"># 或 </span>
py_compile<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r&#39;demo.py&#39;</span><span class="token punctuation">,</span> <span class="token string">r&#39;demo.pyc&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="命令行方式" tabindex="-1"><a class="header-anchor" href="#命令行方式"><span>命令行方式</span></a></h3><p>或者直接在terminal中运行，也生成demo.pyc文件</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code> python <span class="token operator">-</span>m py_compile 文件路径
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="模块使用-不能运行" tabindex="-1"><a class="header-anchor" href="#模块使用-不能运行"><span>模块使用 (不能运行)</span></a></h2><p>编译完成后如果想要直接运行Pyc文件注意两点：</p><ol><li>要把pyc文件从 <strong>pycache</strong> 目录中移动出来，放到py文件对应的位置</li><li>需要将<strong>model.cpython-36.pyc</strong>重命名为<strong>model.pyc</strong></li></ol><p>然后可能会遇到环境问题：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>web<span class="token punctuation">)</span> H:<span class="token punctuation">\\</span><span class="token punctuation">..</span>.<span class="token operator">&gt;</span>app.pyc
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:
  File <span class="token string">&quot;H:\\...<span class="token entity" title="\\a">\\a</span>pp.py&quot;</span>, line <span class="token number">1</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
    from flask <span class="token function">import</span> Flask, request
ModuleNotFoundError: No module named <span class="token string">&#39;flask&#39;</span>

<span class="token punctuation">(</span>web<span class="token punctuation">)</span> H:<span class="token punctuation">\\</span><span class="token punctuation">..</span>.<span class="token operator">&gt;</span>python app.pyc

<span class="token punctuation">(</span>web<span class="token punctuation">)</span> H:<span class="token punctuation">\\</span><span class="token punctuation">..</span>.<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意项：只能import pyc文件。不能用python3.6运行pyc文件</p><h2 id="python源码编译-so文件" tabindex="-1"><a class="header-anchor" href="#python源码编译-so文件"><span>python源码编译.so文件</span></a></h2><p>Python源码编译至.so文件的思路是先将py转换为c代码，然后编译c为so文件。</p><p>所需编译环境：</p><ul><li><p>python安装：cython</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>pip <span class="token function">install</span> cython
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>linux 安装：python-devel,gcc</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>yum <span class="token function">install</span> python-devel
yum <span class="token function">install</span> gcc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>同样举上述例子：在demo文件夹下有一个demo.py，需要将demo.py编译.so。</p><p>demo.py内容如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">print_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在demo文件夹下新建setup.py,内容如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>from distutils.core <span class="token function">import</span> setup
from Cython.Build <span class="token function">import</span> cythonize

setup<span class="token punctuation">(</span>ext_modules <span class="token operator">=</span> cythonize<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;demo.py&quot;</span><span class="token punctuation">]</span><span class="token punctuation">))</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在shell执行：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> demo
python setup.py build_ext
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在demo文件夹下，就会生成demo.c文件，同时在demo文件夹下生成build文件夹，在build文件夹下包含生成的.so文件。</p><h2 id="自定义python模块打包发布" tabindex="-1"><a class="header-anchor" href="#自定义python模块打包发布"><span>自定义python模块打包发布</span></a></h2><p>将自定义python模块打包发布有两种，一种是将python源码打包发布，一种是将python源码转换至动态链接库.so文件打包发布。下面介绍一下这两种打包方式。</p><p><strong>A)、使用python源码打包</strong></p><p>同样使用上述例子：在demo文件夹下有一个demo.py，需要将demo.py打包。</p><p>在demo文件夹下新建setup.py,内容如下：</p><p>from distutils.core import setup</p><p>setup(name = ‘demo’,</p><p>version = &#39;1.0&#39;,</p><p>py_modules = [&#39;demo&#39;],</p><p>)</p><p>在shell执行：</p><p>cd demo</p><p>python setup.py bdist_wheel</p><p>在demo文件夹下，生成dist文件夹，dist文件夹中包含了生成的python模块。</p><p><strong>B)、使用python源码编译成.so打包</strong></p><p>使用上述例子：在demo文件夹下有一个demo.py，需要将demo.py打包。</p><p>首先将python源码转换为c代码：</p><p>在demo文件夹下新建generateC.py，内容如下：</p><p>​ from distutils.core import setup</p><p>from Cython.Build import cythonize</p><p>setup(ext_modules = cythonize([&quot;demo.py&quot;]))</p><p>然后将c代码编译打包，过程如下：</p><p>在demo文件夹下新建generateWHL.py，内容如下：</p><p>​ from setuptools import setup</p><p>from setuptools.dist import Distribution</p><p>from distutils.core import Extension</p><p>setup(name = &#39;demo&#39;,</p><p>​ version = &#39;1.0&#39;,</p><p>​ ext_modules = [Extension(&quot;demo&quot;,[&#39;demo.c&#39;])],</p><p>)</p><p>将上述两个文件执行，如下：在demo文件夹下新建setup.py,内容如下：</p><p>import os</p><p>cmd1 = &quot;python generateC.py build_ext&quot;</p><p>os.system(cmd1)</p><p>cmd2 = &quot;python generateWHL.py bdist_wheel&quot;</p><p>os.system(cmd2)</p><p>在shell执行：</p><p>cd demo</p><p>python setup.py</p><p>在demo文件夹下，生成dist文件夹，dist文件夹中包含了生成的python模块。</p><p><strong>C)、安装卸载</strong></p><p>可以使用pip直接安装和卸载生成的python模块。</p><h2 id="_4、其他" tabindex="-1"><a class="header-anchor" href="#_4、其他"><span><strong>4、其他</strong></span></a></h2><p>本文主要是针对python源码编译打包做了简单介绍，使用了最简单的例子。对于复杂的情况，比如打包时需要额外的数据文件，依赖包等等，需要具体查看setuptools模块的相关内容。</p><h1 id="三" tabindex="-1"><a class="header-anchor" href="#三"><span>三</span></a></h1><p>参考：https://www.zhihu.com/question/604029921，/answer/3053431742</p><p>将Python程序打包成DLL可以使用Cython或pybind11等工具。</p><p>以下是使用Cython打包Python程序的步骤：</p><p>创建一个Python文件，并在其中定义需要打包的函数</p><p>例如，我们定义一个名为“hello”的函数：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个Cython文件，并声明Python函数的C接口创建一个名为“hello.pyx”的Cython文件，并在其中声明“hello”函数的C接口：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>cdef public void hello<span class="token punctuation">(</span>char <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个setup.py文件，用于打包Cython文件并生成DLL</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">from</span> distutils<span class="token punctuation">.</span>core <span class="token keyword">import</span> setup
<span class="token keyword">from</span> Cython<span class="token punctuation">.</span>Build <span class="token keyword">import</span> cythonize

setup<span class="token punctuation">(</span>ext_modules<span class="token operator">=</span>cythonize<span class="token punctuation">(</span><span class="token string">&#39;hello.pyx&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行setup.py文件并生成DLL</p><p>使用以下命令执行setup.py文件，并生成用于Python程序的DLL文件：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>python setup<span class="token punctuation">.</span>py build_ext <span class="token operator">-</span><span class="token operator">-</span>inplace
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成的DLL文件会保存在和Cython文件相同的目录下。</p><p>现在你可以在其他Python程序中导入刚刚生成的DLL文件，并调用其中定义的函数。</p>`,87);function I(T,z){const a=l("ExternalLinkIcon");return i(),o("div",null,[d,n("ol",null,[n("li",null,[r,u,n("p",null,[s("具体步骤可以参考 "),n("a",h,[s("blog.csdn.net "),e(a)]),s("和 "),n("a",v,[s("blog.csdn.net"),e(a)])])]),n("li",null,[y,k,n("p",null,[s("具体步骤可以参考 "),n("a",m,[s("blog.csdn.net "),e(a)]),s("和 "),n("a",b,[s("blog.csdn.net"),e(a)])])]),n("li",null,[g,_,n("p",null,[s("具体步骤可以参考 "),n("a",P,[s("blog.csdn.net "),e(a)]),s("和 "),n("a",f,[s("zhihu.com"),e(a)])])]),L,x,C]),w,n("p",null,[s("参考："),n("a",D,[s("【CSDN】手把手教你将Python程序打包为DLL"),e(a)])]),A,n("p",null,[s("参考："),n("a",E,[s("python的代码编译、代码打包方法"),e(a)])]),q])}const O=p(c,[["render",I],["__file","Python_Dll_Build.html.vue"]]),S=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Type/DLL/DLL%20Compiled%20By%20All%20Language/Python_Dll_Build.html","title":"DLL Compiled By All Language","lang":"zh-CN","frontmatter":{"description":"DLL Compiled By All Language 目录 三种方法 真的是都太麻烦了 参考：https://www.zhihu.com/question/604029921 将Python文件封装成dll文件的方法有多种，其中常用的有以下三种： 使用Cython将Python文件转换为C文件，再使用C编译器生成dll文件 这种方法需要安装Cyth...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Type/DLL/DLL%20Compiled%20By%20All%20Language/Python_Dll_Build.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"DLL Compiled By All Language"}],["meta",{"property":"og:description","content":"DLL Compiled By All Language 目录 三种方法 真的是都太麻烦了 参考：https://www.zhihu.com/question/604029921 将Python文件封装成dll文件的方法有多种，其中常用的有以下三种： 使用Cython将Python文件转换为C文件，再使用C编译器生成dll文件 这种方法需要安装Cyth..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"DLL Compiled By All Language\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"DLL Compiled By All Language","slug":"dll-compiled-by-all-language","link":"#dll-compiled-by-all-language","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"三种方法","slug":"三种方法","link":"#三种方法","children":[]},{"level":1,"title":"Python_Dll_Build","slug":"python-dll-build","link":"#python-dll-build","children":[{"level":2,"title":"cython 原理","slug":"cython-原理","link":"#cython-原理","children":[]},{"level":2,"title":"pyx 工程","slug":"pyx-工程","link":"#pyx-工程","children":[]},{"level":2,"title":"pyx 编译","slug":"pyx-编译","link":"#pyx-编译","children":[]},{"level":2,"title":"查看 c 工程（开头跳过）","slug":"查看-c-工程-开头跳过","link":"#查看-c-工程-开头跳过","children":[]},{"level":2,"title":"c 编译","slug":"c-编译","link":"#c-编译","children":[{"level":3,"title":"cl编译方案","slug":"cl编译方案","link":"#cl编译方案","children":[]},{"level":3,"title":"VS编译方案","slug":"vs编译方案","link":"#vs编译方案","children":[{"level":4,"title":"默认项目","slug":"默认项目","link":"#默认项目","children":[]},{"level":4,"title":"修改项目","slug":"修改项目","link":"#修改项目","children":[]},{"level":4,"title":"VS项目设置（添加包含目录和库目录）","slug":"vs项目设置-添加包含目录和库目录","link":"#vs项目设置-添加包含目录和库目录","children":[]},{"level":4,"title":"Python版本的问题","slug":"python版本的问题","link":"#python版本的问题","children":[]}]}]}]},{"level":1,"title":"其他Python编译方法","slug":"其他python编译方法","link":"#其他python编译方法","children":[{"level":2,"title":"pyc、pyo、pyd","slug":"pyc、pyo、pyd","link":"#pyc、pyo、pyd","children":[]},{"level":2,"title":"把代码编译成pyc文件","slug":"把代码编译成pyc文件","link":"#把代码编译成pyc文件","children":[{"level":3,"title":"python方式","slug":"python方式","link":"#python方式","children":[]},{"level":3,"title":"命令行方式","slug":"命令行方式","link":"#命令行方式","children":[]}]},{"level":2,"title":"模块使用 (不能运行)","slug":"模块使用-不能运行","link":"#模块使用-不能运行","children":[]},{"level":2,"title":"python源码编译.so文件","slug":"python源码编译-so文件","link":"#python源码编译-so文件","children":[]},{"level":2,"title":"自定义python模块打包发布","slug":"自定义python模块打包发布","link":"#自定义python模块打包发布","children":[]},{"level":2,"title":"4、其他","slug":"_4、其他","link":"#_4、其他","children":[]}]},{"level":1,"title":"三","slug":"三","link":"#三","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":12.18,"words":3654},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/04. Project/Type/DLL/DLL Compiled By All Language/Python_Dll_Build.md","excerpt":"\\n<h1>目录</h1>\\n<h1>三种方法</h1>\\n<p>真的是都太麻烦了</p>\\n<p>参考：https://www.zhihu.com/question/604029921</p>\\n<p>将Python文件封装成dll文件的方法有多种，其中常用的有以下三种：</p>\\n<ol>\\n<li>\\n<p>使用Cython将Python文件转换为C文件，再使用C编译器生成dll文件</p>\\n<p>这种方法需要安装Cython并学习其使用方法。Cython是一个将Python代码转换为C语言代码的工具，可以将Python函数转换为C函数，并生成包含函数定义和函数调用的C文件。然后使用C编译器将C文件编译为dll文件。</p>\\n<p>具体步骤可以参考 <a href=\\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/zsh19980724/article/details/115518485\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">blog.csdn.net </a>和 <a href=\\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/xueyuxueyuxueyu/article/details/118392113\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">blog.csdn.net</a></p>\\n</li>\\n<li>\\n<p>使用CPython API编写C/C++代码，调用Python函数并生成dll文件</p>\\n<p>这种方法需要熟悉C/C++和Python语言，并学习CPython API的使用方法。CPython是Python的一种实现，它提供了一些C/C++的API，可以在C/C++代码中调用Python函数和对象。</p>\\n<p>具体步骤可以参考 <a href=\\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/zmr1994/article/details/90703017\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">blog.csdn.net </a>和 <a href=\\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_25368751/article/details/129088459\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">blog.csdn.net</a></p>\\n</li>\\n<li>\\n<p>使用Cython和setup.py文件将Python文件打包成dll文件</p>\\n<p>这种方法需要安装Cython和setuptools，并学习如何编写setup.py文件。setuptools是Python的一个包管理工具，可以用来打包Python代码。</p>\\n<p>具体步骤可以参考 <a href=\\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/ahhhhhh520/article/details/111066334\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">blog.csdn.net </a>和 <a href=\\"https://www.zhihu.com/question/604029921\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">zhihu.com</a></p>\\n</li>\\n<li>\\n<p>ctypes</p>\\n<p>使用Python的ctypes库可以将Python代码封装为DLL。您可以使用ctypes.CDLL或ctypes.WinDLL来加载DLL，并使用它们调用在Python中定义的函数。具体用法可以查阅Python官方文档。</p>\\n</li>\\n<li>\\n<p>py2exe</p>\\n<p>py2exe是一个用于将Python脚本打包成可执行文件的工具。它可以将Python代码打包为独立的可执行文件，包括DLL和其他依赖项。可以通过pip安装py2exe，然后按照文档中的指导进行使用。</p>\\n</li>\\n<li>\\n<p>PyInstaller</p>\\n<p>PyInstaller也是一个用于将Python脚本打包成可执行文件的工具，类似于py2exe。它可以将Python代码打包为独立的可执行文件，包含所有必需的依赖项。可以通过pip安装PyInstaller，然后按照文档中的指导进行使用。</p>\\n</li>\\n</ol>","autoDesc":true}');export{O as comp,S as data};
