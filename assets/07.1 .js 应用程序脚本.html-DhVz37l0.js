import{_ as c,c as d,b as t,d as n,e as l,a as i,o as p,r as s}from"./app-DyeLIyox.js";const o={},u={href:"https://blog.csdn.net/graceland525/article/details/64906354/",target:"_blank",rel:"noopener noreferrer"};function v(m,e){const r=s("ExternalLinkIcon"),a=s("Mermaid");return p(),d("div",null,[e[3]||(e[3]=t('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="js-应用程序脚本" tabindex="-1"><a class="header-anchor" href="#js-应用程序脚本"><span>.js 应用程序脚本</span></a></h1><p>参考</p>',4)),n("ul",null,[e[2]||(e[2]=n("li",null,"《C++ GUI Qt 4 编程》（第二版）P387",-1)),n("li",null,[n("a",u,[e[0]||(e[0]=l("【CSDN】Qt调用JS脚本")),i(r)]),e[1]||(e[1]=l("，提供完整的简易代码"))])]),e[4]||(e[4]=t(`<h2 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h2><h3 id="py与-js区别" tabindex="-1"><a class="header-anchor" href="#py与-js区别"><span>.py与.js区别</span></a></h3><p>.js用作脚本的话和.py脚本类型，有略微不同</p><ul><li>Qt工程上的区别： <ul><li>.py：<mark>可以直接创建，不用加入到.qrc资源文件当中</mark>，会归类到 “Other files” 当中</li><li>.js：<mark>无法直接创建，但可以添加进.qrc资源文件中</mark></li></ul></li><li>语言自身性质区别：python可以创建类，面向对象编程</li><li>Qt支持上的区别：python有<code>PySide2 / PyQt5</code>模块的支持，这能让Python像C++一样使用Qt框架</li></ul><h3 id="ecmascript语言概述" tabindex="-1"><a class="header-anchor" href="#ecmascript语言概述"><span>ECMAScript语言概述</span></a></h3><p>略，详见JavaScript笔记</p><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>Qt4.3开始包含QtScript，这是一个可以使用ECMAScript的模块</p><h2 id="使用脚本扩展qt应用程序" tabindex="-1"><a class="header-anchor" href="#使用脚本扩展qt应用程序"><span>使用脚本扩展Qt应用程序</span></a></h2><h3 id="实战-书例-没法用" tabindex="-1"><a class="header-anchor" href="#实战-书例-没法用"><span><s>实战 - 书例</s>（没法用）</span></a></h3><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void Calculaotr::createCustomButtons()
{
    QDir scriptsDir = directoryOf(&quot;scripts&quot;);										// 访问应用程序的脚本子目录
    QStringList fileNames = scriptsDir.entryList(QStringList(&quot;*.js&quot;),QDir::Files);	// 找.js扩展名的文件
    foreach (QString fileName, fileNames){											// 循环脚本文件
        QString text = fileName;
        // ...
        button-&gt;setProperty(&quot;scriptFileName&quot;, scriptsDir.absoluteFilePath(fileName));// 设置属性使用脚本（绝对路径）
        // ...
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>书例的吐槽：很多地方和实际生成的空demo不同</p><p>比如书上的js文件可以直接在函数外return，而我在项目中在函数外return会报错</p><p>比如这里的<code>directoryOf()</code>函数会报错，根本没法用</p><h3 id="实战" tabindex="-1"><a class="header-anchor" href="#实战"><span>实战</span></a></h3><h4 id="_1-准备脚本文件" tabindex="-1"><a class="header-anchor" href="#_1-准备脚本文件"><span>(1) 准备脚本文件</span></a></h4><p>trans.js</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">var1<span class="token punctuation">,</span>var2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> var1<span class="token operator">+</span>var2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token parameter">var1<span class="token punctuation">,</span>var2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> var1<span class="token operator">-</span>var2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>准备脚本文件并添加进工程的.qrc资源文件</p><p>注意：添加进去.qrc后.pro会自动添加一行<code>DISTFILES +=</code>，等号后面没内容 不知道干嘛用的，可以填js文件的名字，但不填也行，也能正常运行</p><h4 id="_2-使用脚本文件" tabindex="-1"><a class="header-anchor" href="#_2-使用脚本文件"><span>(2) 使用脚本文件</span></a></h4><p>.pro</p><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">QT</span> <span class="token value attr-value">      += script</span>
<span class="token comment"># 需要手动添加：script模块，以使用后面的\`&lt;QScriptEngine&gt; &lt;QScriptValue&gt; &lt;QScriptValueList&gt;\`</span>

<span class="token key attr-name">RESOURCES</span> <span class="token value attr-value">+= \\dojs.qrc</span>
<span class="token comment"># 这个是添加qrc文件时自动生成的</span>

<span class="token key attr-name">DISTFILES</span> <span class="token value attr-value">+= \\TransCal.js</span>
<span class="token comment"># 这个是添加js文件进qrc文件时自动生成的</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>.cpp</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;QDebug&gt;
#include &lt;QFile&gt;                    // 文件（打开脚本用）
#include &lt;QTextStream&gt;              // 文件文本流
#include &lt;QScriptEngine&gt;            // 脚本引擎，   (依赖QtScript模块)用来加载和运行脚本
#include &lt;QScriptValue&gt;             // 脚本变量，   (依赖QtScript模块)用来存放脚本引擎的结果，可以得出脚本返回值
#include &lt;QScriptValueList&gt;         // 脚本变量列表，(依赖QtScript模块)用来存放传给脚本的参数
 
// ...

/** 加载脚本*/
void MainWindow::loadJS()
{
    /*读取脚本*/
    QFile scriptFile(&quot;:/Assets/trans.js&quot;);                  // 读取qrc资源里的js文件
    if (!scriptFile.open(QIODevice::ReadOnly))              // 【只读打开】
    {
        qWarning() &lt;&lt; &quot;encodePass.js open failed&quot;;
        return;
    }
    QTextStream out(&amp;scriptFile);                           // 文本流
    QString contents = out.readAll();                       // 读到contents中
    scriptFile.close();                                     // 【关闭文件】
	
    /*使用脚本*/
    QString result = &quot;&quot;;                                    // 存储脚本运算的返回值
    QScriptValueList args;      							// 调用js方法时传入的参数
    args &lt;&lt; 12 &lt;&lt; 0.5;
    QScriptEngine engine;                                   // 个人理解：加载js文本到操作引擎（返回QScriptValue对象）
    engine.evaluate(contents);

    QScriptValue func;
    func = engine.globalObject().property(&quot;add&quot;);           // 指定函数
    result = func.call(QScriptValue(), args).toString();	// 指定参数并调用
    qDebug() &lt;&lt; &quot;result1:&quot; &lt;&lt; result;                       // 12.5

    func = engine.globalObject().property(&quot;sub&quot;);           // 指定函数
    result = func.call(QScriptValue(), args).toString();	// 指定参数并调用
    qDebug() &lt;&lt; &quot;result2:&quot; &lt;&lt; result;                       // 11.5
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="流程总结-与-机制剖析" tabindex="-1"><a class="header-anchor" href="#流程总结-与-机制剖析"><span>流程总结 与 机制剖析</span></a></h3><blockquote><h4 id="流程与数据流" tabindex="-1"><a class="header-anchor" href="#流程与数据流"><span>流程与数据流</span></a></h4></blockquote><p>从资源到创建脚本引擎</p>`,28)),i(a,{id:"mermaid-128",code:"eJxLL0osyFDwCeIKdMvMSY1/0TLr2Zw1z6a1P9m9TUFX99m8lpcNC5627302dYOurp1CYEhqRUlwSVFqYi5U6fNZLUDVID1bG4EagDIpjjk5YLVAdZl56Qh1T9dOf75m2ZMdm7h0dVPLEnNKE0tSgQoDg5OLMgtKXPPSM/NgDni6Z+qzyX1cAC42TrU="}),e[5]||(e[5]=n("p",null,"从脚本引擎到运算结果",-1)),i(a,{id:"mermaid-132",code:"eJx1kEFLAkEUx+/zKYa9pOQs7ixePQTdghCjyyKyu27bxrK7jGMQEYQZHsoMzIuIUCcPUnoM8+PM7n6MZnaUyOwy8N77/+a9/98lZnQOTw5ApWoTL6KHgesFTj3tjOLxjH0N48ETRMj1Q8v0j60Lx6YIleGlphlr4NT0W05dKpNRh91P2eKWfXymi9caQCgiYeQQeiUp/JuKH7vsfcS6q3g4F2Lb9P10fpe8TGVPQvrWqmyULAfxZCwgGjYp8QI3WSzZ5CFdzeLemwAr1awN+NZibl2sYfbcyyMVbm5j/baKylzHtbrQ/mw78pp0A/Xb/BWcOFMy4joApNtdMWHNUIwwq6Ec1pQ/qWBsKGetwKZeGECz0ciZBWjl4TVxaIvwzr51k0E708G6oWhYLWWK/6IQAsD3FHN7/P+9Hd4x9465d8XQcAEW1VJN2XaKdfAN+hfmiw=="}),e[6]||(e[6]=t(`<h4 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h4><p>数据类型</p><ul><li>QScriptEngine类：提供了一个评估Qt脚本代码的环境，其大多数方法都是返回QScriptValue的</li><li>QScriptValue类：充当Qt脚本数据类型的容器</li><li>QScriptValueList类：（没有找到文档）</li></ul><p>这里特别注意一下<code>QScriptValue类</code>，QScriptValue类的数据流如下</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>engine.globalObject()
// .toString()		&quot;[object global]&quot;
    
engine.globalObject().property(&quot;add&quot;)
// .toString()		&quot;function add(var1, var2) {\\r\\n    return var1+var2;\\r\\n}&quot;
    
engine.globalObject().property(&quot;add&quot;).call(QScriptValue(), args)
// .toString()		&quot;12.5&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意点</p><p>这里有个地方很奇怪，就是这里有三个量都是QScriptValue类型，但toString的结果却不一样</p><p>只能将这里当成函数的重载来理解了，<strong>可以理解为是这三处QScriptValue是处于不同的状态当中的同一类型（我猜的）</strong></p><p>三个QScriptValue都是引擎的全局对象，第一个是整个脚本，第二个指定了函数名，第三个再指定了该函数的参数并进行了调用了</p><blockquote><h4 id="函数作用" tabindex="-1"><a class="header-anchor" href="#函数作用"><span>函数作用</span></a></h4></blockquote><p>函数作用</p><ul><li><p><code>globalObject()</code></p><blockquote><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QScriptValue QScriptEngine::globalObject() const
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>返回此引擎的全局对象</p><p>默认情况下，全局对象包含ECMA-262中的内置对象，例如Math、Date和String 此外，您可以设置全局对象的属性，使您自己的扩展对所有脚本代码都可用 脚本代码中的非局部变量将被创建为全局对象的属性，以及全局代码中的局部变量</p></blockquote></li><li><p><code>property()</code></p><blockquote><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QScriptValue QScriptValue::property(const QString &amp;name, const QScriptValue::ResolveFlags &amp;mode = ResolvePrototype) const
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用给定的名称返回该QScriptValue属性的值，使用给定的模式来解析该属性</p><p>重载：如果不存在这样的属性，则返回一个无效的QScriptValue</p><p>重载：如果属性是使用getter函数实现的(即设置了PropertyGetter标志)，调用property()会对脚本引擎产生副作用，因为getter函数将被调用(可能导致未捕获的脚本异常)</p><p>异常：如果发生异常，property()将返回抛出的值(通常是一个Error对象)</p></blockquote></li><li><p><code>call()</code></p><blockquote><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QScriptValue QScriptValue::call(const QScriptValue &amp;thisObject = QScriptValue(), const QScriptValueList &amp;args = QScriptValueList())
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将这个QScriptValue作为函数调用，在函数调用中使用thisObject作为&#39; this&#39;对象，并将args作为参数传递给函数，返回函数返回的值</p><p>重载：<strong>如果这个QScriptValue不是一个函数</strong>，那么call()不做任何事情并返回一个无效的QScriptValue</p><p>重载：如果thisObject不是一个对象，全局对象(参见QScriptEngine::globalObject())将被用作&#39; this&#39;对象</p><p>异常：调用call()会导致脚本引擎中出现异常;在这种情况下，call()返回抛出的值(通常是一个错误对象)。您可以调用QScriptEngine::hasUncaughtException()来确定是否发生了异常</p></blockquote></li></ul><h2 id="使用本实现gui扩展" tabindex="-1"><a class="header-anchor" href="#使用本实现gui扩展"><span>使用本实现GUI扩展</span></a></h2><p>作用：</p><p>结合ECMAScript代码和Qt设计师创建的窗体开发GUI前端</p><p>这一方法对那些不喜欢C++开发中的 “编译、连接、运行” 周期循环，而更喜欢脚本方法的开发者很有吸引力</p><p>它可以使那些有JavaScript经验的用户不用学习C++就能够设计功能齐全的用户界面</p><p>我们可以在脚本中直接访问应用程序的窗口部件以及其他组件</p><h3 id="实战-1" tabindex="-1"><a class="header-anchor" href="#实战-1"><span>实战</span></a></h3><p>实战项目：两个扩展，Statistics对话框和ReformatText对话框</p><ul><li>Statistics：统计文档中的字符、单词和行的数量</li><li>ReformatText：非模态对话框</li></ul><p><code>createScriptAction()</code>，根据脚本创建动作</p><p>000000000000000000000000000000000000</p><h2 id="使用脚本自动化处理任务" tabindex="-1"><a class="header-anchor" href="#使用脚本自动化处理任务"><span>使用脚本自动化处理任务</span></a></h2><p>如何开发依赖C++组件的脚本</p>`,25))])}const h=c(o,[["render",v],["__file","07.1 .js 应用程序脚本.html.vue"]]),g=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/04.%20%E8%BE%85%E5%8A%A9%E6%96%87%E4%BB%B6/%E5%88%9B%E5%BB%BA%E6%80%A7%E8%BE%85%E5%8A%A9%E6%96%87%E4%BB%B6/07.1%20.js%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%84%9A%E6%9C%AC.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 .js 应用程序脚本 参考 《C++ GUI Qt 4 编程》（第二版）P387 【CSDN】Qt调用JS脚本，提供完整的简易代码 简概 .py与.js区别 .js用作脚本的话和.py脚本类型，有略微不同 Qt工程上的区别： .py：可以直接创建，不用加入到.qrc资源文件当中，会归类到 “Other files” 当中 .js：无法直接创...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/04.%20%E8%BE%85%E5%8A%A9%E6%96%87%E4%BB%B6/%E5%88%9B%E5%BB%BA%E6%80%A7%E8%BE%85%E5%8A%A9%E6%96%87%E4%BB%B6/07.1%20.js%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%84%9A%E6%9C%AC.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 .js 应用程序脚本 参考 《C++ GUI Qt 4 编程》（第二版）P387 【CSDN】Qt调用JS脚本，提供完整的简易代码 简概 .py与.js区别 .js用作脚本的话和.py脚本类型，有略微不同 Qt工程上的区别： .py：可以直接创建，不用加入到.qrc资源文件当中，会归类到 “Other files” 当中 .js：无法直接创..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":".js 应用程序脚本","slug":"js-应用程序脚本","link":"#js-应用程序脚本","children":[{"level":2,"title":"简概","slug":"简概","link":"#简概","children":[{"level":3,"title":".py与.js区别","slug":"py与-js区别","link":"#py与-js区别","children":[]},{"level":3,"title":"ECMAScript语言概述","slug":"ecmascript语言概述","link":"#ecmascript语言概述","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]}]},{"level":2,"title":"使用脚本扩展Qt应用程序","slug":"使用脚本扩展qt应用程序","link":"#使用脚本扩展qt应用程序","children":[{"level":3,"title":"实战 - 书例（没法用）","slug":"实战-书例-没法用","link":"#实战-书例-没法用","children":[]},{"level":3,"title":"实战","slug":"实战","link":"#实战","children":[{"level":4,"title":"(1) 准备脚本文件","slug":"_1-准备脚本文件","link":"#_1-准备脚本文件","children":[]},{"level":4,"title":"(2) 使用脚本文件","slug":"_2-使用脚本文件","link":"#_2-使用脚本文件","children":[]}]},{"level":3,"title":"流程总结 与 机制剖析","slug":"流程总结-与-机制剖析","link":"#流程总结-与-机制剖析","children":[{"level":4,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]}]}]},{"level":2,"title":"使用本实现GUI扩展","slug":"使用本实现gui扩展","link":"#使用本实现gui扩展","children":[{"level":3,"title":"实战","slug":"实战-1","link":"#实战-1","children":[]}]},{"level":2,"title":"使用脚本自动化处理任务","slug":"使用脚本自动化处理任务","link":"#使用脚本自动化处理任务","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.13,"words":1840},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/04. 辅助文件/创建性辅助文件/07.1 .js 应用程序脚本.md","excerpt":"\\n<h1>目录</h1>\\n<h1>.js 应用程序脚本</h1>\\n<p>参考</p>\\n<ul>\\n<li>《C++ GUI Qt 4 编程》（第二版）P387</li>\\n<li><a href=\\"https://blog.csdn.net/graceland525/article/details/64906354/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【CSDN】Qt调用JS脚本</a>，提供完整的简易代码</li>\\n</ul>\\n<h2>简概</h2>\\n<h3>.py与.js区别</h3>\\n<p>.js用作脚本的话和.py脚本类型，有略微不同</p>","autoDesc":true}');export{h as comp,g as data};
