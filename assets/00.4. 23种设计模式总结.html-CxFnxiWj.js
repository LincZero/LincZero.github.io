import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as l,a as i}from"./app-CctSPqZW.js";const r={},a=i('<h1 id="《c-设计模式》视频-李建忠" tabindex="-1"><a class="header-anchor" href="#《c-设计模式》视频-李建忠"><span>《C++设计模式》视频_李建忠</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="_23种设计模式总结" tabindex="-1"><a class="header-anchor" href="#_23种设计模式总结"><span>23种设计模式总结</span></a></h1><h2 id="分类总结" tabindex="-1"><a class="header-anchor" href="#分类总结"><span>分类总结</span></a></h2><h3 id="几种分类方式" tabindex="-1"><a class="header-anchor" href="#几种分类方式"><span>几种分类方式</span></a></h3><ul><li><p>从目的来看（《设计模式：可复用面向对象》中的分类）</p><ul><li><table><thead><tr><th style="text-align:center;">分类</th><th style="text-align:center;">中译</th><th style="text-align:center;">设计模式</th></tr></thead><tbody><tr><td style="text-align:center;">创建型模式<br>（Creational）<br>5</td><td style="text-align:center;">抽象工厂<br>构建器（生成器）<br>工厂方法<br>原型<br>单件</td><td style="text-align:center;">Abstract Factory<br>Builder<br>Factory Method<br>Prototype<br>Singleton</td></tr><tr><td style="text-align:center;">结构型模式<br>（Structural）<br>7</td><td style="text-align:center;">适配器<br>桥接模式<br>组成<br>装饰<br>外观（门面）<br>享元<br>代理</td><td style="text-align:center;">Adapter<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy</td></tr><tr><td style="text-align:center;">行为型模式<br>（Behavioral）<br>11</td><td style="text-align:center;">职责链<br>命令<br>解释器（解析器）<br>迭代器<br>中介者<br>备忘录<br>观察者<br>状态<br>策略<br>模板方法<br>访问者</td><td style="text-align:center;">Chain of Responsibility<br>Command<br>Interpreter<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Template Method<br>Visitor</td></tr></tbody></table></li></ul></li><li><p>从范围来看</p><ul><li>类模式：处理类与子类的静态关系（偏重继承方案）</li><li>对象模式：处理对象间的动态关系（偏重组合方案）</li></ul></li><li><p>从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时）</p><ul><li><table><thead><tr><th style="text-align:center;">分类</th><th style="text-align:center;">中译</th><th style="text-align:center;">设计模式</th><th style="text-align:center;">目的分类</th></tr></thead><tbody><tr><td style="text-align:center;">组件协作</td><td style="text-align:center;">模板方法<br>策略模式<br>观察者模式</td><td style="text-align:center;">Template Method<br>Strategy<br>Observer/Event</td><td style="text-align:center;">行为型</td></tr><tr><td style="text-align:center;">单一职责</td><td style="text-align:center;">装饰模式<br>桥接模式</td><td style="text-align:center;">Decorator<br>Bridge</td><td style="text-align:center;">结构型</td></tr><tr><td style="text-align:center;">对象创建</td><td style="text-align:center;">工厂模式<br>抽象工厂<br>原型模式<br><s>构建器模式</s></td><td style="text-align:center;">Factory Method<br>Abstract Factory<br>Prototype<br>Builder</td><td style="text-align:center;">创建型</td></tr><tr><td style="text-align:center;">对象性能</td><td style="text-align:center;">单件模式<br>享元模式</td><td style="text-align:center;">Singleton<br>Flyweight</td><td style="text-align:center;">创建型<br>结构型</td></tr><tr><td style="text-align:center;">接口隔离</td><td style="text-align:center;">门面模式<br>代理模式<br>适配器<br><s>中介者模式</s></td><td style="text-align:center;">Facade<br>Proxy<br>Adapter<br>Mediator</td><td style="text-align:center;">结构型<br>行为型</td></tr><tr><td style="text-align:center;">状态变化</td><td style="text-align:center;">状态模式<br><s>备忘录模式</s></td><td style="text-align:center;">State<br>Memento</td><td style="text-align:center;">行为型</td></tr><tr><td style="text-align:center;">数据结构</td><td style="text-align:center;">组合模式<br><s>迭代器模式</s><br><s>职责链模式</s></td><td style="text-align:center;">Composite<br>Iterator<br>Chain of Responsibility</td><td style="text-align:center;">结构型<br>行为型</td></tr><tr><td style="text-align:center;">行为变化</td><td style="text-align:center;"><s>命令模式</s><br><s>访问器模式</s></td><td style="text-align:center;">Command<br>Visitor</td><td style="text-align:center;">行为型</td></tr><tr><td style="text-align:center;">领域问题</td><td style="text-align:center;"><s>解析器模式</s></td><td style="text-align:center;">Interpreter</td><td style="text-align:center;">行为型</td></tr></tbody></table></li></ul></li></ul><h3 id="分类总结-1" tabindex="-1"><a class="header-anchor" href="#分类总结-1"><span>分类总结</span></a></h3><p>略</p><h3 id="个人分类" tabindex="-1"><a class="header-anchor" href="#个人分类"><span>个人分类</span></a></h3><p>前面提到过可以用不同的方式对这23种设计模式进行划分和分类</p><p>包括：</p><ul><li>按目的来看（书上的3种）</li><li>按封装变化角度（李建忠的9种）</li><li>按范围来看（2种）</li><li>按启用的原则来看（8种，但一个设计模式会涉及多种原则）</li><li>按重构技法来看（5种，但一个设计模式会涉及多种原则）</li><li>按中间层来看（见下）</li></ul><p>另外，从 Java 中也有一具话叫 “没有什么是加中间层不能解决的，如果有，就再加一层”。我认为我可以以 “中间层” 为切入点，再进行分类。 缺点是这种分类偏代码向，不够本质，归纳流于表面</p><p>有两种中间层提供方法</p><ul><li>a和b之间直接提供。例如 <ul><li>工厂模式：a create b 的中间添加中间层</li><li>适配器模式</li></ul></li><li>通过基类提供。a -&gt; a基 -&gt; b基 -&gt; b，使用这种方法进行传递。 有点类似封装变化点的原则、和晚绑定的技法</li></ul><h2 id="总概共同特点" tabindex="-1"><a class="header-anchor" href="#总概共同特点"><span>总概共同特点</span></a></h2><ul><li><p>一个目标：管理变化，提高复用！</p></li><li><p>两种手段</p><ul><li>分解</li><li>抽象</li></ul></li><li><p>八大原则</p><ul><li>依赖倒置原则（DIP）</li><li>开放封闭原则（OCP）（开闭原则）</li><li>单一职责原则（SRP）</li><li>里氏代换原则（LSP）（Liskov代换原则 / 里斯科夫代换）</li><li>接口隔离原则（ISP）</li><li>合成复用原则（优先使用对象组合，而不是类继承）</li><li>封装变化点</li><li>面向接口编程，而不是面向实现编程</li></ul></li><li><p>五种重构技法</p><ul><li>静态 --&gt; 动态</li><li>早绑定 --&gt; 晚绑定</li><li>继承 --&gt; 组合</li><li>编译时依赖 --&gt; 运行时依赖</li><li>紧耦合 --&gt; 松耦合</li></ul></li><li><p>类图的共同特点与趋向</p><ul><li>继承 --&gt; 组合且是包含一个<strong>抽象基类的指针</strong></li><li><code>class A:B{}</code>（×）</li><li><code>class A{B b}</code>（×）</li><li><code>class A{B* pb}</code>（√）</li></ul></li><li><p>什么时候不用模式（不要盲目模式、为了模式而模式）</p><ul><li>代码可读性很差时</li><li>需求理解还很浅时</li><li>变化没有显现时</li><li>不是系统的关键依赖点</li><li>项目没有复用价值时（比如对于做外包的）</li><li>项目将要发布时</li></ul></li><li><p>设计模式成长之路</p><ul><li>&quot;手中无剑，心中无剑”：见模式而不知</li><li>&quot;手中有剑，心中无剑&quot;：可以识别模式，作为应用开发人员使用模式</li><li>&quot;手中有剑，心中有剑&quot;：作为框架开发人员为应用设计某些模式</li><li>&quot;手中无剑，心中有剑&quot;：忘掉模式，只有原则</li></ul></li></ul><h2 id="每种设计模式的要点" tabindex="-1"><a class="header-anchor" href="#每种设计模式的要点"><span>每种设计模式的要点</span></a></h2><p>略</p><h2 id="常见框架中的设计模式" tabindex="-1"><a class="header-anchor" href="#常见框架中的设计模式"><span>常见框架中的设计模式</span></a></h2><h3 id="模板模式-template-method" tabindex="-1"><a class="header-anchor" href="#模板模式-template-method"><span>模板模式 Template Method</span></a></h3><ul><li>这个太常见了，我就不举例了</li></ul><h3 id="观察者模式-observer" tabindex="-1"><a class="header-anchor" href="#观察者模式-observer"><span>观察者模式 Observer</span></a></h3><ul><li>Java中的Listener机制</li><li>C#的Event模式</li><li>Qt的single-slot机制、Model-View模式</li><li>Vue的核心——数据驱动视图（Observer模块）</li></ul><h3 id="中介者模式-mediator" tabindex="-1"><a class="header-anchor" href="#中介者模式-mediator"><span>中介者模式 Mediator</span></a></h3><ul><li><p>类似于MVVM（Model-View-ViewModel，模型-视图-视图模型）本质上就是MVC （Model-View-Controller，模型-视图-控制器 ）的改进版</p></li><li><p>类似于Vue（Vue中，<code>v-bind</code>/<code> :</code>应该用的是观察者模式，而<code>v-model</code>双向绑定应该是用的中介者模式）</p></li></ul><h3 id="单例模式-singleton" tabindex="-1"><a class="header-anchor" href="#单例模式-singleton"><span>单例模式 Singleton</span></a></h3><ul><li>Qt的QPluginLoader的instance()方法</li><li>Qt开发过程中的自定义类PluginManager也用到了这个模式</li></ul><h3 id="职责链模式-chain-of-responsibility" tabindex="-1"><a class="header-anchor" href="#职责链模式-chain-of-responsibility"><span>职责链模式 Chain of Responsibility</span></a></h3><ul><li>Android的事件分发机制</li><li>QT的消息传递机制</li></ul><h3 id="适配器模式-adapter" tabindex="-1"><a class="header-anchor" href="#适配器模式-adapter"><span>适配器模式 Adapter</span></a></h3><ul><li>原生Android开发的控件有用到过</li></ul>',32),n=[a];function d(s,o){return e(),l("div",null,n)}const p=t(r,[["render",d],["__file","00.4. 23种设计模式总结.html.vue"]]),b=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/03.%20Tools/02.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/00.4.%2023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html","title":"《C++设计模式》视频_李建忠","lang":"zh-CN","frontmatter":{"description":"《C++设计模式》视频_李建忠 目录 23种设计模式总结 分类总结 几种分类方式 从目的来看（《设计模式：可复用面向对象》中的分类） 从范围来看 类模式：处理类与子类的静态关系（偏重继承方案） 对象模式：处理对象间的动态关系（偏重组合方案） 从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时） 分类总结 略 个...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/03.%20Tools/02.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/00.4.%2023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《C++设计模式》视频_李建忠"}],["meta",{"property":"og:description","content":"《C++设计模式》视频_李建忠 目录 23种设计模式总结 分类总结 几种分类方式 从目的来看（《设计模式：可复用面向对象》中的分类） 从范围来看 类模式：处理类与子类的静态关系（偏重继承方案） 对象模式：处理对象间的动态关系（偏重组合方案） 从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时） 分类总结 略 个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《C++设计模式》视频_李建忠\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《C++设计模式》视频_李建忠","slug":"《c-设计模式》视频-李建忠","link":"#《c-设计模式》视频-李建忠","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"23种设计模式总结","slug":"_23种设计模式总结","link":"#_23种设计模式总结","children":[{"level":2,"title":"分类总结","slug":"分类总结","link":"#分类总结","children":[{"level":3,"title":"几种分类方式","slug":"几种分类方式","link":"#几种分类方式","children":[]},{"level":3,"title":"分类总结","slug":"分类总结-1","link":"#分类总结-1","children":[]},{"level":3,"title":"个人分类","slug":"个人分类","link":"#个人分类","children":[]}]},{"level":2,"title":"总概共同特点","slug":"总概共同特点","link":"#总概共同特点","children":[]},{"level":2,"title":"每种设计模式的要点","slug":"每种设计模式的要点","link":"#每种设计模式的要点","children":[]},{"level":2,"title":"常见框架中的设计模式","slug":"常见框架中的设计模式","link":"#常见框架中的设计模式","children":[{"level":3,"title":"模板模式 Template Method","slug":"模板模式-template-method","link":"#模板模式-template-method","children":[]},{"level":3,"title":"观察者模式 Observer","slug":"观察者模式-observer","link":"#观察者模式-observer","children":[]},{"level":3,"title":"中介者模式 Mediator","slug":"中介者模式-mediator","link":"#中介者模式-mediator","children":[]},{"level":3,"title":"单例模式 Singleton","slug":"单例模式-singleton","link":"#单例模式-singleton","children":[]},{"level":3,"title":"职责链模式 Chain of Responsibility","slug":"职责链模式-chain-of-responsibility","link":"#职责链模式-chain-of-responsibility","children":[]},{"level":3,"title":"适配器模式 Adapter","slug":"适配器模式-adapter","link":"#适配器模式-adapter","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.01,"words":1502},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/03. Tools/02. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/00.4. 23种设计模式总结.md","autoDesc":true}');export{p as comp,b as data};
