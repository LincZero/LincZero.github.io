import{_ as i,c as s,e as l,o as t}from"./app-BgHc8lP1.js";const n="/assets/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B-CNb5Kwc7.jpg",a="/assets/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio-ifj9jeWK.png",o="/assets/%E6%80%A7%E8%83%BD-BCGTUnJw.png",r="/assets/redis%E5%AE%98%E6%96%B9%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%9B%9E%E7%AD%94-DWbM5U4u.png",d={};function p(h,e){return t(),s("div",null,e[0]||(e[0]=[l('<h1 id="redis-线程模型" tabindex="-1"><a class="header-anchor" href="#redis-线程模型"><span>Redis 线程模型</span></a></h1><h2 id="redis-线程模型-1" tabindex="-1"><a class="header-anchor" href="#redis-线程模型-1"><span>Redis 线程模型</span></a></h2><h3 id="redis-是单线程吗-单个主线程-多个后台线程" tabindex="-1"><a class="header-anchor" href="#redis-是单线程吗-单个主线程-多个后台线程"><span>Redis 是单线程吗？单个主线程+多个后台线程</span></a></h3><p>先说结论：Redis 是 <strong>单个主线程+多个后台线程</strong></p><ul><li>单线程的部分 <ul><li>「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（<strong>主线程</strong>）来完成的， 这也是我们常说 Redis 是单线程的原因</li></ul></li><li>多线程的部分 <ul><li>Redis 在启动的时候，会启动多个<strong>后台线程（BIO）</strong></li></ul></li></ul><p>其中</p><ul><li>命令处理：主线程、单线程</li><li>关闭文件、AOF刷盘、释放内存：多线程</li><li>网络I/O：6.0之前是单线程，6.0之后引入多线程</li></ul><h3 id="后台线程-bio" tabindex="-1"><a class="header-anchor" href="#后台线程-bio"><span>后台线程 (BIO)</span></a></h3><p>这个后台线程具体讲一下：</p><ul><li><h5 id="后台线程-版本" tabindex="-1"><a class="header-anchor" href="#后台线程-版本"><span>后台线程 - 版本</span></a></h5><ul><li><p>Redis 在 2.6 版本：会启动 2 个后台线程，分别处理：「<em>关闭文件、AOF 刷盘</em>」这两个任务；</p></li><li><p>Redis 在 4.0 版本之后：新增了一个新的后台线程*（lazyfree 线程），用来「异步释放 Redis 内存」*</p></li></ul></li><li><h5 id="后台线程-原因" tabindex="-1"><a class="header-anchor" href="#后台线程-原因"><span>后台线程 - 原因</span></a></h5><ul><li>之所以为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很<em>耗时</em>的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生<em>阻塞</em>，这样就无法处理后续的请求了。</li><li>例如：执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行。好处是不会导致 Redis 主线程卡顿</li><li>启发：因此，当我们要删除一个大 key 的时候，不要使用 <em>del</em> 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿。因此我们应该使用 <em>unlink</em> 命令来异步删除大key。</li></ul></li><li><h5 id="后台线程-三大操作的任务队列" tabindex="-1"><a class="header-anchor" href="#后台线程-三大操作的任务队列"><span>后台线程 - 三大操作的任务队列</span></a></h5><ul><li><p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p></li><li><p>(1) <strong>BIO_CLOSE_FILE，关闭文件任务队列</strong>：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</p></li><li><p>(2) <strong>BIO_AOF_FSYNC，AOF刷盘任务队列</strong>：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘；</p></li><li><p>(3) <strong>BIO_LAZY_FREE，lazy free 任务队列</strong>：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；</p></li><li><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p><p><img src="'+n+'" alt="img" loading="lazy"></p></li></ul></li></ul><h3 id="网络i-o线程-6-0之前的单线程模型-epoll多路复用" tabindex="-1"><a class="header-anchor" href="#网络i-o线程-6-0之前的单线程模型-epoll多路复用"><span>网络I/O线程 - 6.0之前的单线程模型 (epoll多路复用)</span></a></h3><h4 id="流程图" tabindex="-1"><a class="header-anchor" href="#流程图"><span>流程图</span></a></h4><p>Redis 6.0 版本之前的单线模式如下图：（感觉就是很普通的epoll I/O多路复用模型）</p><p><img src="'+a+'" alt="img" loading="lazy"></p><p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到<strong>网络 I/O 和命令处理都是单线程</strong>。</p><ol><li><p>首先进行初始化，会做下面这几件事情：</p><ol><li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li><li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li><li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li></ol></li><li><p>然后主线程就进入到一个事件循环函数，主要会做以下事情：</p><ol><li>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li><li>接着，调用 epoll_wait 函数等待事件的到来：</li></ol><ul><li>如果是<strong>连接事件</strong>到来：则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情： 调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</li><li>如果是<strong>读事件</strong>的到来：则会调用<strong>读事件的处理函数</strong>，该函数会做这些事情： 调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</li><li>如果是<strong>写事件</strong>的到来：则会调用<strong>写事件的处理函数</strong>，该函数会做这些事情： 通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li></ul></li></ol><p>以上就是 Redis 单线模式的工作方式，如果你想看源码解析，可以参考这一篇：<a href="https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw" target="_blank" rel="noopener noreferrer">为什么单线程的 Redis 如何做到每秒数万 QPS ？</a></p><h4 id="采用单线程为什么还这么快" tabindex="-1"><a class="header-anchor" href="#采用单线程为什么还这么快"><span>采用单线程为什么还这么快？</span></a></h4><p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W/每秒</strong>，如下图所示：</p><p><img src="'+o+'" alt="img" loading="lazy"></p><p>之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：</p><ul><li>大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构。 因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，<em>既然 CPU 不是瓶颈，那么自然就采用单线程</em>的解决方案了；</li><li>采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>采用了 **I/O 多路复用机制 **处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ul><h4 id="redis-6-0-之前为什么使用单线程" tabindex="-1"><a class="header-anchor" href="#redis-6-0-之前为什么使用单线程"><span>Redis 6.0 之前为什么使用单线程？</span></a></h4><p>我们都知道单线程的程序是无法利用服务器的多核 CPU 的，那么早期 Redis 版本的主要工作（网络 I/O 和执行命令）为什么还要使用单线程呢？</p><ol><li><p><strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong></p><p>Redis官方给出的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fredis.io%2Ftopics%2Ffaq" target="_blank" rel="noopener noreferrer">FAQ</a> 如下：</p><p><img src="'+r+`" alt="img" loading="lazy"></p><p>核心意思是：CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络I/O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p></li><li><p><strong>减少并发带来的 复杂度、额外性能损耗</strong></p><p>除了上面的官方回答，选择单线程的原因也有下面的考虑。</p><p>使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题。增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</p></li></ol><h3 id="网络i-o线程-6-0之后引入多线程" tabindex="-1"><a class="header-anchor" href="#网络i-o线程-6-0之后引入多线程"><span>网络I/O线程 - 6.0之后引入多线程</span></a></h3><p>性能相关：</p><blockquote><p>虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的<strong>性能瓶颈有时会出现在网络 I/O 的处理上</strong>。所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。</p><p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上</strong>。</p></blockquote><p>常见误区：</p><blockquote><p><strong>但是对于命令的执行，Redis 仍然使用单线程来处理，<strong>所以大家</strong>不要误解</strong> Redis 有多线程同时执行命令。</p></blockquote><p>多线程相关配置：</p><blockquote><p>Redis 6.0 版本支持的 I/O 多线程特性</p><p>默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//读请求也使用io多线程</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">io</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">threads</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-do-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">reads yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">io</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">threads </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p><p>因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p><ul><li>Redis-server ： Redis的主线程，主要负责执行命令；</li><li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li><li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</li></ul></blockquote>`,32)]))}const g=i(d,[["render",p],["__file","01. 线程模型.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/04.%20%E5%9B%BE%E8%A7%A3Redis/01.%20%E9%9D%A2%E8%AF%95%E7%AF%87/01.%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html","title":"Redis 线程模型","lang":"zh-CN","frontmatter":{"description":"Redis 线程模型 Redis 线程模型 Redis 是单线程吗？单个主线程+多个后台线程 先说结论：Redis 是 单个主线程+多个后台线程 单线程的部分 「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的， 这也是我们常说 Redis 是单线程的原因 多线程的部分 Redis 在启动的...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/04.%20%E5%9B%BE%E8%A7%A3Redis/01.%20%E9%9D%A2%E8%AF%95%E7%AF%87/01.%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Redis 线程模型"}],["meta",{"property":"og:description","content":"Redis 线程模型 Redis 线程模型 Redis 是单线程吗？单个主线程+多个后台线程 先说结论：Redis 是 单个主线程+多个后台线程 单线程的部分 「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的， 这也是我们常说 Redis 是单线程的原因 多线程的部分 Redis 在启动的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 线程模型\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Redis 线程模型","slug":"redis-线程模型","link":"#redis-线程模型","children":[{"level":2,"title":"Redis 线程模型","slug":"redis-线程模型-1","link":"#redis-线程模型-1","children":[{"level":3,"title":"Redis 是单线程吗？单个主线程+多个后台线程","slug":"redis-是单线程吗-单个主线程-多个后台线程","link":"#redis-是单线程吗-单个主线程-多个后台线程","children":[]},{"level":3,"title":"后台线程 (BIO)","slug":"后台线程-bio","link":"#后台线程-bio","children":[]},{"level":3,"title":"网络I/O线程 - 6.0之前的单线程模型 (epoll多路复用)","slug":"网络i-o线程-6-0之前的单线程模型-epoll多路复用","link":"#网络i-o线程-6-0之前的单线程模型-epoll多路复用","children":[{"level":4,"title":"流程图","slug":"流程图","link":"#流程图","children":[]},{"level":4,"title":"采用单线程为什么还这么快？","slug":"采用单线程为什么还这么快","link":"#采用单线程为什么还这么快","children":[]},{"level":4,"title":"Redis 6.0 之前为什么使用单线程？","slug":"redis-6-0-之前为什么使用单线程","link":"#redis-6-0-之前为什么使用单线程","children":[]}]},{"level":3,"title":"网络I/O线程 - 6.0之后引入多线程","slug":"网络i-o线程-6-0之后引入多线程","link":"#网络i-o线程-6-0之后引入多线程","children":[]}]}]}],"git":{},"readingTime":{"minutes":8.5,"words":2551},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/04. 图解Redis/01. 面试篇/01. 线程模型.md","excerpt":"\\n<h2>Redis 线程模型</h2>\\n<h3>Redis 是单线程吗？单个主线程+多个后台线程</h3>\\n<p>先说结论：Redis 是 <strong>单个主线程+多个后台线程</strong></p>\\n<ul>\\n<li>单线程的部分\\n<ul>\\n<li>「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（<strong>主线程</strong>）来完成的，\\n这也是我们常说 Redis 是单线程的原因</li>\\n</ul>\\n</li>\\n<li>多线程的部分\\n<ul>\\n<li>Redis 在启动的时候，会启动多个<strong>后台线程（BIO）</strong></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/04. 图解Redis/01. 面试篇/01. 线程模型.md","value":{"title":"01. 线程模型","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/04. 图解Redis/01. 面试篇/01. 线程模型.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{g as comp,k as data};
