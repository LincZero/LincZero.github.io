import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as n,e as l}from"./app-yixEWCFr.js";const s={},i=l(`<h1 id="different" tabindex="-1"><a class="header-anchor" href="#different"><span>Different</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="类中函数" tabindex="-1"><a class="header-anchor" href="#类中函数"><span>类中函数</span></a></h1><h2 id="成员-方法访问控制" tabindex="-1"><a class="header-anchor" href="#成员-方法访问控制"><span>成员/方法访问控制</span></a></h2><h3 id="访问控制关键字" tabindex="-1"><a class="header-anchor" href="#访问控制关键字"><span>访问控制关键字</span></a></h3><ul><li>C++ <ul><li>public、private关键字写在一组实例域和方法之前</li><li>访问控制关键字写在头文件而不写在实现文件中</li></ul></li><li>Java <ul><li>public、private关键字写在每一个实例和方法之前</li><li>没有头文件、访问控制关键字直接写在实现文件中</li></ul></li></ul><h3 id="static-静态方法" tabindex="-1"><a class="header-anchor" href="#static-静态方法"><span>static 静态方法</span></a></h3><p>好像C++中只有static方法才能操作static成员，但Java中似乎没有此限制</p><p>Java中的静态域与静态方法在功能上与C++相同。但是，语法书写上却稍有所不同。</p><ul><li>Java：无需构造对象。使用<code>.</code>操作符直接访问，如<code>Math.pow</code></li><li>C++：无需构造对象。使用<code>::</code>操作符访问自身作用域之外的静态域和静态方法，如<code>Math::PI</code></li></ul><h2 id="构造和析构函数" tabindex="-1"><a class="header-anchor" href="#构造和析构函数"><span>构造和析构函数</span></a></h2><h3 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数"><span>构造函数</span></a></h3><p>构造器名</p><ul><li>C++、Java：构造器名和类同名</li><li>Java：构造器名为<code>init</code></li></ul><h4 id="显式域初始化" tabindex="-1"><a class="header-anchor" href="#显式域初始化"><span>显式域初始化</span></a></h4><p>与C++相似地：</p><ul><li><p>Java：可以在执行构造器之前，先执行赋值操作</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++：</p><p>C++11也可以进行<code>类内初始化</code>（C++前不能），也有功能相似的<code>成员初始化列表</code>（Java没有）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class Employee
{
    Employee::Employee(String n, double s, int y, int m, int d)
        :name(n), salary(s), hireDay(y,m,d)
    {
        // ...    
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="参数名命名习惯" tabindex="-1"><a class="header-anchor" href="#参数名命名习惯"><span>参数名命名习惯</span></a></h4><p><mark>与C/C++不同</mark>：成员函数参数命名习惯</p><ul><li><p>C++</p><ul><li>经常用下划线或某个固定的字母（一般选用m或x）作为实例域的前缀</li><li>例如，_salary、mSalary或xSalary</li></ul></li><li><p>Java</p><ul><li><p>程序员则喜欢在每个参数前面加上一个前缀“a”</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> aName<span class="token punctuation">,</span> <span class="token keyword">double</span> aSalary<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    name <span class="token operator">=</span> aName<span class="token punctuation">;</span>
    salary <span class="token operator">=</span> aSalary<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>还一种常用的技巧，它基于这样的事实：参数变量用同样的名字将实例域屏蔽起来</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h4 id="构造器调用构造器" tabindex="-1"><a class="header-anchor" href="#构造器调用构造器"><span>构造器调用构造器</span></a></h4><ul><li>C++：一个构造器不能调用另一个构造器（你确定不能？）。在C++中，必须将抽取出的公共初始化代码编写成一个独立的方法</li><li>Java：可以，调用构造器的具体处理步骤如下 <ol><li>所有数据域被初始化为默认值（0、false或null）</li><li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li><li>执行这个构造器的主体</li></ol></li></ul><h3 id="析构函数" tabindex="-1"><a class="header-anchor" href="#析构函数"><span>析构函数</span></a></h3><ul><li><p>C++：有显式的析构器方法：<code>~</code>+类名</p></li><li><p>Java：有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器</p><p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p><p>可以为任何一个类添加<code>finalize</code>方法。finalize方法将在垃圾回收器清除对象之前调用</p></li></ul><h2 id="其他函数" tabindex="-1"><a class="header-anchor" href="#其他函数"><span>其他函数</span></a></h2><h3 id="更改器方法与访问器方法-c-中的const成员函数" tabindex="-1"><a class="header-anchor" href="#更改器方法与访问器方法-c-中的const成员函数"><span>更改器方法与访问器方法（C++中的const成员函数）</span></a></h3><p>访问器方法和静态方法</p><ul><li>Java：只访问对象而不修改对象的方法有时称为<code>访问器方法</code>（accessor method） 例如：LocalDate.getYear和GregorianCalendar.get就是访问器方法。 在Java语言中，访问器方法与更改器方法在<strong>语法上没有明显的区别</strong></li><li>C++：带有const后缀的方法是访问器方法；默认为更改器方法。 但C++中似乎没有这种叫法，只是简单称为const成员函数</li></ul><h3 id="内联方法" tabindex="-1"><a class="header-anchor" href="#内联方法"><span>内联方法？</span></a></h3><ul><li>C++ <ul><li>通常在类的外面定义方法</li><li>如果在类的内部定义方法，这个方法将自动地成为内联（inline）方法。</li></ul></li><li>Java <ul><li>所有的方法都必须在类的内部定义</li><li>但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。 即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。</li></ul></li></ul><h3 id="方法参数" tabindex="-1"><a class="header-anchor" href="#方法参数"><span>方法参数</span></a></h3><ul><li><p>Java：程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝。方法不能修改传递给它的任何参数变量的内容</p><p>但注意的是：Java的对象实例本来就是对象的引用，按值引用后依然是对象的引用。可以通过对象方法修改对象实例所引用的对象</p></li><li><p>C++：可以自由选择按值调用（call by value）或按引用调用（call by reference）</p><p>例如：<code>void tripleValue(double&amp;x)</code>，一个方法是按值调用还是按引用调用需要看函数原型才能知道</p></li><li><p>不可单纯将Java的对象实例理解为C++的引用，而必须要看成指针</p><ul><li>比如：不能编写一个交换两个雇员对象的方法，因为交换的只是拷贝进方法中的两个对象实例的地址，而并不能改变外部的两个对象实例的地址</li></ul></li></ul>`,32),t=[i];function c(p,r){return e(),n("div",null,t)}const u=a(s,[["render",c],["__file","02. 类中函数.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Different/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.%20%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0.html","title":"Different","lang":"zh-CN","frontmatter":{"description":"Different 目录 类中函数 成员/方法访问控制 访问控制关键字 C++ public、private关键字写在一组实例域和方法之前 访问控制关键字写在头文件而不写在实现文件中 Java public、private关键字写在每一个实例和方法之前 没有头文件、访问控制关键字直接写在实现文件中 static 静态方法 好像C++中只有static方...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Different/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.%20%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Different"}],["meta",{"property":"og:description","content":"Different 目录 类中函数 成员/方法访问控制 访问控制关键字 C++ public、private关键字写在一组实例域和方法之前 访问控制关键字写在头文件而不写在实现文件中 Java public、private关键字写在每一个实例和方法之前 没有头文件、访问控制关键字直接写在实现文件中 static 静态方法 好像C++中只有static方..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Different\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Different","slug":"different","link":"#different","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"类中函数","slug":"类中函数","link":"#类中函数","children":[{"level":2,"title":"成员/方法访问控制","slug":"成员-方法访问控制","link":"#成员-方法访问控制","children":[{"level":3,"title":"访问控制关键字","slug":"访问控制关键字","link":"#访问控制关键字","children":[]},{"level":3,"title":"static 静态方法","slug":"static-静态方法","link":"#static-静态方法","children":[]}]},{"level":2,"title":"构造和析构函数","slug":"构造和析构函数","link":"#构造和析构函数","children":[{"level":3,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[{"level":4,"title":"显式域初始化","slug":"显式域初始化","link":"#显式域初始化","children":[]},{"level":4,"title":"参数名命名习惯","slug":"参数名命名习惯","link":"#参数名命名习惯","children":[]},{"level":4,"title":"构造器调用构造器","slug":"构造器调用构造器","link":"#构造器调用构造器","children":[]}]},{"level":3,"title":"析构函数","slug":"析构函数","link":"#析构函数","children":[]}]},{"level":2,"title":"其他函数","slug":"其他函数","link":"#其他函数","children":[{"level":3,"title":"更改器方法与访问器方法（C++中的const成员函数）","slug":"更改器方法与访问器方法-c-中的const成员函数","link":"#更改器方法与访问器方法-c-中的const成员函数","children":[]},{"level":3,"title":"内联方法？","slug":"内联方法","link":"#内联方法","children":[]},{"level":3,"title":"方法参数","slug":"方法参数","link":"#方法参数","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.34,"words":1303},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Different/06. 面向对象/02. 类的内容/02. 类中函数.md","autoDesc":true}');export{u as comp,h as data};
