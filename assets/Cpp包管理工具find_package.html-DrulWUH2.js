import{_ as l,c as n,e,a as i,f as s,o as t}from"./app-CZqDObZ4.js";const d="/assets/fbc0ea14540f058e6c7c5ffb5024c81e-B-qxN44_.png",r={};function h(p,a){return t(),n("div",null,a[0]||(a[0]=[e('<h1 id="cpp包管理工具find-package" tabindex="-1"><a class="header-anchor" href="#cpp包管理工具find-package"><span>Cpp包管理工具find_package</span></a></h1><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/97369704" target="_blank" rel="noopener noreferrer">Cmake之深入理解find_package()的用法</a></li><li><a href="https://blog.csdn.net/zhanghm1995/article/details/105466372" target="_blank" rel="noopener noreferrer">“轻松搞定CMake”系列之find_package用法详解</a></li></ul><h2 id="find-package-命令详解" tabindex="-1"><a class="header-anchor" href="#find-package-命令详解"><span>find_package 命令详解</span></a></h2><h2 id="搜包过程、两种工作模式" tabindex="-1"><a class="header-anchor" href="#搜包过程、两种工作模式"><span>搜包过程、两种工作模式</span></a></h2><p>首先我们需要明确一点，CMake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由CMake代码完成，也就是上述中的 <code>XXXConfig.cmake</code> 以及下面将要提到的 <code>FindXXX.cmake</code> 配置文件。只不过，库的作者通常会提供这两个文件，以方便使用者调用。</p><h3 id="两种工作模式" tabindex="-1"><a class="header-anchor" href="#两种工作模式"><span>### 两种工作模式</span></a></h3><h4 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h4><p>find_package命令有两种工作模式，这两种工作模式的不同决定了其搜包路径的不同：</p><ul><li>Module模式 find_package命令基础工作模式(Basic Signature)，也是默认工作模式。</li><li>Config模式 find_package命令高级工作模式(Full Signature)。 只有在find_package()中指定CONFIG、NO_MODULE等关键字，或者Module模式查找失败后才会进入到Config模式。</li></ul><h4 id="查找顺序、流程" tabindex="-1"><a class="header-anchor" href="#查找顺序、流程"><span>查找顺序、流程</span></a></h4><p>因此find_package工作模式流程图为：</p><p><img src="'+d+`" alt="" loading="lazy"></p><p>两种模式看起来似乎差不多，<strong>不过CMake默认采取Module模式，如果Module模式未找到库，才会采取Config模式</strong>。如果XXX_DIR路径下找不到XXXConfig.cmake文件，则会找 <code>/usr/local/lib/cmake/XXX/</code> 中的<code>XXXConfig.cmake</code> 文件。总之，Config模式是一个备选策略。通常，库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。</p><h4 id="提前比较、区别、选用建议" tabindex="-1"><a class="header-anchor" href="#提前比较、区别、选用建议"><span>提前比较、区别、选用建议</span></a></h4><p>上面的查找规则整体看起来好像很复杂，但其实我们在安装库的时候都会自动配置安装到对的位置，一般都不会出现问题。如果我们需要指定特定的库，我们也只需要设置<strong>优先级最高</strong>的几个变量名即可。包括下面两种情况：</p><p>1、如果你明确知道想要查找的库<code>&lt;PackageName&gt;Config.cmake</code>或<code>&lt;lower-case-package-name&gt;-config.cmake</code>文件所在路径，为了能够准确定位到这个包，可以直接设置变量<code>&lt;PackageName&gt;_DIR</code>为具体路径，如：</p><p>就可以明确需要查找的OpenCV包的路径了。</p><p>2、如果你有多个包的配置文件需要查找，可以将这些配置文件都统一放在一个命名为<code>cmake</code>的文件夹下，然后设置变量<code>CMAKE_PREFIX_PATH</code>变量指向这个<code>cmake</code>文件夹路径，<strong>需要注意根据上述的匹配规则，此时每个包的配置文件需要单独放置在命名为包名的<mark>文件夹</mark>下（文件夹名不区分大小写）</strong>，否则会提示找不到。</p><h3 id="module模式" tabindex="-1"><a class="header-anchor" href="#module模式"><span>Module模式</span></a></h3><h4 id="用法" tabindex="-1"><a class="header-anchor" href="#用法"><span>用法</span></a></h4><p><strong>Module</strong>模式的参数为：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">find_package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; [version] [EXACT] [QUIET] [MODULE]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [REQUIRED] [[COMPONENTS] [components...]]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [OPTIONAL_COMPONENTS components...]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_POLICY_SCOPE])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数解释：</p>`,24),i("div",{class:"ab-note drop-shadow"},[i("table",{class:"ab-table ab-list-table ab-listtable-likelist"},[i("tbody",null,[i("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"**package**",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 0
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[i("strong",null,"package")])])])]),i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,"必填参数。需要查找的包名，注意大小写。")])])])]),i("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"**version和EXACT**",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 1
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[i("strong",null,"version和EXACT")])])])]),i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[s("可选参数，version指定的是版本，如果指定就必须检查找到的包的版本是否和"),i("strong",null,"version"),s("兼容。如果指定"),i("strong",null,"EXACT"),s("则表示必须完全匹配的版本而不是兼容版本就可以。")])])])])]),i("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"**QUIET**",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 2
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[i("strong",null,"QUIET")])])])]),i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[s("可选参数，表示如果查找失败，不会在屏幕进行输出（但是如果指定了"),i("strong",null,"REQUIRED"),s("字段，则"),i("strong",null,"QUIET"),s("无效，仍然会输出查找失败提示语）。")])])])])]),i("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"**MODULE**",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 3
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[i("strong",null,"MODULE")])])])]),i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[s("可选字段。前面提到说“如果"),i("strong",null,"Module"),s("模式查找失败则回退到"),i("strong",null,"Config"),s("模式进行查找”，但是假如加入了"),i("strong",null,"MODULE"),s("选项，那么就只在"),i("strong",null,"Module"),s("模式查找，如果"),i("strong",null,"Module"),s("模式下查找失败并不切换到"),i("strong",null,"Config"),s("模式查找。")])])])])]),i("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"**REQUIRED**",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 4
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[i("strong",null,"REQUIRED")])])])]),i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[s("可选字段。表示一定要找到包，找不到的话就立即停掉整个CMake。而如果不指定"),i("strong",null,"REQUIRED"),s("则CMake会继续执行。")])])])])]),i("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"**COMPONENTS，components**",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 5
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[i("strong",null,"COMPONENTS，components")])])])]),i("td",{rowspan:"1"},[i("div",{class:"ab-list-table-witharrow markdown-rendered"},[i("div",null,[i("p",null,[s("可选字段，表示查找的包中必须要找到的组件(components），如果有任何一个找不到就算失败，类似于"),i("strong",null,"REQUIRED"),s("，导致CMake停止执行。")])])])])])]),i("button",{class:"ab-table-fold",is_fold:"false"},"全部折叠/展开")])],-1),e(`<h4 id="查找顺序" tabindex="-1"><a class="header-anchor" href="#查找顺序"><span>查找顺序</span></a></h4><p>Module模式下是要查找到名为 <code>Find&lt;PackageName&gt;.cmake</code> 的配置文件。</p><p>Module模式只有两个查找路径，且他们的查找顺序如下：</p><ul><li>CMAKE_MODULE_PATH <ul><li>路径：<strong>CMAKE_MODULE_PATH</strong> 变量对应的路径中查找。</li><li>打印：<code>CMakeLists.txt</code> 文件中打印：<code>message(STATUS &quot;CMAKE_MODULE_PATH = \${CMAKE_MODULE_PATH}&quot;)</code></li><li>补充：其中 <strong>CMAKE_MODULE_PATH</strong> 默认为空，可以利用 <code>set</code> 命令赋值。</li><li>补充：（如果路径为空，或者路径中查找失败，则找下一项）</li></ul></li><li>CMAKE_ROOT <ul><li>路径：CMake安装目录（即<strong>CMAKE_ROOT</strong>变量）下的 <strong>Modules</strong> 目录下（通常为 <code>/usr/share/cmake-3.10/Modules</code>，3.10是我的CMake版本）查找。</li><li>打印：<code>CMakeLists.txt</code> 文件中打印：<code>message(STATUS &quot;CMAKE_ROOT = \${CMAKE_ROOT}&quot;)</code></li></ul></li></ul><p>在安装CMake时，CMake为我们提供了很多开发库的 <code>FindXXX.cmake</code> 模块文件，可以通过命令查询：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --help-module-list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -E</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ^Find</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="config模式" tabindex="-1"><a class="header-anchor" href="#config模式"><span>Config模式</span></a></h3><h4 id="用法-1" tabindex="-1"><a class="header-anchor" href="#用法-1"><span>用法</span></a></h4><p><strong>Config</strong>模式的完整命令参数为：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">find_package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; [version] [EXACT] [QUIET]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [REQUIRED] [[COMPONENTS] [components...]]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [CONFIG|NO_MODULE]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_POLICY_SCOPE]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NAMES name1 [name2 ...]]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [CONFIGS config1 [config2 ...]]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [HINTS path1 [path2 ... ]]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [PATHS path1 [path2 ... ]]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [PATH_SUFFIXES suffix1 [suffix2 ...]]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_DEFAULT_PATH]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_CMAKE_ENVIRONMENT_PATH]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_CMAKE_PATH]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_SYSTEM_ENVIRONMENT_PATH]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_CMAKE_PACKAGE_REGISTRY]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_CMAKE_SYSTEM_PATH]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             [CMAKE_FIND_ROOT_PATH_BOTH |</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">              ONLY_CMAKE_FIND_ROOT_PATH |</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">              NO_CMAKE_FIND_ROOT_PATH])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于Module模式，Config模式的参数更多，也更复杂，但实际在使用过程中我们并不会用到所有参数，大部分参数都是可选的，我们只需要掌握基本的参数用法即可。</p><p>其中具体查找库并给 <code>XXX_INCLUDE_DIRS</code> 和 <code>XXX_LIBRARIES</code> 两个变量赋值的操作由 <code>XXXConfig.cmake</code> 模块完成。</p><h4 id="查找顺序-1" tabindex="-1"><a class="header-anchor" href="#查找顺序-1"><span>查找顺序</span></a></h4><p><strong>Config</strong> 模式下是要查找名为 <code>&lt;PackageName&gt;Config.cmake</code> 或 <code>&lt;lower-case-package-name&gt;-config.cmake</code> 的模块文件。</p><p>与Module模式不同，Config模式需要查找的路径非常多，也要匹配很多的可能性，因此有些路径是首先作为<strong>根目录</strong>，然后进行子目录的匹配，我会进行说明。</p><p>具体查找顺序为：</p><ul><li>名为 <code>&lt;PackageName&gt;_DIR</code> 的CMake变量或环境变量路径 <ul><li><strong>非根目录</strong>，默认为空。<br> 这个路径是非根目录路径，需要指定到 <code>&lt;PackageName&gt;Config.cmake</code> 或 <code>&lt;lower-case-package-name&gt;-config.cmake</code> 文件所在目录才能找到。</li></ul></li><li>名为 <code>CMAKE_PREFIX_PATH</code>、<code>CMAKE_FRAMEWORK_PATH</code>、<code>CMAKE_APPBUNDLE_PATH</code> 的CMake变量或<strong>环境变量</strong>路径 <ul><li><strong>根目录</strong>，默认都为空。<br> 注意如果你电脑中安装了<strong>ROS</strong>并配置好之后，你在终端执行<code>echo $CMAKE_PREFIX_PATH</code>会发现ROS会将CMAKE_PREFIX_PATH这个变量设置为ROS中的库的路径，意思是会首先查找ROS安装的库，如果恰好你在ROS中安装了OpenCV库，就会发现首先找到的是ROS中的OpenCV，而不是你自己安装到系统中的OpenCV。</li></ul></li><li><code>PATH</code>环境变量路径 <ul><li><strong>根目录</strong>，默认为系统环境<code>PATH</code>环境变量值。<br> 其实这个路径才是<strong>Config</strong>模式大部分情况下能够查找到安装到系统中各种库的原因。</li><li>这个路径的查找规则为：</li><li>遍历<code>PATH</code>环境变量中的各路径，如果该路径如果以bin或sbin结尾，则<strong>自动回退到上一级目录</strong>得到根目录。例如我的<code>PATH</code>路径包括：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> echo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $PATH</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">/home/zhanghm/.local/bin:/usr/local/cuda-10.1/bin:/opt/ros/melodic/bin:/home/zhanghm/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><p>在上述指明的是<strong>根目录</strong>路径时，CMake会首先检查这些<strong>根目录</strong>路径下是否有名为<code>&lt;PackageName&gt;Config.cmake</code>或<code>&lt;lower-case-package-name&gt;-config.cmake</code>的模块文件，如果没有，CMake会继续<strong>检查或匹配</strong>这些根目录下的以下路径（<code>&lt;PackageName&gt;_DIR</code>路径不是根目录路径）：</p><p>其中为系统架构名，如Ubuntu下一般为：<code>/usr/lib/x86_64-linux-gnu</code>，整个<code>(lib/&lt;arch&gt;|lib|share)</code>为可选路径，例如OpenCV库而言会<strong>检查或匹配</strong><code>&lt;prefix&gt;/OpenCV/</code>、<code>&lt;prefix&gt;/lib/x86_64-linux-gnu/OpenCV/</code>、<code>&lt;prefix&gt;/lib/share/OpenCV/</code>、<code>&lt;prefix&gt;/share/OpenCV/</code>等路径；name为包名，不区分大小写<code>&lt;name&gt;*</code>意思是包名后接一些版本后等字符也是合法的，如<code>pcl-1.9</code>也会被找到。</p><h2 id="内置模块、非官方库、自己的库" tabindex="-1"><a class="header-anchor" href="#内置模块、非官方库、自己的库"><span>内置模块、非官方库、自己的库</span></a></h2><h3 id="通过cmake内置模块引入依赖包" tabindex="-1"><a class="header-anchor" href="#通过cmake内置模块引入依赖包"><span>通过Cmake内置模块引入依赖包</span></a></h3><p>为了方便我们在项目中引入外部依赖包，cmake官方为我们预定义了许多寻找<a href="https://zhida.zhihu.com/search?content_id=109768348&amp;content_type=Article&amp;match_order=4&amp;q=%E4%BE%9D%E8%B5%96%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">依赖包</a></p><p>的Module，他们存储在 <code>path_to_your_cmake/share/cmake-&lt;version&gt;/Modules</code> 目录下。每个以<code>Find&lt;LibaryName&gt;.cmake</code> <strong>命名的文件</strong>都可以帮我们找到一个包。我们也可以在官方文档中查看到哪些库官方已经为我们定义好了，我们可以直接使用find_package函数进行引用 <a href="https://link.zhihu.com/?target=https%3A//cmake.org/cmake/help/latest/manual/cmake-modules.7.html" target="_blank" rel="noopener noreferrer">官方文档：Find Modules</a>。</p><p>我们以 <a href="https://zhida.zhihu.com/search?content_id=109768348&amp;content_type=Article&amp;match_order=1&amp;q=curl%E5%BA%93&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">curl库</a> 为例，假设我们项目需要引入这个库，从网站中请求网页到本地，我们看到官方已经定义好了FindCURL.cmake。所以我们在CMakeLists.txt中可以直接用find_pakcage进行引用。</p><h3 id="通过find-package引入非官方的库-该方式只对支持cmake编译安装的库有效" tabindex="-1"><a class="header-anchor" href="#通过find-package引入非官方的库-该方式只对支持cmake编译安装的库有效"><span>通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）</span></a></h3><p>假设此时我们需要引入glog库来进行日志的记录，我们在Module目录下并没有找到 FindGlog.cmake。所以我们需要自行安装glog库，再进行引用。</p><p>安装</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># clone该项目</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> clone</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> https://github.com/google/glog.git</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 切换到需要的版本 </span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">cd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> glog</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> checkout</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> v0.40</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 根据官网的指南进行安装</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -H.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -Bbuild</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -G</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Unix Makefiles&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> build</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> build</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --target</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们便可以通过与引入curl库一样的方式引入glog库了</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" data-title="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">find_package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(GLOG)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add_executable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(glogtest glogtest.cc)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(GLOG_FOUND)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 由于glog在连接时将头文件直接链接到了库里面，所以这里不用显示调用target_include_directories</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    target_link_libraries</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(glogtest glog::glog)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(GLOG_FOUND)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    message</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(FATAL_ERROR ”GLOG library </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">not</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> found”)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">endif</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(GLOG_FOUND)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="module模式与config模式" tabindex="-1"><a class="header-anchor" href="#module模式与config模式"><span>Module模式与Config模式</span></a></h3><p>通过上文我们了解了通过Cmake引入依赖库的基本用法。知其然也要知其所以然，find_package对我们来说是一个黑盒子，那么它是具体通过什么方式来查找到我们依赖的库文件的路径的呢。到这里我们就不得不聊到find_package的两种模式，一种是Module模式，也就是我们引入curl库的方式。另一种叫做Config模式，也就是引入glog库的模式。下面我们来详细介绍着两种方式的运行机制。</p><p>在Module模式中，cmake需要找到一个叫做<code>Find&lt;LibraryName&gt;.cmake</code>的文件。这个文件负责找到库所在的路径，为我们的项目引入<a href="https://zhida.zhihu.com/search?content_id=109768348&amp;content_type=Article&amp;match_order=1&amp;q=%E5%A4%B4%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">头文件路径</a></p><p>和库文件路径。cmake搜索这个文件的路径有两个，一个是上文提到的cmake安装目录下的<code>share/cmake-&lt;version&gt;/Modules</code>目录，另一个使我们指定的<code>CMAKE_MODULE_PATH</code>的所在目录。</p><p>如果Module模式搜索失败，没有找到对应的<code>Find&lt;LibraryName&gt;.cmake</code>文件，则转入Config模式进行搜索。它主要通过<code>&lt;LibraryName&gt;Config.cmake</code> or <code>&lt;lower-case-package-name&gt;-config.cmake</code>这两个文件来引入我们需要的库。以我们刚刚安装的glog库为例，在我们安装之后，它在<code>/usr/local/lib/cmake/glog/</code>目录下生成了<code>glog-config.cmake</code>文件，而<code>/usr/local/lib/cmake/&lt;LibraryName&gt;/</code>正是find_package函数的搜索路径之一。（find_package的搜索路径是一系列的集合，而且在linux，windows，mac上都会有所区别，需要的可以参考官方文档<a href="https://link.zhihu.com/?target=https%3A//cmake.org/cmake/help/latest/command/find_package.html" target="_blank" rel="noopener noreferrer">find_package</a>）</p><p>由以上的例子可以看到，对于原生支持Cmake编译和安装的库通常会安装Config模式的<a href="https://zhida.zhihu.com/search?content_id=109768348&amp;content_type=Article&amp;match_order=1&amp;q=%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">配置文件</a></p><p>到对应目录，这个配置文件直接配置了头文件库文件的路径以及各种<a href="https://zhida.zhihu.com/search?content_id=109768348&amp;content_type=Article&amp;match_order=1&amp;q=cmake%E5%8F%98%E9%87%8F&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">cmake变量</a></p><p>供find_package使用。而对于非由cmake编译的项目，我们通常会编写一个<code>Find&lt;LibraryName&gt;.cmake</code>，通过脚本来获取头文件、库文件等信息。通常，原生支持cmake的项目库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。</p><h3 id="编写自己的-find-libraryname-cmake-模块" tabindex="-1"><a class="header-anchor" href="#编写自己的-find-libraryname-cmake-模块"><span>编写自己的 <code>Find&lt;LibraryName&gt;.cmake</code> 模块</span></a></h3><p>假设我们编写了一个新的函数库，我们希望别的项目可以通过find_package对它进行引用我们应该怎么办呢。</p><p>我们在当前目录下新建一个<code>ModuleMode</code>的文件夹，在里面我们编写一个计算两个整数之和的一个简单的函数库。库函数以手工编写Makefile的方式进行安装，库文件安装在/usr/lib目录下，头文件放在/usr/include目录下。其中的Makefile文件如下：</p><div class="language-make line-numbers-mode" data-highlighter="shiki" data-ext="make" data-title="make" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 1、准备工作，编译方式、目标文件名、依赖库路径的定义。</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">CC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> g++</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">CFLAGS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  :=</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> -Wall -O3 -std=c++11 </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">OBJS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> libadd.o </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#.o文件与.cpp文件同名</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">LIB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> libadd.so </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 目标文件名</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">INCLUDE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> ./ </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 头文件目录</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">HEADER</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> libadd.h </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 头文件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">all</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> :</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> $(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">LIB</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 2. 生成.o文件 </span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">OBJS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> : libadd.cc</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    $(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">CC</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> $(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">CFLAGS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> -I ./ -fpic -c </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">$&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> -o </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">$@</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 3. 生成动态库文件</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">LIB</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> : </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">OBJS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    rm -f </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">$@</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    g++ </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">OBJS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> -shared -o </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">$@</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    rm -f </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">OBJS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 4. 删除中间过程生成的文件 </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    rm -f </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">OBJS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> $(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">TARGET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> $(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">LIB</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 5.安装文件</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">install</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    cp </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">LIB</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> /usr/lib</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    cp </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">HEADER</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> /usr/include</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译安装</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">make</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> make</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们回到我们的Cmake项目中来，在<code>cmake</code>文件夹下新建一个FindAdd.cmake的文件。我们的目标是找到库的头文件所在目录和<a href="https://zhida.zhihu.com/search?content_id=109768348&amp;content_type=Article&amp;match_order=1&amp;q=%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">共享库文件</a></p><p>的所在位置。</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" data-title="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 在指定目录下寻找头文件和动态库文件的位置，可以指定多个目标路径</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">find_path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ADD_INCLUDE_DIR libadd.h /usr/include/ /usr/local/include </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\${CMAKE_SOURCE_DIR}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/ModuleMode)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">find_library</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ADD_LIBRARY </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">NAMES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> add </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">PATHS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /usr/lib/add /usr/local/lib/add </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\${CMAKE_SOURCE_DIR}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/ModuleMode)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (ADD_INCLUDE_DIR </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ADD_LIBRARY)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ADD_FOUND </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">TRUE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">endif</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (ADD_INCLUDE_DIR </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ADD_LIBRARY)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时我们便可以像引用curl一样引入我们自定义的库了。</p><p>在CMakeLists.txt中添加</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" data-title="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将项目目录下的cmake文件夹加入到CMAKE_MODULE_PATH中，让find_pakcage能够找到我们自定义的函数库</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">CMAKE_MODULE_PATH</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;\${CMAKE_SOURCE_DIR}/cmake;\${CMAKE_MODULE_PATH}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add_executable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(addtest addtest.cc)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">find_package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ADD)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ADD_FOUND)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    target_include_directories</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(addtest PRIVATE </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\${ADD_INCLUDE_DIR}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    target_link_libraries</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(addtest </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\${ADD_LIBRARY}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ADD_FOUND)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    message</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(FATAL_ERROR </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;ADD library not found&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">endif</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ADD_FOUND)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="默认路径" tabindex="-1"><a class="header-anchor" href="#默认路径"><span>默认路径</span></a></h4><h4 id="创建自己的包" tabindex="-1"><a class="header-anchor" href="#创建自己的包"><span>创建自己的包</span></a></h4><h2 id="纯头文件问题" tabindex="-1"><a class="header-anchor" href="#纯头文件问题"><span>纯头文件问题</span></a></h2><p>以cpp-httplib为例</p><p>这种也会有提供 <code>FindBrotli.cmake</code> 和 <code>httplibConfig.cmake.in</code> 文件，在repo/cmake文件夹里。但是假如说没提供我又不想自己写 <code>.cmake</code>，或者说我就是不想clone整个仓库，只想下载那个 <code>.h</code> 文件直接就使用了，这时是不是不能用 <code>find_package</code> 找包？</p><p>是的，这时 <code>find_package</code> 无法正常工作。要么你就把仓库提供的cmake相关文件下载下来，要么你就不找包了，将该文件当作工程文件来正常编译使用。</p><p>后者的方法：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">include_directories</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">$</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">CMAKE_SOURCE_DIR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">external</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">httplib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,58)]))}const c=l(r,[["render",h],["__file","Cpp包管理工具find_package.html.vue"]]),o=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/03.%20%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/03.%20%E5%BA%93%E6%88%96%E5%8C%85%E7%AE%A1%E7%90%86/BackEnd/Cpp%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7find_package.html","title":"Cpp包管理工具find_package","lang":"zh-CN","frontmatter":{"description":"Cpp包管理工具find_package 参考： Cmake之深入理解find_package()的用法 “轻松搞定CMake”系列之find_package用法详解 find_package 命令详解 搜包过程、两种工作模式 首先我们需要明确一点，CMake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由CMake代码完成，也就是上...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/03.%20%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/03.%20%E5%BA%93%E6%88%96%E5%8C%85%E7%AE%A1%E7%90%86/BackEnd/Cpp%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7find_package.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Cpp包管理工具find_package"}],["meta",{"property":"og:description","content":"Cpp包管理工具find_package 参考： Cmake之深入理解find_package()的用法 “轻松搞定CMake”系列之find_package用法详解 find_package 命令详解 搜包过程、两种工作模式 首先我们需要明确一点，CMake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由CMake代码完成，也就是上..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Cpp包管理工具find_package\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Cpp包管理工具find_package","slug":"cpp包管理工具find-package","link":"#cpp包管理工具find-package","children":[{"level":2,"title":"find_package 命令详解","slug":"find-package-命令详解","link":"#find-package-命令详解","children":[]},{"level":2,"title":"搜包过程、两种工作模式","slug":"搜包过程、两种工作模式","link":"#搜包过程、两种工作模式","children":[{"level":3,"title":"### 两种工作模式","slug":"两种工作模式","link":"#两种工作模式","children":[{"level":4,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":4,"title":"查找顺序、流程","slug":"查找顺序、流程","link":"#查找顺序、流程","children":[]},{"level":4,"title":"提前比较、区别、选用建议","slug":"提前比较、区别、选用建议","link":"#提前比较、区别、选用建议","children":[]}]},{"level":3,"title":"Module模式","slug":"module模式","link":"#module模式","children":[{"level":4,"title":"用法","slug":"用法","link":"#用法","children":[]},{"level":4,"title":"查找顺序","slug":"查找顺序","link":"#查找顺序","children":[]}]},{"level":3,"title":"Config模式","slug":"config模式","link":"#config模式","children":[{"level":4,"title":"用法","slug":"用法-1","link":"#用法-1","children":[]},{"level":4,"title":"查找顺序","slug":"查找顺序-1","link":"#查找顺序-1","children":[]}]}]},{"level":2,"title":"内置模块、非官方库、自己的库","slug":"内置模块、非官方库、自己的库","link":"#内置模块、非官方库、自己的库","children":[{"level":3,"title":"通过Cmake内置模块引入依赖包","slug":"通过cmake内置模块引入依赖包","link":"#通过cmake内置模块引入依赖包","children":[]},{"level":3,"title":"通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）","slug":"通过find-package引入非官方的库-该方式只对支持cmake编译安装的库有效","link":"#通过find-package引入非官方的库-该方式只对支持cmake编译安装的库有效","children":[]},{"level":3,"title":"Module模式与Config模式","slug":"module模式与config模式","link":"#module模式与config模式","children":[]},{"level":3,"title":"编写自己的 Find<LibraryName>.cmake 模块","slug":"编写自己的-find-libraryname-cmake-模块","link":"#编写自己的-find-libraryname-cmake-模块","children":[{"level":4,"title":"默认路径","slug":"默认路径","link":"#默认路径","children":[]},{"level":4,"title":"创建自己的包","slug":"创建自己的包","link":"#创建自己的包","children":[]}]}]},{"level":2,"title":"纯头文件问题","slug":"纯头文件问题","link":"#纯头文件问题","children":[]}]}],"git":{},"readingTime":{"minutes":12.18,"words":3653},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具find_package.md","excerpt":"\\n<p>参考：</p>\\n<ul>\\n<li><a href=\\"https://zhuanlan.zhihu.com/p/97369704\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Cmake之深入理解find_package()的用法</a></li>\\n<li><a href=\\"https://blog.csdn.net/zhanghm1995/article/details/105466372\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">“轻松搞定CMake”系列之find_package用法详解</a></li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"Cpp包管理工具","link":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具.html"},{"title":"Cpp包管理工具Vcpkg","link":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具Vcpkg.html"}],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具find_package.md","value":{"title":"Cpp包管理工具find_package","path":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具find_package.md","outlink":[],"backlink":["MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具.md","MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具Vcpkg.md"]}},{"id":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具.md","value":{"title":"Cpp包管理工具","path":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具.md","outlink":[],"backlink":[]}},{"id":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具Vcpkg.md","value":{"title":"Cpp包管理工具Vcpkg","path":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具Vcpkg.md","outlink":[],"backlink":[]}}],"links":[{"source":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具.md","target":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具find_package.md"},{"source":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具Vcpkg.md","target":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/03. 多项目管理/03. 库或包管理/BackEnd/Cpp包管理工具find_package.md"}]}}}');export{c as comp,o as data};
