import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,a}from"./app-Bmv5Ekr9.js";const e={},d=a(`<h1 id="《深入了解计算机系统》" tabindex="-1"><a class="header-anchor" href="#《深入了解计算机系统》"><span>《深入了解计算机系统》</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><p>[toc]</p><h1 id="程序的机器级表示" tabindex="-1"><a class="header-anchor" href="#程序的机器级表示"><span>程序的机器级表示</span></a></h1><p>详见汇编笔记</p><table><thead><tr><th>机器位数（字长、PC的大小）</th><th>可以指向多少个内存地址</th><th>可以使用多大的随机访问存储器</th><th>补充</th></tr></thead><tbody><tr><td>16位（2B）微处理器</td><td>2<sup>16</sup></td><td>64KB（2<sup>16</sup>B）</td><td></td></tr><tr><td>32位（4B）</td><td>2<sup>32</sup></td><td>4GB（2<sup>32</sup>B）</td><td></td></tr><tr><td>64位（8B）</td><td>2<sup>64</sup></td><td>16EB（2<sup>64</sup>B）（2000亿亿B）</td><td>比TB后面还有个PB拍字节，才到EB艾字节</td></tr><tr><td>现代的64位（6B）</td><td>2<sup>48</sup></td><td>256TB（2<sup>48</sup>B）</td><td>现在的64位：被限制前16位为0，只能用后48位</td></tr></tbody></table><p>用十进制可能容易理解点：4位数能表示1万个数，8位数能表示1亿，16位数能表示1万亿个数，64位数能表示10<sup>64</sup>个数</p><blockquote><p>旁注：IA32，为x86-64的32位前身</p></blockquote><h2 id="历史观点" tabindex="-1"><a class="header-anchor" href="#历史观点"><span>历史观点</span></a></h2><p>Intel处理器的历史发展（影响机器级编程的特性）</p><table><thead><tr><th>处理器版本</th><th>年份</th><th style="text-align:right;">晶体管数量</th><th>补充</th></tr></thead><tbody><tr><td>8086</td><td>1978</td><td style="text-align:right;">29 K</td><td>第一代单芯片、16位微处理器之一</td></tr><tr><td>80286</td><td>1982</td><td style="text-align:right;">134 K</td><td></td></tr><tr><td>i386</td><td>1985</td><td style="text-align:right;">275 K</td><td>将体系结构扩展到32位</td></tr><tr><td>i486</td><td>1989</td><td style="text-align:right;">1.2 M</td><td></td></tr><tr><td>Pentium</td><td>1993</td><td style="text-align:right;">3.1 M</td><td></td></tr><tr><td>PentiumPro</td><td>1995</td><td style="text-align:right;">5.5 M</td><td>P6微体系结构，指令集增加一类“条件传送”指令</td></tr><tr><td>Peitium/MMX</td><td>1997</td><td style="text-align:right;">4.5 M</td><td></td></tr><tr><td>Pentium II</td><td>1997</td><td style="text-align:right;">7 M</td><td>P6微体系结构的延伸</td></tr><tr><td>Pertium III</td><td>1999</td><td style="text-align:right;">8.2 M</td><td></td></tr><tr><td>Pertium 4</td><td>2000</td><td style="text-align:right;">42 M</td><td></td></tr><tr><td>Pertium 4E</td><td>2004</td><td style="text-align:right;">125 M</td><td>增加超线程，且增加64位扩展（x86-64）</td></tr><tr><td>Core 2</td><td>2006</td><td style="text-align:right;">291 M</td><td>第一个多核微处理器，但不支持超线程</td></tr><tr><td>Core i7，Nehalem</td><td>2008</td><td style="text-align:right;">781 M</td><td>既支持超线程，也有多核</td></tr><tr><td>Core i7，Sandy Bridge</td><td>2011</td><td style="text-align:right;">1.17 G</td><td></td></tr><tr><td>Core i7，Haswell</td><td>2013</td><td style="text-align:right;">1.4 G</td><td></td></tr></tbody></table><ul><li>机器语言有很多特性只有从历史的观点来看才有意义（当时技术有限做了很多妥协）</li><li>且每个后继处理器设计都提供了向后兼容的特性</li></ul><p>所以指令集有很多奇怪的东西</p><blockquote><p>摩尔定律：18个月一翻</p></blockquote><h2 id="程序编码" tabindex="-1"><a class="header-anchor" href="#程序编码"><span>程序编码</span></a></h2><p>Unix命令行编译C程序中的两个文件（p1.c和p2.c）</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-Og</span> <span class="token parameter variable">-o</span> p p1.c p2.c
<span class="token comment"># ggc：GCC C编译器，是Linux上默认的编译器</span>
<span class="token comment"># -Og：使用生成符合原始C代码整体结构的机器代码优化等级，而不适用较高级别的优化，以便学习</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再重复一下第一大章的内容：</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
A<span class="token text string">[源程序-文本-hello.c]</span><span class="token arrow operator">--</span>预处理器-cpp<span class="token arrow operator">--&gt;</span>
B<span class="token text string">[修改了的源程序-文本-hello.i]</span><span class="token arrow operator">--</span>编译器-ccl<span class="token arrow operator">--&gt;</span>
C<span class="token text string">[汇编程序-文本-hello.s]</span><span class="token arrow operator">--</span>汇编器-as<span class="token arrow operator">--&gt;</span>
D<span class="token text string">[可重定位目标程序-二进制-hello.o]</span><span class="token arrow operator">--</span>链接器-ld<span class="token arrow operator">--&gt;</span>
E<span class="token text string">[可执行目标程序-二进制-hello]</span>

F<span class="token text string">[C编译器提供的标准C库中的函数对应文件-二进制-print.o]</span><span class="token arrow operator">--</span>链接器-ld<span class="token arrow operator">--&gt;</span>E
G<span class="token text string">[系统头文件-文本-stdio.h]</span><span class="token arrow operator">--</span>预处理器-cpp<span class="token arrow operator">--&gt;</span>B
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="机器级代码" tabindex="-1"><a class="header-anchor" href="#机器级代码"><span>机器级代码</span></a></h3><p>机器级编程（像计算机系统那样）使用了多种抽象，其中两种尤为重要</p><ol><li><p>由<code>指令集体系结构或指令集架构（Instruction Set Architecture，ISA）</code>来定义机器级程序的格式和行为</p><p>如：将程序行为描述成好像每条指令都是按顺序执行的</p></li><li><p>机器级程序使用的内存地址是虚拟地址</p></li></ol><p>区别</p><blockquote><ul><li>汇编与二进制相比：拥有可读性更好的文本格式表示</li><li>机器代码和C相比： <ul><li>一些通常对C语言程序猿隐藏的处理器状态都是可见的，如： <ul><li>程序计数器（PC，x86-64中用<code>%rip</code>表示）给出将要执行的下条指令在内存中的地址</li><li>整数寄存器文件</li><li>条件码寄存器</li><li>向量寄存器</li></ul></li><li>C语言提供声明的数据类型，机器语言不区分各种数，甚至不区分指针和整数</li></ul></li></ul></blockquote><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h3><blockquote><h4 id="linux编译器和反汇编器的使用" tabindex="-1"><a class="header-anchor" href="#linux编译器和反汇编器的使用"><span>Linux编译器和反汇编器的使用</span></a></h4></blockquote><p>gcc和g++都可以编译C/C++，但教程上一般是gcc对C，gcc汇编，g++对C++，具体的这里不再深入</p><p>两者的用法几乎完全一致</p><table><thead><tr><th>linux指令（<code>gcc</code>与<code>objdump</code>）</th><th>操作</th><th>生成文件</th><th>文件补充</th></tr></thead><tbody><tr><td><code>gcc -Og -S main.c</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>可以文本方式打开阅读汇编代码</td></tr><tr><td><code>gcc -Og -S -masm=intel main.c</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>还可以生成Intel格式的代码（没区别？）</td></tr><tr><td><code>gcc -Og -c main.c</code></td><td>编译+汇编</td><td>二进制文件<code>main.o</code></td><td><code>sudo ./main.o</code>可运行该文件</td></tr><tr><td><code>gcc -Og -o prog main.c hello.c</code></td><td>编译+汇编+链接</td><td>二进制文件<code>prog</code></td><td><code>sudo ./prog</code>可运行该文件</td></tr><tr><td><code>gcc main.c</code></td><td>编译+汇编+链接</td><td>二进制文件<code>a.out</code></td><td><code>sudo ./a.out</code>可运行该文件</td></tr><tr><td>——————</td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td><code>g++ -S main.cpp</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>可以文本方式打开阅读汇编代码</td></tr><tr><td><code>g++ -c main.cpp</code></td><td>编译+汇编</td><td>二进制文件<code>main.o</code></td><td><code>sudo ./main.o</code>可运行该文件</td></tr><tr><td><code>g++ -o [world] main.cpp</code></td><td>编译+汇编+链接</td><td>二进制文件<code>main</code> (或<code>world</code>)</td><td><code>sudo ./prog</code>可运行该文件</td></tr><tr><td><code>g++ main.cpp</code></td><td>编译+汇编+链接</td><td>二进制文件<code>a.out</code></td><td><code>sudo ./a.out</code>可运行该文件</td></tr><tr><td>——————</td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td><code>objdump -d mstore.o</code></td><td>反汇编二进制代码</td><td>不生成，在终端显示结果</td><td></td></tr><tr><td><code>objdump -d prog</code></td><td>反汇编二进制代码</td><td>不生成，在终端显示结果</td><td></td></tr></tbody></table><p><strong>表格补充：如进行链接，则必须要有一个main函数</strong></p><p>反编译器（disassembler）补充：反汇编特性：</p><ul><li><p>指令长度：x86-64的从1-15个字节不等，常用指令和操作数较少的指令所需的字节数少（反之）</p></li><li><p>设计指令格式的方式：从某个给定位置开始可以唯一性解码（如：只有pushq %rbx是以字节值53开头的）</p></li><li><p>指令名：反汇编使用的指令命名规则和GCC生成的有细微差别（如：末尾的q）</p></li></ul><blockquote><h4 id="实验代码" tabindex="-1"><a class="header-anchor" href="#实验代码"><span>实验代码</span></a></h4></blockquote><p>C语言代码<code>main.c</code></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> d<span class="token punctuation">;</span>
    <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;2*3 --&gt; %ld\\n&quot;</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">long</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> s <span class="token operator">=</span> a<span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C语言代码<code>mstore.c</code></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回两数相乘的值，来自main.c文件的函数</span>

<span class="token keyword">void</span> <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>dest<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 把前两参相乘的值给第三参，提供给main.c文件用</span>
    <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token function">mult2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>dest <span class="token operator">=</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><h4 id="汇编代码结果" tabindex="-1"><a class="header-anchor" href="#汇编代码结果"><span>汇编代码结果</span></a></h4></blockquote><p><code>mstore.c</code>编译的汇编代码<code>mstore.s</code>（忽略以.开头的伪指令）</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code># void multstore(long x, long y, long *dest)
# x in %rdi, y in %rsi, dest in %rdx
   
multstore:
	pushq	%rbx			# Save %rbx
	movq	%rdx, %rbx		# Copy dest to %rbx
	call	mult2			# Call mult2(x, y)
	movq	%rax, (%rbx)	# Store result at *dest
	popq	%rbx			# Restore %rbx
	ret						# Return (默认返回%rax，这里没有操作%rax，即返回0)

# 每个缩进行对应一条机器指令，一条机器指令只能执行一个非常基础的操作
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>mstore.c</code>编译并汇编的机器代码<code>mstore.o</code></p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 14字节序列的16进制显示：</span>
<span class="token number">53</span> <span class="token number">48</span> <span class="token number">89</span> d3 e8 00 00 00 00 <span class="token number">48</span> <span class="token number">89</span> 03 5b c3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>mstore.o</code>反汇编生成的类汇编代码<code>mstore.s</code>，略有不同应该是因为之前汇编器改进了一些程序，反编译应该原编译程序更精准</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code># 右侧部分为注解

0000000000000000 &lt;multstore&gt;:
    0:	53						push	%rbx
    1:	48 89 d3				mov		%rdx,%rbx
    4:	e8 00 00 00 00			callq	9 &lt;multstore+0x9&gt;
    9:	48 89 03				mov		%rax,(%rbx)
    c:	5b						pop		%rbx
    d:	c3						retq
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一个C语言程序<code>main.c</code></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;studio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把前两参相乘的值给第三参，来自mstore.c文件</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 格式化输出2,3相乘的结果</span>
    <span class="token keyword">long</span> d<span class="token punctuation">;</span>
    <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;2 * 3 --&gt; %1d\\n&quot;</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">long</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 返回两数相乘的值，提供给mstore.c文件用</span>
    <span class="token keyword">long</span> s <span class="token operator">=</span> a<span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>main.c</code>和<code>mstore.c</code>生成可执行文件<code>prop</code>再反汇编为类汇编代码<code>prop.s</code>（和<code>mstore.c</code>反汇编的代码几乎一样）</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>0000000000400540 &lt;multstore&gt;:
	400540:		53					push	%rbx
	400541:		48 89 d3			mov		%rdx,%rbx
	400544:		e8 42 00 00 00		callq	40058b &lt;mult2&gt;
    400549:		48 89 03			mov		%rax,(%rbx)
	40054c:		5b					pop		%rbx
	40054d:		c3					retq
	40054e:		90					nop
	40054f:		90					nop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="关于格式的注解" tabindex="-1"><a class="header-anchor" href="#关于格式的注解"><span>关于格式的注解</span></a></h3><p>解释汇编代码：见前</p><p>旁注：可以在C程序中插入汇编代码，有两种方法：</p><ul><li>编写完整函数到独立的汇编代码文件，再用汇编器和链接器合并起来</li><li>GCC的内联汇编特性，在C中包含简短的汇编代码</li></ul>`,52),o=[d];function l(p,c){return n(),s("div",null,o)}const u=t(e,[["render",l],["__file","03. 程序的机器级表示.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/01.%20%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C/03.%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA.html","title":"《深入了解计算机系统》","lang":"zh-CN","frontmatter":{"description":"《深入了解计算机系统》 目录 [toc] 程序的机器级表示 详见汇编笔记 用十进制可能容易理解点：4位数能表示1万个数，8位数能表示1亿，16位数能表示1万亿个数，64位数能表示1064个数 旁注：IA32，为x86-64的32位前身 历史观点 Intel处理器的历史发展（影响机器级编程的特性） 机器语言有很多特性只有从历史的观点来看才有意义（当时技术...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/01.%20%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C/03.%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《深入了解计算机系统》"}],["meta",{"property":"og:description","content":"《深入了解计算机系统》 目录 [toc] 程序的机器级表示 详见汇编笔记 用十进制可能容易理解点：4位数能表示1万个数，8位数能表示1亿，16位数能表示1万亿个数，64位数能表示1064个数 旁注：IA32，为x86-64的32位前身 历史观点 Intel处理器的历史发展（影响机器级编程的特性） 机器语言有很多特性只有从历史的观点来看才有意义（当时技术..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《深入了解计算机系统》\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《深入了解计算机系统》","slug":"《深入了解计算机系统》","link":"#《深入了解计算机系统》","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"程序的机器级表示","slug":"程序的机器级表示","link":"#程序的机器级表示","children":[{"level":2,"title":"历史观点","slug":"历史观点","link":"#历史观点","children":[]},{"level":2,"title":"程序编码","slug":"程序编码","link":"#程序编码","children":[{"level":3,"title":"机器级代码","slug":"机器级代码","link":"#机器级代码","children":[]},{"level":3,"title":"代码示例","slug":"代码示例","link":"#代码示例","children":[]},{"level":3,"title":"关于格式的注解","slug":"关于格式的注解","link":"#关于格式的注解","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.77,"words":2031},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《深入理解计算机系统》/01. 程序结构和执行/03. 程序的机器级表示.md","autoDesc":true}');export{u as comp,m as data};
