import{_ as n,e as a,g as l,o}from"./app-CuJixpuN.js";const t={};function i(r,e){return o(),a("div",null,e[0]||(e[0]=[l('<h1 id="_02-编程原理-入门篇" tabindex="-1"><a class="header-anchor" href="#_02-编程原理-入门篇"><span>02. 编程原理 - 入门篇</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="入门" tabindex="-1"><a class="header-anchor" href="#入门"><span>入门</span></a></h1><h2 id="概念、底层原理-通用" tabindex="-1"><a class="header-anchor" href="#概念、底层原理-通用"><span>概念、底层原理（通用）</span></a></h2><ul><li><strong>函数原型</strong><ul><li>内容：使用函数前，C/C++编译器必须知道函数的<code>参数类型</code>和<code>返回值类型</code>，函数原型将提供这些信息</li><li>与定义区别：原型只描述函数接口（发送的信息和返回的信息），定义则包含了函数的代码</li></ul></li><li><strong>提供函数原型方法</strong><ul><li>源代码文件中输入函数原型</li><li>或在头文件中定义其原型</li></ul></li><li><strong>返回值</strong><ul><li>一些语言将由返回值的函数称为函数（function），没有返回值的函数被称为过程（procedure）或子程序（subroutine）</li><li>但C++/C，将这两种变体都称为函数</li></ul></li></ul><h2 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h2><h2 id="常量的运算和使用时的底层原理" tabindex="-1"><a class="header-anchor" href="#常量的运算和使用时的底层原理"><span>常量的运算和使用时的底层原理</span></a></h2><h3 id="常量也需要设置存储内存的类型" tabindex="-1"><a class="header-anchor" href="#常量也需要设置存储内存的类型"><span>常量也需要设置存储内存的类型</span></a></h3><p>在常量的运算和使用中，常数需要使用内存空间来存储，而至于使用什么类型的内存空间呢？</p><p>可以进行显式标注或由程序隐式决定，以C/C++为例说明：</p><ul><li><p>显式标注（带后缀）</p><ul><li>long：<code>l</code>或<code>L</code></li><li>unsigned：<code>u</code>或<code>U</code></li><li>或者组合使用，如<code>ul</code>、<code>ll</code>、<code>ull</code></li></ul></li><li><p>隐式判断（不带后缀）</p><ul><li><p>不标明会自动判断，如在16位平台上（INT_MAX=32767，LONG_MIN=2147483648）：</p><p>20000被表示为int，40000被表示为long，3000000000被表示为longlong</p></li></ul></li></ul><h3 id="举例佐证" tabindex="-1"><a class="header-anchor" href="#举例佐证"><span>举例佐证</span></a></h3><ul><li>不定义时使用常量时往往要加后缀，以便进行存储内存的类型选择，如进行加法运算标注后缀<code>l</code>，进行除法运算标注后缀<code>f</code></li><li>在早期C++的Release 2.0之前，<code>cout &lt;&lt; &#39;A&#39;</code>会把<code>A</code>自动存储为int类型，然后打印<code>65</code>，<code>cout &lt;&lt; c_A</code>则没有该情况</li></ul><h2 id="哈希表" tabindex="-1"><a class="header-anchor" href="#哈希表"><span>哈希表</span></a></h2><p>百度百科</p><blockquote><p>本词条由<a href="https://baike.baidu.com/science" target="_blank" rel="noopener noreferrer">“科普中国”科学百科词条编写与应用工作项目</a> 审核 。</p><p><a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933" target="_blank" rel="noopener noreferrer">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener noreferrer">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288" target="_blank" rel="noopener noreferrer">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097" target="_blank" rel="noopener noreferrer">数组</a>叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933" target="_blank" rel="noopener noreferrer">散列表</a>。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p></blockquote>',16)]))}const d=n(t,[["render",i],["__file","02. 编程原理 - 入门篇.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/01.%20ALL/02.%20%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%20-%20%E5%85%A5%E9%97%A8%E7%AF%87.html","title":"02. 编程原理 - 入门篇","lang":"zh-CN","frontmatter":{"description":"02. 编程原理 - 入门篇 目录 入门 概念、底层原理（通用） 函数原型 内容：使用函数前，C/C++编译器必须知道函数的参数类型和返回值类型，函数原型将提供这些信息 与定义区别：原型只描述函数接口（发送的信息和返回的信息），定义则包含了函数的代码 提供函数原型方法 源代码文件中输入函数原型 或在头文件中定义其原型 返回值 一些语言将由返回值的函数称...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/01.%20ALL/02.%20%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%20-%20%E5%85%A5%E9%97%A8%E7%AF%87.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"02. 编程原理 - 入门篇"}],["meta",{"property":"og:description","content":"02. 编程原理 - 入门篇 目录 入门 概念、底层原理（通用） 函数原型 内容：使用函数前，C/C++编译器必须知道函数的参数类型和返回值类型，函数原型将提供这些信息 与定义区别：原型只描述函数接口（发送的信息和返回的信息），定义则包含了函数的代码 提供函数原型方法 源代码文件中输入函数原型 或在头文件中定义其原型 返回值 一些语言将由返回值的函数称..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"02. 编程原理 - 入门篇\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":2.16,"words":649},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/归纳总结/01. ALL/02. 编程原理 - 入门篇.md","excerpt":"\\n<h1>目录</h1>\\n<h1>入门</h1>\\n<h2>概念、底层原理（通用）</h2>\\n<ul>\\n<li><strong>函数原型</strong>\\n<ul>\\n<li>内容：使用函数前，C/C++编译器必须知道函数的<code>参数类型</code>和<code>返回值类型</code>，函数原型将提供这些信息</li>\\n<li>与定义区别：原型只描述函数接口（发送的信息和返回的信息），定义则包含了函数的代码</li>\\n</ul>\\n</li>\\n<li><strong>提供函数原型方法</strong>\\n<ul>\\n<li>源代码文件中输入函数原型</li>\\n<li>或在头文件中定义其原型</li>\\n</ul>\\n</li>\\n<li><strong>返回值</strong>\\n<ul>\\n<li>一些语言将由返回值的函数称为函数（function），没有返回值的函数被称为过程（procedure）或子程序（subroutine）</li>\\n<li>但C++/C，将这两种变体都称为函数</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/归纳总结/01. ALL/02. 编程原理 - 入门篇.md","value":{"title":"02. 编程原理 - 入门篇","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/归纳总结/01. ALL/02. 编程原理 - 入门篇.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{d as comp,p as data};
