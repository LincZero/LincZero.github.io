import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as i,a as n}from"./app-Bmv5Ekr9.js";const e="/assets/image-20240228220139063-BFsx_unB.png",s="/assets/image-20240228220150918-CBYLwp-P.png",t="/assets/image-20240228220621158-FrL5_u9b.png",p={},o=n(`<h1 id="操作系统-cpu管理" tabindex="-1"><a class="header-anchor" href="#操作系统-cpu管理"><span>操作系统 - CPU管理</span></a></h1><h2 id="启动流程" tabindex="-1"><a class="header-anchor" href="#启动流程"><span>启动流程</span></a></h2><p>细节不同系统不同</p><p>物理存储</p><ul><li>磁盘 <ul><li>Bootloader (且在磁盘的第一个主引导扇区，且512MB。自己写系统的话首先就会先接触这个东西)</li><li>OS</li></ul></li><li>主板内存 <ul><li>BIOS</li></ul></li></ul><p>流程</p><ol><li>CPU执行BIOS指令：(1) 自检，(2) 加载 BootLoader 的内存</li><li>CPU执行BootLoader指令：将OS和数据加载到内存</li><li>CPU执行OS指令：(1) 开始操作系统初始化工作，(2) 创建各种应用，(3) 直至启动完成</li></ol><p>操作系统、CPU、内存三者 关系：CPU不断从内存中取出操作系统/应用的指令执行</p><h2 id="内核态-vs-用户态" tabindex="-1"><a class="header-anchor" href="#内核态-vs-用户态"><span>内核态 vs 用户态</span></a></h2><h3 id="vs" tabindex="-1"><a class="header-anchor" href="#vs"><span>vs</span></a></h3><p>运行的东西</p><ul><li>软件 <ul><li>用户态：应用程序、用户接口程序</li><li>内核态：操作系统</li></ul></li><li>硬件</li></ul><p>权限</p><ul><li>用户态：只能执行一部分机器指令 (mov、add、sub、push、ret ……)</li><li>内核态：完全访问所有的硬件 (in、out、……等特权指令，能控制计算机、直接操作硬件)</li></ul><p>定义</p><ul><li>用户态：应用程序在运行时CPU所属的状态，此时CPU为低级别，不能直接访问某些机器指令，或不能直接访问I/O</li><li>内核态：操作系统在运行CPU所属的状态，此时CPU为高级别，可以运行任何指令（包括特权指令、直接访问I/O）</li></ul><h3 id="系统调用-用户态和内核态的切换" tabindex="-1"><a class="header-anchor" href="#系统调用-用户态和内核态的切换"><span>系统调用 - 用户态和内核态的切换</span></a></h3><h4 id="用户态-陷入-trap-内核态" tabindex="-1"><a class="header-anchor" href="#用户态-陷入-trap-内核态"><span>用户态**陷入(trap)**内核态</span></a></h4><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用链：（从上往下）</p><ol><li>用户态部分 <ol><li>应用程序部分 <ol><li>main()</li></ol></li><li>用户接口程序 (库函数 glibc) <ol><li>printf()</li><li>……</li><li>用户态write()</li></ol></li></ol></li><li>内核态部分 <ol><li>内核态write()</li><li>……</li><li>sys_write()</li><li><strong>out</strong></li></ol></li></ol><p>这里面</p><ul><li>用户态调用用户态函数有栈</li><li>内核态调用内核态函数，也有个内核栈</li><li>问题在于 —— 如何从用户态**陷入(trap)**内核态。方法： <ul><li>linux 32位操作系统：80中断</li><li>linux 64位操作系统：syscall 汇编指令</li></ul></li></ul><h5 id="_80软中断" tabindex="-1"><a class="header-anchor" href="#_80软中断"><span>80软中断</span></a></h5><p>write()会使用 <code>ENTER_KERNEL</code>，产生中断的指令，int $0x80</p><p>然后CPU会指向：系统调用中断服务程序 entry_INT80_32</p><p>……</p><p>系统调用号，用来查 系统调用表 (sys_call_table)</p><p>……</p><ol><li>用户态的寄存器保存到 pt_regs 中</li><li>在 sys_call_table 中根据调用号找到对应的函数</li><li>执行函数实现，将返回值写入 pt_regs 的 ax 位置</li><li>通过指令 iret 根据 pt_regs 恢复用户态程序</li></ol><p>64位过程差不多</p><h5 id="syscall-汇编指令" tabindex="-1"><a class="header-anchor" href="#syscall-汇编指令"><span>syscall 汇编指令</span></a></h5><p>特殊模块寄存器 (Model Specific Registers, MSR)</p><p>……</p><p>……</p><h4 id="内核态回用户态" tabindex="-1"><a class="header-anchor" href="#内核态回用户态"><span>内核态回用户态</span></a></h4><p>无</p><h2 id="cpu-和-io-设备交互" tabindex="-1"><a class="header-anchor" href="#cpu-和-io-设备交互"><span>CPU 和 IO 设备交互</span></a></h2><p>操作系统如何和外设交互，两种方式：</p><ul><li>汇编指令：in、out、mov 等 (通常都是特权指令)</li><li>中断机制</li></ul><h3 id="方式一-汇编方式" tabindex="-1"><a class="header-anchor" href="#方式一-汇编方式"><span>方式一：汇编方式</span></a></h3><h4 id="分层架构与总线" tabindex="-1"><a class="header-anchor" href="#分层架构与总线"><span>分层架构与总线</span></a></h4><figure><img src="`+e+'" alt="image-20240228220139063" tabindex="0" loading="lazy"><figcaption>image-20240228220139063</figcaption></figure><h4 id="设备控制器" tabindex="-1"><a class="header-anchor" href="#设备控制器"><span>设备控制器</span></a></h4><ul><li>设备控制器 <ul><li>命令寄存器</li><li>数据寄存器</li><li>状态寄存器</li><li>接口控制电路</li></ul></li></ul><figure><img src="'+s+'" alt="image-20240228220150918" tabindex="0" loading="lazy"><figcaption>image-20240228220150918</figcaption></figure><p>轮询 / 忙等待</p><figure><img src="'+t+'" alt="image-20240228220621158" tabindex="0" loading="lazy"><figcaption>image-20240228220621158</figcaption></figure><h4 id="端口映射io-和-内存映射io" tabindex="-1"><a class="header-anchor" href="#端口映射io-和-内存映射io"><span>端口映射IO 和 内存映射IO</span></a></h4><p>Out指令，如：<code>out 0x03B0 EAX</code>，这里的0x03B0是数据寄存器</p><ul><li><p>CPU怎么知道将数据给哪个控制器的寄存器？</p><ul><li><p>方式一：端口映射IO。操作系统为每个控制器中的寄存器设置唯一的端口号</p><p>方式二：内存映射IO。把IO设备的各个寄存器都编址，看成 “内存地址”</p><p>两种方式都有，各位有优缺点。</p><p>Windows可以这样查看：设备管理器 &gt; 选中设备右击属性 &gt; 资源 标签栏 &gt; 资源类型，会看到 “内存范围” 和 “IO范围”，分别是内存映射IO和端口映射IO</p></li></ul></li></ul><h3 id="方式二-中断机制-键盘原理" tabindex="-1"><a class="header-anchor" href="#方式二-中断机制-键盘原理"><span>方式二：中断机制 - 键盘原理</span></a></h3><p>为什么需要中断机制：在上面的基础上，不忙等待，而是充分利用CPU时间，提高CPU利用率</p><p>例如CPU通知打印机打印，并去做其他事了，那CPU怎么知道打印机设备完成了？</p><h4 id="键盘原理" tabindex="-1"><a class="header-anchor" href="#键盘原理"><span>键盘原理</span></a></h4><ol><li>键盘：输入字符 -&gt; 键盘编码器</li><li>键盘编码器：知道按了什么，上报数据给键盘控制器</li><li>键盘控制器：解码保存数据到数据寄存器</li><li>中断控制器：由中断控制器发起中断请求 (InterruptRequest)，将对应的键盘中断号发给CPU <ul><li>Windows可以这样查看：设备管理器 &gt; 选中键盘右击属性 &gt; 资源 &gt; IRQ (InterruptRequestQuest)</li></ul></li><li>CPU：维护一张中断向量表 (map&lt;中断号, 中断服务程序内存基地址&gt;)，然后CPU找到对应的地址中，对应的是 “键盘中断服务程序” <ul><li>向量表在系统初始化时就有了</li></ul></li><li>中断服务程序：具体流程 <ul><li>(1) 保存之前程序的状态</li><li>(2) IN EAX 0x03FA (将这个地址写到寄存器中)</li><li>(3) OUT 0x06B1 EAX (将寄存器内容输出到显卡)</li><li>(4) 恢复之前的程序状态</li></ul></li></ol><p>Q：中断后，CPU寄存器状态存在哪？rip、rsp、状态寄存器等，放在内存中</p><h4 id="中断机制如何提高cpu利用率" tabindex="-1"><a class="header-anchor" href="#中断机制如何提高cpu利用率"><span>中断机制如何提高CPU利用率</span></a></h4><p>（步骤序号根据打印机中断服务程序来）</p><ol><li><p>CPU指向应用程序1：该程序为打印字符串</p></li><li><p>CPU指向内核态：处理out命令进行打印，而后打印机需要10ms来处理，但CPU不等待</p></li><li><p>CPU指向应用程序2：处理其他东西 (打印机正在打印的同时)</p><p>打印机完成后，直到发出中断信号给中断控制器，中断控制器再告诉CPU</p><p>CPU去中断向量表去找，根据中断号找到 “中断服务程序内存基地址”</p></li><li><p>CPU指向打印机中断服务程序：继续处理打印相关的事项，从步骤二开始循环流程，直到中断服务程序的所有事件处理完成</p></li><li><p>CPU指向回应用程序1</p></li></ol><h3 id="dma再加速-dma-中断" tabindex="-1"><a class="header-anchor" href="#dma再加速-dma-中断"><span>DMA再加速 (DMA+中断)</span></a></h3><p>前面还是比较慢，打印1个字符中断一次，原因在于CPU参与的移动比较多</p><p>可以使用 DMA (DIrect Memory Access，直接内存访问) 机制减少CPU开销。</p><p>DMA是什么：</p><blockquote><p>DMA控制器是设备上配套的，如打印机有打印机的DMA控制器，磁盘有磁盘的DMA控制器。</p><p>DMA内容：</p><ul><li>数据源地址</li><li>数据目的地址</li><li>数据长度</li></ul></blockquote><p>新流程</p><ol><li>CPU设置DMA控制器，设置完后，其他事情都交给DMA控制器。CPU不再参与移动，DMA参与移动</li><li>DMA负责持续从内存中读取字符，并交给打印机，将所有输出完成后，才再来通知CPU返回打印机中断服务程序</li></ol><p>这种方式，不会再那么频繁去用CPU</p>',68),c=[o];function r(u,d){return a(),i("div",null,c)}const E=l(p,[["render",r],["__file","02. CPU管理.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20(%E9%9D%A2%E8%AF%95%E7%89%88)/02.%20CPU%E7%AE%A1%E7%90%86.html","title":"操作系统 - CPU管理","lang":"zh-CN","frontmatter":{"description":"操作系统 - CPU管理 启动流程 细节不同系统不同 物理存储 磁盘 Bootloader (且在磁盘的第一个主引导扇区，且512MB。自己写系统的话首先就会先接触这个东西) OS 主板内存 BIOS 流程 CPU执行BIOS指令：(1) 自检，(2) 加载 BootLoader 的内存 CPU执行BootLoader指令：将OS和数据加载到内存 CP...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20(%E9%9D%A2%E8%AF%95%E7%89%88)/02.%20CPU%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"操作系统 - CPU管理"}],["meta",{"property":"og:description","content":"操作系统 - CPU管理 启动流程 细节不同系统不同 物理存储 磁盘 Bootloader (且在磁盘的第一个主引导扇区，且512MB。自己写系统的话首先就会先接触这个东西) OS 主板内存 BIOS 流程 CPU执行BIOS指令：(1) 自检，(2) 加载 BootLoader 的内存 CPU执行BootLoader指令：将OS和数据加载到内存 CP..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"操作系统 - CPU管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"操作系统 - CPU管理","slug":"操作系统-cpu管理","link":"#操作系统-cpu管理","children":[{"level":2,"title":"启动流程","slug":"启动流程","link":"#启动流程","children":[]},{"level":2,"title":"内核态 vs 用户态","slug":"内核态-vs-用户态","link":"#内核态-vs-用户态","children":[{"level":3,"title":"vs","slug":"vs","link":"#vs","children":[]},{"level":3,"title":"系统调用 - 用户态和内核态的切换","slug":"系统调用-用户态和内核态的切换","link":"#系统调用-用户态和内核态的切换","children":[{"level":4,"title":"用户态**陷入(trap)**内核态","slug":"用户态-陷入-trap-内核态","link":"#用户态-陷入-trap-内核态","children":[{"level":5,"title":"80软中断","slug":"_80软中断","link":"#_80软中断","children":[]},{"level":5,"title":"syscall 汇编指令","slug":"syscall-汇编指令","link":"#syscall-汇编指令","children":[]}]},{"level":4,"title":"内核态回用户态","slug":"内核态回用户态","link":"#内核态回用户态","children":[]}]}]},{"level":2,"title":"CPU 和 IO 设备交互","slug":"cpu-和-io-设备交互","link":"#cpu-和-io-设备交互","children":[{"level":3,"title":"方式一：汇编方式","slug":"方式一-汇编方式","link":"#方式一-汇编方式","children":[{"level":4,"title":"分层架构与总线","slug":"分层架构与总线","link":"#分层架构与总线","children":[]},{"level":4,"title":"设备控制器","slug":"设备控制器","link":"#设备控制器","children":[]},{"level":4,"title":"端口映射IO 和 内存映射IO","slug":"端口映射io-和-内存映射io","link":"#端口映射io-和-内存映射io","children":[]}]},{"level":3,"title":"方式二：中断机制 - 键盘原理","slug":"方式二-中断机制-键盘原理","link":"#方式二-中断机制-键盘原理","children":[{"level":4,"title":"键盘原理","slug":"键盘原理","link":"#键盘原理","children":[]},{"level":4,"title":"中断机制如何提高CPU利用率","slug":"中断机制如何提高cpu利用率","link":"#中断机制如何提高cpu利用率","children":[]}]},{"level":3,"title":"DMA再加速 (DMA+中断)","slug":"dma再加速-dma-中断","link":"#dma再加速-dma-中断","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.71,"words":1714},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/操作系统 (面试版)/02. CPU管理.md","autoDesc":true}');export{E as comp,m as data};
