import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,o as r,c as o,b as e,e as n,d as l,a as i}from"./app-CyJMR3JQ.js";const c={},p=i('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="qml-编程简概" tabindex="-1"><a class="header-anchor" href="#qml-编程简概"><span>QML 编程简概</span></a></h1><p>参考：</p>',4),d={href:"http://c.biancheng.net/view/3877.html",target:"_blank",rel:"noopener noreferrer"},u=e("li",null,[n("QML文档： "),e("ul",null,[e("li",null,"个人博客：https://robinsea.github.io/2020/09/16/QmlBook/quick_starter/README/")])],-1),m=i(`<h2 id="简概-qt-quick项目" tabindex="-1"><a class="header-anchor" href="#简概-qt-quick项目"><span>简概 - Qt Quick项目</span></a></h2><h3 id="qml与qtquick" tabindex="-1"><a class="header-anchor" href="#qml与qtquick"><span>QML与QtQuick</span></a></h3><ul><li><p>QML</p><ul><li><p>概念</p><ul><li>QML（Qt Meta Language，Qt元语言）是一种用来描述应用程序界面的<strong>声明式脚本语言</strong>（这是标记语言吧）。自Qt4.7引用</li></ul></li><li><p>优点</p><ul><li>良好的易读性。以可视化组件及其交互和相互关联的方式来描述界面，使组件能在动态行为中互相连接</li></ul></li><li><p>原理</p><ul><li><p>通过Qt QML引擎在程序运行时解析并运行的</p></li><li><p>(旧) 编译器通道</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> LR
A<span class="token text string">(JS/QML)</span><span class="token arrow operator">--&gt;</span>
Lexer/Parser_词法语法分析<span class="token arrow operator">--&gt;</span>
Codegen_代码生成<span class="token arrow operator">--&gt;</span>
Optimizer_优化<span class="token arrow operator">--&gt;</span>
	Moth_Isel<span class="token arrow operator">--&gt;</span>Bytecode_字节码
Optimizer_优化<span class="token arrow operator">--&gt;</span>
	JIT_Isel<span class="token arrow operator">--&gt;</span>Assembly_装配归档
	JIT_Isel<span class="token arrow operator">--&gt;</span>Compilation_Unit_汇编单元
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>(新) 编译器通道</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> LR
A<span class="token text string">(JS/QML)</span><span class="token arrow operator">--&gt;</span>
Lexer/Parser_词法语法分析<span class="token arrow operator">--&gt;</span>
Codegen_代码生成<span class="token arrow operator">--&gt;</span>
	Bytecode_字节码<span class="token arrow operator">--&gt;</span>
	JIT<span class="token arrow operator">--&gt;</span>
	Assembly_装配归档
Codegen_代码生成<span class="token arrow operator">---&gt;</span>
	Compilation_Unit_汇编单元
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul></li><li><p>Qt Quick</p><ul><li>概念 <ul><li>是Qt为QML提供的一套类库，由QML标准类型和功能组成</li><li>包括可视化类型、交互类型、动画类型、模型和视图、粒子系统和渲染效果等</li></ul></li><li>优点 <ul><li>易于使用，在编程时只需要一条import语句就能访问这些功能</li><li>易于开发UI界面</li></ul></li></ul></li><li><p>比较 QML C++</p><ul><li>并列称为Qt的首选编程语言</li></ul></li></ul><h3 id="创建qt-quick工程" tabindex="-1"><a class="header-anchor" href="#创建qt-quick工程"><span>创建Qt Quick工程</span></a></h3><p>详见 简概 &gt; 开发流程 - 创建</p><p>创建 - 选项配置</p><ul><li>其他和普通项目选项差不多，主要注意一个新选项 <ul><li>Define Project Details：选择最低适应的Qt版本</li></ul></li></ul><h3 id="项目基本结构" tabindex="-1"><a class="header-anchor" href="#项目基本结构"><span>项目基本结构</span></a></h3><ul><li>QtQuickTest.pro</li><li>main.cpp</li><li>qml.qrc</li><li>main.qml（该文件视为qrc资源文件）</li></ul><p>pro</p><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">QT</span> <span class="token value attr-value">+= quick</span>

<span class="token key attr-name">CONFIG</span> <span class="token value attr-value">+= c++11</span>

<span class="token comment"># You can make your code fail to compile if it uses deprecated APIs.</span>
<span class="token comment"># In order to do so, uncomment the following line.</span>
<span class="token comment">#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0</span>

<span class="token key attr-name">SOURCES</span> <span class="token value attr-value">+= \\
        main.cpp</span>

<span class="token key attr-name">RESOURCES</span> <span class="token value attr-value">+= qml.qrc</span>

<span class="token comment"># Additional import path used to resolve QML modules in Qt Creator&#39;s code model</span>
<span class="token key attr-name">QML_IMPORT_PATH</span> <span class="token value attr-value">=</span>

<span class="token comment"># Additional import path used to resolve QML modules just for Qt Quick Designer</span>
<span class="token key attr-name">QML_DESIGNER_IMPORT_PATH</span> <span class="token value attr-value">=</span>

<span class="token comment"># Default rules for deployment.</span>
<span class="token key attr-name">qnx</span><span class="token punctuation">:</span> <span class="token value attr-value">target.path = /tmp/$\${TARGET}/bin</span>
<span class="token key attr-name">else</span><span class="token punctuation">:</span> <span class="token value attr-value">unix:!android: target.path = /opt/$\${TARGET}/bin</span>
<span class="token comment">!isEmpty(target.path): INSTALLS += target</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>main.cpp</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;QGuiApplication&gt;
#include &lt;QQmlApplicationEngine&gt;

int main(int argc, char *argv[])
{
#if QT_VERSION &lt; QT_VERSION_CHECK(6, 0, 0)
    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
#endif

    QGuiApplication app(argc, argv);

    QQmlApplicationEngine engine;                                       // QML引擎
    const QUrl url(QStringLiteral(&quot;qrc:/main.qml&quot;));                    // 需要加载的qml
    QObject::connect(&amp;engine, &amp;QQmlApplicationEngine::objectCreated,	// 将引擎结果关联到lambda上
                     &amp;app, [url](QObject *obj, const QUrl &amp;objUrl) {
        if (!obj &amp;&amp; url == objUrl)
            QCoreApplication::exit(-1);                                 // 无法加载则退出程序
    }, Qt::QueuedConnection);
    engine.load(url);                                                   // 用QML引擎加载qml文档

    return app.exec();                                                  // 消息循环
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>qml</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token comment">/* import部分 */</span>
import QtQuick <span class="token number">2.12</span>					<span class="token comment">// 导入Qt Quick 2.7库</span>
import QtQuick.Window <span class="token number">2.12</span>			<span class="token comment">// 导入Qt Quick 窗体库</span>

<span class="token comment">/* 对象声明部分 */</span>
Window <span class="token punctuation">{</span>							<span class="token comment">// 对象、根对象</span>
    width<span class="token operator">:</span> <span class="token number">640</span>						<span class="token comment">// 宽度属性</span>
    height<span class="token operator">:</span> <span class="token number">480</span>						<span class="token comment">// 高度属性</span>
    visible<span class="token operator">:</span> <span class="token boolean">true</span>					<span class="token comment">// 可见性属性</span>
    title<span class="token operator">:</span> qsTr(<span class="token string">&quot;Hello World&quot;</span>)		<span class="token comment">// 标题属性</span>
	MainForm <span class="token punctuation">{</span>						<span class="token comment">// 子对象</span>
        anchor.fill<span class="token operator">:</span> parent
        mouseArea.onClicked<span class="token operator">:</span> <span class="token punctuation">{</span>		<span class="token comment">// 点击的回调函数</span>
            console.log(qsTr(&#39;Clicked on background. Text<span class="token operator">:</span> <span class="token string">&quot;&#39; + textEdit.text +&#39;&quot;</span>&#39;))
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="项目分析" tabindex="-1"><a class="header-anchor" href="#项目分析"><span>项目分析</span></a></h3><p>要点如下：</p><ul><li>cpp：<code>#include &lt;QtQml&gt; </code>，包含模块类的定义</li><li>.qml：<code>import QtQml 2.15 </code>，能使用QML类型</li><li>.pro：<code>QT += qml</code>，链接模块</li></ul><h2 id="简概-qt-widgets项目" tabindex="-1"><a class="header-anchor" href="#简概-qt-widgets项目"><span>简概 - Qt Widgets项目</span></a></h2><h3 id="创建-qml-文件" tabindex="-1"><a class="header-anchor" href="#创建-qml-文件"><span>创建 QML 文件</span></a></h3><p>项目右键 &gt; Add new &gt; Qt &gt;</p><ul><li>Qt <ul><li>QML File (Qt Quick 2)，创建<code>.qml</code>QML文件 （需要注意的是，一般会将默认创建的qml放入qrc资源文件，然后可以将.pro 中 DISTFILES 列表中的qml文件删掉）</li><li><s>QtQuick UI File，创建两个文件 <code>xxx.qml</code> <code>xxxFrom.ui.qml</code></s><s>（需要注意的是，一般会将默认创建的qml放入qrc资源文件，然后可以将.pro 中 DISTFILES 列表中的qml文件删掉）</s> （新版Qt Creator把这个选项给删了）</li></ul></li></ul><h3 id="qml-与-ui-qml-区别-现在-ui-qml选项已经被删了" tabindex="-1"><a class="header-anchor" href="#qml-与-ui-qml-区别-现在-ui-qml选项已经被删了"><span><s>.qml 与 .ui.qml 区别</s>（现在.ui.qml选项已经被删了）</span></a></h3><p>简单来说就是后者有助于UI和业务分离，有点类似于这个比喻：（不确定我理解得对不对）</p><blockquote><p>.qml 类似于 .html，你可以在里面写标签和Script，也可以只写标签、另建一个文件写Script .ui.qml 类似于声明了一种新的 .html，你不能在里面写Script</p></blockquote><p>当然我个人的想法是更类似于Vue那种设计的，组件分离 First，UI业务分离 Second，两者都需要分离。</p>`,26),h=e("p",null,"[!quote]- https://www.zhihu.com/question/55353497",-1),Q=e("p",null,".qml文件，就叫QML文件。.ui.qml文件，叫QtQuick UI文件",-1),v=e("p",null,[n("对于"),e("code",null,".ui.qml"),n("文件来说，不支持以下特性：")],-1),_={href:"https://www.zhihu.com/search?q=%E6%A0%B9%E7%BB%84%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},q={href:"https://www.zhihu.com/search?q=%E7%88%B6%E7%BB%84%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},k=i("<p>在<code>.ui.qml</code>文件中，不支持下列组件类型： （1）Behavior （2）Binding （3）Canvas （4）Shader Effect （5）Timer （6）Transform</p><p>在<code>.ui.qml</code>文件中，支持的方法如下『JavaScript 函数』：</p><p>这 <code>.ui.qml</code>文件的存在是为了帮助 Qt Quick Designer。 例如，普通 QML 文件可以包含 JavaScript 表达式，但 Qt Quick Designer 很难使用这些表达式。 另一方面，普通 QML 并不那么困难，并且更接近于等价于的小部件 <code>.ui</code>文件 - 详细说明用户界面中的一组项目的文档，而不是它们背后的逻辑。</p><p>用处：</p>",4),b={href:"https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},g=e("code",null,".ui.qml",-1),L=e("code",null,".qml",-1),M={href:"https://www.zhihu.com/search?q=%E8%AE%BE%E8%AE%A1%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,"[!quote]- https://stackoverflow.com/questions/30652537/what-is-the-use-of-the-ui-qml-files-in-qt5-qml",-1),E=e("p",null,[n("这 "),e("code",null,".ui.qml"),n("文件的存在是为了帮助 Qt Quick Designer。 例如，普通 QML 文件可以包含 JavaScript 表达式，但 Qt Quick Designer 很难使用这些表达式。 另一方面，普通 QML 并不那么困难，并且更接近于等价于的小部件 "),e("code",null,".ui"),n("文件 - 详细说明用户界面中的一组项目的文档，而不是它们背后的逻辑。")],-1),C=e("p",null,"该功能 是几年前在博客上提出的",-1),A=e("blockquote",null,[e("p",null,"经典的 Widget Designer 是围绕声明式和命令式逻辑之间的区别构建的。 声明形式是可设计的并存储在 .ui 文件中。"),e("p",null,"在 Qml 中，很容易混合声明式代码和命令式代码。 如果您向 Qml 文件添加命令式指令（影响视觉方面），它们不再是纯粹的声明式，并且可视化编辑器中的可视化表示将会中断。 可视化编辑器需要一种方法将可视化描述转换回文本描述。 对于命令式代码，这通常是不可能的，Qt Quick Designer 甚至不会尝试。")],-1),w={href:"http://doc.qt.io/qt-5/qtqml-documents-topic.html",target:"_blank",rel:"noopener noreferrer"},B=e("blockquote",null,[e("p",null,"从 Qt 5.4 开始，文档也可以有文件扩展名“.ui.qml”。 QML 引擎像处理标准 .qml 文件一样处理这些文件，并忽略扩展名的 .ui 部分。 Qt Creator 将这些文件作为 Qt Quick Designer 的 UI 表单处理。 这些文件只能包含 Qt Creator 定义的 QML 语言的一个子集。")],-1),x={href:"http://doc.qt.io/qtcreator/creator-quick-ui-forms.html",target:"_blank",rel:"noopener noreferrer"},y=i("<blockquote><p>您可以使用 Qt Creator 向导创建文件扩展名为 .ui.qml 的 UI 表单。 UI 表单包含 QML 语言的纯声明子集。 建议您在设计模式下编辑表单。 但是，将项目导出为别名属性是一项仅供商业使用的功能，因此如果您使用 Qt Creator 的开源版本，则必须使用编辑模式来执行此操作。 Qt Creator 通过显示错误消息强制使用支持的 QML 功能。</p><p>不支持以下功能：</p><ul><li>JavaScript 块</li><li>函数定义</li><li>函数调用（qsTr 除外）</li><li>纯表达式以外的其他绑定</li><li>信号处理器</li><li>根项以外的其他项中的状态</li><li>不是从 QQuickItem 或 Item 派生的根项</li></ul><p>不支持以下类型：</p><ul><li>Behavior，行为</li><li>Binding，捆绑</li><li>Canvas，帆布</li><li>Component，零件</li><li>Shader Effect，着色效果</li><li>Timer，计时器</li><li>Transform，转换</li><li>Transition，过渡</li></ul></blockquote>",1),I=e("blockquote",null,[e("p",null,"[!quote]- Qt Assistant：qthelp://org.qt-project.qtqml.5128/qtqml/qtqml-index.html"),e("p",null,'从Qt 5.4开始，文档也可以有扩展名为" .ui.qml "的文件。QML引擎像处理标准的. QML文件一样处理这些文件，而忽略扩展名的.ui部分。Qt Creator将这些文件作为Qt Quick Designer的UI表单处理。这些文件只能包含Qt Creator定义的QML语言的一个子集。')],-1),T=e("h2",{id:"qml底层原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#qml底层原理"},[e("span",null,"QML底层原理")])],-1),D=e("p",null,"参考",-1),S={href:"https://link.jianshu.com?t=http://qt-project.org/doc/qt-5.0/qtqml/qtqml-index.html",target:"_blank",rel:"noopener noreferrer"},j={href:"https://www.jianshu.com/p/3e959cbaff3a",target:"_blank",rel:"noopener noreferrer"},P={href:"https://link.jianshu.com?t=http://www.kdab.com/qml-engine-internals-part-1-qml-file-loading/",target:"_blank",rel:"noopener noreferrer"},U={href:"https://blog.csdn.net/bootleader/article/details/68937159",target:"_blank",rel:"noopener noreferrer"},F={href:"https://www.pianshen.com/article/41642047038/",target:"_blank",rel:"noopener noreferrer"},R=e("h3",{id:"基本原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#基本原理"},[e("span",null,"基本原理")])],-1),N=e("li",null,[n("QML生成C++类 "),e("ul",null,[e("li",null,"QML文件中每个元素都对应于一个C++类。QML引擎在加载QML文件时，会为文件中的所有元素以某种方式创建相应的C++对象")])],-1),O={href:"https://link.jianshu.com?t=http://blog.qt.digia.com/blog/2010/05/18/a-qt-scenegraph/",target:"_blank",rel:"noopener noreferrer"},J={href:"https://link.jianshu.com?t=http://qt.gitorious.org/qt/qtdeclarative/blobs/master/src/quick/items/qquickview.h#line59",target:"_blank",rel:"noopener noreferrer"},V={href:"https://link.jianshu.com?t=http://www.kdab.com",target:"_blank",rel:"noopener noreferrer"},G={href:"https://link.jianshu.com?t=http://www.kdab.com/kdab-products/gammaray/",target:"_blank",rel:"noopener noreferrer"},z=e("li",null,"![img](01.%20QML 编程简概.assets/438086-2eb1771ce04b1370.png)",-1),W={href:"https://link.jianshu.com?t=http://blog.qt.digia.com/blog/2012/02/07/qml-profiler-update/",target:"_blank",rel:"noopener noreferrer"},H=e("h3",{id:"qml文件加载步骤",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#qml文件加载步骤"},[e("span",null,"QML文件加载步骤")])],-1),$=e("p",null,"探寻QML引擎从解析QML文件开始，到形成一棵完整的C++对象树的整个过程",-1),Z=e("p",null,"当加载QML文件时，会执行三个不同的步骤，接下来我们将深入研究这些步骤：",-1),K=e("ol",null,[e("li",null,"解析"),e("li",null,"编译"),e("li",null,"创建")],-1),Y=e("h4",{id:"解析",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#解析"},[e("span",null,"解析")])],-1),X={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/parser/qqmljs.g",target:"_blank",rel:"noopener noreferrer"},ee=e("p",null,"![img](01.%20QML 编程简概.assets/438086-608a25f403cf24b7.png)",-1),ne={href:"https://link.jianshu.com?t=http://qt.gitorious.org/qt/qtdeclarative/blobs/master/src/qml/qml/qqmlscript_p.h#line299",target:"_blank",rel:"noopener noreferrer"},te={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlscript_p.h#line230",target:"_blank",rel:"noopener noreferrer"},le={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlscript_p.h#line183",target:"_blank",rel:"noopener noreferrer"},ie=e("h4",{id:"编译",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#编译"},[e("span",null,"编译")])],-1),se={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlcompiler_p.h#line283",target:"_blank",rel:"noopener noreferrer"},ae=e("p",null,"综上所述：解析和编译QML文件都只会做一次，在此之后，都是直接使用QQmlCompiledData对象来快速创建C++对象。",-1),re=e("h4",{id:"创建",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#创建"},[e("span",null,"创建")])],-1),oe=e("p",null,"我不会深入研究QQmlCompiledData的细节，但有一个东西可能会引起你的注意：“QByteArray bytecode”成员变量。实际上，创建C++对象并给它的属性赋值的指令会被编译为了字节码，之后由字节码解析器解析！字节码包含了一堆指令，当这些指令执行时，QQmlCompiledData的其余部分仅是辅助数据。",-1),ce={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlvme_p.h",target:"_blank",rel:"noopener noreferrer"},pe=e("p",null,"（略）",-1),de=e("h4",{id:"结论",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#结论"},[e("span",null,"结论")])],-1),ue=e("p",null,"在这篇博文的最后，我们已经揭示了一个QML文件是如何进行解析、处理、编译的，以及VME是如何创建对象的。我希望你已经更加深入地理解了QML引擎。",-1),me={href:"https://www.jianshu.com/p/9b277a3ee613",target:"_blank",rel:"noopener noreferrer"};function he(Qe,ve){const t=a("ExternalLinkIcon");return r(),o("div",null,[p,e("ul",null,[e("li",null,[e("a",d,[n("【C语言中文网】学习QML还是C++？"),l(t)])]),u]),m,e("blockquote",null,[h,Q,v,e("p",null,[n("（1）JavaScript块代码。 （2）纯表达式之外的其他绑定。 （3）信号处理。 （4）在"),e("a",_,[n("根组件"),l(t)]),n("之外的其他组件中的状态。 （5）不是从QQuickItem或Item派生的根组件。 （6）引用根组件的"),e("a",q,[n("父组件"),l(t)]),n("。")]),k,e("p",null,[n("将UI与"),e("a",b,[n("应用程序"),l(t)]),n("逻辑分离是一种较好的开发方式。一般来说，设计人员应该使用UI文件("),g,n(")，而开发人员应该使用相应的实现文件("),L,n(")来定义编程行为或编写JavaScript代码。通过这种方式，可以使得"),e("a",M,[n("设计端"),l(t)]),n("和开发端都可以进行迭代，而不会出现覆盖彼此工作的问题。")])]),e("blockquote",null,[f,E,C,A,e("p",null,[e("a",w,[n("QML 文档 "),l(t)]),n("文档指出")]),B,e("p",null,[e("a",x,[n("Qt Quick UI 表单 "),l(t)])]),y]),I,T,D,e("ul",null,[e("li",null,[e("a",S,[n("【Qt官网文档】Qt QML"),l(t)])]),e("li",null,[e("a",j,[n("【简书】[翻译] 深入解析QML引擎， 第1部分:QML文件加载"),l(t)]),n(" （原文 "),e("a",P,[n("QML Engine Internals, Part 1: QML File Loading"),l(t)]),n("，这个解析QML引擎的文章共4篇）")]),e("li",null,[e("a",U,[n("【CSDN】Qml运行机制的理解（原创）"),l(t)])]),e("li",null,[e("a",F,[n("qml 引擎（V8）原理总结"),l(t)])])]),R,e("ul",null,[N,e("li",null,[n("绘制C++对象树 "),e("ul",null,[e("li",null,[n("这些元素将被绘制在一个"),e("a",O,[n("OpenGL scenegraph"),l(t)]),n("中，绘制及事件处理都是由"),e("a",J,[n("QQuickView"),l(t)]),n("控制的")]),e("li",null,[n("我们可以利用"),e("a",V,[n("KDAB"),l(t)]),n("的Qt自检工具"),e("a",G,[n("GammaRay"),l(t)]),n("来验证QML文件对应的C++对象树")]),z])]),e("li",null,[n("用"),e("a",W,[n("QML分析器（QML profiler）"),l(t)]),n("来运行并分析")])]),H,$,Z,K,Y,e("p",null,[n("首先，QML文件是由QQmlScript::Parser这个解析器来解析的。该解析器内部的绝大多数内容都是由��"),e("a",X,[n("语法文件"),l(t)]),n("自动生成的。我们这个例子的抽象语法树（AST）看起来是这样的：")]),ee,e("p",null,[n("这个AST是比较底层的东西，紧接着，它将被转换成更高层级结构的"),e("a",ne,[n("对象"),l(t)]),n("，"),e("a",te,[n("属性"),l(t)]),n("和"),e("a",le,[n("值"),l(t)]),n("。这是通过使用一个访问器遍历AST来完成的。这一步的对象就和QML中的元素一一对应上了，且对象的属性/值和QML元素的属性/值也一一对应上。我们的例子中Rectangle元素的属性“color”，其对应的值是“lightsteelblue”，它们就是属性/值的关系。即使像onClicked这样的信号处理程序也被看作只是属性/值的关系，属性是onClicked，值就是JavaScript函数体。")]),ie,e("p",null,[n("在理论上，对象，属性和值已经足够用于创建对应的C++对象，并给属性赋上对应的值。但这些对象，属性和值依然过于原始，在创建C++对象之前，还需要进行一些后置处理。这些后置处理是由"),e("a",se,[n("QQmlCompiler"),l(t)]),n("来完成的，这对应于QML分析器（QML profiler）输出中看到的编译阶段。该编译器会为QML文件创建了一个QQmlCompiledData对象。 用QQmlCompiledData创建C++对象比直接使用对象、属性和值来创建C++对象快了很多。当多次使用同一个QML文件，该文件也只会编译一次。比如在一个工程中，其他所有的QML文件都会用到的Button.qml，编译时Button.qml只会被编译一次。Button.qml的QQmlCompiledData会一直保存，每次使用该按钮组件时，都会根据这个Button.qml的QQmlCompiledData来创建C++对象。在编译之后，就是创建阶段，这在QML分析器（QML profiler）的输出中可以看到。")]),ae,re,oe,e("p",null,[n("在创建阶段，字节码是由"),e("a",ce,[n("QQmlVME"),l(t)]),n("类解析的。阅读QQmlVME::run（）这个函数的代码，里面有一个循环用于遍历字节码包含的所有指令，在循环体内部，有一个很大的判定不同指令类型的switch语句。运行带有QML_COMPILER_DUMP=1的例子程序，我们可以看到字节码所包含的每个指令：")]),pe,de,ue,e("p",null,[n("下一篇的博文（"),e("a",me,[n("绑定(Bindings)"),l(t)]),n("）将进一步探讨属性绑定是如何进行的，敬请关注！")])])}const ke=s(c,[["render",he],["__file","01. QML 编程简概.html.vue"]]),be=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/02.%20QtGUI%E7%B1%BB/02.%20QtQuick/01.%20QML/01.%20QML%20%E7%BC%96%E7%A8%8B%E7%AE%80%E6%A6%82.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 QML 编程简概 参考： 【C语言中文网】学习QML还是C++？ QML文档： 个人博客：https://robinsea.github.io/2020/09/16/QmlBook/quick_starter/README/ 简概 - Qt Quick项目 QML与QtQuick QML 概念 QML（Qt Meta Language，Qt...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/02.%20QtGUI%E7%B1%BB/02.%20QtQuick/01.%20QML/01.%20QML%20%E7%BC%96%E7%A8%8B%E7%AE%80%E6%A6%82.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 QML 编程简概 参考： 【C语言中文网】学习QML还是C++？ QML文档： 个人博客：https://robinsea.github.io/2020/09/16/QmlBook/quick_starter/README/ 简概 - Qt Quick项目 QML与QtQuick QML 概念 QML（Qt Meta Language，Qt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"QML 编程简概","slug":"qml-编程简概","link":"#qml-编程简概","children":[{"level":2,"title":"简概 - Qt Quick项目","slug":"简概-qt-quick项目","link":"#简概-qt-quick项目","children":[{"level":3,"title":"QML与QtQuick","slug":"qml与qtquick","link":"#qml与qtquick","children":[]},{"level":3,"title":"创建Qt Quick工程","slug":"创建qt-quick工程","link":"#创建qt-quick工程","children":[]},{"level":3,"title":"项目基本结构","slug":"项目基本结构","link":"#项目基本结构","children":[]},{"level":3,"title":"项目分析","slug":"项目分析","link":"#项目分析","children":[]}]},{"level":2,"title":"简概 - Qt Widgets项目","slug":"简概-qt-widgets项目","link":"#简概-qt-widgets项目","children":[{"level":3,"title":"创建 QML 文件","slug":"创建-qml-文件","link":"#创建-qml-文件","children":[]},{"level":3,"title":".qml 与 .ui.qml 区别（现在.ui.qml选项已经被删了）","slug":"qml-与-ui-qml-区别-现在-ui-qml选项已经被删了","link":"#qml-与-ui-qml-区别-现在-ui-qml选项已经被删了","children":[]}]},{"level":2,"title":"QML底层原理","slug":"qml底层原理","link":"#qml底层原理","children":[{"level":3,"title":"基本原理","slug":"基本原理","link":"#基本原理","children":[]},{"level":3,"title":"QML文件加载步骤","slug":"qml文件加载步骤","link":"#qml文件加载步骤","children":[{"level":4,"title":"解析","slug":"解析","link":"#解析","children":[]},{"level":4,"title":"编译","slug":"编译","link":"#编译","children":[]},{"level":4,"title":"创建","slug":"创建","link":"#创建","children":[]},{"level":4,"title":"结论","slug":"结论","link":"#结论","children":[]}]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":11.21,"words":3364},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/04. Project/Platform/Multi/QT（Cpp）/02. QtGUI类/02. QtQuick/01. QML/01. QML 编程简概.md","autoDesc":true}');export{ke as comp,be as data};
