import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o as a,c as i,a as l,d as s,e as n,b as e}from"./app-D3nI0jiY.js";const d={},c=n('<h1 id="竞争算法" tabindex="-1"><a class="header-anchor" href="#竞争算法"><span>竞争算法</span></a></h1><p>详细见：</p><ul><li>线程冲突：<a href="../../03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81">../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突</a></li><li>Cache冲突：[../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性](../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性)</li></ul><h2 id="竞争冲突算法-vs-竞争调度算法" tabindex="-1"><a class="header-anchor" href="#竞争冲突算法-vs-竞争调度算法"><span>竞争冲突算法 vs 竞争调度算法</span></a></h2><p>这两个词的前缀 “竞争” 我是加上的，这两个东西其实都是一种 “竞争”，但本质大有不同：</p><ul><li><p>调度算法：<em>多个任务去竞争一个处理器 / 多个数据去竞争一块内存</em>。竞争的结果是用算法去计算竞争者的<strong>优先级</strong>。</p></li><li><p>竞争算法：<em>多个处理器核/线程去竞争一个资源 (内存/Cache等)</em>，和上面反过来。竞争的结果是<strong>错峰避免同时使用</strong>。</p><p>竞争算法也可以说是<strong>一致性算法</strong> (Cache一致性或者是其他的什么一致性)</p></li></ul><h2 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h2><h3 id="冲突情景的总结" tabindex="-1"><a class="header-anchor" href="#冲突情景的总结"><span>冲突情景的总结</span></a></h3>',8),u=l("li",null,[l("p",null,"多线程冲突"),l("ul",null,[l("li",null,[e("普通内存冲突 "),l("ul",null,[l("li",null,[l("em",null,"锁"),e("：加锁、解锁操作（Test-and-Set 原子指令）")]),l("li",null,[l("em",null,"信号量"),e("：P、V 操作（P、V 原子指令）")])])])])],-1),E=l("p",null,"多核冲突",-1),p=l("p",null,[e("Cache内存冲突、即"),l("strong",null,"Cache一致性"),e("问题。"),l("em",null,"一致性算法"),e("：")],-1),h={class:"ab-note drop-shadow"},B={class:"ab-table ab-branch-table"},_=l("tr",null,[l("td",{rowspan:"7",col_index:"0",class:"markdown-rendered"},[l("div",null,[l("p",null,"低性能错误方案：")])]),l("td",{rowspan:"7",col_index:"1",class:"markdown-rendered"},[l("div",null,[l("p",null,"不独占Cache")])]),l("td",{rowspan:"2",col_index:"5",class:"markdown-rendered"},[l("div",null,[l("p",null,"DPDK方法")])]),l("td",{rowspan:"2",col_index:"6",class:"markdown-rendered"},[l("div",null,[l("p",null,"避免多个数据备份、避免多个核访问同一内存地址")])]),l("td",{rowspan:"1",col_index:"8",class:"markdown-rendered"},[l("div",null,[l("p",null,"多个核同时需要一些数据结构，为每个核都单独定义一份")])])],-1),A=l("tr",null,[l("td",{rowspan:"1",col_index:"8",class:"markdown-rendered"},[l("div",null,[l("p",null,"多个核访问同一个网卡的接收队列/发送队列，为每个核都准备一个单独的接收队列/发送队列")])])],-1),m=l("tr",null,[l("td",{rowspan:"1",col_index:"5",class:"markdown-rendered"},[l("div",null,[l("p",null,"基于目录的协议（Directory-based protocol）")])]),l("td",{rowspan:"1",col_index:"6",class:"markdown-rendered"},[l("div",null,[l("p",null,"全局统一管理")])])],-1),C=l("tr",null,[l("td",{rowspan:"1",col_index:"5",class:"markdown-rendered"},[l("div",null,[l("p",null,"总线窥探协议（Bus snooping protocol）")])]),l("td",{rowspan:"1",col_index:"6",class:"markdown-rendered"},[l("div",null,[l("p",null,"利用总线进行的分布式的广播和被通知")])])],-1),w=l("tr",null,[l("td",{rowspan:"1",col_index:"5",class:"markdown-rendered"},[l("div",null,[l("p",null,"Snarfing协议")])]),l("td",{rowspan:"1",col_index:"6",class:"markdown-rendered"},[l("div",null,[l("p",null,"在此不作讨论")])])],-1),g={rowspan:"1",col_index:"3",class:"markdown-rendered"},k=l("p",null,"寄存器内存冲突、即寄存器一致性问题？",-1),v=l("p",null,[l("strong",null,"（不一定存在。如果寄存器和Cache的数据交换是原子性的，那么不存在这个问题。问题保留，待验证）")],-1),D=l("p",null,"如果存在，但本质上感觉和Cache一致性是一个原理。Cache一致性能用的，对于寄存器内存应该也能用。",-1),x=l("p",null,"区别应该就只有对于三级Cache，不存在Cache一致性问题，只存在寄存器一致性问题。",-1),N=l("tr",null,[l("td",{rowspan:"1",col_index:"3",class:"markdown-rendered"},[l("div",null,[l("p",null,"内存冲突、内存一致性问题？"),l("p",null,[l("strong",null,"（不一定存在。感觉应该不会出现多个内存去缓存同一个硬盘数据的情况，那么就不存在这个问题。问题保留，待验证）"),e(" （搜了下好像是有这么个概念，但可能和我想象中的不同）")])])]),l("td",{rowspan:"1",col_index:"5",class:"markdown-rendered"},[l("div",null,[l("p",null,"CPU Cache缓存的是内存数据，内存缓存的是硬盘数据")])])],-1),b=l("tr",null,[l("td",{rowspan:"1",col_index:"0",class:"markdown-rendered"},[l("div",null,[l("p",null,"其他")])]),l("td",{rowspan:"1",col_index:"2",class:"markdown-rendered"},[l("div",null,[l("p",null,"MySQL的并发导致的事务隔离性问题")])]),l("td",{rowspan:"1",col_index:"3",class:"markdown-rendered"},[l("div",null,[l("p",null,"MySQL 的 MVCC（Multi-Version Concurrency Control，多版本并发控制）")])])],-1),F=n('<h3 id="冲突解决方法的总结" tabindex="-1"><a class="header-anchor" href="#冲突解决方法的总结"><span>冲突解决方法的总结</span></a></h3><ul><li>多线程冲突 <ul><li>基本通过原子操作解决 (锁/信号量)，避免指令乱序</li></ul></li><li>一致性冲突 (多个数据备份) <ul><li>通过全局统一管理</li><li>分布式的广播/被广播</li></ul></li><li>其他 <ul><li>MySQL 的 MVCC（Multi-Version Concurrency Control，多版本并发控制）</li></ul></li></ul><h3 id="其他-杂项" tabindex="-1"><a class="header-anchor" href="#其他-杂项"><span>其他？杂项？</span></a></h3><p>（<strong>GPT</strong>）</p><blockquote><ul><li>共享内存</li><li>总线</li><li>互斥锁</li><li>IO设备</li><li>其他共享资源 <ul><li>信号量 <ul><li>事件</li><li>队列</li></ul></li></ul></li></ul><p>方法</p><ul><li><strong>锁优化：</strong> 使用更细粒度的锁、自旋锁、读写锁等技术来减少锁竞争。</li><li><strong>无锁算法：</strong> 采用无锁或无等待的数据结构和算法，避免使用锁。</li><li><strong>缓存优化：</strong> 使用缓存一致性协议、伪共享填充等技术来提高缓存利用率。</li><li><strong>线程池：</strong> 通过线程池管理线程，避免线程频繁创建和销毁。</li><li><strong>异步I/O：</strong> 使用异步I/O操作，避免线程阻塞。</li><li><strong>负载均衡：</strong> 将任务均匀分配给各个核心，避免单个核心负载过重。</li></ul></blockquote><blockquote><p>我有一个疑问，Cache一致性那里有三个前提条件。但这里不考虑寄存器的吗？为什么限制了那么多原因？我感觉非独占Cache也会出现问题啊，多核是独占寄存器的啊。</p><p>目前我个人的理解是，也会有冲突，但这种冲突不叫 “Cache一致性的竞争冲突”，而是别的冲突，姑且叫 “寄存器的竞争冲突” 好了。</p><p>不确定</p></blockquote>',6);function y(V,f){const o=r("mermaid");return a(),i("div",null,[c,l("ul",null,[u,l("li",null,[E,l("ul",null,[l("li",null,[p,l("div",h,[l("table",B,[l("tbody",null,[_,A,m,C,w,l("tr",null,[l("td",g,[l("div",null,[k,v,D,x,s(o,{id:"mermaid-12",code:"eJxLL0osyFAIceLiKi5NgnCcA0LjnfOLUuMNuZ6ub3m6dsbTmSsMo+FMq8RnM9YbGsVyOScmZ6QaGkY/2dHwfNdyMA9Vzggot6sHJheLZJquni5UBbKgLkTQ0JArNS+FC2KGMdD4TnxGGCPEjBBiWHxjhKQQwzdP9q97NmXnkx27QFwjE5jnjLB4DrtSI6BSrH41gnsL2QHwADCC+PVpWytQJhpCoYcw0ASIBMxVaAJGoMBAEQCZjyxgjOADAA+J404="})])])]),N,b])])])])])])]),F])}const L=t(d,[["render",y],["__file","竞争冲突算法.html.vue"]]),K=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E5%86%B2%E7%AA%81%E7%AE%97%E6%B3%95.html","title":"竞争算法","lang":"zh-CN","frontmatter":{"description":"竞争算法 详细见： 线程冲突：../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突 Cache冲突：[../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性](../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06....","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E5%86%B2%E7%AA%81%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"竞争算法"}],["meta",{"property":"og:description","content":"竞争算法 详细见： 线程冲突：../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突 Cache冲突：[../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性](../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"竞争算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"竞争算法","slug":"竞争算法","link":"#竞争算法","children":[{"level":2,"title":"竞争冲突算法 vs 竞争调度算法","slug":"竞争冲突算法-vs-竞争调度算法","link":"#竞争冲突算法-vs-竞争调度算法","children":[]},{"level":2,"title":"目录","slug":"目录","link":"#目录","children":[{"level":3,"title":"冲突情景的总结","slug":"冲突情景的总结","link":"#冲突情景的总结","children":[]},{"level":3,"title":"冲突解决方法的总结","slug":"冲突解决方法的总结","link":"#冲突解决方法的总结","children":[]},{"level":3,"title":"其他？杂项？","slug":"其他-杂项","link":"#其他-杂项","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.19,"words":1256},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","excerpt":"\\n<p>详细见：</p>\\n<ul>\\n<li>线程冲突：<a href=\\"../../03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81\\">../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突</a></li>\\n<li>Cache冲突：[../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性](../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性)</li>\\n</ul>","autoDesc":true}');export{L as comp,K as data};
