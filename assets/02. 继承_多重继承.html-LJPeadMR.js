import{_ as e,c as i,e as n,o as t}from"./app-BHdORQJ2.js";const a={};function r(c,l){return t(),i("div",null,l[0]||(l[0]=[n('<h1 id="继承-多重继承" tabindex="-1"><a class="header-anchor" href="#继承-多重继承"><span>继承_多重继承</span></a></h1><h2 id="多重继承-multipleinheritance-mi" tabindex="-1"><a class="header-anchor" href="#多重继承-multipleinheritance-mi"><span>多重继承（<em>multipleinheritance，MI</em>）</span></a></h2><ul><li><p>使用</p><ul><li>用逗号分隔，如<code>class A: public APerent1, public APerent2 {...}</code></li></ul></li><li><p>多重继承带来的问题</p><ul><li><p>多重继承比单继承麻烦，也更容易出现问题</p></li><li><p>多重继承会带来新的问题，其中两个主要问题：</p><ul><li>从两个不同的基类继承同名方法。解决方案：作用域解析运算符</li><li>从两个或更多相关基类中继承同一个类的多个实例。解决方案：虚基类</li></ul></li><li><p>而虚基类该解决方案有会带来新的问题： - 构造时重复传参或无法传参 - 派生类无法调用虚基类的方法</p></li><li><p>为了解决这些问题需要一些<strong>新规则和不同语法</strong></p></li></ul></li></ul><h2 id="【缺陷补丁】" tabindex="-1"><a class="header-anchor" href="#【缺陷补丁】"><span>【缺陷补丁】</span></a></h2><h3 id="【缺陷补丁】虚基类——解决多个类同祖先问题" tabindex="-1"><a class="header-anchor" href="#【缺陷补丁】虚基类——解决多个类同祖先问题"><span>【缺陷补丁】虚基类——解决多个类同祖先问题</span></a></h3><h4 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h4><p>虚基类（<em>virtual base class</em>）与禁止传参给基类原则</p><ul><li><mark>原理</mark><ul><li>虚基类使得从多个类（他们的基类相同）<strong>派生出的对象</strong>只继承同一个<strong>基类对象</strong>（是基类对象而不是基类）</li><li>即只有一个基类对象副本</li><li>即新类如果多重继承这些类，也只会有一个基类对象</li></ul></li><li>特性 <ul><li>禁止信息通过中间类传给基类</li><li>因为如果继承多个由虚基类派生而来的类，构造基类时重复传参将出错</li><li>这时需要新的写法——直接调用基类的基类的构造函数</li><li>虚基类必须使用该新写法，而非虚基类，该写法是非法的</li></ul></li><li>写法 <ul><li>例：<code>class A : virtual public APerent {...}</code></li><li>或：<code>class A : public virtual Aperent {...}</code>（<code>virtual</code>和<code>public</code>的次序无关紧要）</li></ul></li><li>多重继承的写法 <ul><li>虚基类为避免重复传参的冲突，禁止信息通过中间类自动传递给基类，而需要显式地调用所需基类的构造函数</li><li>如：<code>A() : APerentPerent(), APerent1(), APerent2() {...}</code>（补注：默认为私有继承）</li></ul></li></ul><h4 id="带来新的问题" tabindex="-1"><a class="header-anchor" href="#带来新的问题"><span>带来新的问题</span></a></h4><p>虚基类会带来新的问题</p><ul><li><s>重复传参问题（内置问题）</s><ul><li><s>解决方案（内置方案）：进制信息通过中间量传给基类 ——&gt; 无法传参的问题</s></li></ul></li><li>无法传参问题 <ul><li>解决方案：显示调用所需的基类的构造函数</li></ul></li></ul><h4 id="效率和成本" tabindex="-1"><a class="header-anchor" href="#效率和成本"><span>效率和成本</span></a></h4><p>虚基类不是默认的方式，因为其有额外的开销（就像虚函数不是默认的方式那样）</p><ul><li>在一些情况下，可能需要基类的多个拷贝</li><li>将基类作为虚基类需要额外的计算</li><li>这样做有缺点</li></ul><h3 id="【缺陷解决】作用域解析运算符——解决基类同名函数问题" tabindex="-1"><a class="header-anchor" href="#【缺陷解决】作用域解析运算符——解决基类同名函数问题"><span>【缺陷解决】作用域解析运算符——解决基类同名函数问题</span></a></h3><ul><li>解决方法 <ul><li>方法一：使用作用域解析运算符，如<code>a.APerent2::fn();</code></li><li>方法二：重新定义方法，并指出要使用哪个基类版本的方法，如<code>void a:fn(){APerent2::fn();}</code></li></ul></li></ul>',16)]))}const o=e(a,[["render",r],["__file","02. 继承_多重继承.html.vue"]]),s=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/02.%20%E7%BB%A7%E6%89%BF_%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.html","title":"继承_多重继承","lang":"zh-CN","frontmatter":{"description":"继承_多重继承 多重继承（multipleinheritance，MI） 使用 用逗号分隔，如class A: public APerent1, public APerent2 {...} 多重继承带来的问题 多重继承比单继承麻烦，也更容易出现问题 多重继承会带来新的问题，其中两个主要问题： 从两个不同的基类继承同名方法。解决方案：作用域解析运算符 从...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/02.%20%E7%BB%A7%E6%89%BF_%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"继承_多重继承"}],["meta",{"property":"og:description","content":"继承_多重继承 多重继承（multipleinheritance，MI） 使用 用逗号分隔，如class A: public APerent1, public APerent2 {...} 多重继承带来的问题 多重继承比单继承麻烦，也更容易出现问题 多重继承会带来新的问题，其中两个主要问题： 从两个不同的基类继承同名方法。解决方案：作用域解析运算符 从..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"继承_多重继承\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"继承_多重继承","slug":"继承-多重继承","link":"#继承-多重继承","children":[{"level":2,"title":"多重继承（multipleinheritance，MI）","slug":"多重继承-multipleinheritance-mi","link":"#多重继承-multipleinheritance-mi","children":[]},{"level":2,"title":"【缺陷补丁】","slug":"【缺陷补丁】","link":"#【缺陷补丁】","children":[{"level":3,"title":"【缺陷补丁】虚基类——解决多个类同祖先问题","slug":"【缺陷补丁】虚基类——解决多个类同祖先问题","link":"#【缺陷补丁】虚基类——解决多个类同祖先问题","children":[{"level":4,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":4,"title":"带来新的问题","slug":"带来新的问题","link":"#带来新的问题","children":[]},{"level":4,"title":"效率和成本","slug":"效率和成本","link":"#效率和成本","children":[]}]},{"level":3,"title":"【缺陷解决】作用域解析运算符——解决基类同名函数问题","slug":"【缺陷解决】作用域解析运算符——解决基类同名函数问题","link":"#【缺陷解决】作用域解析运算符——解决基类同名函数问题","children":[]}]}]}],"git":{},"readingTime":{"minutes":2.39,"words":717},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/03. 类的重用/02. 继承_多重继承.md","excerpt":"\\n<h2>多重继承（<em>multipleinheritance，MI</em>）</h2>\\n<ul>\\n<li>\\n<p>使用</p>\\n<ul>\\n<li>用逗号分隔，如<code>class A: public APerent1, public APerent2 {...}</code></li>\\n</ul>\\n</li>\\n<li>\\n<p>多重继承带来的问题</p>\\n<ul>\\n<li>\\n<p>多重继承比单继承麻烦，也更容易出现问题</p>\\n</li>\\n<li>\\n<p>多重继承会带来新的问题，其中两个主要问题：</p>\\n<ul>\\n<li>从两个不同的基类继承同名方法。解决方案：作用域解析运算符</li>\\n<li>从两个或更多相关基类中继承同一个类的多个实例。解决方案：虚基类</li>\\n</ul>\\n</li>\\n<li>\\n<p>而虚基类该解决方案有会带来新的问题：\\n- 构造时重复传参或无法传参\\n- 派生类无法调用虚基类的方法</p>\\n</li>\\n<li>\\n<p>为了解决这些问题需要一些<strong>新规则和不同语法</strong></p>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/03. 类的重用/02. 继承_多重继承.md","value":{"title":"02. 继承_多重继承","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/03. 类的重用/02. 继承_多重继承.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{o as comp,s as data};
