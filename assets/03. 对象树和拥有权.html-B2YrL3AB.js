import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,e as i}from"./app-yixEWCFr.js";const o={},c=i('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="对象树和拥有权" tabindex="-1"><a class="header-anchor" href="#对象树和拥有权"><span>对象树和拥有权</span></a></h1><h2 id="对象模型-对象树" tabindex="-1"><a class="header-anchor" href="#对象模型-对象树"><span>对象模型（对象树）</span></a></h2><p>parent-child机制</p><ul><li><p>作用</p><ul><li>介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制</li><li>这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁</li></ul></li><li><p>简概</p><ul><li>Qt中创建对象时会提供一个Parent对象指针</li><li>注意，对象树不等于继承树</li></ul></li><li><p>原理</p><ul><li><p>当创建一个<code>QObject</code>对象时，其构造函数接受一个<code>QObject</code>指针作为参数，这个参数是<code>parent</code>，也就是<code>父对象指针</code>（不是父类）</p><ul><li><p>可以通过构造函数传入<code>父对象指针</code>，也可以后期通过<code>setParent()</code>函数修改<code>父对象指针</code>，一般为this</p></li><li><p>这个QObject对象会自动添加到<strong>父对象的<code>children()</code>列表</strong></p></li></ul></li><li><p>当<code>父对象</code>析构时，这个列表中的所有对象也会被析构</p></li><li><p>这种机制在GUI程序设计中相当有用</p></li><li><p>即：<mark>不需要delete QObject对象及其后代类</mark></p></li></ul></li><li><p>补充</p><ul><li>这里的设计可能有点反直觉：父对象指针为参，但目的是要调用*parent里面的addChildren()??方法来修改的是父对象中的children()列表</li><li>之所以这样设计 <ul><li>一是方便于为组件指定的父对象（如控件所属哪个窗口）</li><li>二是以便与在构造QObject对象时完成所有操作（而不是把QObject对象传入到包含它的类的方法参数里）</li><li>三是将children放在父对象中，当销毁父对象的时候不需要遍历所有对象，就能直接找到要销毁的子对象</li></ul></li></ul></li></ul>',6),r=[c];function a(n,p){return t(),l("div",null,r)}const s=e(o,[["render",a],["__file","03. 对象树和拥有权.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/03.%20%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%8B%A5%E6%9C%89%E6%9D%83.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 对象树和拥有权 对象模型（对象树） parent-child机制 作用 介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制 这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁 简概 Qt中创建对象时会提供一个Parent对象指针 注意，对象树不等于继承树 原理 当创建一个QObject对象时...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/03.%20%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%8B%A5%E6%9C%89%E6%9D%83.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 对象树和拥有权 对象模型（对象树） parent-child机制 作用 介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制 这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁 简概 Qt中创建对象时会提供一个Parent对象指针 注意，对象树不等于继承树 原理 当创建一个QObject对象时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"对象树和拥有权","slug":"对象树和拥有权","link":"#对象树和拥有权","children":[{"level":2,"title":"对象模型（对象树）","slug":"对象模型-对象树","link":"#对象模型-对象树","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.42,"words":425},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/03. 对象树和拥有权.md","autoDesc":true}');export{s as comp,h as data};
