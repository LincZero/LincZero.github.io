import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as e,a as s}from"./app-OHhlwNoJ.js";const t={},i=s(`<h1 id="different" tabindex="-1"><a class="header-anchor" href="#different"><span>Different</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h1><h2 id="继承-类继承" tabindex="-1"><a class="header-anchor" href="#继承-类继承"><span>继承 - 类继承</span></a></h2><h3 id="继承-1" tabindex="-1"><a class="header-anchor" href="#继承-1"><span>继承</span></a></h3><ul><li><p>java <mark>（在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承）</mark></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class A : public APerent {}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="多继承-不支持" tabindex="-1"><a class="header-anchor" href="#多继承-不支持"><span><s>多继承（不支持）</s></span></a></h3><ul><li>C++支持多继承</li><li>Java不支持多继承</li></ul><h2 id="继承-方法继承" tabindex="-1"><a class="header-anchor" href="#继承-方法继承"><span>继承 - 方法继承</span></a></h2><h3 id="重载、覆盖、隐藏-override、override、hide" tabindex="-1"><a class="header-anchor" href="#重载、覆盖、隐藏-override、override、hide"><span>重载、覆盖、隐藏（override、Override、hide）</span></a></h3><p>C++中的重载、覆盖、隐藏（override、Override、hide）</p><ul><li><p>相同范围：重载</p></li><li><p>不同范围：覆盖或隐藏（即：继承 x 多态）</p><table><thead><tr><th>函数名</th><th>参数</th><th>基类有virtual关键字</th><th>结果</th></tr></thead><tbody><tr><td>相同</td><td>不同</td><td>有或无</td><td>隐藏</td></tr><tr><td>相同</td><td>相同</td><td>无</td><td>隐藏</td></tr><tr><td>相同</td><td>相同</td><td>有</td><td><strong>覆盖</strong></td></tr></tbody></table></li></ul><p>Java中的重载、覆盖、隐藏（override、Override、hide）</p><ul><li><p>不同范围</p><table><thead><tr><th>函数名</th><th>参数</th><th>Java默认使用动态绑定，否则final</th><th>结果</th></tr></thead><tbody><tr><td>相同</td><td>不相</td><td>——</td><td>？？</td></tr><tr><td>相同</td><td>相同</td><td>——</td><td><strong>覆盖</strong></td></tr></tbody></table></li></ul><h3 id="覆盖方法、选择方法版本" tabindex="-1"><a class="header-anchor" href="#覆盖方法、选择方法版本"><span>覆盖方法、选择方法版本</span></a></h3><ul><li><p>继承（inheritance）：子类自动地继承了父类中的方法</p></li><li><p>覆盖（Override）：提供一个新的方法来覆盖（Override）超类中的原方法</p><ul><li><p>如果希望调用超类而不是子类的方法</p><ul><li><p>Java：使用特定的关键字super解决这个问题</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>C++：使用<code>::</code></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>父类名::getSalary()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>注意：有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字</p></li></ul></li></ul><h3 id="子类构造器" tabindex="-1"><a class="header-anchor" href="#子类构造器"><span>子类构造器</span></a></h3><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>A::A():PerentA(){}
// 一般使用成员初始化列表语法（效率高）来调用基类构造函数
// 缺省时：
//     如果省略基类的构造函数，则程序自动使用默认的基类构造函数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salarym<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用super调用构造器的语句必须是子类构造器的【第一条】语句</span>
    <span class="token comment">// 这里的关键字super具有不同的含义</span>
    <span class="token comment">// 是“调用超类Employee中含有n、s、year、month和day参数的构造器”的简写形式</span>
    bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 缺省时：</span>
<span class="token comment">//     如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器</span>
<span class="token comment">//     如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="动态绑定" tabindex="-1"><a class="header-anchor" href="#动态绑定"><span>动态绑定</span></a></h3><ul><li><p>一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为<strong>多态（polymorphism）</strong></p></li><li><p>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定（dynamic binding）</strong></p></li><li><p>C：默认是<strong>静态绑定</strong></p></li><li><p>Java：不需要将方法声明为虚拟方法。<strong>动态绑定是默认的处理方式</strong>。如果不希望让一个方法具有虚拟特征，可以将它标记为final</p></li></ul><h2 id="继承-其他" tabindex="-1"><a class="header-anchor" href="#继承-其他"><span>继承 - 其他</span></a></h2><h3 id="阻止继承" tabindex="-1"><a class="header-anchor" href="#阻止继承"><span>阻止继承</span></a></h3><p>Java</p><ul><li><p>作用1：不允许类被继承 例如，假设希望阻止人们定义Executive类的子类，就可以在定义这个类的时候，使用final修饰符声明</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Executive</span> <span class="token keyword">extends</span> <span class="token class-name">Manager</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>作用2：不允许类方法被复写 类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Emplyee</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>C++11，final关键字</p><ul><li><p>作用1：不允许类被继承</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>struct Basel final{};		// 不让别人继承自己
struct Derived1:Base1 {};	// 此时会报错
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>作用2：不允许类方法被复写</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>struct Base2{
    virtual void f() final;	// 不允许被复写
};
struct Derived2:Base2{
    void f();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>用途：将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。例如在Java中：</p><ul><li>Calendar类中的getTime和setTime方法都声明为final 这表明Calendar类的设计者负责实现Date类与日历状态之间的转换，而不允许子类处理这些问题</li><li>String类也是final类 这意味着不允许任何人定义String的子类。 换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。</li></ul><h3 id="方法-域的访问权限-保护访问" tabindex="-1"><a class="header-anchor" href="#方法-域的访问权限-保护访问"><span>方法/域的访问权限（保护访问）</span></a></h3><ul><li><p>Java</p><ul><li><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// priveate：仅对本类可见</span>
<span class="token comment">// public：对所有类可见</span>
<span class="token comment">// protected：对本包和所有子类可见</span>
<span class="token comment">// 默认：对本包可见</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>C++</p><ul><li>基本同上</li></ul></li><li><p>总结</p><ul><li>Java中的受保护部分对所有子类<strong>及同一个包中的所有其他类</strong>都可见。这与C++中的保护机制稍有不同</li><li>Java中的protected概念要比C++中的<strong>安全性差</strong></li></ul></li></ul><h2 id="【功能扩展】继承" tabindex="-1"><a class="header-anchor" href="#【功能扩展】继承"><span>【功能扩展】继承</span></a></h2><h3 id="【功能扩展】继承-x-转换-强制类型转换" tabindex="-1"><a class="header-anchor" href="#【功能扩展】继承-x-转换-强制类型转换"><span>【功能扩展】继承 x 转换，强制类型转换</span></a></h3><p><mark>与C++不同</mark></p><ul><li><p>类型转换 Java使用的类型转换语法来源于C语言，但处理过程却有些像C++的dynamic_cast操作。以下两种写法等价</p><ul><li><p>Java</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">// Java</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>Manager* boss = dynamic_cast&lt;Manager*&gt;(staff[1]);	// C++
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>判断是否能转换</p><ul><li><p>Java：<strong>当类型转换失败时，抛出一个异常</strong>（有点像C++中的引用（reference）转换）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span>					<span class="token comment">// Java，需要将instanceof运算符和类型转换组合起来使用</span>
<span class="token punctuation">{</span>
    boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++：<strong>当类型转换失败时，生成一个null对象</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>Manager* boss = dynamic_cast&lt;Manager*&gt;(staff[1]);	// C++，直接转换
if (boss != NULL) ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>`,37),l=[i];function d(c,p){return n(),e("div",null,l)}const u=a(t,[["render",d],["__file","03. 继承.html.vue"]]),v=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Different/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/03.%20%E7%BB%A7%E6%89%BF.html","title":"Different","lang":"zh-CN","frontmatter":{"description":"Different 目录 继承 继承 - 类继承 继承 java （在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承） C++ C++支持多继承 Java不支持多继承 继承 - 方法继承 重载、覆盖、隐藏（override、Override、hide） C++中的重载、覆盖、隐藏（override、Override、hide） ...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Different/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/03.%20%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Different"}],["meta",{"property":"og:description","content":"Different 目录 继承 继承 - 类继承 继承 java （在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承） C++ C++支持多继承 Java不支持多继承 继承 - 方法继承 重载、覆盖、隐藏（override、Override、hide） C++中的重载、覆盖、隐藏（override、Override、hide） ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Different\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Different","slug":"different","link":"#different","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"继承","slug":"继承","link":"#继承","children":[{"level":2,"title":"继承 - 类继承","slug":"继承-类继承","link":"#继承-类继承","children":[{"level":3,"title":"继承","slug":"继承-1","link":"#继承-1","children":[]},{"level":3,"title":"多继承（不支持）","slug":"多继承-不支持","link":"#多继承-不支持","children":[]}]},{"level":2,"title":"继承 - 方法继承","slug":"继承-方法继承","link":"#继承-方法继承","children":[{"level":3,"title":"重载、覆盖、隐藏（override、Override、hide）","slug":"重载、覆盖、隐藏-override、override、hide","link":"#重载、覆盖、隐藏-override、override、hide","children":[]},{"level":3,"title":"覆盖方法、选择方法版本","slug":"覆盖方法、选择方法版本","link":"#覆盖方法、选择方法版本","children":[]},{"level":3,"title":"子类构造器","slug":"子类构造器","link":"#子类构造器","children":[]},{"level":3,"title":"动态绑定","slug":"动态绑定","link":"#动态绑定","children":[]}]},{"level":2,"title":"继承 - 其他","slug":"继承-其他","link":"#继承-其他","children":[{"level":3,"title":"阻止继承","slug":"阻止继承","link":"#阻止继承","children":[]},{"level":3,"title":"方法/域的访问权限（保护访问）","slug":"方法-域的访问权限-保护访问","link":"#方法-域的访问权限-保护访问","children":[]}]},{"level":2,"title":"【功能扩展】继承","slug":"【功能扩展】继承","link":"#【功能扩展】继承","children":[{"level":3,"title":"【功能扩展】继承 x 转换，强制类型转换","slug":"【功能扩展】继承-x-转换-强制类型转换","link":"#【功能扩展】继承-x-转换-强制类型转换","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.64,"words":1393},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Different/06. 面向对象/03. 类的重用/03. 继承.md","autoDesc":true}');export{u as comp,v as data};
