import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,o as s,c,b as l,e,d as t,a as i}from"./app-OHhlwNoJ.js";const r={},o=i('<h1 id="类中函数-分类-特殊成员或非成员函数" tabindex="-1"><a class="header-anchor" href="#类中函数-分类-特殊成员或非成员函数"><span>类中函数（分类，特殊成员或非成员函数）</span></a></h1><h2 id="成员-方法访问控制" tabindex="-1"><a class="header-anchor" href="#成员-方法访问控制"><span>成员/方法访问控制</span></a></h2><table><thead><tr><th>访问控制</th><th>客户通过类实例与句点</th><th>派生类中</th><th>类实现中</th><th>类实现的类方法中</th><th>场景</th></tr></thead><tbody><tr><td>private（默认）</td><td>不能访问</td><td>不能访问</td><td>作用域解析运算符定义函数</td><td>可以访问</td><td>数据项一般放在私有部分</td></tr><tr><td>protected</td><td>不能访问</td><td>可以访问</td><td>作用域解析运算符定义函数</td><td>可以访问</td><td></td></tr><tr><td>public</td><td>可以访问</td><td>可以访问</td><td>作用域解析运算符定义函数</td><td>可以访问</td><td>类接口放在公有部分、#define或const</td></tr><tr><td>友元函数</td><td>可以访问</td><td>可以访问</td><td>可以访问</td><td>可以访问</td><td></td></tr></tbody></table><h3 id="friend-友元函数【非成员函数】" tabindex="-1"><a class="header-anchor" href="#friend-友元函数【非成员函数】"><span>friend 友元函数【非成员函数】</span></a></h3><h4 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h4><p>友元有三种</p><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul><h4 id="【功能扩展】友元函数-友元-x-函数" tabindex="-1"><a class="header-anchor" href="#【功能扩展】友元函数-友元-x-函数"><span>【功能扩展】友元函数 = 友元 x 函数</span></a></h4><ul><li><p>使用</p><ul><li><p>原型：将原型放在类声明中，并在声明前加上关键字<code>friend</code></p><p>例如：<code>friend Time operator*(double m, const Time &amp;t);</code></p></li><li><p>定义：不是成员函数，不加<code>类名::</code>的限定符</p></li></ul></li><li><p>特点</p><ul><li>友元函数在类声明中声明，但不是成员函数，即不能通过成员运算符来调用</li><li>虽然友元函数不是成员函数，但它和成员函数的访问权限相同</li></ul></li><li><p>【实例】常用的友元：&lt;&lt;</p><ul><li>这里要注意一下：通常重载&lt;&lt;运算符用于cout输出</li><li>该友元函数的返回值通常设置为<code>ostream &amp;</code>，使之能进行连续的<code>&lt;&lt;</code>运算符</li><li>（这里之所以是返回引用类型，是为了让ostream的派生类都可用）</li></ul></li><li><p>【实例】前缀<code>++</code>和后缀<code>++</code>的写法</p><ul><li>......</li></ul></li><li><p>两种重载运算符比较</p><ul><li><table><thead><tr><th>函数版本</th><th>声明（类声明中）</th><th>定义（类实现中）</th><th>使用（客户代码中）</th><th>传参本质</th></tr></thead><tbody><tr><td>普通函数</td><td>前面不加<code>friend</code></td><td>使用<code>类名::</code>指定类<br>只显式声明一个传入参数</td><td>使用<code>成员运算符</code>调用</td><td>一个操作数通过this指针隐式传递<br>一个显式传递</td></tr><tr><td>成员函数版本</td><td>前面不加<code>friend</code></td><td>使用<code>类名::</code>指定类<br>只显式声明一个传入参数</td><td>使用<code>运算符</code>隐式调用</td><td>一个操作数通过this指针隐式传递<br>一个显式传递</td></tr><tr><td>友元非成员函数版本</td><td>前面加<code>friend</code></td><td>不使用<code>类名::</code>指定类<br>显式声明两个传入参数<br>且其中一个为类的引用</td><td>使用<code>运算符</code>隐式调用</td><td>两个操作数都作为参数来传递</td></tr></tbody></table></li></ul></li></ul><h2 id="成员函数与非成员函数" tabindex="-1"><a class="header-anchor" href="#成员函数与非成员函数"><span>成员函数与非成员函数</span></a></h2><h3 id="成员函数简概" tabindex="-1"><a class="header-anchor" href="#成员函数简概"><span>成员函数简概</span></a></h3><ul><li>简概 <ul><li>包括构造函数和析构函数</li></ul></li><li>与普通函数相比 <ul><li>定义上：先用作用域解析运算符指定类</li><li>性质上：可访问指定的类的私有成员</li></ul></li></ul><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h3><p>类中函数一共两种：</p><ul><li>非友元 - 类成员函数 <ul><li>构造函数 <ul><li>默认构造函数（自动提供）</li><li>复制构造函数（自动提供）</li><li>移动构造函数（C++11）</li><li>移动赋值函数（C++11）</li><li>其他构造函数 <ul><li>可单参数的构造函数</li></ul></li></ul></li><li>析构函数 <ul><li>默认析构函数（自动提供）</li></ul></li><li>非友元的运算符重载函数</li><li>类型转换函数</li><li><strong>普通成员函数</strong></li></ul></li><li>友元 - 非成员函数 <ul><li>友元函数（包括友元的运算符重载函数）</li></ul></li><li><s>非友元 - 非成员函数（类中不存在，是与类无关的普通函数）</s></li><li><s>友元 - 成员函数（不存在，两者互斥）</s></li></ul><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h3><p>非友元 - 类成员函数</p><ul><li>原型上：正常定义</li><li>定义上：先用作用域解析运算符指定类</li><li>性质上：可访问指定的类的私有成员</li></ul><p>友元 - 非类成员函数</p><ul><li>原型上：<code>friend</code>关键字开头</li><li>定义上：不用作用域解析运算符</li><li>性质上：可访问指定的类的私有成员</li></ul><p>非友元 - 非类成员函数（普通函数）</p><ul><li>略</li></ul><h3 id="【总结】成员函数属性-或友元" tabindex="-1"><a class="header-anchor" href="#【总结】成员函数属性-或友元"><span>【总结】成员函数属性（或友元）</span></a></h3><p>注意：不全都是成员函数</p><table><thead><tr><th>函数</th><th>能否继承</th><th>成员还是友元</th><th>默认能否生成</th><th>能否为虚函数</th><th>是否可以有返回类型</th></tr></thead><tbody><tr><td>构造函数</td><td><strong>否</strong></td><td>成员</td><td><strong>能</strong></td><td><strong>否</strong></td><td><strong>否</strong></td></tr><tr><td>析构函数</td><td><strong>否</strong></td><td>成员</td><td><strong>能</strong></td><td>能</td><td><strong>否</strong></td></tr><tr><td>=</td><td><strong>否</strong></td><td>成员</td><td><strong>能</strong></td><td>能</td><td>能</td></tr><tr><td>&amp;</td><td>能</td><td><strong>任意</strong></td><td><strong>能</strong></td><td>能</td><td>能</td></tr><tr><td>转换函数</td><td>能</td><td>成员</td><td>否</td><td>能</td><td><strong>否</strong></td></tr><tr><td>()</td><td>能</td><td>成员</td><td>否</td><td>能</td><td>能</td></tr><tr><td>[]</td><td>能</td><td>成员</td><td>否</td><td>能</td><td>能</td></tr><tr><td>-&gt;</td><td>能</td><td>成员</td><td>否</td><td>能</td><td>能</td></tr><tr><td>op=</td><td>能</td><td><strong>任意</strong></td><td>否</td><td>能</td><td>能</td></tr><tr><td>new</td><td>能</td><td><mark>静态成员</mark></td><td>否</td><td><strong>否</strong></td><td><code>void *</code></td></tr><tr><td>delete</td><td>能</td><td><mark>静态成员</mark></td><td>否</td><td><strong>否</strong></td><td><code>void</code></td></tr><tr><td>其他运算符</td><td>能</td><td><strong>任意</strong></td><td>否</td><td>能</td><td>能</td></tr><tr><td>其他成员</td><td>能</td><td>成员</td><td>否不是</td><td>能</td><td>能</td></tr><tr><td>友元</td><td><strong>否</strong></td><td><code>友元</code></td><td>否</td><td><strong>否</strong></td><td>能</td></tr></tbody></table><h1 id="类中函数-具体函数" tabindex="-1"><a class="header-anchor" href="#类中函数-具体函数"><span>类中函数（具体函数）</span></a></h1><h2 id="构造与析构函数【成员函数】" tabindex="-1"><a class="header-anchor" href="#构造与析构函数【成员函数】"><span>构造与析构函数【成员函数】</span></a></h2><h3 id="构造函数-及其原理" tabindex="-1"><a class="header-anchor" href="#构造函数-及其原理"><span>构造函数（及其原理）</span></a></h3><h4 id="简概-1" tabindex="-1"><a class="header-anchor" href="#简概-1"><span>简概</span></a></h4><ul><li>简概 <ul><li>简单来说就是创建类实例的时候初始化</li></ul></li><li>使用 <ul><li>没定义时有隐式版本的默认构造函数</li><li>定义：使用类名作为构造函数名（该函数名开头也大写），例如<code>Stock::Stock(...){...}</code></li></ul></li><li>与普通成员函数相比 <ul><li>可默认声明</li><li>首字母大写并同类名（这种设计使得能用类名调用构造函数函数，而Python使用的是<code>__init__</code>标识构造函数名）</li><li>没有返回值</li><li>默认还会被用于隐式转换</li></ul></li></ul><h4 id="成员变量注意项" tabindex="-1"><a class="header-anchor" href="#成员变量注意项"><span>（成员变量注意项）</span></a></h4><ul><li>注意项 <ul><li>传输参数时，成员名和参数名不能相同，否则会出错（好像就只有C++会有这个问题）</li><li>解决方案：数据成员名使用<code>m_</code>前缀或使用<code>_</code>后缀（有点类似于Python类设计中的双下划线标识和单下划线标识）</li><li>能接受一个参数的构造函数，会被提供给自动/强制类型转换使用，也会被使用作<code>A a = val;</code>的初始化方式。这种行为可通过<code>explicit</code>关闭</li></ul></li></ul><h4 id="默认构造函数-自动提供" tabindex="-1"><a class="header-anchor" href="#默认构造函数-自动提供"><span>默认构造函数（自动提供）</span></a></h4><ul><li>要点 <ul><li>不提供任何构造函数时会创建默认构造函数，如果定义了构造函数将不会提供默认构造函数</li><li>也可自己显式地写默认构造函数</li><li>只能有一个默认构造函数，否则会引发二义性</li></ul></li><li>原型 <ul><li><code>ClassName::ClassName();</code></li></ul></li><li>调用场景 <ul><li>用于创建默认对象。如<code>A a;</code></li></ul></li></ul><h4 id="复制构造函数-自动提供" tabindex="-1"><a class="header-anchor" href="#复制构造函数-自动提供"><span>复制构造函数（自动提供）</span></a></h4><ul><li>要点 <ul><li>只能复制到<strong>新赋值</strong>的对象</li><li>赋值给新对象的对象应是对应类的引用（包括派生类）</li><li>赋值构造函数的功能是浅赋值 <ul><li>当成员中有动态创建的变量时这可能会<strong>引发一些问题</strong>（如<code>delete</code>一块堆内存两次，其症状之一是字符串出现乱码）</li></ul></li></ul></li><li>原型（注意是const引用） <ul><li><code>ClassName(const ClassName &amp;);</code>，如<code>StringBad(const StringBad &amp;);</code></li></ul></li><li>调用场景 <ul><li>用于将一个对象复制到<strong>新创建</strong>的对象中，即只能用于<strong>初始化</strong>而<strong>不能用于其他赋值</strong></li><li>具体场景（以类A为例，a1和a2都是类A的实例） <ul><li>新对象初始化为一个同类对象 <ul><li><code>A a1(a2);</code></li><li><code>A a1 = a2;</code></li><li><code>A a1 = A(a2)</code></li><li><code>A * a1 = new A(a2)</code></li></ul></li><li>按值将对象传递给函数</li><li>函数按值返回非引用对象</li><li>编译器生成临时对象 <ul><li><mark>？？？</mark></li></ul></li></ul></li></ul></li></ul><h4 id="移动构造函数-c-11" tabindex="-1"><a class="header-anchor" href="#移动构造函数-c-11"><span>移动构造函数（C++11）</span></a></h4><h4 id="移动赋值函数-c-11" tabindex="-1"><a class="header-anchor" href="#移动赋值函数-c-11"><span>移动赋值函数（C++11）</span></a></h4><h3 id="析构函数-及其原理" tabindex="-1"><a class="header-anchor" href="#析构函数-及其原理"><span>析构函数（及其原理）</span></a></h3><h4 id="简概-2" tabindex="-1"><a class="header-anchor" href="#简概-2"><span>简概</span></a></h4><ul><li>简概 <ul><li>程序能跟踪对象，直到其过期为止</li></ul></li><li>使用 <ul><li>没定义时有隐式版本的默认析构函数</li><li>定义：使用类名前加<code>~</code>作为析构函数名，例如<code>Stock::~Stock(){}</code></li><li>调用：一般不能直接调用，使用定位new除外，写法例如<code>p_a.~A();</code></li></ul></li><li>与普通成员函数相比 <ul><li>可默认声明</li><li>以<code>~</code>开头且首字母大写并同类名</li><li>没有返回值</li><li>不接受参数</li><li>会被自动调用（通常不显式调用，如果使用定义new运算符时手动调用可能会出错）</li></ul></li><li>调用析构函数的情况（4种） <ul><li>如果对象是动态变量，则执行完程序块后，<strong>自动调用析构函数</strong></li><li>如果对象是静态变量，则程序结束时，<strong>自动调用析构函数</strong></li><li>如果对象是new变量，则需要使用delete删除对象，<strong>间接自动调用析构函数</strong></li><li>如果对象是非堆定位new变量，则不能使用delete，而应<strong>直接调用析构函数</strong></li></ul></li></ul><h4 id="默认析构函数-自动提供" tabindex="-1"><a class="header-anchor" href="#默认析构函数-自动提供"><span>默认析构函数（自动提供）</span></a></h4><p>略，注意默认析构函数不会自动删除类中new创建的变量</p><h3 id="【功能扩展】构造函数的扩展" tabindex="-1"><a class="header-anchor" href="#【功能扩展】构造函数的扩展"><span>【功能扩展】构造函数的扩展</span></a></h3><h4 id="【特殊语法】成员初始化列表-构造函数-x-成员变量初始化" tabindex="-1"><a class="header-anchor" href="#【特殊语法】成员初始化列表-构造函数-x-成员变量初始化"><span>【特殊语法】成员初始化列表 = 构造函数 x 成员变量初始化</span></a></h4>',45),u=i(`<li><p>使用</p><ul><li><p>举例</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>Classy::Classy(int n, int m)
    :mem1(n),mem2(0),mem3(n*m+2)
{     
	// ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li>`,1),h=l("p",null,"为什么效率高",-1),p=l("li",null,[l("p",null,[e("对于简单变量来说没什么区别，但对于类对象成员来说，其"),l("strong",null,"效率更高")])],-1),v=l("p",null,[l("mark",null,"效率更高，但为什么效率高呢？")],-1),m={href:"https://www.cnblogs.com/GEEK-ZHAO/p/15767627.html",target:"_blank",rel:"noopener noreferrer"},b=l("strong",null,"非常好",-1),g=i(`<div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class B
{
public:
	explicit B(A a)	// (1) 改成B(A a):m_a(a)		// (2) 将该行改为 B(A&amp; a):m_a(a)
    {
        cout &lt;&lt; &quot;////////////////////&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;a = &quot; &lt;&lt; &amp;a &lt;&lt; endl;
        cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; &amp;m_a &lt;&lt; endl;
        m_a = a;
    }
private:
	A m_a;										// (2) 将该行改为 A&amp; m_a;
}

int main()
{
    A a{5};
    B b{a};

	return 0;
}

// 在这里，A的 Big3 一共调用了【4】次
// 1. A构造函数：创建 a
// 2. A构造函数：创建 m_a
// 3. A拷贝构造函数：B 构造函数形参构建
// 4. A的=号函数：为了给 m_a 赋值，还调用了一次赋值函数

// 【优化(1)】改成成员初始化列表
// 将第四点的赋值函数优化掉了，减少了一次 Big3 的使用。Big3 的数量为【3】

// 【优化(2)】Big3 的数量还能优化，将传参改成引用传参（指针传参也行）
// 此时，只会调用一次A的构造函数。Big3 的数量为【1】

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),x=i(`<li><p>使用场景 / <strong>必须</strong>使用的场景：</p><p>《C++ Primer》中提到在以下三种情况下需要使用初始化成员列表</p><ol><li><strong>需要初始化的数据成员是对象的情况；</strong></li><li><strong>需要初始化const修饰的类成员；</strong>（不能赋值只能初始化）</li><li><strong>需要初始化引用成员数据</strong>（不能“赋值”只能初始化）</li></ol><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// 这里仅列举情况一
class CMyClass {
    CMember m_member;
public:
    CMyClass();
};
// 必须使用初始化列表来初始化成员 m_member
CMyClass::CMyClass() : m_member(2)
{
...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>杂项</p><ul><li><p>局限性：这种格式<strong>只能</strong>用于<strong>构造函数</strong></p><ul><li>指的是函数后面初始化的语法格式，而不是指初始化变量的语法格式</li><li>后者可以用于常规初始化，如<code>int games(162);</code>、<code>double talk(2.71828);</code></li></ul></li><li><p>为什么叫 “成员初始化列表”，顾名思义，就是 成员变量 初始化 的列表</p></li><li><p>初始化顺序（<strong>大坑</strong>）</p><p>初始化的顺序为他们被声明的顺序，而不是他们在初始化列表中的顺序</p><ul><li><p>如<code>A(int n1, int n2): an2(n1), an1(n2) {}</code>，如果在类中an1先被声明，则an1比an2先初始化</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class CMyClass {
    CMyClass(int x, int y);
    int m_x;
    int m_y;
};
CMyClass::CMyClass(int i) : m_y(i), m_x(m_y)
{
}
// 编译器先初始化m_x，然后是m_y,，因为它们是按这样的顺序声明的
// 有两种方法避免它
// 		一个是总是按照你希望它们被初始化的顺序来声明成员
//		第二个是，如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul></li>`,2),_=i(`<h4 id="【特殊语法】类内初始化-构造函数-x-成员变量初始化" tabindex="-1"><a class="header-anchor" href="#【特殊语法】类内初始化-构造函数-x-成员变量初始化"><span>【特殊语法】类内初始化 = 构造函数 x 成员变量初始化</span></a></h4><ul><li><p><strong>C++11</strong>中引入了类内初始化器，以减少构造函数和初始化代码的数量</p></li><li><p>使用</p><ul><li><p>举例</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class Classy
{
    int n1 = 1;
    const int n2 = 2;
    // ...
    Classy(){}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>性质</p><ul><li>这种写法==<strong>和使用成员初始化列表等价</strong>==</li><li>但如果同时使用，成员初始化列表会覆盖类内初始化</li><li>而且成员初始化列表能使用传入的参进行初始化，而类内初始化不行</li></ul></li></ul><h2 id="类型转换函数【可隐式调用】【成员函数】" tabindex="-1"><a class="header-anchor" href="#类型转换函数【可隐式调用】【成员函数】"><span>类型转换函数【可隐式调用】【成员函数】</span></a></h2><p><strong>类型转化函数</strong>和<strong>运算符重载函数</strong>一样都使用 <code>operator</code> 关键字</p><h3 id="能接受一个参数的构造函数-其他类型转换为类" tabindex="-1"><a class="header-anchor" href="#能接受一个参数的构造函数-其他类型转换为类"><span>能接受一个参数的构造函数（其他类型转换为类）</span></a></h3><h4 id="对象创建写法" tabindex="-1"><a class="header-anchor" href="#对象创建写法"><span>对象创建写法</span></a></h4><p><code>A a = val;</code></p><p>本质是隐式类型转换的写法</p><h4 id="自动-强制类型转换" tabindex="-1"><a class="header-anchor" href="#自动-强制类型转换"><span>自动/强制类型转换</span></a></h4><ul><li>描述：能接受一个参数的构造函数，也会被提供给自动和强制类型转换使用</li><li>好处：使用能接受单变量的构造函数来声明类型转换行为的好处：不用单独再写一种函数出来（比如转换函数）</li></ul><h3 id="转换函数-类转换为其他类型" tabindex="-1"><a class="header-anchor" href="#转换函数-类转换为其他类型"><span>转换函数（类转换为其他类型）</span></a></h3><ul><li>作用 <ul><li>将类自动或强制转换为其他类型</li></ul></li><li>使用 <ul><li><p>例如<code>Stonewt::operator double()const;</code></p></li><li><p>例如：分数转化为浮点数</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;iostream&gt;
using namespace std;

class Fraction
{
    public:
        Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {}
        operator double() const {	// 分数转化为浮点数
            return (double) m_numerator/m_denominator; 
        }
    private:
        int m_numerator;        // 分子
        int m_denominator;      // 分母
};
int main(void)
{
    Fraction f(3, 5); 
    double d = 3.2 + f;
    cout &lt;&lt; d &lt;&lt; endl;

    return 0;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="二义性问题" tabindex="-1"><a class="header-anchor" href="#二义性问题"><span>二义性问题</span></a></h3><ul><li>二步转换与二义性 <ul><li>比如给<code>Stonewt(double lbs);</code>赋值int类型时：会先将int转换为double，再进行转换</li><li>但仅当转换不存在二义性时才会进行二步转换，比如还定义了<code>Stonewt(long);</code>则编译器会报错，指出二义性</li></ul></li><li>转换函数二义性 <ul><li>例如如果同时定义了类转换为int和转换为double两种转换函数，隐式转换会产生二义性</li></ul></li></ul><h3 id="explicit-阻止隐式转换" tabindex="-1"><a class="header-anchor" href="#explicit-阻止隐式转换"><span>explicit 阻止隐式转换</span></a></h3><ul><li>作用 <ul><li>可通过关键字<code>explicit</code>关闭前面两种自动特性（单参数对象创建写法和自动类型转换）</li><li>但仍允许显示强制类型转换</li></ul></li><li>使用 <ul><li>例如<code>explicit Stonewt(double lbs);</code>（构造函数）</li><li>例如<code>explicit operator int() const;</code>（转换函数）</li></ul></li><li>关闭的隐式转换种类：（以<code>A(B b);</code>的构造函数为例） <ul><li>用B类型初始化A对象</li><li>B类型赋值给A</li><li>B值传递给接受A参数的函数</li><li>返回值为A的函数试图返回B值</li></ul></li><li>历史版本 <ul><li>C++98中，关键字<code>explicit</code>不能用于转换函数，但C++11消除了这种限制</li></ul></li></ul><h2 id="运算符重载函数【可隐式调用】【成员函数】" tabindex="-1"><a class="header-anchor" href="#运算符重载函数【可隐式调用】【成员函数】"><span>运算符重载函数【可隐式调用】【成员函数】</span></a></h2><p><strong>类型转化函数</strong>和<strong>运算符重载函数</strong>一样都使用 <code>operator</code> 关键字</p><h3 id="简概-3" tabindex="-1"><a class="header-anchor" href="#简概-3"><span>简概</span></a></h3><ul><li>听起来和函数重载差不多，但写法完完全全不同</li><li>类的多态的表现之一（类的多态的具体表现有：运算符重载、成员函数多态、构造函数多态、多态继承等）</li></ul><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><ul><li><code>operator符号()</code></li><li>举例：<code>operator+()</code>，<code>Time Time::operator+(const Time &amp; t) const;</code></li></ul><h3 id="重载限制" tabindex="-1"><a class="header-anchor" href="#重载限制"><span>重载限制</span></a></h3><h4 id="重载限制-1" tabindex="-1"><a class="header-anchor" href="#重载限制-1"><span>重载限制</span></a></h4><ul><li><p>重载后的运算符必须至少有一个操作数是用户定义的类型</p><ul><li>如：不能重载两个double值的和</li></ul></li><li><p>不能违反运算符原来的句法规则</p><ul><li><p>如：不能将求模运算符<code>%</code>重载成只使用一个操作数</p></li><li><p>如：不能修改运算符的优先级</p></li></ul></li><li><p>不能创建新的运算符</p><ul><li>如：不能定义<code>operator**()</code>函数来表示求幂</li></ul></li><li><p>有的运算符不能重载，如下：</p><ul><li><code>sizeof</code>，sizeof运算符</li><li><code>.</code>，成员运算符</li><li><code>.*</code>，成员指针运算符</li><li><code>::</code>，作用域解析运算符</li><li><code>?:</code>，条件运算符</li><li><code>typeid</code>，一个RTTI运算符</li><li><code>const_cast</code>，强制类型转换运算符</li><li><code>dynamic_cast</code>，强制类型转换运算符</li><li><code>reinterpret_cast</code>，强制类型转换运算符</li><li><code>static_cast</code>，强制类型转换运算符</li></ul></li><li><p>大多数运算符可以通过<code>成员</code>或<code>非成员</code>函数进行重组，但有的运算符只能通过<code>成员</code>函数重载，如下</p><ul><li><code>=</code>，赋值运算符</li><li><code>()</code>，函数调用运算符</li><li><code>[]</code>，下标运算符</li><li><code>-&gt;</code>，通过指针访问类成员的运算符</li></ul></li></ul><h4 id="可重载的运算符-表" tabindex="-1"><a class="header-anchor" href="#可重载的运算符-表"><span>可重载的运算符（表）</span></a></h4><ul><li><table><thead><tr><th><code>+</code></th><th><code>-</code></th><th><code>*</code></th><th><code>/</code></th><th><code>%</code></th><th><code>^</code></th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>\`</td><td>\`</td><td><code>~=</code></td><td><code>!</code></td><td><code>=</code></td></tr><tr><td><code>&gt;</code></td><td><code>+=</code></td><td><code>-=</code></td><td><code>*=</code></td><td><code>/=</code></td><td><code>%=</code></td></tr><tr><td><code>^=</code></td><td><code>&amp;=</code></td><td>\`</td><td>=\`</td><td><code>&lt;&lt;</code></td><td><code>&gt;&gt;</code></td></tr><tr><td><code>&lt;&lt;=</code></td><td><code>==</code></td><td><code>!=</code></td><td><code>&lt;=</code></td><td><code>&gt;=</code></td><td><code>&amp;&amp;</code></td></tr><tr><td>\`</td><td></td><td>\`</td><td><code>++</code></td><td><code>--</code></td><td><code>,</code></td></tr><tr><td><code>()</code></td><td><code>[]</code></td><td><code>new</code></td><td><code>delete</code></td><td><code>new[]</code></td><td><code>delete[]</code></td></tr></tbody></table></li></ul><h4 id="【缺陷补丁】友元函数" tabindex="-1"><a class="header-anchor" href="#【缺陷补丁】友元函数"><span>【缺陷补丁】友元函数</span></a></h4><ul><li>缺陷场景 <ul><li>比如能定义<code>classA * int</code>但不能定义<code>int * classA</code></li></ul></li><li>使用 <ul><li>略，详见功能扩展一节</li></ul></li></ul><h1 id="捋一下" tabindex="-1"><a class="header-anchor" href="#捋一下"><span>捋一下</span></a></h1><h2 id="the-big-three" tabindex="-1"><a class="header-anchor" href="#the-big-three"><span><mark>The Big Three</mark></span></a></h2>`,31),f={href:"https://gcallah.github.io/OOP2/big3.html",target:"_blank",rel:"noopener noreferrer"},k=i('<ul><li>如果类包含指针，<strong>必须</strong>要自己写拷贝构造，否则两个指针会指向同一个东西</li><li>当您需要编写其中任何一个时，您很可能需要编写另外两个。如果类包含指针，就<strong>必须</strong>手动实现这三种而非用默认给你的，否则会导致两个类</li></ul><h2 id="自动提供的成员函数【可隐式调用】-如果没有定义" tabindex="-1"><a class="header-anchor" href="#自动提供的成员函数【可隐式调用】-如果没有定义"><span>自动提供的成员函数【可隐式调用】（如果没有定义）</span></a></h2><p>这里重点捋一下自动调用的场景</p><p>自动提供的成员函数：</p><ul><li>默认构造函数</li><li>默认析构函数</li><li>复制构造函数</li><li>赋值运算符</li><li>地址运算符</li></ul><p>其中默认构造函数、默认析构函数、复制构造函数，前面都说过。这里来看下赋值运算符</p><h3 id="赋值运算符-自动提供" tabindex="-1"><a class="header-anchor" href="#赋值运算符-自动提供"><span>赋值运算符（自动提供）</span></a></h3><ul><li>要点 <ul><li>赋值构造函数的功能是浅赋值 <ul><li>当成员中有动态创建的变量时这可能会<strong>引发一些问题</strong>（如<code>delete</code>一块堆内存两次，其症状之一是字符串出现乱码）</li></ul></li></ul></li><li>原型 <ul><li><code>ClassName &amp; Classname::operator=(const ClassName &amp;);</code></li></ul></li><li>调用场景 <ul><li>不要弄混赋值和初始化。若创建新的对象则使用初始化，若修改已有对象的值则使用赋值</li><li>同一个类的引用对象（包括派生类对象）赋值给该类的对象。如<code>a1 = a2;</code></li><li>用类的引用对象（包括派生类对象）初始化该类的对象时，一定调用复制构造函数，但<strong>不一定</strong>使用赋值运算符。如<code>A a1 = a2;</code><ul><li>不一定是什么意思？详见前面<code>创建对象的n种方式</code>一节</li><li>解释器有两种方式去解释<code>A a1 = a2;</code>该语句：创建一个临时对象然后赋值的版本 才会使用赋值运算符</li></ul></li></ul></li></ul><h3 id="带来的一些问题-有new声明的成员时" tabindex="-1"><a class="header-anchor" href="#带来的一些问题-有new声明的成员时"><span>带来的一些问题（有new声明的成员时）</span></a></h3><ul><li><p>问题</p><ul><li>默认的<code>复制构造函数</code>和<code>复制运算符</code>使用的都是浅赋值</li><li>当成员中有动态创建的变量时这可能会<strong>引发一些问题</strong>（如<code>delete</code>一块堆内存两次，其症状之一是字符串出现乱码）</li></ul></li><li><p>解决方案</p><ul><li>详见前面的<code>【功能扩展】类成员 x new</code>一节</li></ul></li></ul><h2 id="【区别】复制构造与重载-、构造与重载" tabindex="-1"><a class="header-anchor" href="#【区别】复制构造与重载-、构造与重载"><span>【区别】复制构造与重载=、构造与重载()</span></a></h2><h4 id="复制构造函数、重载运算符-、转换函数" tabindex="-1"><a class="header-anchor" href="#复制构造函数、重载运算符-、转换函数"><span>复制构造函数、重载运算符 =、转换函数</span></a></h4><h4 id="构造函数、重载运算符" tabindex="-1"><a class="header-anchor" href="#构造函数、重载运算符"><span>构造函数、重载运算符 ()</span></a></h4><h2 id="【功能扩展】类中函数" tabindex="-1"><a class="header-anchor" href="#【功能扩展】类中函数"><span>【功能扩展】类中函数</span></a></h2><h3 id="构造函数的扩展" tabindex="-1"><a class="header-anchor" href="#构造函数的扩展"><span>构造函数的扩展</span></a></h3><h4 id="【功能扩展】构造函数-x-函数重载-模板函数" tabindex="-1"><a class="header-anchor" href="#【功能扩展】构造函数-x-函数重载-模板函数"><span>【功能扩展】构造函数 x 函数重载/模板函数</span></a></h4><h4 id="【功能拓展】类模板-构造函数-x-模板" tabindex="-1"><a class="header-anchor" href="#【功能拓展】类模板-构造函数-x-模板"><span>【功能拓展】类模板 = 构造函数 x 模板</span></a></h4><h4 id="【功能拓展】stl-类-x-泛型-c-标准模板库" tabindex="-1"><a class="header-anchor" href="#【功能拓展】stl-类-x-泛型-c-标准模板库"><span>【功能拓展】STL = 类 x 泛型（C++标准模板库）</span></a></h4><h3 id="友元的扩展" tabindex="-1"><a class="header-anchor" href="#友元的扩展"><span>友元的扩展</span></a></h3><ul><li>使用场景：要让一个类访问令一个类的成员有两种途径： <ul><li>让整个类成为另一个类的友元</li><li>让特定的类成员称为另一个类的友元（这种做法必须小心排列声明和定义的顺序）</li></ul></li></ul><h4 id="【功能扩展】友元-x-类" tabindex="-1"><a class="header-anchor" href="#【功能扩展】友元-x-类"><span>【功能扩展】友元 x 类</span></a></h4><ul><li>写法 <ul><li>举例：<code>class TV { public: friend Remote; ...</code></li><li>顺序：可以先声明<code>class Tv</code>再声明<code>class Remote</code>，也可以反过来（所以可以互相成为友元）</li><li>顺序问题：这里先声明的Tv，但Remote不用向前声明是因为该友元语句本身已经指出Remote是一个类</li></ul></li><li>扩展 <ul><li>可以让类彼此成为对方的友元</li></ul></li></ul><h4 id="【功能扩展】友元-x-类成员" tabindex="-1"><a class="header-anchor" href="#【功能扩展】友元-x-类成员"><span>【功能扩展】友元 x 类成员</span></a></h4>',23),A=i("<li><p>写法</p><ul><li>举例：<code>class TV { public: friend void Remote::setTv(); ...</code></li><li>顺序：<code>class Tv;</code>-&gt;<code>Remote的定义</code>-&gt;<code>Tv的定义</code>（反过来不行，应在Tv前定义setTv方法）</li><li>顺序问题：这里顺序有点麻烦： <ul><li>编译器要能够处理这条语句，必须先知道Remote的定义，那应先声明Remote</li><li>而Remote中要访问Tv的成员，所以Tv应该声明在Remote前</li><li>这会形成<code>循环依赖</code>，解决方案：使用<code>向前声明</code>（<em>forward declaration</em>）</li></ul></li></ul></li>",1),C=l("p",null,"顺序补充（谁向前声明）",-1),B={href:"https://blog.csdn.net/weixin_30951389/article/details/96460710",target:"_blank",rel:"noopener noreferrer"},E=i(`<li><p>CA.h</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#ifndef HEADER_CA
#define HEADER_CA
#include &quot;CB.h&quot;
class CA
{
	CB* pB;
	CB  b; //正确,因为此处已经知道CB类的大小,且定义了CB,可以为b分配空间
};
#endif
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>CB.h</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#ifndef HEADER_CB
#define HEADER_CB
class CA;//这个必须要用,不能只用#include &quot;CA.h&quot;,如果只是#include &quot;CA.h&quot;而没有class CA;则会报错.
class CB
{
	CA* pA;
	//CA a;//错误,因为此时还不知道CA的大小,无法分配空间
};
#endif 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>CA.cpp</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &quot;CA.h&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>*.cpp文件只能#include “CA.h”.如果#icnlude “CB.h”则错误(展开后CA不识别CB)。</p></li>`,3),y=l("p",null,"局限性",-1),T={href:"https://www.cnblogs.com/wkfvawl/p/10801725.html",target:"_blank",rel:"noopener noreferrer"},w=i("<li>使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，在提供一个完整的类声明之前： <ul><li><strong><mark>不能</mark>定义该类的对象</strong> （因为此时编译器只知道这是个类，还不知道这个类的大小有多大）</li><li><strong><mark>不能</mark>在内联成员函数中使用该类的对象。</strong> （因为此时根本不知道有些什么成员）</li><li><strong><mark>可以</mark>定义该类的指针、引用、以及用于函数形参的指针和引用</strong></li></ul></li>",1);function D(N,R){const d=a("ExternalLinkIcon");return s(),c("div",null,[o,l("ul",null,[u,l("li",null,[h,l("ul",null,[p,l("li",null,[v,l("ul",null,[l("li",null,[l("p",null,[e("参考："),l("a",m,[e("【博客园】C++成员初始化列表作用，以及减少构造函数初始化步骤"),t(d)]),e("（这篇文章讲得"),b,e("，推荐一看）")]),g])])])])]),x]),_,l("p",null,[l("a",f,[e("The Big Three"),t(d)]),e("，指 拷贝构造函数、赋值操作符、析构函数")]),k,l("ul",null,[A,l("li",null,[C,l("ul",null,[l("li",null,[l("p",null,[e("参考："),l("a",B,[e("【CSDN】类的向前声明"),t(d)])])]),E])]),l("li",null,[y,l("ul",null,[l("li",null,[e("参考："),l("a",T,[e("【博客园】C++ 类的前向声明的用法"),t(d)])]),w])])])])}const M=n(r,[["render",D],["__file","02. 类中函数.html.vue"]]),L=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.%20%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0.html","title":"类中函数（分类，特殊成员或非成员函数）","lang":"zh-CN","frontmatter":{"description":"类中函数（分类，特殊成员或非成员函数） 成员/方法访问控制 friend 友元函数【非成员函数】 简概 友元有三种 友元函数 友元类 友元成员函数 【功能扩展】友元函数 = 友元 x 函数 使用 原型：将原型放在类声明中，并在声明前加上关键字friend 例如：friend Time operator*(double m, const Time &t)...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.%20%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"类中函数（分类，特殊成员或非成员函数）"}],["meta",{"property":"og:description","content":"类中函数（分类，特殊成员或非成员函数） 成员/方法访问控制 friend 友元函数【非成员函数】 简概 友元有三种 友元函数 友元类 友元成员函数 【功能扩展】友元函数 = 友元 x 函数 使用 原型：将原型放在类声明中，并在声明前加上关键字friend 例如：friend Time operator*(double m, const Time &t)..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类中函数（分类，特殊成员或非成员函数）\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"类中函数（分类，特殊成员或非成员函数）","slug":"类中函数-分类-特殊成员或非成员函数","link":"#类中函数-分类-特殊成员或非成员函数","children":[{"level":2,"title":"成员/方法访问控制","slug":"成员-方法访问控制","link":"#成员-方法访问控制","children":[{"level":3,"title":"friend 友元函数【非成员函数】","slug":"friend-友元函数【非成员函数】","link":"#friend-友元函数【非成员函数】","children":[{"level":4,"title":"简概","slug":"简概","link":"#简概","children":[]},{"level":4,"title":"【功能扩展】友元函数 = 友元 x 函数","slug":"【功能扩展】友元函数-友元-x-函数","link":"#【功能扩展】友元函数-友元-x-函数","children":[]}]}]},{"level":2,"title":"成员函数与非成员函数","slug":"成员函数与非成员函数","link":"#成员函数与非成员函数","children":[{"level":3,"title":"成员函数简概","slug":"成员函数简概","link":"#成员函数简概","children":[]},{"level":3,"title":"分类","slug":"分类","link":"#分类","children":[]},{"level":3,"title":"区别","slug":"区别","link":"#区别","children":[]},{"level":3,"title":"【总结】成员函数属性（或友元）","slug":"【总结】成员函数属性-或友元","link":"#【总结】成员函数属性-或友元","children":[]}]}]},{"level":1,"title":"类中函数（具体函数）","slug":"类中函数-具体函数","link":"#类中函数-具体函数","children":[{"level":2,"title":"构造与析构函数【成员函数】","slug":"构造与析构函数【成员函数】","link":"#构造与析构函数【成员函数】","children":[{"level":3,"title":"构造函数（及其原理）","slug":"构造函数-及其原理","link":"#构造函数-及其原理","children":[{"level":4,"title":"简概","slug":"简概-1","link":"#简概-1","children":[]},{"level":4,"title":"（成员变量注意项）","slug":"成员变量注意项","link":"#成员变量注意项","children":[]},{"level":4,"title":"默认构造函数（自动提供）","slug":"默认构造函数-自动提供","link":"#默认构造函数-自动提供","children":[]},{"level":4,"title":"复制构造函数（自动提供）","slug":"复制构造函数-自动提供","link":"#复制构造函数-自动提供","children":[]},{"level":4,"title":"移动构造函数（C++11）","slug":"移动构造函数-c-11","link":"#移动构造函数-c-11","children":[]},{"level":4,"title":"移动赋值函数（C++11）","slug":"移动赋值函数-c-11","link":"#移动赋值函数-c-11","children":[]}]},{"level":3,"title":"析构函数（及其原理）","slug":"析构函数-及其原理","link":"#析构函数-及其原理","children":[{"level":4,"title":"简概","slug":"简概-2","link":"#简概-2","children":[]},{"level":4,"title":"默认析构函数（自动提供）","slug":"默认析构函数-自动提供","link":"#默认析构函数-自动提供","children":[]}]},{"level":3,"title":"【功能扩展】构造函数的扩展","slug":"【功能扩展】构造函数的扩展","link":"#【功能扩展】构造函数的扩展","children":[{"level":4,"title":"【特殊语法】成员初始化列表 = 构造函数 x 成员变量初始化","slug":"【特殊语法】成员初始化列表-构造函数-x-成员变量初始化","link":"#【特殊语法】成员初始化列表-构造函数-x-成员变量初始化","children":[]},{"level":4,"title":"【特殊语法】类内初始化 = 构造函数 x 成员变量初始化","slug":"【特殊语法】类内初始化-构造函数-x-成员变量初始化","link":"#【特殊语法】类内初始化-构造函数-x-成员变量初始化","children":[]}]}]},{"level":2,"title":"类型转换函数【可隐式调用】【成员函数】","slug":"类型转换函数【可隐式调用】【成员函数】","link":"#类型转换函数【可隐式调用】【成员函数】","children":[{"level":3,"title":"能接受一个参数的构造函数（其他类型转换为类）","slug":"能接受一个参数的构造函数-其他类型转换为类","link":"#能接受一个参数的构造函数-其他类型转换为类","children":[{"level":4,"title":"对象创建写法","slug":"对象创建写法","link":"#对象创建写法","children":[]},{"level":4,"title":"自动/强制类型转换","slug":"自动-强制类型转换","link":"#自动-强制类型转换","children":[]}]},{"level":3,"title":"转换函数（类转换为其他类型）","slug":"转换函数-类转换为其他类型","link":"#转换函数-类转换为其他类型","children":[]},{"level":3,"title":"二义性问题","slug":"二义性问题","link":"#二义性问题","children":[]},{"level":3,"title":"explicit 阻止隐式转换","slug":"explicit-阻止隐式转换","link":"#explicit-阻止隐式转换","children":[]}]},{"level":2,"title":"运算符重载函数【可隐式调用】【成员函数】","slug":"运算符重载函数【可隐式调用】【成员函数】","link":"#运算符重载函数【可隐式调用】【成员函数】","children":[{"level":3,"title":"简概","slug":"简概-3","link":"#简概-3","children":[]},{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"重载限制","slug":"重载限制","link":"#重载限制","children":[{"level":4,"title":"重载限制","slug":"重载限制-1","link":"#重载限制-1","children":[]},{"level":4,"title":"可重载的运算符（表）","slug":"可重载的运算符-表","link":"#可重载的运算符-表","children":[]},{"level":4,"title":"【缺陷补丁】友元函数","slug":"【缺陷补丁】友元函数","link":"#【缺陷补丁】友元函数","children":[]}]}]}]},{"level":1,"title":"捋一下","slug":"捋一下","link":"#捋一下","children":[{"level":2,"title":"The Big Three","slug":"the-big-three","link":"#the-big-three","children":[]},{"level":2,"title":"自动提供的成员函数【可隐式调用】（如果没有定义）","slug":"自动提供的成员函数【可隐式调用】-如果没有定义","link":"#自动提供的成员函数【可隐式调用】-如果没有定义","children":[{"level":3,"title":"赋值运算符（自动提供）","slug":"赋值运算符-自动提供","link":"#赋值运算符-自动提供","children":[]},{"level":3,"title":"带来的一些问题（有new声明的成员时）","slug":"带来的一些问题-有new声明的成员时","link":"#带来的一些问题-有new声明的成员时","children":[]}]},{"level":2,"title":"【区别】复制构造与重载=、构造与重载()","slug":"【区别】复制构造与重载-、构造与重载","link":"#【区别】复制构造与重载-、构造与重载","children":[{"level":4,"title":"复制构造函数、重载运算符 =、转换函数","slug":"复制构造函数、重载运算符-、转换函数","link":"#复制构造函数、重载运算符-、转换函数","children":[]},{"level":4,"title":"构造函数、重载运算符 ()","slug":"构造函数、重载运算符","link":"#构造函数、重载运算符","children":[]}]},{"level":2,"title":"【功能扩展】类中函数","slug":"【功能扩展】类中函数","link":"#【功能扩展】类中函数","children":[{"level":3,"title":"构造函数的扩展","slug":"构造函数的扩展","link":"#构造函数的扩展","children":[{"level":4,"title":"【功能扩展】构造函数 x 函数重载/模板函数","slug":"【功能扩展】构造函数-x-函数重载-模板函数","link":"#【功能扩展】构造函数-x-函数重载-模板函数","children":[]},{"level":4,"title":"【功能拓展】类模板 = 构造函数 x 模板","slug":"【功能拓展】类模板-构造函数-x-模板","link":"#【功能拓展】类模板-构造函数-x-模板","children":[]},{"level":4,"title":"【功能拓展】STL = 类 x 泛型（C++标准模板库）","slug":"【功能拓展】stl-类-x-泛型-c-标准模板库","link":"#【功能拓展】stl-类-x-泛型-c-标准模板库","children":[]}]},{"level":3,"title":"友元的扩展","slug":"友元的扩展","link":"#友元的扩展","children":[{"level":4,"title":"【功能扩展】友元 x 类","slug":"【功能扩展】友元-x-类","link":"#【功能扩展】友元-x-类","children":[]},{"level":4,"title":"【功能扩展】友元 x 类成员","slug":"【功能扩展】友元-x-类成员","link":"#【功能扩展】友元-x-类成员","children":[]}]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":17.83,"words":5349},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/06. 面向对象/02. 类的内容/02. 类中函数.md","autoDesc":true}');export{M as comp,L as data};
