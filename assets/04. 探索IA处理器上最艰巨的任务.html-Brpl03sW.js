import{_ as t,c as o,e as n,o as l}from"./app-BgHc8lP1.js";const i="/assets/Image00044-D_Ck8HNj.jpg",E={};function r(p,e){return l(),o("div",null,e[0]||(e[0]=[n('<h1 id="探索ia处理器上最艰巨的任务" tabindex="-1"><a class="header-anchor" href="#探索ia处理器上最艰巨的任务"><span>探索IA处理器上最艰巨的任务</span></a></h1><p>在通用处理器上处理包的最大挑战是什么？为什么以往通用处理器很少在数据面中扮演重要的角色？如果我们带着这些问题来看数据面上的负载，就会有一个比较直观的理解。这里拿40Gbit/s的速率作为考察包转发能力的样本。如图1-8所示，曲线为不同大小的包的最大理论转发能力。</p><p>线速情况下的报文的<strong>指令成本</strong></p><p><img src="'+i+'" alt="img" loading="lazy"></p><p>计算</p><blockquote><p>分别截取64B和1024B数据包长，图1-8所示的线速情况下的报文的指令成本能明显地说明不同报文大小给系统带来的巨大差异。</p><ul><li><strong>包到达间隔</strong>：就如我们在包转发率那一节中理解的，对于越小的包，相邻包到达的时间间隔就越小。64B 和 1024B 分别为<em>16.8ns 和 208.8ns</em>。</li><li><strong>允许消耗</strong>：假设CPU的主频率是2GHz，要达到理论最大的转发能力，对于64B和1024B软件分别允许消耗 <em>33 和 417 个时钟周期</em>。</li><li><strong>实际消耗 - 访存部分</strong>：在<em>存储转发（store-forward）模型</em>下，报文收发以及查表都需要访存。那就对比一下访存的时钟周期。 <ul><li>一次LLC (最后一级缓存) 命中需要大约 <em>40个时钟周期</em></li><li>如果LLC未命中，一次内存的读就需要 <em>70ns</em></li></ul></li><li><strong>差距</strong>：换句话说，对于64B大小的包，即使每次都能命中LLC，<em>40个时钟周期依然离33有距离</em>。显然，小包处理时延对于通用CPU系统架构的挑战是巨大的。</li></ul></blockquote><p>解决</p><blockquote><p>那是否说明IA就完全不适合高性能的网络负载呢？答案是否定的。证明这样的结论我们从两个方面入手，一个是IA平台实际能提供的最大能力，另一个是这个能力是否足以应对一定领域的高性能网络负载。</p><p>DPDK的出现充分释放了IA平台对包处理的吞吐能力。我们知道，随着吞吐率的上升，中断触发的开销是不能忍受的，DPDK通过一系列软件优化方法（<em>大页利用，cache对齐，线程绑定，NUMA感知，内存通道交叉访问，无锁化数据结构，预取，SIMD指令利用等</em>）利用IA平台硬件特性，提供完整的底层开发支持库。使得单核三层转发可以轻松地突破小包30Mpps，随着CPU封装的核数越来越多，支持的PCIe通道数越来越多，整系统的三层转发吞吐在2路CPU的Xeon E5-2658v3上可以达到300Mpps。这已经是一个相当可观的转发吞吐能力了。</p><p>虽然这个能力不足以覆盖网络中所有端到端的设备场景，但无论在核心网接入侧，还是在数据中心网络中，都已经可以覆盖相当多的场景。</p><p>随着数据面可软化的发生，数据面的设计、开发、验证乃至部署会发生一系列的变化。</p><ul><li>首先，可以采用通用服务器平台，降低专门硬件设计成本；</li><li>其次，基于C语言的开发，就程序员数量以及整个生态都要比专门硬件开发更丰富；</li><li>另外，灵活可编程的数据面部署也给网络功能虚拟化（NFV）带来了可能，更会进一步推进软件定义网络（SDN）的全面展开。</li></ul></blockquote>',8)]))}const s=t(E,[["render",r],["__file","04. 探索IA处理器上最艰巨的任务.html.vue"]]),A=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/01.%20%E8%AE%A4%E8%AF%86DPDK/04.%20%E6%8E%A2%E7%B4%A2IA%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8A%E6%9C%80%E8%89%B0%E5%B7%A8%E7%9A%84%E4%BB%BB%E5%8A%A1.html","title":"探索IA处理器上最艰巨的任务","lang":"zh-CN","frontmatter":{"description":"探索IA处理器上最艰巨的任务 在通用处理器上处理包的最大挑战是什么？为什么以往通用处理器很少在数据面中扮演重要的角色？如果我们带着这些问题来看数据面上的负载，就会有一个比较直观的理解。这里拿40Gbit/s的速率作为考察包转发能力的样本。如图1-8所示，曲线为不同大小的包的最大理论转发能力。 线速情况下的报文的指令成本 img 计算 分别截取64B和1...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/01.%20%E8%AE%A4%E8%AF%86DPDK/04.%20%E6%8E%A2%E7%B4%A2IA%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8A%E6%9C%80%E8%89%B0%E5%B7%A8%E7%9A%84%E4%BB%BB%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"探索IA处理器上最艰巨的任务"}],["meta",{"property":"og:description","content":"探索IA处理器上最艰巨的任务 在通用处理器上处理包的最大挑战是什么？为什么以往通用处理器很少在数据面中扮演重要的角色？如果我们带着这些问题来看数据面上的负载，就会有一个比较直观的理解。这里拿40Gbit/s的速率作为考察包转发能力的样本。如图1-8所示，曲线为不同大小的包的最大理论转发能力。 线速情况下的报文的指令成本 img 计算 分别截取64B和1..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"探索IA处理器上最艰巨的任务\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"探索IA处理器上最艰巨的任务","slug":"探索ia处理器上最艰巨的任务","link":"#探索ia处理器上最艰巨的任务","children":[]}],"git":{},"readingTime":{"minutes":3.1,"words":929},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/01. 认识DPDK/04. 探索IA处理器上最艰巨的任务.md","excerpt":"\\n<p>在通用处理器上处理包的最大挑战是什么？为什么以往通用处理器很少在数据面中扮演重要的角色？如果我们带着这些问题来看数据面上的负载，就会有一个比较直观的理解。这里拿40Gbit/s的速率作为考察包转发能力的样本。如图1-8所示，曲线为不同大小的包的最大理论转发能力。</p>\\n<p>线速情况下的报文的<strong>指令成本</strong></p>\\n<p></p>\\n<p>计算</p>\\n<blockquote>\\n<p>分别截取64B和1024B数据包长，图1-8所示的线速情况下的报文的指令成本能明显地说明不同报文大小给系统带来的巨大差异。</p>\\n<ul>\\n<li><strong>包到达间隔</strong>：就如我们在包转发率那一节中理解的，对于越小的包，相邻包到达的时间间隔就越小。64B 和 1024B 分别为<em>16.8ns 和 208.8ns</em>。</li>\\n<li><strong>允许消耗</strong>：假设CPU的主频率是2GHz，要达到理论最大的转发能力，对于64B和1024B软件分别允许消耗 <em>33 和 417 个时钟周期</em>。</li>\\n<li><strong>实际消耗 - 访存部分</strong>：在<em>存储转发（store-forward）模型</em>下，报文收发以及查表都需要访存。那就对比一下访存的时钟周期。\\n<ul>\\n<li>一次LLC (最后一级缓存) 命中需要大约 <em>40个时钟周期</em></li>\\n<li>如果LLC未命中，一次内存的读就需要 <em>70ns</em></li>\\n</ul>\\n</li>\\n<li><strong>差距</strong>：换句话说，对于64B大小的包，即使每次都能命中LLC，<em>40个时钟周期依然离33有距离</em>。显然，小包处理时延对于通用CPU系统架构的挑战是巨大的。</li>\\n</ul>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/01. 认识DPDK/04. 探索IA处理器上最艰巨的任务.md","value":{"title":"04. 探索IA处理器上最艰巨的任务","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/01. 认识DPDK/04. 探索IA处理器上最艰巨的任务.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{s as comp,A as data};
