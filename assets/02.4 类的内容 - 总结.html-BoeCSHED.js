import{_ as i,e as t,g as n,o as a}from"./app-CuJixpuN.js";const l={};function e(c,s){return a(),t("div",null,s[0]||(s[0]=[n(`<h1 id="类的内容-总结" tabindex="-1"><a class="header-anchor" href="#类的内容-总结"><span>类的内容 - 总结</span></a></h1><h2 id="访问控制" tabindex="-1"><a class="header-anchor" href="#访问控制"><span>访问控制</span></a></h2><h3 id="const-成员函数-访问器方法" tabindex="-1"><a class="header-anchor" href="#const-成员函数-访问器方法"><span>Const 成员函数（访问器方法）</span></a></h3><h4 id="const成员函数-常量成员函数" tabindex="-1"><a class="header-anchor" href="#const成员函数-常量成员函数"><span>const成员函数 / 常量成员函数</span></a></h4><ul><li><p>使用场景</p><ul><li>举例：<code>const Stock land = Stock(&quot;LLL&quot;); land.show();</code>中，第二条语句会被拒绝</li></ul></li><li><p>使用</p><ul><li><p>声明时在后面加<code>cosnt</code>，如<code>void stock::show() const;</code>。这种函数称为<code>const成员函数</code></p></li><li><p>设计思路（猜的）</p><ul><li><p>一般函数的解决方案是在参数列表中添加<code>const</code>，但这里实例本身是隐式参，不在参数列表里</p></li><li><p>既然参数列表里不能加，函数前面的const又表示返回值的类型，于是这里的const就被设计成放在后面了</p></li><li><p>用来表示在该成员函数中，对象本身的传入类型是<code>const</code></p></li></ul></li></ul></li><li><p>作用</p><ul><li><p>一是能规定一些函数当对象实例被声明为const时不可用</p><p>即被声明未const类型的对象实例能访问<code>const成员函数</code>而不能访问<code>非const成员函数</code></p></li><li><p>二是使被声明为const的对象实例仍能访问其中的函数（主要作用）</p></li><li><p>三是防止数据被某些成员函数改变</p></li></ul></li></ul><p>参考：https://www.cnblogs.com/cthon/p/9178701.html</p><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员**（准确地说是非静态数据成员）**作任何改变</p><p>在设计类的时候，一个原则就是对于<strong>不改变数据成员的成员函数都要在后面加 const</strong>，而对于改变数据成员的成员函数不能加 const</p><ul><li>（1）有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；<br> 没有 const 修饰的成员函数，对数据成员则是可读可写的。</li><li>（2）除此之外，在类的成员函数后面加 const 还有什么好处呢？<br> 那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。</li></ul><h4 id="const成员变量-常量成员变量" tabindex="-1"><a class="header-anchor" href="#const成员变量-常量成员变量"><span>const成员变量 / 常量成员变量</span></a></h4><p>略</p><p>和const成员变量之间<strong>没有什么关系</strong>，</p><ul><li>const成员变量：这里的const指的是 “常量”</li><li>const成员函数：这里的const着重指 “不修改” <ul><li>非const/const成员函数，都能调用 非const/const成员变量</li></ul></li></ul><h4 id="const对象-常量对象" tabindex="-1"><a class="header-anchor" href="#const对象-常量对象"><span>const对象 / 常量对象</span></a></h4><p>略</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><ol><li><p><strong>const对象</strong>只能调用<strong>const成员函数</strong>，不能调用<strong>非const成员函数</strong></p><p><strong>非const对象</strong>可以调用const成员函数，自然也能调用非const成员函数</p></li><li><p><strong>非const成员函数</strong>可以调用<strong>const成员函数</strong>，</p><p>反过来则不行，const成员函数不能调用非const成员函数</p></li><li><p>非const/const成员函数 都能调用 <strong>非const/const成员变量</strong>（<em>他们之间没什么关系</em>）</p></li></ol><h3 id="static-静态成员函数" tabindex="-1"><a class="header-anchor" href="#static-静态成员函数"><span>Static 静态成员函数</span></a></h3><p>静态成员函数 = 成员函数 x 静态成员变量</p><p>说明</p><ul><li>静态成员变量，一般与静态成员函数一起使用</li><li>静态成员变量和静态成员函数，均不与对象实例相关，可以在不创建对象的情况下使用</li><li>静态成员函数：只能使用静态成员变量，而不能使用其他成员变量</li></ul><h4 id="static成员变量-静态成员变量" tabindex="-1"><a class="header-anchor" href="#static成员变量-静态成员变量"><span>static成员变量 / 静态成员变量</span></a></h4><ul><li>使用 <ul><li>注意：不仅仅只是在前面加static关键字</li><li>使用静态成员变量时，还需要在类实现文件中进行初始化，比如 <ul><li>.h：<code>static PluginManager *m_instance;</code></li><li>.cpp：<code>PluginManager* PluginManager::m_instance;</code>（是否初始化值均可，但一定要在cpp声明）</li><li>如果没有初始化，QT中会报错：<code>LNK2001: 无法解析的外部符号 &quot;xxx: static class xxx</code></li><li>若不使用，比如只是为了使用其析构函数（如在类中嵌套垃圾回收的类），则不需要初始化</li></ul></li></ul></li></ul><h4 id="static成员函数-静态成员函数" tabindex="-1"><a class="header-anchor" href="#static成员函数-静态成员函数"><span>static成员函数 / 静态成员函数</span></a></h4><ul><li>说明 <ul><li>可将成员函数声明未静态的（静态就意味着存储在全局/静态区，且只有一个备份）</li></ul></li><li>使用 <ul><li>定义：在前面加关键字<code>static</code>，如<code>static int HowMany(){return num_strings;}</code></li><li>使用：例如<code>int count = String::HowMany();</code>（不使用成员运算符）</li><li>补充：可以在不创建对象的情况下直接使用静态成员函数，如 <code>pluginManager = PluginManager::instance();</code><br> 如果非静态成员函数用这种写法的话会报错 <code>call to non-static member function without an object argument</code>（在没有对象参数的情况下，调用了一个非静态成员函数）</li></ul></li><li>注意 <ul><li>静态成员函数不与特定的对象相联，只能使用静态数据成员而不能使用类的其他成员</li><li>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员<br> 而静态成员函数没有 this 指针，只能访问静态成员</li></ul></li></ul><h4 id="static对象-静态对象" tabindex="-1"><a class="header-anchor" href="#static对象-静态对象"><span>static对象 / 静态对象</span></a></h4><p>略</p><p>单例模式会用到 static对象，将构造函数放入private，然后将static对象的创建放入instant 方法中。<br> 那么在调用 instant 方法之前，该static对象不存在。调用 instant 方法后，该static对象一直存在至程序结束。</p><h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h4><ul><li><strong>static成员函数</strong>和<strong>非static成员函数</strong>其实能互相调用。但static函数调用非static函数需要一点技巧，见：https://www.cnblogs.com/rickyk/p/4238380.html</li><li><strong>static对象</strong>和static成员函数或非static成员函数 <em>没有什么关系</em></li><li>static成员变量和static成员函数或非static成员函数也 <em>没有什么关系</em></li></ul><h3 id="const-static-conststatic" tabindex="-1"><a class="header-anchor" href="#const-static-conststatic"><span>const static / conststatic</span></a></h3><p>这个应该只能修饰成员变量，至于成员函数应该无法修饰（再说成员函数的const和static分别在括号的后面和函数声明的最前面，不在一起的），对象应该也无法修饰</p><h4 id="const-static-conststatic-成员变量" tabindex="-1"><a class="header-anchor" href="#const-static-conststatic-成员变量"><span>const static / conststatic 成员变量</span></a></h4><p>参考：https://blog.csdn.net/lp10031312/article/details/79512165</p><p>const定义的常量在超出其作用域之后其空间会被释放，而<strong>static定义的静态常量在函数执行后不会释放其存储空间</strong></p><p>static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。<strong>即使没有具体对象，也能调用类的静态成员函数和成员变量</strong>。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。</p><ul><li><strong>const成员函数主要目的是防止成员函数修改对象的内容</strong></li><li><strong>static成员函数主要目的是作为类作用域的全局函数</strong></li></ul><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){}  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    enum</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">size1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">size2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 只能在构造函数初始化列表中初始化  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 在类的实现文件中定义并初始化  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    conststatic </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> c;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// 与 static const int c;相同。  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Test::b</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">cosnt intTest::c</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,38)]))}const p=i(l,[["render",e],["__file","02.4 类的内容 - 总结.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.4%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9%20-%20%E6%80%BB%E7%BB%93.html","title":"类的内容 - 总结","lang":"zh-CN","frontmatter":{"description":"类的内容 - 总结 访问控制 Const 成员函数（访问器方法） const成员函数 / 常量成员函数 使用场景 举例：const Stock land = Stock(\\"LLL\\"); land.show();中，第二条语句会被拒绝 使用 声明时在后面加cosnt，如void stock::show() const;。这种函数称为const成员函数 设...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.4%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9%20-%20%E6%80%BB%E7%BB%93.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"类的内容 - 总结"}],["meta",{"property":"og:description","content":"类的内容 - 总结 访问控制 Const 成员函数（访问器方法） const成员函数 / 常量成员函数 使用场景 举例：const Stock land = Stock(\\"LLL\\"); land.show();中，第二条语句会被拒绝 使用 声明时在后面加cosnt，如void stock::show() const;。这种函数称为const成员函数 设..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类的内容 - 总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":5.93,"words":1780},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/02. 类的内容/02.4 类的内容 - 总结.md","excerpt":"\\n<h2>访问控制</h2>\\n<h3>Const 成员函数（访问器方法）</h3>\\n<h4>const成员函数 / 常量成员函数</h4>\\n<ul>\\n<li>\\n<p>使用场景</p>\\n<ul>\\n<li>举例：<code>const Stock land = Stock(\\"LLL\\"); land.show();</code>中，第二条语句会被拒绝</li>\\n</ul>\\n</li>\\n<li>\\n<p>使用</p>\\n<ul>\\n<li>\\n<p>声明时在后面加<code>cosnt</code>，如<code>void stock::show() const;</code>。这种函数称为<code>const成员函数</code></p>\\n</li>\\n<li>\\n<p>设计思路（猜的）</p>\\n<ul>\\n<li>\\n<p>一般函数的解决方案是在参数列表中添加<code>const</code>，但这里实例本身是隐式参，不在参数列表里</p>\\n</li>\\n<li>\\n<p>既然参数列表里不能加，函数前面的const又表示返回值的类型，于是这里的const就被设计成放在后面了</p>\\n</li>\\n<li>\\n<p>用来表示在该成员函数中，对象本身的传入类型是<code>const</code></p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>作用</p>\\n<ul>\\n<li>\\n<p>一是能规定一些函数当对象实例被声明为const时不可用</p>\\n<p>即被声明未const类型的对象实例能访问<code>const成员函数</code>而不能访问<code>非const成员函数</code></p>\\n</li>\\n<li>\\n<p>二是使被声明为const的对象实例仍能访问其中的函数（主要作用）</p>\\n</li>\\n<li>\\n<p>三是防止数据被某些成员函数改变</p>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/02. 类的内容/02.4 类的内容 - 总结.md","value":{"title":"02.4 类的内容 - 总结","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/02. 类的内容/02.4 类的内容 - 总结.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{p as comp,h as data};
