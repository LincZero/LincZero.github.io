import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as i,e as l}from"./app-CoO7IlkE.js";const n={},d=l(`<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>QT</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="事件类-event" tabindex="-1"><a class="header-anchor" href="#事件类-event"><span>事件类 <code>Event</code></span></a></h1><h2 id="鼠标事件-鼠标事件类" tabindex="-1"><a class="header-anchor" href="#鼠标事件-鼠标事件类"><span>鼠标事件 &amp;&amp; 鼠标事件类</span></a></h2><h3 id="鼠标事件-各种" tabindex="-1"><a class="header-anchor" href="#鼠标事件-各种"><span>鼠标事件（各种）</span></a></h3><p>头文件</p><ul><li><code>#include &lt;QMouseEvent&gt;</code></li></ul><p>具体查文档</p><ul><li>鼠标进入，原型：<code>[virtual protected] void QWidget::enterEvent(QEvent *event);</code></li><li>鼠标离开，原型：<code>[virtual protected] void QWidget::leaveEvent(QEvent *event);</code></li><li>鼠标按下，原型：<code>[virtual void] void QLabel::mousePressEvent(QMouseEvent *ev);</code></li><li>鼠标释放，原型：<code>[virtual void] void QLabel::mouseReleaseEvent(QMouseEvent *ev);</code></li><li>鼠标按住移动，原型：<code>[virtual void] void QLabel::mouseMoveEvent(QMouseEvent *ev);</code></li></ul><h3 id="qmouseevent对象的公有方法" tabindex="-1"><a class="header-anchor" href="#qmouseevent对象的公有方法"><span><code>QMouseEvent</code>对象的公有方法</span></a></h3><p>继承关系</p><ul><li><code>QMouseEvent</code>父类为<code>QInputEvent</code>，再父类为<code>QEvent</code></li></ul><p><code>QMouseEvent</code>常用公有方法的原型（详细查文档）</p><ul><li><code>int x() const;</code>，x坐标，相对于局部控件而言</li><li><code>int y() const;</code>，y坐标，相对于局部控件而言</li><li><code>int globalX() const;</code>，x坐标，相对于屏幕分辨率而言</li><li><code>int globalY() const;</code>，y坐标，相对于屏幕分辨率而言</li><li><code>Qt::MouseButton button() const;</code>，返回按下的键所对应的媒体值 <ul><li>常用媒体值：（具体查文档，非常多媒体值） <ul><li><code>Qt::LeftButton</code></li><li><code>Qt::RightButton</code></li><li><code>Qt::MidButton</code></li></ul></li><li>补充1 <ul><li>移动事件时会返回nobutton，需要使用<code>buttons()</code>方法</li></ul></li></ul></li><li><code>Qt::MouseButtons buttons() const;</code><ul><li>常用媒体值：（与瞬间值相比，这里可以有多个键同时按住） <ul><li><code>Qt::LeftButton</code>：0x00000001（001）</li><li><code>Qt::RightButton</code>：0x00000002（010）</li><li><code>Qt::MidButton</code>：0x00000004（100）</li></ul></li><li>补充1 <ul><li>判断时不能像button()一样用<code>==</code>，而需要使用按位与<code>&amp;</code>运算符</li><li>为什么这样设计？<code>&amp;</code>可以轻易判断多个键同时按住的状态（只运算一个位而不是全部）</li><li>比如<code>... &amp; Qt::LeftButton &amp; Qt::RightButton</code></li></ul></li><li>补充2 <ul><li>可以设置鼠标追踪状态，<code>setMouseTracking(true);</code></li><li>然后不需要按下按键就会跟踪移动</li></ul></li></ul></li></ul><h3 id="鼠标实战-判断是否点击在指定区域" tabindex="-1"><a class="header-anchor" href="#鼠标实战-判断是否点击在指定区域"><span>鼠标实战 - 判断是否点击在指定区域</span></a></h3><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>int width = this-&gt;width();
int height = mListWidget-&gt;height();
// 获取鼠标点击的区域，判断是否点在弹出框内
// x = 鼠标的屏幕像素坐标 - (莫名奇妙的坐标 - 控件的局部坐标)，后者是控件坐上的屏幕像素坐标
// Global作用：将小部件坐标pos转换为全局屏幕坐标，不过结果有点奇怪就是
// 比较 x 是否在 0~width 之间
int x = QCursor::pos().x() - mapToGlobal(geometry().topLeft()).x() + geometry().x();
int y = QCursor::pos().y() - mapToGlobal(geometry().topLeft()).y() + geometry().y();
//qDebug()&lt;&lt;&quot;1:&quot;&lt;&lt;QCursor::pos().x();
//qDebug()&lt;&lt;&quot;2:&quot;&lt;&lt;mapToGlobal(geometry().topLeft()).x();
//qDebug()&lt;&lt;&quot;3:&quot;&lt;&lt;geometry().x();
if (x &gt;= 0 &amp;&amp; x &lt;= width &amp;&amp; y &gt;= this-&gt;height() &amp;&amp; y &lt;= height + this-&gt;height())
{
    //...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![mouseArea](04.%20事件函数 &amp; 事件类.assets/mouseArea.png)</p><h2 id="定时器事件-定时器类" tabindex="-1"><a class="header-anchor" href="#定时器事件-定时器类"><span>定时器事件 &amp;&amp; 定时器类</span></a></h2><h3 id="方式一-timerevent-事件方法" tabindex="-1"><a class="header-anchor" href="#方式一-timerevent-事件方法"><span>方式一 <code>timerEvent()</code>事件方法</span></a></h3><ul><li><p>原型：<code>[virtual protected] void QTimer::timerEvent(QTimerEvent *e);</code></p></li><li><p>使用：（省略原型定义）</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>  构造函数 {
      /*返回值为定时器的标示，要在原型处声明以提高其作用域*/
      int id1 = startTime(1000); 						// 启动定时器（每1s调用一次）
      int id2 = startTime(2000);						// 启动定时器（每2s调用一次）
  }
  void Widget::timerEvent(QTimerEvent *)				// 每隔一段时间调用一次这个方法
  {
      if(ev-&gt;timerId() == id1)						// 每1s被调用一次
      {
          static int num 1= 1;						// 静态变量，只会初始化一次
      	ui-&gt;label_1-&gt;setText(QString::number(num1++));	// 数值转字符串
      }
      if(ev-&gt;timerId() == id2)						// 每2s被调用一次
      {
          static int num2 = 1;						// 静态变量，只会初始化一次
      	ui-&gt;label_2-&gt;setText(QString::number(num2++));	// 数值转字符串
      }
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="方式二-qtimer对象-面向对象方式-推荐" tabindex="-1"><a class="header-anchor" href="#方式二-qtimer对象-面向对象方式-推荐"><span>方式二 <code>QTimer</code>对象（面向对象方式，推荐）</span></a></h3><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QTimer * timer = new QTimer(this);							// 创建定时器对象
timer-&gt;start(1000);											// 启动定时器
connect(timer, &amp;QTimer::timerout, [=](){/**/});				// 触发定时事件
// 多个定时任务时创建多个定时器对象即可
connect(ui-&gt;btn, &amp;QPushButton::clicked, [=](){
    timer-&gt;stop();											// 停止计时
    timer-&gt;start(1000);										// 重新启动
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="event事件分发器-事件类【底层原理】" tabindex="-1"><a class="header-anchor" href="#event事件分发器-事件类【底层原理】"><span>Event事件分发器 &amp;&amp; 事件类【底层原理】</span></a></h2><h3 id="event-事件分发器" tabindex="-1"><a class="header-anchor" href="#event-事件分发器"><span><code>event()</code>事件分发器</span></a></h3><ul><li><p>原理</p></li><li><p>触发事件后，会由<code>event()</code>进行事件分发。判断是哪一种事件类型，然后自动触发对应的事件函数</p></li><li><p>原型</p><ul><li><code>bool event (QEvent *v);</code></li></ul></li><li><p>用途</p><ul><li>用于事件分发，也可以做拦截操作但不建议</li></ul></li><li><p>返回值</p><ul><li>如果是true则表示用户自己处理事件，不继续向下分发</li></ul></li><li><p>使用示例</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>  bool myLabel::event(QEvent *e)
  {
      if(e-&gt;type() == QEvent::MouseButtonPress)	// 如果是鼠标按下，则处理并event事件分发中做拦截操作
      {
          QMouseEvent * ev = static_cast&lt;QMouseEvent *&gt;(e)	// 高级类型转换
          QString str = QString(&quot;Event函数中，鼠标按下了，x=%1，y=%2&quot;.arg(ev.x).arg(ev.y));
          qDebug() &lt;&lt; str;
          return true;							// 代表用户自己处理这个事件，不向下分发（此处不分发给mousePressEvent函数）
      }
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="qevent对象" tabindex="-1"><a class="header-anchor" href="#qevent对象"><span><code>QEvent</code>对象</span></a></h3><ul><li>继承关系 <ul><li><code>QMouseEvent</code>父类为<code>QInputEvent</code>，再父类为<code>QEvent</code></li></ul></li><li>常用枚举值 <ul><li><code>QEvent::None</code>，无，0</li><li><code>QEvent::MouseButtonDbClick</code>，鼠标双击，4</li><li><code>QEvent::MouseButtonPress</code>，鼠标按下，2</li><li><code>QEvent::MouseButtonRelease</code>，鼠标释放，3</li></ul></li></ul><h2 id="事件过滤器【底层】" tabindex="-1"><a class="header-anchor" href="#事件过滤器【底层】"><span>事件过滤器【底层】</span></a></h2><ul><li><p>原理</p><ul><li>可以在程序分到<code>event事件分发器</code>前做一次高级拦截，优先度高于<code>event()</code></li></ul></li><li><p>原型</p><ul><li><code>bool eventFilter(QObject *, QEvent *);</code></li></ul></li><li><p>使用</p><ul><li><p>(1) 给空间安装事件过滤器，<code>ui-&gt;label-&gt;installEventFilter(this);</code></p></li><li><p>(2) 重写<code>eventfilter</code>事件，<code>eventFilter(QObject *obj, QEvent *e){}</code></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>bool eventFilter(QObject *obj, QEvent *e)
{
    if(obj == ui-&gt;label &amp;&amp; e-&gt;type() == QEvent::MouseButtonPress)	// 如果是某对象和某方法时
    {
        //
        return true;							// 用户自己处理，不行给event()方法进行事件分发
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>`,29),a=[d];function s(o,c){return t(),i("div",null,a)}const u=e(n,[["render",s],["__file","04. 事件函数 _ 事件类.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/05.%20%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3/04.%20%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%20_%20%E4%BA%8B%E4%BB%B6%E7%B1%BB.html","title":"QT","lang":"zh-CN","frontmatter":{"description":"QT 目录 事件类 Event 鼠标事件 && 鼠标事件类 鼠标事件（各种） 头文件 #include <QMouseEvent> 具体查文档 鼠标进入，原型：[virtual protected] void QWidget::enterEvent(QEvent *event); 鼠标离开，原型：[virtual protected] void QWi...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/05.%20%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3/04.%20%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%20_%20%E4%BA%8B%E4%BB%B6%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"QT"}],["meta",{"property":"og:description","content":"QT 目录 事件类 Event 鼠标事件 && 鼠标事件类 鼠标事件（各种） 头文件 #include <QMouseEvent> 具体查文档 鼠标进入，原型：[virtual protected] void QWidget::enterEvent(QEvent *event); 鼠标离开，原型：[virtual protected] void QWi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"QT\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"QT","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"事件类 Event","slug":"事件类-event","link":"#事件类-event","children":[{"level":2,"title":"鼠标事件 && 鼠标事件类","slug":"鼠标事件-鼠标事件类","link":"#鼠标事件-鼠标事件类","children":[{"level":3,"title":"鼠标事件（各种）","slug":"鼠标事件-各种","link":"#鼠标事件-各种","children":[]},{"level":3,"title":"QMouseEvent对象的公有方法","slug":"qmouseevent对象的公有方法","link":"#qmouseevent对象的公有方法","children":[]},{"level":3,"title":"鼠标实战 - 判断是否点击在指定区域","slug":"鼠标实战-判断是否点击在指定区域","link":"#鼠标实战-判断是否点击在指定区域","children":[]}]},{"level":2,"title":"定时器事件 && 定时器类","slug":"定时器事件-定时器类","link":"#定时器事件-定时器类","children":[{"level":3,"title":"方式一 timerEvent()事件方法","slug":"方式一-timerevent-事件方法","link":"#方式一-timerevent-事件方法","children":[]},{"level":3,"title":"方式二 QTimer对象（面向对象方式，推荐）","slug":"方式二-qtimer对象-面向对象方式-推荐","link":"#方式二-qtimer对象-面向对象方式-推荐","children":[]}]},{"level":2,"title":"Event事件分发器 && 事件类【底层原理】","slug":"event事件分发器-事件类【底层原理】","link":"#event事件分发器-事件类【底层原理】","children":[{"level":3,"title":"event()事件分发器","slug":"event-事件分发器","link":"#event-事件分发器","children":[]},{"level":3,"title":"QEvent对象","slug":"qevent对象","link":"#qevent对象","children":[]}]},{"level":2,"title":"事件过滤器【底层】","slug":"事件过滤器【底层】","link":"#事件过滤器【底层】","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.13,"words":1239},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/04. Project/Platform/Multi/QT（Cpp）/03. Qt其他类（按功能）/05. 事件相关/04. 事件函数 & 事件类.md","autoDesc":true}');export{u as comp,m as data};
