import{_ as s,c as l,e,o as a}from"./app-CcegWvWz.js";const n={};function t(d,i){return a(),l("div",null,i[0]||(i[0]=[e(`<h1 id="类的使用" tabindex="-1"><a class="header-anchor" href="#类的使用"><span>类的使用</span></a></h1><h2 id="类的使用-1" tabindex="-1"><a class="header-anchor" href="#类的使用-1"><span>类的使用</span></a></h2><h3 id="通用格式" tabindex="-1"><a class="header-anchor" href="#通用格式"><span>通用格式</span></a></h3><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> className</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // data member declarations</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // member function prototypes</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用demo" tabindex="-1"><a class="header-anchor" href="#使用demo"><span>使用demo</span></a></h3><p>代码较多，此处不再赘述，详见配套源码</p><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><h4 id="创建对象的n种方式" tabindex="-1"><a class="header-anchor" href="#创建对象的n种方式"><span>创建对象的n种方式</span></a></h4><table><thead><tr><th>方式</th><th>写法</th><th>区别补充</th></tr></thead><tbody><tr><td>默认</td><td><code>A a;</code></td><td>调用<code>默认构造函数</code><br>【使用限制】仅当没定义构造函数 / 定义了无参数或全有默认值参数的构造函数时可用</td></tr><tr><td>——————</td><td>————————</td><td>————————</td></tr><tr><td>单变量简写</td><td><code>A a = val;</code></td><td>调用对应的单参数<code>构造函数</code>，本质是<strong>隐式类型转换</strong><br>【使用限制】仅当定义了单参数的构造函数，并且没有用<code>explicit</code>关闭该特性时可用</td></tr><tr><td>显式</td><td><code>A a = A(...);</code></td><td>显式调用<code>构造函数</code>，可能调用<code>赋值运算符？</code><br>【缺点】该写法可能会创建临时变量</td></tr><tr><td>隐式</td><td><code>A a(...);</code></td><td>隐式调用<code>构造函数</code><br>【注意点】当不传参数时使用该写法有歧义，应不写后面的括号<br>【注意点】否则可能会理解为返回值为该类的函数的原型</td></tr><tr><td>new方式</td><td><code>A *a = new A(...);</code></td><td>调用<code>构造函数</code><br>【注意点】动态分配内存（注意该写法需要手动delete来间接调用析构函数）</td></tr><tr><td>定位new</td><td><code>A *a = new(add)A(...);</code></td><td>调用<code>构造函数</code><br>【注意点】动态分配内存（注意该写法可能不能delete且要直接调用析构函数）</td></tr><tr><td>——————</td><td>——————</td><td>————————</td></tr><tr><td>类引用创建 x 单变量</td><td><code>A a = a2;</code></td><td>（同上，把<code>构造函数</code>具体化为<code>(默认)复制构造函数</code>）</td></tr><tr><td>类引用创建 x显示</td><td><code>A a = A(a2);</code></td><td>（同上，把<code>构造函数</code>具体化为<code>(默认)复制构造函数</code>）</td></tr><tr><td>类引用创建 x 隐式</td><td><code>A a(a2);</code></td><td>（同上，把<code>构造函数</code>具体化为<code>(默认)复制构造函数</code>）</td></tr><tr><td>类引用创建 x new</td><td><code>A *a = new A(a2);</code></td><td>（同上，把<code>构造函数</code>具体化为<code>(默认)复制构造函数</code>）</td></tr><tr><td>类引用创建 x 定位</td><td><code>A *a = new(add)A(a2);</code></td><td>（同上，把<code>构造函数</code>具体化为<code>(默认)复制构造函数</code>）</td></tr><tr><td>——————</td><td>——————</td><td>————————</td></tr><tr><td>列表初始化 x 显示</td><td><code>A a = {...};</code></td><td>【使用限制】C++11新增</td></tr><tr><td>列表初始化 x 隐式</td><td><code>A a {...};</code></td><td>【使用限制】C++11新增</td></tr><tr><td>列表初始化 x new</td><td><code>A *a = new A{...};</code></td><td>【使用限制】C++11新增</td></tr><tr><td>列表初始化 x 定位</td><td><code>A *a = new(add)A{...};</code></td><td>【使用限制】C++11新增</td></tr><tr><td>——————</td><td>——————</td><td>————————</td></tr><tr><td><s>引用时</s></td><td><s>这个应该不行</s></td><td></td></tr><tr><td>（Java）</td><td><code>A a = new A(...);</code></td><td>（Java隐藏起了指针，这里的<code>a</code>实质是一个智能引用）</td></tr><tr><td>（Python）</td><td><code>a = A(...)</code></td><td></td></tr></tbody></table><p>补充：当<code>...</code>中的内容为A的引用时</p><h4 id="补充-关于a-a-a-的写法底层" tabindex="-1"><a class="header-anchor" href="#补充-关于a-a-a-的写法底层"><span>补充：关于<code>A a = A(...);</code>的写法底层</span></a></h4><ul><li><p>几种写法的底层区别：（下面这几种写法都分别显示/隐式调用了构造函数，但有所区别）</p><ul><li><code>A a(...);</code><ul><li>行为：调用一次构造函数</li></ul></li><li><code>A a = A(...);</code><ul><li>行为：根据编译器不同而行为不同</li></ul></li><li><code>A a; a = A(...);</code><ul><li>行为：第一条表达式调用一次构造函数；第二条表达式行为同<code>A a = A(...);</code>？</li></ul></li></ul></li><li><p>对<code>A a = A(...);</code>编译器有两种方式来执行该语法</p><ul><li>第一种：与<code>A a(...);</code>的行为完全相同 <ul><li>行为：调用一次构造函数</li></ul></li><li>第二种：允许等号右侧创建一个临时变量，然后将该临时对象<strong>赋值</strong>到左侧的变量并<strong>丢弃</strong>它 <ul><li>补充：这里所说的丢弃：编译器可能让立刻删除临时对象，但也可能会等一段时间</li><li>行为：调用一次构造函数，一次析构函数，一次复制构造函数==（未清楚移动语义下的情况）==</li></ul></li></ul></li><li><p>选择建议</p><ul><li>视有构造时有无参而交替使用<code>A a();</code>和<code>A a;</code>，其效率更高</li></ul></li></ul><h2 id="一些零散特性" tabindex="-1"><a class="header-anchor" href="#一些零散特性"><span>一些零散特性</span></a></h2><h3 id="this指针" tabindex="-1"><a class="header-anchor" href="#this指针"><span>this指针</span></a></h3><ul><li>使用场景 <ul><li>举例：<code>const Stock &amp; topval(const Stock &amp; s) const</code>中使用了两个对象，比较并返回结果大的那个</li></ul></li><li>使用（类似于Python中的self） <ul><li>举例：<code>return *this</code></li></ul></li><li>本质原理 <ul><li>调用成员函数时，会通过<code>this</code>指针隐式传入一个参数，该参数为<code>this</code>指针，指向调用成员函数的实例对象本身</li></ul></li></ul><h3 id="类作用域" tabindex="-1"><a class="header-anchor" href="#类作用域"><span>类作用域</span></a></h3><h4 id="描述" tabindex="-1"><a class="header-anchor" href="#描述"><span>描述</span></a></h4><ul><li>在类中定义的名称，作用域都为整个类。作用域为整个类的名称只在类中是已知的，在类外是不可知的</li><li>在类中外，需要根据上下文使用直接成员运算符<code>.</code>、间接成员运算符<code>-&gt;</code>、作用域解析运算符<code>::</code>，如 <ul><li>客户代码中，想要调用公有成员函数，需要通过对象</li><li>实现代码中，想要定义成员函数时，需要使用作用域解析运算符</li></ul></li></ul><h4 id="作用域为类的常量" tabindex="-1"><a class="header-anchor" href="#作用域为类的常量"><span>作用域为类的常量</span></a></h4><p>有几种实现方案</p><ul><li>直接加<code>const</code><strong>（不可行）</strong><ul><li>举例：<code>class A{ private: const int Months = 12; ...</code>，不行</li><li>失败原因：声明类只是描述了对象的形式，并没有创建对象</li></ul></li><li>使用枚举（<code>enum</code>） <ul><li>举例：<code>class A{ private: enum {Months = 12}; ...</code><br> 或者也可以使用作用域内枚举（C++11）</li><li>缺点：记得枚举只能定义整型，如果是浮点就不行了</li><li>实现原理：创建符号常量<br> 注意这里是匿名枚举的用法，没有创建数据成员（只定义了枚举量，没有定义枚举变量，甚至连枚举名都没声明）<br> 即所有对象实例都不包含枚举对象</li></ul></li><li>创建静态变量的方法（<code>static</code>） <ul><li>举例：<code>class A{ private: static const int Months = 12; ...</code></li><li>实现原理：该变量将与其他静态变量存储在一起，而不是存储在对象中<br> 因此只有一个常量副本，被所有该类的对象共享<br> （在C++98中，只能使用这种技术声明整数或枚举的静态常量而不能存储double常量。C++11消除了这种限制）</li></ul></li></ul><h3 id="explicit" tabindex="-1"><a class="header-anchor" href="#explicit"><span>explicit</span></a></h3><p>详见自动类型转换一节</p><h3 id="初始化列表语法" tabindex="-1"><a class="header-anchor" href="#初始化列表语法"><span>初始化列表语法</span></a></h3><p>详见构造函数的扩展</p><h2 id="【功能扩展】类" tabindex="-1"><a class="header-anchor" href="#【功能扩展】类"><span>【功能扩展】类</span></a></h2><h3 id="类本身的扩展" tabindex="-1"><a class="header-anchor" href="#类本身的扩展"><span>类本身的扩展</span></a></h3><h4 id="【功能扩展】类-x-命名空间" tabindex="-1"><a class="header-anchor" href="#【功能扩展】类-x-命名空间"><span>【功能扩展】类 x 命名空间</span></a></h4><ul><li>一般形式：</li></ul><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> VECTOR_H_</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> VECTOR_H_</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> VECTOR</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Vector</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>或</li></ul><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* 在QT中的使用 */</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QT_BEGIN_NAMESPACE</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Ui</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MainWindow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QT_END_NAMESPACE</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MainWindow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> QMainWindow</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="【功能扩展】类-x-new" tabindex="-1"><a class="header-anchor" href="#【功能扩展】类-x-new"><span>【功能扩展】类 x new</span></a></h4><ul><li>写法 <ul><li>创建与销毁 <ul><li><code>A *a = new A(...)</code></li><li><code>delete a</code></li></ul></li><li>删除 <ul><li>不同于动态变量或静态变量的对象，当<strong>程序块或程序结束</strong>时<strong>自动调用析构函数</strong></li><li>new创建时，需要显示使用delete以<strong>间接调用析构函数</strong></li><li>定位new非堆创建时，不能使用delete而应<strong>直接调用析构函数</strong></li></ul></li></ul></li></ul><h4 id="【功能扩展】静态类-类-x-静态-没这个概念" tabindex="-1"><a class="header-anchor" href="#【功能扩展】静态类-类-x-静态-没这个概念"><span>【功能扩展】静态类 = 类 x 静态（没这个概念）</span></a></h4><ul><li><p>Q</p><ul><li>C++有没有静态类这个概念？</li></ul></li><li><p>其他</p><ul><li>C++类静态变量和类静态成员函数这两个我知道，Java中有静态类这个概念我也知道，虽然不知道是不是我想的那个。就问问C++后面的版本有没有这个概念或这样写行不行？</li></ul></li><li><p>使用场景</p><ul><li>开发的时候所有成员变量和成员函数都是static类型。想到这个整个类其实不需要实例，或者说只需要一份（其实用单例模式也可以，我就是实验心态弄着来试试）</li></ul></li><li><p>网络资料与实验</p><ul><li>搜了一下static静态类，有人说C++没这个概念，但也有人这样用了。而我自己实测，会有一个警告</li><li>英报错：<code>warning C4091: ‘static ’ : ignored on left of ‘ClassName’ when no variable is declared</code></li><li>中报错：<code>warning: C4091: “static ”: 没有声明变量时忽略“ClassName”的左侧</code></li><li>但是可以正常运行，没问题</li></ul></li><li><p>参考写法1（静态类，没有这个概念）</p><ul><li><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> View</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Student  student;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> much ;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  addStudent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>参考写法2（直接在.h中创建静态实例，但没单例模式安全）</p><ul><li><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> View</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Student  student;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> much ;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  addStudent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> View </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> view </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> View</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>参考写法3（单例模式，较安全的写法，可以与写法2相结合）</p><ul><li>略</li></ul></li></ul><h3 id="类成员的扩展" tabindex="-1"><a class="header-anchor" href="#类成员的扩展"><span>类成员的扩展</span></a></h3><h4 id="【功能扩展】类成员-x-内联函数" tabindex="-1"><a class="header-anchor" href="#【功能扩展】类成员-x-内联函数"><span>【功能扩展】类成员 x 内联函数</span></a></h4><ul><li><p>一般而言在头文件中不能定义函数，但可以定义内联函数</p><p>但在类声明（类作用域）中，可以不加关键字<code>inline</code>而直接定义函数。编译器会视作其为内联函数</p></li></ul><h4 id="【功能扩展】类成员-x-new" tabindex="-1"><a class="header-anchor" href="#【功能扩展】类成员-x-new"><span>【功能扩展】类成员 x new</span></a></h4><p>类中创建的动态成员</p><ul><li>注意要点和常规解决方法 <ul><li>注意不仅仅是<code>构造函数</code>，<code>复制构造函数</code> [和<code>赋值运算符</code>] 都要手动<code>new</code>对象 <ul><li>而且应使用相同的方式new（指针初始化为空除外）</li></ul></li><li>注意不仅仅是<code>析构函数</code> [和<code>赋值运算符</code>] 也要手动<code>delete</code>对象（防止内存泄露） <ul><li>而且应使用与new对应的方式delete</li></ul></li><li>注意<code>默认复制构造函数</code>和<code>默认赋值运算符</code>的默认行为是<code>浅赋值</code>，这会带来的问题，通常解决方案是转换为深拷贝</li><li>赋值运算符技巧 <ul><li>可以先判断一下是不是自我复制，如果是，则什么都不做。以避免不必要的性能损耗</li><li>赋值运算符中一般会先把旧的动态对象<code>delete掉，再new</code>一个新的动态对象<br> 但若极个别情况，能确定大小相同时。其实也可以不delete再重新new，只需注意深拷贝的问题即可<br> 但一般动态性对象大小都是随机的，如动态处理字符串长度，则需要先delete再new</li></ul></li></ul></li><li>伪私有方法的解决方法 <ul><li>简概 <ul><li>如果觉得常规解决方法太麻烦，可以将方法定义为<code>伪私有方法</code></li><li>与其面对无法预料的运行故障，不如得到一个易于跟踪的编译错误</li></ul></li><li>方法 <ul><li>即在<code>private</code>里定义复制构造函数和赋值运算符</li></ul></li><li>作用 <ul><li>避免本来自动生成的默认方法定义</li><li>这些方法是私有的，不能被广泛使用。即<code>A a1(a2);</code>、<code>a1 = a2;</code>会产生编译错误</li></ul></li></ul></li><li><code>delete</code>禁用方法的解决方法（C++11新增） <ul><li>略</li></ul></li></ul><h4 id="【功能扩展】静态变量-类成员-x-静态变量" tabindex="-1"><a class="header-anchor" href="#【功能扩展】静态变量-类成员-x-静态变量"><span>【功能扩展】静态变量 = 类成员 x 静态变量</span></a></h4><ul><li>特点：静态变量的特点</li><li>访问：静态变量可以被静态类成员函数访问</li><li>作用：实现 “作用域为类的常量” 方法之一</li></ul><h3 id="类对象的扩展" tabindex="-1"><a class="header-anchor" href="#类对象的扩展"><span>类对象的扩展</span></a></h3><h4 id="【功能扩展】对象-x-函数返回" tabindex="-1"><a class="header-anchor" href="#【功能扩展】对象-x-函数返回"><span>【功能扩展】对象 x 函数返回</span></a></h4><p>返回类型的选择（4种）</p><ul><li><p>返回指向const对象的引用</p><ul><li>优点：效率高、不修改</li></ul></li><li><p>返回指向非const对象的引用</p><ul><li>优点：效率高、可修改（连续使用）</li><li>场景 <ul><li>重载运算符<code>=</code>（效率高，可避免调用复制构造函数来创建一个新对象）（当等式右边是cosnt引用时才会使用复制构造函数）<br> 可以用于连续赋值，如<code>a1 = a2 = a3;</code>）</li><li>重载与cout一起使用的&lt;&lt;运算符（效率高，连续修改cout对象）<br> 可以用于串联输出，如<code>cout &lt;&lt; a1 &lt;&lt; a2;</code>）</li></ul></li></ul></li><li><p>返回对象</p><ul><li><p>场景</p><ul><li><p>如果被返回的对象是局部变量，则无法按引用方式返回，一般重载<code>算术运算符</code>属于这一类</p><p>如<code>a = a1 + a2;</code>（不能修改<code>a1、a2</code>）</p></li></ul></li></ul></li><li><p>返回const对象</p><ul><li><p>场景</p><ul><li><p>返回非const对象的话，有个奇异的属性，如可以这样写：<code>a1 + a2 = a3;</code>，虽然并没有什么意义</p><p>如果不想产生这种行为，可以返回const对象，该语句是非法的</p></li></ul></li></ul></li></ul>`,48)]))}const c=s(n,[["render",t],["__file","02. 类的使用.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8.html","title":"类的使用","lang":"zh-CN","frontmatter":{"description":"类的使用 类的使用 通用格式 使用demo 代码较多，此处不再赘述，详见配套源码 使用 创建对象的n种方式 补充：当...中的内容为A的引用时 补充：关于A a = A(...);的写法底层 几种写法的底层区别：（下面这几种写法都分别显示/隐式调用了构造函数，但有所区别） A a(...); 行为：调用一次构造函数 A a = A(...); 行为：根...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"类的使用"}],["meta",{"property":"og:description","content":"类的使用 类的使用 通用格式 使用demo 代码较多，此处不再赘述，详见配套源码 使用 创建对象的n种方式 补充：当...中的内容为A的引用时 补充：关于A a = A(...);的写法底层 几种写法的底层区别：（下面这几种写法都分别显示/隐式调用了构造函数，但有所区别） A a(...); 行为：调用一次构造函数 A a = A(...); 行为：根..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类的使用\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"类的使用","slug":"类的使用","link":"#类的使用","children":[{"level":2,"title":"类的使用","slug":"类的使用-1","link":"#类的使用-1","children":[{"level":3,"title":"通用格式","slug":"通用格式","link":"#通用格式","children":[]},{"level":3,"title":"使用demo","slug":"使用demo","link":"#使用demo","children":[]},{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[{"level":4,"title":"创建对象的n种方式","slug":"创建对象的n种方式","link":"#创建对象的n种方式","children":[]},{"level":4,"title":"补充：关于A a = A(...);的写法底层","slug":"补充-关于a-a-a-的写法底层","link":"#补充-关于a-a-a-的写法底层","children":[]}]}]},{"level":2,"title":"一些零散特性","slug":"一些零散特性","link":"#一些零散特性","children":[{"level":3,"title":"this指针","slug":"this指针","link":"#this指针","children":[]},{"level":3,"title":"类作用域","slug":"类作用域","link":"#类作用域","children":[{"level":4,"title":"描述","slug":"描述","link":"#描述","children":[]},{"level":4,"title":"作用域为类的常量","slug":"作用域为类的常量","link":"#作用域为类的常量","children":[]}]},{"level":3,"title":"explicit","slug":"explicit","link":"#explicit","children":[]},{"level":3,"title":"初始化列表语法","slug":"初始化列表语法","link":"#初始化列表语法","children":[]}]},{"level":2,"title":"【功能扩展】类","slug":"【功能扩展】类","link":"#【功能扩展】类","children":[{"level":3,"title":"类本身的扩展","slug":"类本身的扩展","link":"#类本身的扩展","children":[{"level":4,"title":"【功能扩展】类 x 命名空间","slug":"【功能扩展】类-x-命名空间","link":"#【功能扩展】类-x-命名空间","children":[]},{"level":4,"title":"【功能扩展】类 x new","slug":"【功能扩展】类-x-new","link":"#【功能扩展】类-x-new","children":[]},{"level":4,"title":"【功能扩展】静态类 = 类 x 静态（没这个概念）","slug":"【功能扩展】静态类-类-x-静态-没这个概念","link":"#【功能扩展】静态类-类-x-静态-没这个概念","children":[]}]},{"level":3,"title":"类成员的扩展","slug":"类成员的扩展","link":"#类成员的扩展","children":[{"level":4,"title":"【功能扩展】类成员 x 内联函数","slug":"【功能扩展】类成员-x-内联函数","link":"#【功能扩展】类成员-x-内联函数","children":[]},{"level":4,"title":"【功能扩展】类成员 x new","slug":"【功能扩展】类成员-x-new","link":"#【功能扩展】类成员-x-new","children":[]},{"level":4,"title":"【功能扩展】静态变量 = 类成员 x 静态变量","slug":"【功能扩展】静态变量-类成员-x-静态变量","link":"#【功能扩展】静态变量-类成员-x-静态变量","children":[]}]},{"level":3,"title":"类对象的扩展","slug":"类对象的扩展","link":"#类对象的扩展","children":[{"level":4,"title":"【功能扩展】对象 x 函数返回","slug":"【功能扩展】对象-x-函数返回","link":"#【功能扩展】对象-x-函数返回","children":[]}]}]}]}],"git":{},"readingTime":{"minutes":9.61,"words":2882},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/01. 面向对象/02. 类的使用.md","excerpt":"\\n<h2>类的使用</h2>\\n<h3>通用格式</h3>\\n<div class=\\"language-c++ line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"c++\\" data-title=\\"c++\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">class</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> className</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">private:</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">    // data member declarations</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">public:</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">    // member function prototypes</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/01. 面向对象/02. 类的使用.md","value":{"title":"02. 类的使用","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/06. 面向对象/01. 面向对象/02. 类的使用.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{c as comp,p as data};
