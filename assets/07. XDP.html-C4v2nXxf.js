import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,a}from"./app-DGJmjHtg.js";const i={},l=a(`<h1 id="《linux内核观测技术bpf》" tabindex="-1"><a class="header-anchor" href="#《linux内核观测技术bpf》"><span>《Linux内核观测技术BPF》</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="xdp" tabindex="-1"><a class="header-anchor" href="#xdp"><span>XDP</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>简单介绍</p><ul><li>是什么： XDP 是 Linux 网络数据路径上内核集成的数据包处理器</li><li>特点： 安全、可编程、高性能</li><li>作用： 当网卡驱动程序收到数据包时， 该处理器执行 BPF 程序。这使得 XDP 程序可以在最早的时间点 ， 对接收到的数据包进行丢弃、修改或允 许等操作。</li></ul><p>注意点：</p><ul><li>使用 XDP 进行数据包处理时，<strong>没有内存分配</strong>。</li><li>XDP 程序<strong>仅适用于线性的、无碎片的数据包，并且有数据包</strong>的头指针和尾指针 。</li><li>XDP 程序<strong>无法访问完整的数据包元数据</strong>，这种程序接收的输入上下文是 <code>xdp_buff</code> 类型，而不是在第 6 章中提到的 <code>sk_buff</code> 结构（比较见下）</li><li>由于 XDP 程序是 <strong>eBPF 程序</strong>，在网络管道中 XDP 程序的使用开销是固定的，所以 XDP 程序的执行时间有限。</li></ul><p>当谈论 XDP 时， 我们需要记住的是 XDP 不是一个内核旁路机制。 XDP 的设计旨在与其他内核组件和 Linux 内部安全模型集成。</p><p>xdp_buff vs sk_buff</p><ul><li>XDP 程序<strong>无法访问完整的数据包元数据</strong>，这种程序接收的输入上下文是 <code>xdp_buff</code> 类型，而不是在第 6 章中提到的 <code>sk_buff</code> 结构</li><li><code>xdp_buff</code> 结构可视为 <code>sk_buff </code>的 &quot;轻量级&quot;版本</li><li>两者之间的区别在于： <ul><li><code>sk_buff</code> 于保留数据包的元数据，允许与这些数据包的元数据 (包括原型、标记和类型) 联合使用，这些元数据仅在网络管道的更高级别可用。</li><li><code>xdp_buf</code> 创建很早，不依赖其他内核层，所以 XDP 可以更快地获得和处理数据包。</li></ul></li><li>另一个原因是 <code>xdp_buff</code> 与使用 <code>sk_buff</code> 的程序类型有所差异，<code>xdp_buff</code> 并不保存对路由、流量控制钩子或其他类型的数据包元数据的引用。</li></ul><h2 id="xdp-程序概述" tabindex="-1"><a class="header-anchor" href="#xdp-程序概述"><span>XDP 程序概述</span></a></h2><h3 id="介绍-1" tabindex="-1"><a class="header-anchor" href="#介绍-1"><span>介绍</span></a></h3><p>作用：</p><blockquote><p>本质上 XDP 程序所做的是对接收的数据包进行决策，然后对接收的数据包内容进行<strong>编辑或者仅返回一个结果码</strong>。 结果码用于决定对数据包进行的操作。你可以丢弃数据包，或将其发送到同一接口，也可以将其传递给其余的网络栈。 此外， XDP 程序可与网络技协作推送和拉取数据包头。例如，如果当前内核不支持封装格式或协议， XDP 程序可以对其进行解包或转换协议，然后 将结果发送到内核进行处理 。</p></blockquote><p>XDP 和 eBPF 之间有什么关联呢?</p><blockquote><p>XDP 程序是通过 bpf 系统调用进行控制的，使用程序类型 BPF_PROG_TYPE_XDP 进行加载。执行驱动程序将挂钩执行 BPF 字节码。</p></blockquote><p>当编写 XDP 程序时，我们要理解的一个重要慨念是程序运行的上下文，也称为操作模式。</p><h3 id="操作模式" tabindex="-1"><a class="header-anchor" href="#操作模式"><span>操作模式</span></a></h3><p>XDP 有三种操作模式 :</p><ul><li>原生 XDP</li><li>卸载 XDP</li><li>通用 XDP</li></ul><h4 id="_1-原生-xdp" tabindex="-1"><a class="header-anchor" href="#_1-原生-xdp"><span>(1) 原生 XDP</span></a></h4><p>这是默认模式 。 在这种模式下， XDP 的 BPF 程序在网络驱动程序的早期接收路径之外直接运行。</p><p>检查是否支持该模式： 使用此模式时<strong>需要检查驱动程序是否支持此模式</strong>。你可以在给定内核版本的源代码上执行如下命令进行检查:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Clone the linux<span class="token operator">-</span>stab1e repository</span></span>
git clone git<span class="token operator">:</span><span class="token comment">//git.kernel.org/pub/scm/linux/kernel/git/stab1e/linux-stable.git\\
linux-stable</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Checkout the tag <span class="token keyword">for</span> your current kernel version</span></span>
cd linux<span class="token operator">-</span>stable
git checkout tags<span class="token operator">/</span>v4<span class="token punctuation">.</span><span class="token number">18</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Check the availab1e drivers</span></span>
git grep <span class="token operator">-</span>l XDP_SETUP_PROG drivers<span class="token operator">/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令输出结果如下:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
drivers/net/ethernet/cavium/thunder/nicvf main.c
drivers/net/ethernet/intel/i40e/i40e main.c
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main <span class="token builtin class-name">.</span> c
drivers/net/ethernet/mel1anox/mlx4/en netdev.c
drivers/net/ethernet/mel1anox/mlx5/core/en main.c
drivers/net/ethernet/netronome/nfp/nfp_net_common.c
drivers/net/ethernet/qlogic/qede/qede_filter.c
drivers/net/netdevsim/bpf.c
drivers/net/tun.c
drivers/net/virtio net.c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如我们所见，内核 4 . 18 支持以下驱动:</p><ul><li>Broadcom NetXtreme-C/E 网络驱动 bnxt</li><li>Cavium thunderx 驱动</li><li>lntel i40 驱动</li><li>Intel ixgbe and ixgvevf 驱动</li><li>Mellanox mlx4 and mlx5 驱动</li><li>Netronome 网络流处理器</li><li>QLogic qede NIC 驱动</li><li>TUNrrAP</li><li>Virtio</li></ul><p>在熟悉原生 XDP 操作模式 后 ，我们将继续看一 下如何通过网卡使用卸载 XDP 来直接处理 XDP 程序。</p><h4 id="_2-卸载-xdp" tabindex="-1"><a class="header-anchor" href="#_2-卸载-xdp"><span>(2) 卸载 XDP</span></a></h4><p>（这里翻译成卸载有点……emmm）</p><p>在这种模式下 XDP 的 BPF 程序直接卸载到网卡上，而不是在主机 CPU 上执行。因为将执行从 CPU 上移出，所以这种模式比原生 XDP 具有<strong>更高的性能</strong>。</p><p>检查是否支持该模式： 我们可以重复使用克隆的内核源代码，通过查找 XDP_SE TUP_PROG_HW。检查在内核 4.18 上<strong>哪些网卡驱动程序支持硬件卸载</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">grep</span> <span class="token parameter variable">-1</span> XDP_SETUP_PROG_HW driversl
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令输出如下:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>include/linux/netdevice.h
<span class="token number">886</span>:    XDP_SETUP_PROG_HW, net/core/dev.c

<span class="token number">8001</span>:   xdp.command XDP_SETUP_PROG_HW<span class="token punctuation">;</span>

drivers/net/netdevsim/bpf.c
<span class="token number">200</span>:    <span class="token keyword">if</span> <span class="token punctuation">(</span>bp手-<span class="token punctuation">)</span>c创rnand <span class="token operator">==</span> XDP SETUP PRC巳二刷抽 <span class="token operator">!</span>ns-<span class="token punctuation">)</span>bpf_xd阳忏1oad_accept<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">205</span>:    <span class="token keyword">if</span> <span class="token punctuation">(</span>bpf• <span class="token builtin class-name">command</span> XDP_SETUP_PROG_HW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">560</span>:    <span class="token keyword">case</span> XDP SETUP PROG HW:

drivers/net/ethernet/netronome/nfp/nfp_net_common.c
<span class="token number">3476</span>:   <span class="token keyword">case</span> XDP SETUP PROG HW:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里仅显示了 Netronome Network Flow Processor (nfp)。这意味着该<strong>驱动支持硬件卸载 XDP 和原生 XDP 两种操作模式</strong>。</p><p>现在，你可能要问：如果我没有网卡和驱动程序来测试 XDP 程序，该怎么办？答案很简单，使用通用 XDP！</p><h4 id="_3-通用-xdp" tabindex="-1"><a class="header-anchor" href="#_3-通用-xdp"><span>(3) 通用 XDP</span></a></h4><p>如果开发人员想要编写和运行 XDP 程序，但是没有原生 XDP 或卸载 XDP 的功能，可以使用通用 XDP ，通用 XDP 是一种测试模式。</p><p>检查是否支持该模式： 内核从版本 4.12 开始支持通用 XDP。你可以在 veth 设备上使用这种模式。我们将在后续的示例中使用该模式来演示 XDP 的功能，无须购买特定的硬件。</p><p>但是，谁负责所有组件和操作模式之间的协调呢?下面我们将介绍数据包处理器。</p><h4 id="总结-比较三种xdp" tabindex="-1"><a class="header-anchor" href="#总结-比较三种xdp"><span>总结 - 比较三种XDP</span></a></h4><h3 id="数据包处理器" tabindex="-1"><a class="header-anchor" href="#数据包处理器"><span>数据包处理器</span></a></h3><p>XDP 数据包处理器可以在 XDP 数据包上执行 BPF 程序，并协调 BPF 程序和网络技之间的交互。</p><p>数据包处理器是 XDP 程序的内核组件，一旦数据包被网卡接收，数据包处理器直接处理接收 (RX) 队列上的数据包。数据包处理器保证数据包是可读写的，井允许以操作的形式附加处理后决策。数据包处理器可以在运行时原子性地更新程序和加载新程序，并且不会导致网络和相关流量中断服务。在运行时， XDP 可以使用&quot;忙轮询&quot;模式，在这种模式下，CPU 会一直保持处理每个 RX 队列上的数据包，由于避免了上下文切换，可使得数据包到达后立即被处理，无论 IRQ 亲和性如何。另一方面， XDP 可以使用的另一种模式是&quot;中断驱动&quot;模式，在该模式下， CPU 可以进行其他处理，当接收到数据包时，会产生一个事件中断行为指令，通知 CPU 在继续正常处理的同时必须处理一个新事件。</p><h4 id="xdp-结果码-数据包处理器操作" tabindex="-1"><a class="header-anchor" href="#xdp-结果码-数据包处理器操作"><span>XDP 结果码(数据包处理器操作)</span></a></h4><h3 id="xdp-和-iproute2-加载器" tabindex="-1"><a class="header-anchor" href="#xdp-和-iproute2-加载器"><span>XDP 和 iproute2 加载器</span></a></h3><h2 id="xdp和bcc" tabindex="-1"><a class="header-anchor" href="#xdp和bcc"><span>XDP和BCC</span></a></h2><h2 id="测试xdp程序" tabindex="-1"><a class="header-anchor" href="#测试xdp程序"><span>测试XDP程序</span></a></h2><h2 id="xdp用户案例" tabindex="-1"><a class="header-anchor" href="#xdp用户案例"><span>XDP用户案例</span></a></h2><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2>`,53),t=[l];function r(p,d){return n(),s("div",null,t)}const u=e(i,[["render",r],["__file","07. XDP.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/07.%20XDP.html","title":"《Linux内核观测技术BPF》","lang":"zh-CN","frontmatter":{"description":"《Linux内核观测技术BPF》 目录 XDP 介绍 简单介绍 是什么： XDP 是 Linux 网络数据路径上内核集成的数据包处理器 特点： 安全、可编程、高性能 作用： 当网卡驱动程序收到数据包时， 该处理器执行 BPF 程序。这使得 XDP 程序可以在最早的时间点 ， 对接收到的数据包进行丢弃、修改或允 许等操作。 注意点： 使用 XDP 进行数...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/07.%20XDP.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《Linux内核观测技术BPF》"}],["meta",{"property":"og:description","content":"《Linux内核观测技术BPF》 目录 XDP 介绍 简单介绍 是什么： XDP 是 Linux 网络数据路径上内核集成的数据包处理器 特点： 安全、可编程、高性能 作用： 当网卡驱动程序收到数据包时， 该处理器执行 BPF 程序。这使得 XDP 程序可以在最早的时间点 ， 对接收到的数据包进行丢弃、修改或允 许等操作。 注意点： 使用 XDP 进行数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《Linux内核观测技术BPF》\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《Linux内核观测技术BPF》","slug":"《linux内核观测技术bpf》","link":"#《linux内核观测技术bpf》","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"XDP","slug":"xdp","link":"#xdp","children":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"XDP 程序概述","slug":"xdp-程序概述","link":"#xdp-程序概述","children":[{"level":3,"title":"介绍","slug":"介绍-1","link":"#介绍-1","children":[]},{"level":3,"title":"操作模式","slug":"操作模式","link":"#操作模式","children":[{"level":4,"title":"(1) 原生 XDP","slug":"_1-原生-xdp","link":"#_1-原生-xdp","children":[]},{"level":4,"title":"(2) 卸载 XDP","slug":"_2-卸载-xdp","link":"#_2-卸载-xdp","children":[]},{"level":4,"title":"(3) 通用 XDP","slug":"_3-通用-xdp","link":"#_3-通用-xdp","children":[]},{"level":4,"title":"总结 - 比较三种XDP","slug":"总结-比较三种xdp","link":"#总结-比较三种xdp","children":[]}]},{"level":3,"title":"数据包处理器","slug":"数据包处理器","link":"#数据包处理器","children":[{"level":4,"title":"XDP 结果码(数据包处理器操作)","slug":"xdp-结果码-数据包处理器操作","link":"#xdp-结果码-数据包处理器操作","children":[]}]},{"level":3,"title":"XDP 和 iproute2 加载器","slug":"xdp-和-iproute2-加载器","link":"#xdp-和-iproute2-加载器","children":[]}]},{"level":2,"title":"XDP和BCC","slug":"xdp和bcc","link":"#xdp和bcc","children":[]},{"level":2,"title":"测试XDP程序","slug":"测试xdp程序","link":"#测试xdp程序","children":[]},{"level":2,"title":"XDP用户案例","slug":"xdp用户案例","link":"#xdp用户案例","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.97,"words":1792},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/07. XDP.md","autoDesc":true}');export{u as comp,h as data};
