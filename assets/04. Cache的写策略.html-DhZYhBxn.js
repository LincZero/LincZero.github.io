import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,e as c}from"./app-CoO7IlkE.js";const h={},i=c('<h1 id="cache的写策略-未" tabindex="-1"><a class="header-anchor" href="#cache的写策略-未"><span>Cache的写策略 (未)</span></a></h1><p>内存的数据被加载到Cache后，在某个时刻其要被写回内存，对于这个时刻的选取，有如下几个不同的策略。</p><h2 id="通用策略" tabindex="-1"><a class="header-anchor" href="#通用策略"><span>通用策略</span></a></h2><h3 id="直写-write-through" tabindex="-1"><a class="header-anchor" href="#直写-write-through"><span>直写（write-through）</span></a></h3><p>直写（write-through）：所谓直写，就是指在处理器对Cache写入的同时，将数据写入到内存中。这种策略保证了在任何时刻，内存的数据和Cache中的数据都是同步的，这种方式简单、可靠。但由于处理器每次对Cache更新时都要对内存进行写操作，因此总线工作繁忙，内存的带宽被大大占用，因此运行速度会受到影响。假设一段程序在频繁地修改一个局部变量，尽管这个局部变量的生命周期很短，而且其他进程/线程也用不到它，CPU依然会频繁地在Cache和内存之间交换数据，造成不必要的带宽损失。</p><h3 id="回写-write-back" tabindex="-1"><a class="header-anchor" href="#回写-write-back"><span>回写（write-back）</span></a></h3><p>回写（write-back）：回写相对于直写而言是一种高效的方法。直写不仅浪费时间，而且有时是不必要的，比如上文提到的局部变量的例子。回写系统通过将Cache line的标志位字段添加一个Dirty标志位，当处理器在改写了某个Cache line后，并不是马上把其写回内存，而是将该Cache line的Dirty标志设置为1。当处理器再次修改该Cache line并且写回到Cache中，查表发现该Dirty位已经为1，则先将Cache line内容写回到内存中相应的位置，再将新数据写到Cache中。其实，回写策略在多核系统中会引起Cache一致性的问题。设想有两个处理器核心都需要对某个内存块进行读写，其中一个核心已经修改了该数据块，并且写回到Cache中，设置了Dirty位；这时另外一个核心也完成了该内存块的修改，并且准备写入到Cache中，这时才发现该Cache line是“脏”的，在这种情况下，Cache如何处理呢？之后的章节我们会继续这个话题。</p><h2 id="特殊的地址空间策略" tabindex="-1"><a class="header-anchor" href="#特殊的地址空间策略"><span>特殊的地址空间策略</span></a></h2><p>除了上述这两种写策略，还有WC（write-combining）和UC（uncacheable）。这两种策略都是针对特殊的地址空间来使用的。</p><h3 id="wc-write-combining" tabindex="-1"><a class="header-anchor" href="#wc-write-combining"><span>WC（write-combining）</span></a></h3><p>write-combining策略：是针对于具体设备内存（如显卡的RAM）的一种优化处理策略。对于这些设备来说，数据从Cache到内存转移的开销比直接访问相应的内存的开销还要高得多，所以应该尽量避免过多的数据转移。试想，如果一个Cache line里的字被改写了，处理器将其写回内存，紧接着又一个字被改写了，处理器又将该Cache line写回内存，这样就显得低效，符合这种情况的一个例子就是显示屏上水平相连的像素点数据。write-combining策略的引入就是为了解决这种问题，顾名思义，这种策略就是当一个Cache line里的数据一个字一个字地都被改写完了之后，才将该Cache line写回到内存中。</p><h3 id="uc-uncacheable" tabindex="-1"><a class="header-anchor" href="#uc-uncacheable"><span>UC（uncacheable）</span></a></h3><p>uncacheable内存是一部分特殊的内存，比如PCI设备的I/O空间通过MMIO方式被映射成内存来访问。这种内存是不能缓存在Cache中的，因为设备驱动在修改这种内存时，总是期望这种改变能够尽快通过总线写回到设备内部，从而驱动设备做出相应的动作。如果放在Cache中，硬件就无法收到指令。</p>',13),r=[i];function n(l,E){return a(),t("div",null,r)}const s=e(h,[["render",n],["__file","04. Cache的写策略.html.vue"]]),B=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/04.%20Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5.html","title":"Cache的写策略 (未)","lang":"zh-CN","frontmatter":{"description":"Cache的写策略 (未) 内存的数据被加载到Cache后，在某个时刻其要被写回内存，对于这个时刻的选取，有如下几个不同的策略。 通用策略 直写（write-through） 直写（write-through）：所谓直写，就是指在处理器对Cache写入的同时，将数据写入到内存中。这种策略保证了在任何时刻，内存的数据和Cache中的数据都是同步的，这种方...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/04.%20Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Cache的写策略 (未)"}],["meta",{"property":"og:description","content":"Cache的写策略 (未) 内存的数据被加载到Cache后，在某个时刻其要被写回内存，对于这个时刻的选取，有如下几个不同的策略。 通用策略 直写（write-through） 直写（write-through）：所谓直写，就是指在处理器对Cache写入的同时，将数据写入到内存中。这种策略保证了在任何时刻，内存的数据和Cache中的数据都是同步的，这种方..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Cache的写策略 (未)\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Cache的写策略 (未)","slug":"cache的写策略-未","link":"#cache的写策略-未","children":[{"level":2,"title":"通用策略","slug":"通用策略","link":"#通用策略","children":[{"level":3,"title":"直写（write-through）","slug":"直写-write-through","link":"#直写-write-through","children":[]},{"level":3,"title":"回写（write-back）","slug":"回写-write-back","link":"#回写-write-back","children":[]}]},{"level":2,"title":"特殊的地址空间策略","slug":"特殊的地址空间策略","link":"#特殊的地址空间策略","children":[{"level":3,"title":"WC（write-combining）","slug":"wc-write-combining","link":"#wc-write-combining","children":[]},{"level":3,"title":"UC（uncacheable）","slug":"uc-uncacheable","link":"#uc-uncacheable","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.16,"words":949},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/04. Cache的写策略.md","autoDesc":true}');export{s as comp,B as data};
