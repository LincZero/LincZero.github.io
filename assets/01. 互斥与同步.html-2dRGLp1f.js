import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-yixEWCFr.js";const t="/assets/10-临界区-DcKfbrmn.jpg",p="/assets/11-吃饭同步-CFWsMZ5l.jpg",o={},l=e(`<h1 id="竞争与协作" tabindex="-1"><a class="header-anchor" href="#竞争与协作"><span>竞争与协作</span></a></h1><h2 id="竞争问题" tabindex="-1"><a class="header-anchor" href="#竞争问题"><span>竞争问题</span></a></h2><h3 id="为什么会有竞争" tabindex="-1"><a class="header-anchor" href="#为什么会有竞争"><span>为什么会有竞争</span></a></h3><p>在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了，就切换下一个进程运行，由于这个时间片的时间很短，于是就造成了「并发」的现象。</p><p>![并发](01. 互斥与同步.assets/3-并发.jpg)</p><p>另外，操作系统也为每个进程创建巨大、私有的虚拟内存的假象，这种地址空间的抽象让每个程序好像拥有自己的内存，而实际上操作系统在背后秘密地让多个地址空间「复用」物理内存或者磁盘。</p><p>![虚拟内存管理-换入换出](01. 互斥与同步.assets/4-内存交换.jpg)</p><p>如果一个程序只有一个执行流程，也代表它是单线程的。当然一个程序可以有多个执行流程，也就是所谓的多线程程序，线程是调度的基本单位，进程则是资源分配的基本单位。</p><p>所以，线程之间是可以共享进程的资源，比如代码段、堆空间、数据段、打开的文件等资源，但每个线程都有自己独立的栈空间。</p><p>![多线程](01. 互斥与同步.assets/5-多线程.jpg)</p><h3 id="demo-竞争bug" tabindex="-1"><a class="header-anchor" href="#demo-竞争bug"><span>demo - 竞争bug</span></a></h3><p>那么问题就来了，多个线程如果竞争共享资源，如果不采取有效的措施，则会造成共享数据的混乱。</p><p>我们做个小实验，创建两个线程，它们分别对共享变量 <code>i</code> 自增 <code>1</code> 执行 <code>10000</code> 次，如下代码（虽然说是 C++ 代码，但是没学过 C++ 的同学也是看到懂的）：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> <span class="token comment">// std::cout</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span>	<span class="token comment">// std::thread</span></span>

<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>			<span class="token comment">// 共享数据</span>

<span class="token comment">// 线程函数:对共享变量i自增1，执行10000次</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span> num<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		i<span class="token operator">=</span>i<span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
    <span class="token comment">// 创建线程</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Start all threads.&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread thread <span class="token function">testl</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread thread <span class="token function">test2</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 等待线程执行完成</span>
    thread testl<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread test2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">&quot;All threads joined.&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    
    <span class="token comment">// 结果</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;now i is &quot;</span><span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>	<span class="token comment">// 这里的取值范围是 [10000, 20000]，而非我们预想的20000</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="demo-bug原因" tabindex="-1"><a class="header-anchor" href="#demo-bug原因"><span>demo bug原因</span></a></h3><p>为了理解为什么会发生这种情况，我们必须了解编译器为更新计数器 <code>i</code> 变量生成的代码序列，也就是要了解汇编指令的执行顺序。</p><p>在这个例子中，我们只是想给 <code>i</code> 加上数字 1，那么它对应的汇编指令执行过程是这样的：</p><p>![img](01. 互斥与同步.assets/8-汇编语句赋值过程.jpg)</p><p>可以发现，只是单纯给 <code>i</code> 加上数字 1，在 CPU 运行的时候，实际上要执行 <code>3</code> 条指令。</p><ol><li>设想我们的线程 1 进入这个代码区域，它将 i 的值（假设此时是 50 ）从内存加载到它的寄存器中，然后它向寄存器加 1，此时在寄存器中的 i 值是 51。</li><li>现在，一件不幸的事情发生了：<strong>时钟中断发生</strong>。因此，操作系统将当前正在运行的线程的状态保存到线程的线程控制块 TCB。</li><li>现在更糟的事情发生了，线程 2 被调度运行，并进入同一段代码。它也执行了第一条指令，从内存获取 i 值并将其放入到寄存器中，此时内存中 i 的值仍为 50，因此线程 2 寄存器中的 i 值也是 50。假设线程 2 执行接下来的两条指令，将寄存器中的 i 值 + 1，然后将寄存器中的 i 值保存到内存中，于是此时全局变量 i 值是 51。</li><li>最后，又发生一次上下文切换，线程 1 恢复执行。还记得它已经执行了两条汇编指令，现在准备执行最后一条指令。回忆一下， 线程 1 寄存器中的 i 值是51，因此，执行最后一条指令后，将值保存到内存，全局变量 i 的值再次被设置为 51。</li><li>简单来说，增加 i （值为 50 ）的代码被运行两次，按理来说，最后的 i 值应该是 52，但是由于<strong>不可控的调度</strong>，导致最后 i 值却是 51。</li></ol><p>针对上面线程 1 和线程 2 的执行过程，我画了一张流程图，会更明确一些：</p><p>![蓝色表示线程 1 ，红色表示线程 2](01. 互斥与同步.assets/9-汇编语句-赋值过程-竞争.jpg)</p><h2 id="【扩展】一些常见的原子与非原子操作" tabindex="-1"><a class="header-anchor" href="#【扩展】一些常见的原子与非原子操作"><span>【扩展】一些常见的原子与非原子操作</span></a></h2><h3 id="赋值常数-1-是" tabindex="-1"><a class="header-anchor" href="#赋值常数-1-是"><span>赋值常数 (1, 是)</span></a></h3><p>（本篇扩展不在原转载内容，是后面补充的。参考：https://blog.csdn.net/JMW1407/article/details/108318960）</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种指令操作一般是原子的。因为对应着一条计算机指令，cpu将立即数1搬运到变量a的内存地址中即可</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">tmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> _TCHAR<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// example 1:</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// a=1 汇编指令</span>
    _asm <span class="token punctuation">{</span>
    	mov dword ptr<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="变量自增自减-3-否" tabindex="-1"><a class="header-anchor" href="#变量自增自减-3-否"><span>变量自增自减 (3, 否)</span></a></h3><p>不是，经典的 “内存不可见” 问题</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>i<span class="token operator">++</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>i++分为三个阶段：在cpu执行时</p><ol><li>第一步，先将count所在内存的值加载到寄存器；</li><li>第二步，将寄存器的值自增1;</li><li>第三步，将寄存器中的值写回内存。</li></ol><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> TCHAR<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// example 2:</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// a++ 汇编指令</span>
    _asm <span class="token punctuation">{</span>
        mov eax<span class="token punctuation">,</span> dword ptr<span class="token punctuation">[</span>a<span class="token punctuation">]</span>	<span class="token comment">//step 1</span>
        inc eax					<span class="token comment">//step 2</span>
        mov dword ptr<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> eax	<span class="token comment">//step 3</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="赋值变量-2-否" tabindex="-1"><a class="header-anchor" href="#赋值变量-2-否"><span>赋值变量 (2, 否)</span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>C/C++语法上是一条语句，但现代CPU架构来看，数据不能直接从一块内存帮运到另一块内存，必须借助寄存器中断</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>mov eax, dword ptr [b]
mov dword ptr [a], eax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常用原子操作-pv操作、测试并设置" tabindex="-1"><a class="header-anchor" href="#常用原子操作-pv操作、测试并设置"><span>常用原子操作：PV操作、测试并设置</span></a></h3><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>这里只讲概念，至于实现方法这节先不讲，在下一章节中</p><h3 id="互斥概念、临界区概念" tabindex="-1"><a class="header-anchor" href="#互斥概念、临界区概念"><span>互斥概念、临界区概念</span></a></h3><p>上面展示的情况称为 <strong>竞争条件（<em>race condition</em>）</strong>，当多线程相互竞争操作共享变量时，由于运气不好，即在执行过程中发生了上下文切换，我们得到了错误的结果，事实上，每次运行都可能得到不同的结果，因此输出的结果存在 <strong>不确定性（<em>indeterminate</em>）</strong>。</p><p>由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为 <strong>临界区（<em>critical section</em>），它是访问共享资源的代码片段，一定不能给多线程同时执行。</strong></p><p>我们希望这段代码是 <strong>互斥（<em>mutualexclusion</em>）的，也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区</strong>，说白了，就是这段代码执行过程中，最多只能出现一个线程。</p><figure><img src="`+t+'" alt="互斥" tabindex="0" loading="lazy"><figcaption>互斥</figcaption></figure><p>另外，说一下互斥也并不是只针对多线程。在多进程竞争共享资源的时候，也同样是可以使用互斥的方式来避免资源竞争造成的资源混乱。</p><h3 id="同步概念" tabindex="-1"><a class="header-anchor" href="#同步概念"><span>同步概念</span></a></h3><p>互斥解决了并发进程/线程对临界区的使用问题。这种基于临界区控制的交互作用是比较简单的，只要一个进程/线程进入了临界区，其他试图想进入临界区的进程/线程都会被阻塞着，直到第一个进程/线程离开了临界区。</p><p>我们都知道在多线程里，每个线程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个线程能密切合作，以实现一个共同的任务。</p><p>例子，线程 1 是负责读入数据的，而线程 2 是负责处理数据的，这两个线程是相互合作、相互依赖的。线程 2 在没有收到线程 1 的唤醒通知时，就会一直阻塞等待，当线程 1 读完数据需要把数据传给线程 2 时，线程 1 会唤醒线程 2，并把数据交给线程 2 处理。</p><p><strong>所谓同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步</strong>。</p><p>举个生活的同步例子，你肚子饿了想要吃饭，你叫妈妈早点做菜，妈妈听到后就开始做菜，但是在妈妈没有做完饭之前，你必须阻塞等待，等妈妈做完饭后，自然会通知你，接着你吃饭的事情就可以进行了。</p><figure><img src="'+p+'" alt="吃饭与做菜的同步关系" tabindex="0" loading="lazy"><figcaption>吃饭与做菜的同步关系</figcaption></figure><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>注意，同步与互斥是两种不同的概念：</p><ul><li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；</li><li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；</li></ul>',57),i=[l];function c(d,u){return s(),a("div",null,i)}const m=n(o,[["render",c],["__file","01. 互斥与同步.html.vue"]]),v=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/01.%20%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5.html","title":"竞争与协作","lang":"zh-CN","frontmatter":{"description":"竞争与协作 竞争问题 为什么会有竞争 在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了，就切换下一个进程运行，由于这个时间片的时间很短，于是就造成了「并发」的现象。 ![并发](01. 互斥与同步.assets/3-并发.jpg) 另外，操作系统也为每个进程创建巨大、...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/01.%20%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"竞争与协作"}],["meta",{"property":"og:description","content":"竞争与协作 竞争问题 为什么会有竞争 在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了，就切换下一个进程运行，由于这个时间片的时间很短，于是就造成了「并发」的现象。 ![并发](01. 互斥与同步.assets/3-并发.jpg) 另外，操作系统也为每个进程创建巨大、..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"竞争与协作\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"竞争与协作","slug":"竞争与协作","link":"#竞争与协作","children":[{"level":2,"title":"竞争问题","slug":"竞争问题","link":"#竞争问题","children":[{"level":3,"title":"为什么会有竞争","slug":"为什么会有竞争","link":"#为什么会有竞争","children":[]},{"level":3,"title":"demo - 竞争bug","slug":"demo-竞争bug","link":"#demo-竞争bug","children":[]},{"level":3,"title":"demo bug原因","slug":"demo-bug原因","link":"#demo-bug原因","children":[]}]},{"level":2,"title":"【扩展】一些常见的原子与非原子操作","slug":"【扩展】一些常见的原子与非原子操作","link":"#【扩展】一些常见的原子与非原子操作","children":[{"level":3,"title":"赋值常数 (1, 是)","slug":"赋值常数-1-是","link":"#赋值常数-1-是","children":[]},{"level":3,"title":"变量自增自减 (3, 否)","slug":"变量自增自减-3-否","link":"#变量自增自减-3-否","children":[]},{"level":3,"title":"赋值变量 (2, 否)","slug":"赋值变量-2-否","link":"#赋值变量-2-否","children":[]},{"level":3,"title":"常用原子操作：PV操作、测试并设置","slug":"常用原子操作-pv操作、测试并设置","link":"#常用原子操作-pv操作、测试并设置","children":[]}]},{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[{"level":3,"title":"互斥概念、临界区概念","slug":"互斥概念、临界区概念","link":"#互斥概念、临界区概念","children":[]},{"level":3,"title":"同步概念","slug":"同步概念","link":"#同步概念","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.85,"words":2355},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/03. 线程冲突/01. 互斥与同步.md","autoDesc":true}');export{m as comp,v as data};
