import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as o,b as e,e as l}from"./app-Bh75ISgc.js";const a={},i=e("h3",{id:"继承的设计技巧",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#继承的设计技巧"},[e("span",null,"继承的设计技巧")])],-1),r=e("ul",null,[e("li",null,"1.将公共操作和域放在超类"),e("li",null,[l("2.不要使用受保护的域 "),e("ul",null,[e("li",null,"有些程序员认为，将大多数的实例域定义为protected是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。 然而，protected机制并不能够带来更好的保护，其原因主要有两点。"),e("li",null,"第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的实例域，从而破坏了封装性。"),e("li",null,"第二，在Java程序设计语言中，在同一个包中的所有类都可以访问proteced域，而不管它是否为这个类的子类。 （这点与C++不同）")])]),e("li",null,"3.使用继承实现“is-a”关系"),e("li",null,[l("4.除非所有继承的方法都有意义，否则不要使用继承 "),e("ul",null,[e("li",{"css-module":"."},"假设想编写一个Holiday类。毫无疑问，每个假日也是一日，并且一日可以用Gregorian Calendar类的实例表示，因此可以使用继承 class Holiday extends GregorianCalender"),e("li",null,"很遗憾，在继承的操作中，假日集不是封闭的。在GregorianCalendar中有一个公有方法add，可以将假日转换成非假日"),e("li",null,"因此，继承对于这个例子来说并不太适宜"),e("li",null,"如果扩展LocalDate就不会出现这个问题。由于这个类是不可变的，所以没有任何方法会把假日变成非假日")])]),e("li",null,[l("5.在覆盖方法时，不要改变预期的行为 "),e("ul",null,[e("li",null,"置换原则不仅应用于语法，而且也可以应用于行为")])]),e("li",null,[l("6.使用多态，而非类型信息 "),e("ul",null,[e("li",null,"面对if-else代码时，都应该考虑使用多态性"),e("li",null,"action1与action2表示的是相同的概念吗？如果是相同的概念，就应该为这个概念定义一个方法，并将其放置在两个类的超类或接口中")])]),e("li",null,[l("7.不要过多地使用反射 "),e("ul",null,[e("li",null,"反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。 这种功能对于编写系统程序来说极其实用，但是通常不适于编写应用程序。"),e("li",null,"反射是很脆弱的，即编译器很难帮助人们发现程序中的错误")])])],-1),c=[i,r];function E(u,d){return n(),o("div",null,c)}const B=t(a,[["render",E],["__file","01. 继承与重用思想.html.vue"]]),_=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/01.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%87%8D%E7%94%A8%E6%80%9D%E6%83%B3.html","title":"","lang":"zh-CN","frontmatter":{"description":"继承的设计技巧 1.将公共操作和域放在超类 2.不要使用受保护的域 有些程序员认为，将大多数的实例域定义为protected是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。 然而，protected机制并不能够带来更好的保护，其原因主要有两点。 第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问prot...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/01.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%87%8D%E7%94%A8%E6%80%9D%E6%83%B3.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:description","content":"继承的设计技巧 1.将公共操作和域放在超类 2.不要使用受保护的域 有些程序员认为，将大多数的实例域定义为protected是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。 然而，protected机制并不能够带来更好的保护，其原因主要有两点。 第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问prot..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":3,"title":"继承的设计技巧","slug":"继承的设计技巧","link":"#继承的设计技巧","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2,"words":599},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Java/06. 面向对象/03. 类的重用/01. 继承与重用思想.md","autoDesc":true}');export{B as comp,_ as data};
