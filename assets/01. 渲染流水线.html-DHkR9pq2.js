import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,e as n}from"./app-DtBZtuIa.js";const l={},r=n('<h1 id="unityshadow" tabindex="-1"><a class="header-anchor" href="#unityshadow"><span>UnityShadow</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="渲染流水线-流程顺序-新编并简化" tabindex="-1"><a class="header-anchor" href="#渲染流水线-流程顺序-新编并简化"><span>渲染流水线（流程顺序 - 新编并简化）</span></a></h1><p>图2.2 渲染流水线中的三个概念阶段</p><p>![概念流水线.png-16.9kB](01. 渲染流水线.assets/概念流水线.png)</p><h2 id="应用阶段-application-stage-cpu实现" tabindex="-1"><a class="header-anchor" href="#应用阶段-application-stage-cpu实现"><span>应用阶段（<em>Application Stage</em>）（CPU实现）</span></a></h2><h3 id="准备好场景数据" tabindex="-1"><a class="header-anchor" href="#准备好场景数据"><span>准备好场景数据</span></a></h3><p>（例如：摄像机位置、视锥体、场景中包含哪些模型、使用了哪些光源等等）</p><h3 id="剔除不可见物体" tabindex="-1"><a class="header-anchor" href="#剔除不可见物体"><span>剔除不可见物体</span></a></h3><p>为了提高渲染性能，需要作一个粗粒度剔除（<em>culling</em>）工作，剔除不可见物体不提交给集合阶段</p><p>（注：这里的不可见是指被隐藏而非被遮挡而不可见）</p><h3 id="设置好每个模型的渲染状态" tabindex="-1"><a class="header-anchor" href="#设置好每个模型的渲染状态"><span>设置好每个模型的渲染状态</span></a></h3><p>需要设置好每个模型的渲染状态（例如：使用的材质（漫反射颜色、高光反射颜色）、纹理、Shader等等）</p><h2 id="从cpu过渡到gpu" tabindex="-1"><a class="header-anchor" href="#从cpu过渡到gpu"><span>从CPU过渡到GPU</span></a></h2><h3 id="把数据加载到到显存中" tabindex="-1"><a class="header-anchor" href="#把数据加载到到显存中"><span>把数据加载到到显存中</span></a></h3><p>图2.3 渲染所需的数据（两张纹理以及3个网格）从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据</p><p>![CopyDataToGPU.png-86.5kB](01. 渲染流水线.assets/CopyDataToGPU.png)</p><h3 id="设置渲染状态" tabindex="-1"><a class="header-anchor" href="#设置渲染状态"><span>设置渲染状态</span></a></h3><p>图2.4 在同一状态下渲染三个网格。由于没有更改渲染状态，因此三个网格的外观看起来像是同一种材质的物体</p><p>![SetRenderState.png-157.1kB](01. 渲染流水线.assets/SetRenderState.png)</p><h3 id="调用draw-call" tabindex="-1"><a class="header-anchor" href="#调用draw-call"><span>调用Draw Call</span></a></h3><p>图2.5 CPU通过调用Draw Call来告诉GPU开始进行一个渲染过程。一个Draw Call会指向本次调用需要渲染的图元列表</p><p>![DrawCall.png-59.1kB](01. 渲染流水线.assets/DrawCall.png)</p><h2 id="几何阶段-geometry-stage-gpu实现" tabindex="-1"><a class="header-anchor" href="#几何阶段-geometry-stage-gpu实现"><span>几何阶段（<em>Geometry Stage</em>）（GPU实现）</span></a></h2><p>图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性</p><p>![GPU流水线.png-82.2kB](01. 渲染流水线.assets/GPU流水线.png)</p><h3 id="顶点着色器-vertex-shader-可编程" tabindex="-1"><a class="header-anchor" href="#顶点着色器-vertex-shader-可编程"><span>顶点着色器（<em>Vertex Shader</em>）（可编程）</span></a></h3><ul><li>主要工作：坐标变换、逐顶点光照</li></ul><p>图2.7 GPU在每个输入的网格顶点上都会调用顶点着色器。顶点着色器必须进行顶点的坐标变换，需要时还可以计算和输出顶点的颜色。例如，我们可能需要进行逐顶点的光照</p><p>![VertexShaderProcess.png-43kB](01. 渲染流水线.assets/VertexShaderProcess.png)</p><p>图2.8 顶点着色器会将模型顶点的位置变换到齐次裁剪坐标空间下，进行输出后再由硬件做透视除法得到NDC下的坐标</p><p>![Vertex Shader.png-34.9kB](01. 渲染流水线.assets/Vertex Shader.png)</p><h3 id="曲面细分着色器-tessellation-shader-可编程、可选" tabindex="-1"><a class="header-anchor" href="#曲面细分着色器-tessellation-shader-可编程、可选"><span>曲面细分着色器（<em>Tessellation Shader</em>）（可编程、可选）</span></a></h3><ul><li>作用：细分图元</li></ul><h3 id="几何着色器-geometry-shader-可编程、可选" tabindex="-1"><a class="header-anchor" href="#几何着色器-geometry-shader-可编程、可选"><span>几何着色器（<em>Geometry Shader</em>）（可编程、可选）</span></a></h3><ul><li>作用：执行逐图元（<em>Per-Primitive</em>）的着色操作，或者被用于产生更多的图元</li></ul><h3 id="裁剪-clipping-可配置" tabindex="-1"><a class="header-anchor" href="#裁剪-clipping-可配置"><span>裁剪（<em>Clipping</em>）（可配置）</span></a></h3><ul><li>作用：将不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片</li></ul><p>图2.9 只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图元（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃</p><p>![Clipping.png-25.5kB](01. 渲染流水线.assets/Clipping.png)</p><h3 id="屏幕映射-screen-mapping-固定" tabindex="-1"><a class="header-anchor" href="#屏幕映射-screen-mapping-固定"><span>屏幕映射（<em>Screen Mapping</em>）（固定）</span></a></h3><ul><li>作用：负责把每个图元的坐标转换到屏幕坐标系（<em>Screen Coordinates</em>）中</li></ul><p>图2.10 屏幕映射将x、y坐标从（-1, 1）范围转换到屏幕坐标系中</p><p>![ScreenMapping.png-22.6kB](01. 渲染流水线.assets/ScreenMapping.png)</p><p>图2.11 OpenGL和DirectX的屏幕坐标系差异。对于一张512*512大小的图像，在OpenGL中其（0, 0）点在左下角，而在DirectX中其(0, 0)点在左上角</p><p>![Screen Mapping_OpenGL_DirectX.png-26.9kB](01. 渲染流水线.assets/Screen Mapping_OpenGL_DirectX.png)</p><h2 id="光栅化阶段-rasterizer-stage-gpu实现" tabindex="-1"><a class="header-anchor" href="#光栅化阶段-rasterizer-stage-gpu实现"><span>光栅化阶段（<em>Rasterizer Stage</em>）（GPU实现）</span></a></h2><p>有两个重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色</p><p>图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性</p><p>![GPU流水线.png-82.2kB](01. 渲染流水线.assets/GPU流水线.png)</p><h3 id="三角形设置-triangle-setup-固定" tabindex="-1"><a class="header-anchor" href="#三角形设置-triangle-setup-固定"><span>三角形设置（<em>Triangle Setup</em>）（固定）</span></a></h3><ul><li>作用：计算光栅化一个三角网格所需的信息（在此之前处理的都是图元中的点）</li></ul><h3 id="三角形遍历-triangle-traversal-固定" tabindex="-1"><a class="header-anchor" href="#三角形遍历-triangle-traversal-固定"><span>三角形遍历（<em>Triangle Traversal</em>）（固定）</span></a></h3><ul><li>作用：检查每个像素是否被一个三角网格所覆盖，这个阶段也被称为<code>扫描变换</code>（<em>Scan Conversion</em>）</li></ul><p>图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0</p><p>![TriangleSetupAndTraversal.png-80kB](01. 渲染流水线.assets/TriangleSetupAndTraversal.png)</p><h3 id="片元着色器-fragment-shader-可编程、可选-这步不太懂" tabindex="-1"><a class="header-anchor" href="#片元着色器-fragment-shader-可编程、可选-这步不太懂"><span>片元着色器（<em>Fragment Shader</em>）（可编程、可选）<mark>这步不太懂</mark></span></a></h3><ul><li>作用：完成一些渲染技术（例如纹理采样）</li></ul><p>图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0</p><p>![FragmentShader.png-42.4kB](01. 渲染流水线.assets/FragmentShader.png)</p><h3 id="逐片元操作-per-fragment-operations-可配置" tabindex="-1"><a class="header-anchor" href="#逐片元操作-per-fragment-operations-可配置"><span>逐片元操作（<em>Per-Fragment Operations</em>）（可配置）</span></a></h3><ul><li>作用：逐片元（<em>Per-Fragment Operations</em>）的着色操作（例如修改颜色、深度缓冲、进行魂环等等）</li></ul><p>图2.14 逐片元操作阶段所做的操作。只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中</p><p>![Per-fragment Operations.png-23.1kB](01. 渲染流水线.assets/Per-fragment Operations.png)</p><h4 id="模板测试-stencil-test" tabindex="-1"><a class="header-anchor" href="#模板测试-stencil-test"><span>模板测试（<em>Stencil Test</em>）</span></a></h4><p>图2.15 模板测试和深度测试的简化流程图</p><p>![Stencil Test_Depth Test.png-93.5kB](01. 渲染流水线.assets/Stencil Test_Depth Test.png)</p><h4 id="深度测试-depth-test" tabindex="-1"><a class="header-anchor" href="#深度测试-depth-test"><span>深度测试（<em>Depth Test</em>）</span></a></h4><ul><li>深度测试补充：对于被其他物体遮挡的就不需要出现在屏幕上</li></ul><h4 id="混合-blend" tabindex="-1"><a class="header-anchor" href="#混合-blend"><span>混合（<em>Blend</em>）</span></a></h4><p>图2.16 混合操作的简化流程图</p><p>![Blending.png-67.6kB](01. 渲染流水线.assets/Blending.png)</p>',72),s=[r];function p(i,h){return a(),t("div",null,s)}const g=e(l,[["render",p],["__file","01. 渲染流水线.html.vue"]]),o=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Graphics/%E3%80%8AUnityShadow%E3%80%8B/01.%20%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.html","title":"UnityShadow","lang":"zh-CN","frontmatter":{"description":"UnityShadow 目录 渲染流水线（流程顺序 - 新编并简化） 图2.2 渲染流水线中的三个概念阶段 ![概念流水线.png-16.9kB](01. 渲染流水线.assets/概念流水线.png) 应用阶段（Application Stage）（CPU实现） 准备好场景数据 （例如：摄像机位置、视锥体、场景中包含哪些模型、使用了哪些光源等等） 剔...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Graphics/%E3%80%8AUnityShadow%E3%80%8B/01.%20%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"UnityShadow"}],["meta",{"property":"og:description","content":"UnityShadow 目录 渲染流水线（流程顺序 - 新编并简化） 图2.2 渲染流水线中的三个概念阶段 ![概念流水线.png-16.9kB](01. 渲染流水线.assets/概念流水线.png) 应用阶段（Application Stage）（CPU实现） 准备好场景数据 （例如：摄像机位置、视锥体、场景中包含哪些模型、使用了哪些光源等等） 剔..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"UnityShadow\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"UnityShadow","slug":"unityshadow","link":"#unityshadow","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"渲染流水线（流程顺序 - 新编并简化）","slug":"渲染流水线-流程顺序-新编并简化","link":"#渲染流水线-流程顺序-新编并简化","children":[{"level":2,"title":"应用阶段（Application Stage）（CPU实现）","slug":"应用阶段-application-stage-cpu实现","link":"#应用阶段-application-stage-cpu实现","children":[{"level":3,"title":"准备好场景数据","slug":"准备好场景数据","link":"#准备好场景数据","children":[]},{"level":3,"title":"剔除不可见物体","slug":"剔除不可见物体","link":"#剔除不可见物体","children":[]},{"level":3,"title":"设置好每个模型的渲染状态","slug":"设置好每个模型的渲染状态","link":"#设置好每个模型的渲染状态","children":[]}]},{"level":2,"title":"从CPU过渡到GPU","slug":"从cpu过渡到gpu","link":"#从cpu过渡到gpu","children":[{"level":3,"title":"把数据加载到到显存中","slug":"把数据加载到到显存中","link":"#把数据加载到到显存中","children":[]},{"level":3,"title":"设置渲染状态","slug":"设置渲染状态","link":"#设置渲染状态","children":[]},{"level":3,"title":"调用Draw Call","slug":"调用draw-call","link":"#调用draw-call","children":[]}]},{"level":2,"title":"几何阶段（Geometry Stage）（GPU实现）","slug":"几何阶段-geometry-stage-gpu实现","link":"#几何阶段-geometry-stage-gpu实现","children":[{"level":3,"title":"顶点着色器（Vertex Shader）（可编程）","slug":"顶点着色器-vertex-shader-可编程","link":"#顶点着色器-vertex-shader-可编程","children":[]},{"level":3,"title":"曲面细分着色器（Tessellation Shader）（可编程、可选）","slug":"曲面细分着色器-tessellation-shader-可编程、可选","link":"#曲面细分着色器-tessellation-shader-可编程、可选","children":[]},{"level":3,"title":"几何着色器（Geometry Shader）（可编程、可选）","slug":"几何着色器-geometry-shader-可编程、可选","link":"#几何着色器-geometry-shader-可编程、可选","children":[]},{"level":3,"title":"裁剪（Clipping）（可配置）","slug":"裁剪-clipping-可配置","link":"#裁剪-clipping-可配置","children":[]},{"level":3,"title":"屏幕映射（Screen Mapping）（固定）","slug":"屏幕映射-screen-mapping-固定","link":"#屏幕映射-screen-mapping-固定","children":[]}]},{"level":2,"title":"光栅化阶段（Rasterizer Stage）（GPU实现）","slug":"光栅化阶段-rasterizer-stage-gpu实现","link":"#光栅化阶段-rasterizer-stage-gpu实现","children":[{"level":3,"title":"三角形设置（Triangle Setup）（固定）","slug":"三角形设置-triangle-setup-固定","link":"#三角形设置-triangle-setup-固定","children":[]},{"level":3,"title":"三角形遍历（Triangle Traversal）（固定）","slug":"三角形遍历-triangle-traversal-固定","link":"#三角形遍历-triangle-traversal-固定","children":[]},{"level":3,"title":"片元着色器（Fragment Shader）（可编程、可选）这步不太懂","slug":"片元着色器-fragment-shader-可编程、可选-这步不太懂","link":"#片元着色器-fragment-shader-可编程、可选-这步不太懂","children":[]},{"level":3,"title":"逐片元操作（Per-Fragment Operations）（可配置）","slug":"逐片元操作-per-fragment-operations-可配置","link":"#逐片元操作-per-fragment-operations-可配置","children":[{"level":4,"title":"模板测试（Stencil Test）","slug":"模板测试-stencil-test","link":"#模板测试-stencil-test","children":[]},{"level":4,"title":"深度测试（Depth Test）","slug":"深度测试-depth-test","link":"#深度测试-depth-test","children":[]},{"level":4,"title":"混合（Blend）","slug":"混合-blend","link":"#混合-blend","children":[]}]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.33,"words":1598},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Graphics/《UnityShadow》/01. 渲染流水线.md","autoDesc":true}');export{g as comp,o as data};
