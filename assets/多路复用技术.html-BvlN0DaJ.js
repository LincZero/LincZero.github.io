import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as t,c as n,a as l,b as p,d as r,e as a}from"./app-yixEWCFr.js";const s="/assets/image-20240113141923400-DZUnETgI.png",c="/assets/image-20240113170355112-Bhm9QxAe.png",u="/assets/image-20240113170518622-QXHEQkb5.png",E={},g=l("h1",{id:"多路复用技术",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#多路复用技术"},[l("span",null,"多路复用技术")])],-1),B=l("p",null,"参考：",-1),d={href:"https://www.bilibili.com/video/BV1gN411e7gd",target:"_blank",rel:"noopener noreferrer"},h=l("li",null,"有部分笔记在《五种IO模型》里",-1),A=a('<p>目录</p><ul><li>传统阻塞IO</li><li>NIO</li><li>BIO</li><li>多路复用</li></ul><h2 id="bio底层原理与不足" tabindex="-1"><a class="header-anchor" href="#bio底层原理与不足"><span>BIO底层原理与不足</span></a></h2><h3 id="动画讲解原理" tabindex="-1"><a class="header-anchor" href="#动画讲解原理"><span>动画讲解原理</span></a></h3><p>Java 运行到 server.accept() 时，阻塞等待三次握手。实际上底层在内核态创建了一个socket对象，并添加到进程等待队列中</p><p>Java 运行到 reader.readLine() 时，再次阻塞，等待接收。底层是对应 recvfrom() 方法</p><p>_</p><p>接收：</p><p>第一阶段： 客户端发送数据到服务端网卡后，服务端先会通过 <strong>DMA</strong> Copy 拷贝数据到自己的内核环形缓冲区中，<strong>RingBuffer</strong>，发生IO软中断，同时文件描述符读就绪。</p><p>（DMA (直接内存访问)：是发生在IO设备和主存之间的。 DMA控制器的硬件位置通常是主板上的芯片组或南桥芯片中，也可能集成在CPU上。 可以有效减少CPU切换直接将内存放入对应的主存空间，这里对应的空间则是 RingBuff）</p><p>第二阶段： 根据文件描述符拷贝数据到对应的Socket接收队列中。recvfrom在把数据从内核态复制到用户态中才会接触阻塞</p><figure><img src="'+s+'" alt="image-20240113141923400" tabindex="0" loading="lazy"><figcaption>image-20240113141923400</figcaption></figure><p><mark><strong>图注</strong></mark>：</p><blockquote><p>四块不同的内存：</p><ul><li>&quot;设备数据接收队列&quot;：网络设备，如网卡上的硬件缓冲区，用于暂存从网络上接收到的数据包。这部分内存是设备专用的，不属于主机内存。</li><li>&quot;<strong>内核环形</strong>缓冲区&quot;：内核空间。用于存储从设备数据接收队列拷贝过来的数据包，以供内核处理</li><li>&quot;内核数据接收队列&quot;：内核空间。用于存储从内核环形缓冲区中处理过的数据包，等待被用户态程序读取。这是一个FIFO（先进先出）队列</li><li>&quot;用户空间&quot;：用户空间。是操作系统为用户态程序分配的内存空间。当用户态程序通过系统调用读取网络数据时，数据会从内核数据接收队列拷贝到用户空间 <ul><li>补充举例：就是read(buf*) 的buf里。</li><li>补充等待：传统的非阻塞等待 (如事件通知)，只是信息到达前不等待，但从内核接收队列/ringBuf中拷贝到用户态的过程，这个拷贝是阻塞的。 而真AIO，则是提供一个桶，在拷贝的过程都是不阻塞的（这需要系统级的支持，Linux无AIO） （libevent 的事件通知机制，我猜测是在拷贝后才进行事件通知，但这应该只是模拟AIO而不是真AIO，应该会有拷贝阻塞发生在库里）</li></ul></li></ul><p>相互关系</p><ul><li>一般而言。到达网卡的数据被read(buf*)读取后，一般来说，会经历两次内存拷贝。这就是常说的 <strong>“两次拷贝”</strong>。 <ul><li>一次是从 &quot;设备接收队列&quot; 拷贝到 &quot;内核环形缓存区&quot;，也叫 &quot;DMA Copy&quot;。并且此时会将文件描述符状态中 &quot;未就绪&quot; 改成 &quot;已就绪&quot;</li><li>另一次是从 &quot;内核接收队列&quot; 拷贝到 &quot;用户空间&quot;</li><li>你可能会发现怎么好像不对，&quot;内核环形缓冲队列 -&gt; 内核接收队列&quot; 呢？ 解释是：因为内核环形缓冲区和内核接收队列都处于内核空间，所以数据在这两者之间的移动通常不被视为真正意义上的“拷贝”，因为它们只是在内核内部移动，没有涉及到用户空间和内核空间之间的切换。甚至这里可能会存在通过指针或页表映射等方式实现的零拷贝。所以在这里，我们通常说数据包经历了 &quot;两次拷贝&quot;</li></ul></li><li>但如果使用DPDK。数据包被读取后只需要一次内存拷贝，即从设备接收队列拷贝到用户空间</li></ul></blockquote><h3 id="操作系统层" tabindex="-1"><a class="header-anchor" href="#操作系统层"><span>操作系统层</span></a></h3><p>略</p><h2 id="nio底层原理与不足" tabindex="-1"><a class="header-anchor" href="#nio底层原理与不足"><span>NIO底层原理与不足</span></a></h2><p>Java可以使用 <code>ssC.configureBlocking(false); </code> 将BIO转化为NIO</p><p>recvfrom发现没有数据到达 (数据接收队列为空)，则会马上返回一个 -1 更准确的说法是：非阻塞 read：在数据到达网卡前，或已到达网卡但还没有拷贝到接收队列前，会立刻返回 -1</p><p>优点</p><ul><li>两处阻塞变成一次阻塞。等待不阻塞，拷贝阻塞</li></ul><p>缺点</p><ul><li><p><strong>一次阻塞</strong></p><ul><li>在从 &quot;数据接收队列&quot; 拷贝到 &quot;用户空间&quot; 这一过程，其实还是会发生阻塞。但这一阻塞是 <code>操作阻塞</code> 而 <code>非等待阻塞</code>，相对没那么长</li><li>不过Linux都是同步IO，没提供AIO (Windows倒是有)，必须发生一次阻塞</li></ul></li><li><p><strong>两次线程切换</strong></p><ul><li>当数据到达数据接收队列，该进程会阻塞等待读数据，发生一次线程切换，对应线程会让出cpu资源</li><li>数据接受拷贝到用户空间后，线程被重新唤醒，加入到进程等待队列中，再发生一次线程切换</li></ul></li><li><p>不断轮询，浪费资源</p></li></ul><h2 id="三种多路复用技术" tabindex="-1"><a class="header-anchor" href="#三种多路复用技术"><span>三种多路复用技术</span></a></h2><ul><li><p>Select</p><ul><li><p>特点：Select是最早的一款IO多路复用模型，它将所有的socket都存储在一个1024长的数组中</p></li><li><p>缺点：</p><ul><li><p>每次调用Select都需要<strong>遍历整个数组</strong>，所以处理效率比较低。</p></li><li><p>其最大的缺点是每次返回结果后，<strong>用户必须遍历整个fd集合</strong>才能得到已经就绪的socket，这就是所谓的O(n)复杂度。</p></li><li><p>同时，它有<strong>最大连接数限制</strong>，即FD_SETSIZE限制，通常其值为1024。Select适用于连接数不是特别多，且连接都比较活跃的情况。</p><p>Poll和Epoll等都不存在这个问题</p></li></ul></li></ul></li><li><p>Poll</p><ul><li>特点：设计初衷是为了克服Select模型的缺点</li><li>优点： <ul><li>没有最大连接数的限制</li><li>返回结果后它能够直接找到就绪的socket，这是因为它记住了上次搜索的位置。</li></ul></li><li>缺点：Poll仍然存在效率较低的问题，尤其是在处理大量空闲连接时，因为它依然需要<strong>遍历所有的连接</strong>。</li></ul></li><li><p>Epoll</p><ul><li>特点：Epoll是在2.6内核中出现的，是为了克服Select、Poll效率低下的问题。名字中的e可以理解成 extend-poll 的意思。</li><li>优点： <ul><li>Epoll使用一个事件驱动方式，<strong>只对发生变化的socket</strong>进行操作</li><li>在活动连接较少的情况下，效率会很高</li><li>没有最大连接数的限制，这是因为在内核中我们是根据链表来存储的（同时用了链表和红黑树，链表是就绪链表，红黑树是注册文件描述符）</li></ul></li><li>缺点：Epoll在连接数非常多，且都非常活跃的情况下，会导致一次Epoll返回的可读事件过多，进而导致处理不过来。</li></ul></li><li><p>IOCP</p><ul><li>特点：IOCP是Windows下的一种高效IO模型，全称为I/O Completion Port，即I/O完成端口。IOCP是Windows下效率最高的异步I/O模型，它本质上是一个多线程的消息队列模型，各个线程通过GetQueuedCompletionStatus等待I/O完成消息。这些消息由系统在合适的时候为每个I/O操作送入队列，线程则负责处理I/O操作后的数据处理工作</li><li>优点：操作系统对线程的优秀管理能力和合理的调度机制</li></ul></li></ul><hr><p>库使用：</p><ul><li>Libevent <ul><li>Linux：Libevent优先选择 <strong>epoll</strong> 作为其事件通知机制。<strong>Reactor</strong> 模型</li><li>Windows：如果系统不支持epoll，那么Libevent会选择poll或者select。在Windows平台上，Libevent使用 <strong>select</strong> 作为事件通知机制。<strong>Reactor</strong> 模型</li></ul></li><li>Asio <ul><li>Windows：<strong>IOCP</strong>。<strong>Reactor</strong> 模型</li><li>Linux：Asio使用 <strong>epoll</strong> 作为其事件通知机制。如果系统不支持epoll，那么Asio也可以选择使用poll或者select。 Asio同时还提供了一个 <strong>模拟的 Proactor</strong> 模式（与reactor模式相对），可以在不支持异步操作的平台上模拟异步操作，从而提供统一的API。</li></ul></li></ul><h3 id="epoll面试重点" tabindex="-1"><a class="header-anchor" href="#epoll面试重点"><span>epoll面试重点</span></a></h3><p>这些模型中，epoll 是面试的重点。常见问题：</p><ul><li><p>epoll 的执行原理</p><ul><li>epoll_ctl()：注册区，结构为红黑树</li><li>epoll_wait()：就绪队列，结构为双向链表</li></ul></li><li><p>epoll 为什么比 select/poll 快</p><ul><li>epoll_ctl() 监听时才将用户态拷贝到内核态，而非每次拷贝</li><li>epoll_wait() 读取时仅拷贝已就绪的，不会拷贝未就绪的</li><li>采用回调，而非轮询，检查是否有文件描述符就续的时间复杂度O(1)</li></ul></li><li><p>epoll 为什么采样红黑树，而不是hash、b+树</p><ul><li><p>hash时间快，但可能需要哈希的动态扩容，频繁动态扩容开销大</p></li><li><p>B+树能降低树高度，做磁盘索引好，但在内存中没那么适用。</p><ul><li>磁盘IO：操作的时间消耗主要在寻道和旋转，降低<strong>寻址</strong>次数必要性更大</li><li>内存IO：<strong>寻址</strong>的成本几乎可以忽略不计，时间消耗主要在于数据的读取，主要目标是减少读取的数据量</li></ul><p>并且，B+树非叶子节点并不存储数据信息，这对磁盘查询很高效。但对于可以直接存取地址的内存来说，这一点优势不大</p></li></ul></li><li><p>epoll 一定比 poll 快吗，为什么还有人使用poll模型</p><ul><li>未必，只有在高并发，epoll才全胜</li></ul></li></ul><figure><img src="'+c+'" alt="image-20240113170355112" tabindex="0" loading="lazy"><figcaption>image-20240113170355112</figcaption></figure><h3 id="触发机制" tabindex="-1"><a class="header-anchor" href="#触发机制"><span>触发机制</span></a></h3><figure><img src="'+u+'" alt="image-20240113170518622" tabindex="0" loading="lazy"><figcaption>image-20240113170518622</figcaption></figure><p>一般默认水平触发。边缘触发更复杂，但通知用户态的次数更少，Nginx采用这种</p>',35);function m(I,O){const e=o("ExternalLinkIcon");return t(),n("div",null,[g,B,l("ul",null,[l("li",null,[l("a",d,[p("腾讯面试：请描述 select、poll、epoll 这三种IO多路复用技术的执行原理"),r(e)])]),h]),A])}const b=i(E,[["render",m],["__file","多路复用技术.html.vue"]]),q=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF.html","title":"多路复用技术","lang":"zh-CN","frontmatter":{"description":"多路复用技术 参考： 腾讯面试：请描述 select、poll、epoll 这三种IO多路复用技术的执行原理 有部分笔记在《五种IO模型》里 目录 传统阻塞IO NIO BIO 多路复用 BIO底层原理与不足 动画讲解原理 Java 运行到 server.accept() 时，阻塞等待三次握手。实际上底层在内核态创建了一个socket对象，并添加到进程...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"多路复用技术"}],["meta",{"property":"og:description","content":"多路复用技术 参考： 腾讯面试：请描述 select、poll、epoll 这三种IO多路复用技术的执行原理 有部分笔记在《五种IO模型》里 目录 传统阻塞IO NIO BIO 多路复用 BIO底层原理与不足 动画讲解原理 Java 运行到 server.accept() 时，阻塞等待三次握手。实际上底层在内核态创建了一个socket对象，并添加到进程..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多路复用技术\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"多路复用技术","slug":"多路复用技术","link":"#多路复用技术","children":[{"level":2,"title":"BIO底层原理与不足","slug":"bio底层原理与不足","link":"#bio底层原理与不足","children":[{"level":3,"title":"动画讲解原理","slug":"动画讲解原理","link":"#动画讲解原理","children":[]},{"level":3,"title":"操作系统层","slug":"操作系统层","link":"#操作系统层","children":[]}]},{"level":2,"title":"NIO底层原理与不足","slug":"nio底层原理与不足","link":"#nio底层原理与不足","children":[]},{"level":2,"title":"三种多路复用技术","slug":"三种多路复用技术","link":"#三种多路复用技术","children":[{"level":3,"title":"epoll面试重点","slug":"epoll面试重点","link":"#epoll面试重点","children":[]},{"level":3,"title":"触发机制","slug":"触发机制","link":"#触发机制","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.15,"words":2444},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络编程与网络模型与网络架构/多路复用技术.md","autoDesc":true}');export{b as comp,q as data};
