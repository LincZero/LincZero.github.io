import{_ as p,e as o,g as t,o as n}from"./app-DPU1xou8.js";const a="/assets/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84-bYuZNhHD.jpg",s="/assets/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-BXn5moPM.png",E="/assets/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-BIEZozLP.png",i="/assets/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95-CDXHTTMa.png",l="/assets/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-C-SCAN%E7%AE%97%E6%B3%95-D-ZQxaeh.png",r="/assets/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-LOOK%E7%AE%97%E6%B3%95-DFkW3uSS.png",c="/assets/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-C-LOOK%E7%AE%97%E6%B3%95-43PcDhmp.png",B={};function d(A,e){return n(),o("div",null,e[0]||(e[0]=[t('<h1 id="磁盘调度算法" tabindex="-1"><a class="header-anchor" href="#磁盘调度算法"><span>磁盘调度算法</span></a></h1><h2 id="磁盘结构、性能瓶颈" tabindex="-1"><a class="header-anchor" href="#磁盘结构、性能瓶颈"><span>磁盘结构、性能瓶颈</span></a></h2><p>我们来看看磁盘的结构，如下图：</p><p><img src="'+a+'" alt="磁盘的结构" loading="lazy"></p><p>常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 <code>512</code> 字节。那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图里中间的样子。</p><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过<strong>优化磁盘的访问请求顺序</strong>来做到的。</p><p><strong>寻道的时间</strong>是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p><p>假设有下面一个请求序列，每个数字代表磁道的位置：</p><p>98，183，37，122，14，124，65，67</p><p>初始磁头当前的位置是在第 <code>53</code> 磁道。</p><h2 id="磁盘调度算法-1" tabindex="-1"><a class="header-anchor" href="#磁盘调度算法-1"><span>磁盘调度算法</span></a></h2><p>接下来，分别对以上的序列，作为每个调度算法的例子，那常见的磁盘调度算法有：</p><ul><li>先来先服务算法</li><li>最短寻道时间优先算法</li><li>扫描算法</li><li>循环扫描算法</li><li>LOOK 与 C-LOOK 算法</li></ul><h3 id="先来先服务-fcfs" tabindex="-1"><a class="header-anchor" href="#先来先服务-fcfs"><span>先来先服务 (<em>FCFS</em>)</span></a></h3><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p><p>那按照这个序列的话：</p><p>98，183，37，122，14，124，65，67</p><p>那么，磁盘的写入顺序是从左到右，如下图：</p><p><img src="'+s+'" alt="先来先服务" loading="lazy"></p><p>先来先服务算法总共移动了 <code>640</code> 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</p><p>缺点：性能差、寻道时间长</p><h3 id="最短寻道时间优先-ssf" tabindex="-1"><a class="header-anchor" href="#最短寻道时间优先-ssf"><span>最短寻道时间优先 (<em>SSF</em>)</span></a></h3><p>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</p><p>98，183，37，122，14，124，65，67</p><p>那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</p><p>65，67，37，14，98，122，124，183</p><p><img src="'+E+'" alt="最短寻道时间优先" loading="lazy"></p><p>磁头移动的总距离是 <code>236</code> 磁道</p><ul><li>优点 <ul><li>相比先来先服务性能提高了不少。</li></ul></li><li>缺点 <ul><li>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</li></ul></li></ul><h3 id="扫描算法-scan-也叫电梯算法" tabindex="-1"><a class="header-anchor" href="#扫描算法-scan-也叫电梯算法"><span>扫描算法 (<em>Scan</em>)，也叫电梯算法</span></a></h3><p>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</p><p>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（<em>Scan</em>）算法</strong>。</p><p>这种算法也叫做<strong>电梯算法</strong>，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p><p>还是以这个序列为例子，磁头的初始位置是 53：</p><p>98，183，37，122，14，124，65，67</p><p>那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</p><p>37，14，<code>0</code>，65，67，98，122，124，183</p><p><img src="'+i+'" alt="扫描算法" loading="lazy"></p><p>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</p><ul><li>优点 <ul><li>扫描调度算法性能较好</li><li>不会产生饥饿现象</li></ul></li><li>缺点 <ul><li>但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。</li></ul></li></ul><h3 id="循环扫描算法-cscan" tabindex="-1"><a class="header-anchor" href="#循环扫描算法-cscan"><span>循环扫描算法 (<em>CScan</em>)</span></a></h3><p>扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</p><p>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</p><p>还是以这个序列为例子，磁头的初始位置是 53：</p><p>98，183，37，122，14，124，65，67</p><p>那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</p><p>65，67，98，122，124，183，<code>199</code>，<code>0</code>，14，37</p><p><img src="'+l+'" alt="循环扫描算法" loading="lazy"></p><p>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</p><p>优点：循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。</p><h3 id="look-与-c-look-算法" tabindex="-1"><a class="header-anchor" href="#look-与-c-look-算法"><span>LOOK 与 C-LOOK 算法</span></a></h3><p>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</p><p>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></p><p>那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</p><p><img src="'+r+'" alt="LOOK 算法" loading="lazy"></p><p>而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</p><p><img src="'+c+'" alt="C-LOOK 算法" loading="lazy"></p>',57)]))}const h=p(B,[["render",d],["__file","03. 磁盘调度算法.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/06.%20%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/03.%20%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html","title":"磁盘调度算法","lang":"zh-CN","frontmatter":{"description":"磁盘调度算法 磁盘结构、性能瓶颈 我们来看看磁盘的结构，如下图： 磁盘的结构 常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 512 字节。那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图里中间的...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/06.%20%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/03.%20%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"磁盘调度算法"}],["meta",{"property":"og:description","content":"磁盘调度算法 磁盘结构、性能瓶颈 我们来看看磁盘的结构，如下图： 磁盘的结构 常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 512 字节。那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图里中间的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"磁盘调度算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":6.23,"words":1870},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/03. 磁盘调度算法.md","excerpt":"\\n<h2>磁盘结构、性能瓶颈</h2>\\n<p>我们来看看磁盘的结构，如下图：</p>\\n<p></p>\\n<p>常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 <code>512</code> 字节。那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图里中间的样子。</p>\\n<p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过<strong>优化磁盘的访问请求顺序</strong>来做到的。</p>\\n<p><strong>寻道的时间</strong>是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/03. 磁盘调度算法.md","value":{"title":"03. 磁盘调度算法","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/03. 磁盘调度算法.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{h as comp,m as data};
