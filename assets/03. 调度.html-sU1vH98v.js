import{_ as e,c as a,e as l,o as t}from"./app-BG6lKC-Y.js";const n="/assets/23-%E4%BA%94%E7%A7%8D%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99-4x0CCry7.jpg",p="/assets/24-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-C3M21X29.jpg",i="/assets/25-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95-CXlfIpiX.jpg",r="/assets/27-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%AF%A2-Cjo6ORsI.jpg",o="/assets/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97-BmVi52K3.jpg",c="/assets/29-%E9%93%B6%E8%A1%8C1V1-D-myxlaA.jpg",m="/assets/30-%E9%93%B6%E8%A1%8C-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-DFBq0-j5.jpg",h="/assets/31-%E9%93%B6%E8%A1%8C-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-19eBpiqo.jpg",g="/assets/32-%E9%93%B6%E8%A1%8C-%E6%97%B6%E9%97%B4%E8%AE%BA%E7%89%87-DqZMm2fA.jpg",E="/assets/33-%E9%93%B6%E8%A1%8C-%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7-Cz0-TGFM.jpg",d="/assets/34-%E9%93%B6%E8%A1%8C-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88-DIuYOhqp.jpg",_={};function A(B,s){return t(),a("div",null,s[0]||(s[0]=[l('<h1 id="调度" tabindex="-1"><a class="header-anchor" href="#调度"><span>调度</span></a></h1><p><mark>（补充：该笔记还有一个独立章节《调度算法》，是进程调度/页面置换/磁盘调度算法的多种调度算法的综合，可以结合一起看）</mark></p><h2 id="调度概念" tabindex="-1"><a class="header-anchor" href="#调度概念"><span>调度概念</span></a></h2><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p><p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程。</p><p>选择一个进程运行这一功能是在操作系统中完成的，通常称为 <strong>调度程序</strong>（<em>scheduler</em>）。</p><p>那到底什么时候调度进程，或以什么原则来调度进程呢？</p><blockquote><p>TIP</p><p>我知道很多人会问，线程不是操作系统的调度单位吗？为什么这里参与调度的是进程？</p><p>先提前说明，这里的进程指只有主线程的进程，所以调度主线程就等于调度了整个进程。</p><p>那为什么干脆不直接取名线程调度？主要是操作系统相关书籍，都是用进程调度这个名字，所以我也沿用了这个名字。</p></blockquote><h2 id="调度时机" tabindex="-1"><a class="header-anchor" href="#调度时机"><span>调度时机</span></a></h2><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</p><p>比如，以下状态的变化都会触发操作系统的调度：</p><ul><li><em>从就绪态 -&gt; 运行态</em>：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；</li><li><em>从运行态 -&gt; 阻塞态</em>：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行；</li><li><em>从运行态 -&gt; 结束态</em>：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；</li></ul><p>因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。</p><h2 id="调度分类" tabindex="-1"><a class="header-anchor" href="#调度分类"><span>调度分类</span></a></h2><p>另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：</p><ul><li><strong>非抢占式调度算法</strong> 挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li><li><strong>抢占式调度算法</strong> 挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生 <strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的 <strong>时间片机制</strong>。</li></ul><h2 id="调度原则" tabindex="-1"><a class="header-anchor" href="#调度原则"><span>调度原则</span></a></h2><ol><li><em>原则一</em>：如果运行的程序，发生了 I/O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，<strong>为了提高 CPU 利用率，在这种发送 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。</strong></li><li><em>原则二</em>：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，<strong>要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。</strong></li><li><em>原则三</em>：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，<strong>如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。</strong></li><li><em>原则四</em>：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，<strong>就绪队列中进程的等待时间也是调度程序所需要考虑的原则。</strong></li><li><em>原则五</em>：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，<strong>对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。</strong></li></ol><p><img src="'+n+'" alt="五种调度原则" loading="lazy"></p><p>针对上面的五种调度原则，总结成如下：</p><ul><li><strong>CPU 利用率</strong>：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li><li><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li><li><strong>周转时间</strong>：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；</li><li><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li><li><strong>响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li></ul><p>说白了，这么多调度原则，目的就是要使得进程要「快」。</p><h2 id="调度算法" tabindex="-1"><a class="header-anchor" href="#调度算法"><span>调度算法</span></a></h2><p>不同的调度算法适用的场景也是不同的。</p><p>接下来，说说在<strong>单核 CPU 系统</strong>中常见的调度算法。</p><h3 id="_1-先来先服务-fcfs-调度算法" tabindex="-1"><a class="header-anchor" href="#_1-先来先服务-fcfs-调度算法"><span>(1) 先来先服务 (<em>FCFS</em>) 调度算法</span></a></h3><p>最简单的一个调度算法，就是非抢占式的 **先来先服务（<em>First Come First Serve, FCFS</em>）算法 **了。</p><p><img src="'+p+'" alt="FCFS 调度算法" loading="lazy"></p><p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</p><h3 id="_2-短作业优先-sjf-调度算法" tabindex="-1"><a class="header-anchor" href="#_2-短作业优先-sjf-调度算法"><span>(2) 短作业优先 (<em>SJF</em>) 调度算法</span></a></h3><p><strong>最短作业优先（<em>Shortest Job First, SJF</em>）调度算法</strong> 同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p><p><img src="'+i+'" alt="SJF 调度算法" loading="lazy"></p><p>这显然对长作业不利，很容易造成一种极端现象。</p><p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p><h3 id="_3-高响应比优先-hrrn-调度算法-理想型-无法实现" tabindex="-1"><a class="header-anchor" href="#_3-高响应比优先-hrrn-调度算法-理想型-无法实现"><span>(3) 高响应比优先 (<em>HRRN</em>) 调度算法 (理想型，无法实现)</span></a></h3><p>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</p><p>那么，<strong>高响应比优先 （<em>Highest Response Ratio Next, HRRN</em>）调度算法</strong>主要是权衡了短作业和长作业。</p><p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>优先权</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">优先权=\\frac{等待时间+要求服务时间}{要求服务时间} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">优先权</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">要求服务时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>从上面的公式，可以发现：</p><ul><li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li><li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li></ul><blockquote><p>TIP</p><p>很多人问怎么才能知道一个进程要求服务的时间？这不是不可预知的吗？</p><p>对的，这是不可预估的。所以，高响应比优先调度算法是**「理想型」的调度算法，现实中是实现不了的**。</p></blockquote><h3 id="_4-时间片轮转-rr-调度算法" tabindex="-1"><a class="header-anchor" href="#_4-时间片轮转-rr-调度算法"><span>(4) 时间片轮转 (<em>RR</em>) 调度算法</span></a></h3><p>最古老、最简单、最公平且使用最广的算法就是 <strong>时间片轮转（<em>Round Robin, RR</em>）调度算法</strong>。</p><p><img src="'+r+'" alt="RR 调度算法" loading="lazy"></p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长。将</li></ul><p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><h3 id="_5-最高优先级-hpf-调度算法" tabindex="-1"><a class="header-anchor" href="#_5-最高优先级-hpf-调度算法"><span>(5) 最高优先级 (<em>HPF</em>) 调度算法</span></a></h3><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p><p>进程的优先级可以分为，静态优先级和动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><h3 id="_6-多级反馈队列-mfq-调度算法" tabindex="-1"><a class="header-anchor" href="#_6-多级反馈队列-mfq-调度算法"><span>(6) 多级反馈队列 (<em>MFQ</em>) 调度算法</span></a></h3><p><strong>多级反馈队列（<em>Multilevel Feedback Queue</em>）调度算法</strong> 是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="'+o+'" alt="多级反馈队列" loading="lazy"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><h2 id="调度算法-形象类比篇" tabindex="-1"><a class="header-anchor" href="#调度算法-形象类比篇"><span>调度算法 - 形象类比篇</span></a></h2><p>看的迷迷糊糊？那我拿去银行办业务的例子，把上面的调度算法串起来，你还不懂，你锤我！</p><p><strong>办理业务的客户相当于进程，银行窗口工作人员相当于 CPU。</strong></p><p>现在，假设这个银行只有一个窗口（单核 CPU ），那么工作人员一次只能处理一个业务。</p><p><img src="'+c+'" alt="银行办业务" loading="lazy"></p><h3 id="_1-先来先服务-fcfs-调度算法-1" tabindex="-1"><a class="header-anchor" href="#_1-先来先服务-fcfs-调度算法-1"><span>(1) 先来先服务 (<em>FCFS</em>) 调度算法</span></a></h3><p>那么最简单的处理方式，就是先来的先处理，后面来的就乖乖排队，这就是 <strong>先来先服务（<em>FCFS</em>）调度算法</strong>。但是万一先来的这位老哥是来贷款的，这一谈就好几个小时，一直占用着窗口，这样后面的人只能干等，或许后面的人只是想简单的取个钱，几分钟就能搞定，却因为前面老哥办长业务而要等几个小时，你说气不气人？</p><p><img src="'+m+'" alt="先来先服务" loading="lazy"></p><h3 id="_2-短作业优先-sjf-调度算法-1" tabindex="-1"><a class="header-anchor" href="#_2-短作业优先-sjf-调度算法-1"><span>(2) 短作业优先 (<em>SJF</em>) 调度算法</span></a></h3><p>有客户抱怨了，那我们就要改进，我们干脆优先给那些几分钟就能搞定的人办理业务，这就是 <strong>短作业优先（<em>SJF</em>）调度算法</strong>。听起来不错，但是依然还是有个极端情况，万一办理短业务的人非常的多，这会导致长业务的人一直得不到服务，万一这个长业务是个大客户，那不就捡了芝麻丢了西瓜</p><p><img src="'+h+'" alt="最短作业优先" loading="lazy"></p><h3 id="_4-时间片轮转-rr-调度算法-1" tabindex="-1"><a class="header-anchor" href="#_4-时间片轮转-rr-调度算法-1"><span>(4) 时间片轮转 (<em>RR</em>) 调度算法</span></a></h3><p>那就公平起见，现在窗口工作人员规定，每个人我只处理 10 分钟。如果 10 分钟之内处理完，就马上换下一个人。如果没处理完，依然换下一个人，但是客户自己得记住办理到哪个步骤了。这个也就是 <strong>时间片轮转（<em>RR</em>）调度算法</strong>。但是如果时间片设置过短，那么就会造成大量的上下文切换，增大了系统开销。如果时间片过长，相当于退化成 FCFS 算法了。</p><p><img src="'+g+'" alt="时间片轮转" loading="lazy"></p><h3 id="_5-最高优先级-hpf-调度算法-1" tabindex="-1"><a class="header-anchor" href="#_5-最高优先级-hpf-调度算法-1"><span>(5) 最高优先级 (<em>HPF</em>) 调度算法</span></a></h3><p>既然公平也可能存在问题，那银行就对客户分等级，分为普通客户、VIP 客户、SVIP 客户。只要高优先级的客户一来，就第一时间处理这个客户，这就是 <strong>最高优先级（<em>HPF</em>）调度算法</strong>。但依然也会有极端的问题，万一当天来的全是高级客户，那普通客户不是没有被服务的机会，不把普通客户当人是吗？ 那我们把优先级改成动态的，如果客户办理业务时间增加，则降低其优先级，如果客户等待时间增加，则升高其优先级。</p><p><img src="'+E+'" alt="最高优先级（静态）" loading="lazy"></p><h3 id="_6-多级反馈队列-mfq-调度算法-1" tabindex="-1"><a class="header-anchor" href="#_6-多级反馈队列-mfq-调度算法-1"><span>(6) 多级反馈队列 (<em>MFQ</em>) 调度算法</span></a></h3><p>那有没有兼顾到公平和效率的方式呢？这里介绍一种算法，考虑的还算充分的，<strong>多级反馈队列（<em>MFQ</em>）调度算法</strong>，它是时间片轮转算法和优先级算法的综合和发展。它的工作方式：</p><p><img src="'+d+'" alt="多级反馈队列" loading="lazy"></p><p>流程：</p><ol><li>银行设置了多个排队（就绪）队列，每个队列都有不同的优先级，<strong>各个队列优先级从高到低</strong>，同时每个队列执行时间片的长度也不同，<strong>优先级越高的时间片越短</strong>。</li><li>新客户（进程）来了，先进入第一级队列的末尾，按先来先服务原则排队等待被叫号（运行）。如果时间片用完客户的业务还没办理完成，则让客户进入到下一级队列的末尾，以此类推，直至客户业务办理完成。</li><li>当第一级队列没人排队时，就会叫号二级队列的客户。如果客户办理业务过程中，有新的客户加入到较高优先级的队列，那么此时办理中的客户需要停止办理，回到原队列的末尾等待再次叫号，因为要把窗口让给刚进入较高优先级队列的客户。</li></ol><p>算法特点，可以发现：</p><ul><li>对于要办理短业务的客户来说，可以很快的轮到并解决</li><li>对于要办理长业务的客户，一下子解决不了，就可以放到下一个队列，虽然等待的时间稍微变长了，但是轮到自己的办理时间也变长了，也可以接受，不会造成极端的现象</li></ul><p>可以说是综合上面几种算法的优点（「时间片轮转算法」和「最高优先级算法」的综合和发展）</p>',93)]))}const f=e(_,[["render",A],["__file","03. 调度.html.vue"]]),C=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/01.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03.%20%E8%B0%83%E5%BA%A6.html","title":"调度","lang":"zh-CN","frontmatter":{"description":"调度 （补充：该笔记还有一个独立章节《调度算法》，是进程调度/页面置换/磁盘调度算法的多种调度算法的综合，可以结合一起看） 调度概念 进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。 一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/01.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03.%20%E8%B0%83%E5%BA%A6.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"调度"}],["meta",{"property":"og:description","content":"调度 （补充：该笔记还有一个独立章节《调度算法》，是进程调度/页面置换/磁盘调度算法的多种调度算法的综合，可以结合一起看） 调度概念 进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。 一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"调度\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"调度","slug":"调度","link":"#调度","children":[{"level":2,"title":"调度概念","slug":"调度概念","link":"#调度概念","children":[]},{"level":2,"title":"调度时机","slug":"调度时机","link":"#调度时机","children":[]},{"level":2,"title":"调度分类","slug":"调度分类","link":"#调度分类","children":[]},{"level":2,"title":"调度原则","slug":"调度原则","link":"#调度原则","children":[]},{"level":2,"title":"调度算法","slug":"调度算法","link":"#调度算法","children":[{"level":3,"title":"(1) 先来先服务 (FCFS) 调度算法","slug":"_1-先来先服务-fcfs-调度算法","link":"#_1-先来先服务-fcfs-调度算法","children":[]},{"level":3,"title":"(2) 短作业优先 (SJF) 调度算法","slug":"_2-短作业优先-sjf-调度算法","link":"#_2-短作业优先-sjf-调度算法","children":[]},{"level":3,"title":"(3) 高响应比优先 (HRRN) 调度算法 (理想型，无法实现)","slug":"_3-高响应比优先-hrrn-调度算法-理想型-无法实现","link":"#_3-高响应比优先-hrrn-调度算法-理想型-无法实现","children":[]},{"level":3,"title":"(4) 时间片轮转 (RR) 调度算法","slug":"_4-时间片轮转-rr-调度算法","link":"#_4-时间片轮转-rr-调度算法","children":[]},{"level":3,"title":"(5) 最高优先级 (HPF) 调度算法","slug":"_5-最高优先级-hpf-调度算法","link":"#_5-最高优先级-hpf-调度算法","children":[]},{"level":3,"title":"(6) 多级反馈队列 (MFQ) 调度算法","slug":"_6-多级反馈队列-mfq-调度算法","link":"#_6-多级反馈队列-mfq-调度算法","children":[]}]},{"level":2,"title":"调度算法 - 形象类比篇","slug":"调度算法-形象类比篇","link":"#调度算法-形象类比篇","children":[{"level":3,"title":"(1) 先来先服务 (FCFS) 调度算法","slug":"_1-先来先服务-fcfs-调度算法-1","link":"#_1-先来先服务-fcfs-调度算法-1","children":[]},{"level":3,"title":"(2) 短作业优先 (SJF) 调度算法","slug":"_2-短作业优先-sjf-调度算法-1","link":"#_2-短作业优先-sjf-调度算法-1","children":[]},{"level":3,"title":"(4) 时间片轮转 (RR) 调度算法","slug":"_4-时间片轮转-rr-调度算法-1","link":"#_4-时间片轮转-rr-调度算法-1","children":[]},{"level":3,"title":"(5) 最高优先级 (HPF) 调度算法","slug":"_5-最高优先级-hpf-调度算法-1","link":"#_5-最高优先级-hpf-调度算法-1","children":[]},{"level":3,"title":"(6) 多级反馈队列 (MFQ) 调度算法","slug":"_6-多级反馈队列-mfq-调度算法-1","link":"#_6-多级反馈队列-mfq-调度算法-1","children":[]}]}]}],"git":{},"readingTime":{"minutes":15.63,"words":4690},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/01. 基础知识/03. 调度.md","excerpt":"\\n<p><mark>（补充：该笔记还有一个独立章节《调度算法》，是进程调度/页面置换/磁盘调度算法的多种调度算法的综合，可以结合一起看）</mark></p>\\n<h2>调度概念</h2>\\n<p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p>\\n<p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程。</p>\\n<p>选择一个进程运行这一功能是在操作系统中完成的，通常称为 <strong>调度程序</strong>（<em>scheduler</em>）。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/01. 基础知识/03. 调度.md","value":{"title":"03. 调度","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/01. 基础知识/03. 调度.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{f as comp,C as data};
