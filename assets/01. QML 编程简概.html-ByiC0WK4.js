import{_ as a,c as u,e as s,a as t,d as n,b as e,o as p,r as o}from"./app-Bin8OjZ-.js";const d={},m={href:"http://c.biancheng.net/view/3877.html",target:"_blank",rel:"noopener noreferrer"},Q={class:"callout","data-callout":"quote"},v={class:"callout-content"},c={href:"https://www.zhihu.com/search?q=%E6%A0%B9%E7%BB%84%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.zhihu.com/search?q=%E7%88%B6%E7%BB%84%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},q={href:"https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.zhihu.com/search?q=%E8%AE%BE%E8%AE%A1%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2682313148%7D",target:"_blank",rel:"noopener noreferrer"},g={class:"callout","data-callout":"quote"},h={class:"callout-content"},M={href:"http://doc.qt.io/qt-5/qtqml-documents-topic.html",target:"_blank",rel:"noopener noreferrer"},f={href:"http://doc.qt.io/qtcreator/creator-quick-ui-forms.html",target:"_blank",rel:"noopener noreferrer"},L={href:"https://link.jianshu.com?t=http://qt-project.org/doc/qt-5.0/qtqml/qtqml-index.html",target:"_blank",rel:"noopener noreferrer"},E={href:"https://www.jianshu.com/p/3e959cbaff3a",target:"_blank",rel:"noopener noreferrer"},C={href:"https://link.jianshu.com?t=http://www.kdab.com/qml-engine-internals-part-1-qml-file-loading/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://blog.csdn.net/bootleader/article/details/68937159",target:"_blank",rel:"noopener noreferrer"},A={href:"https://www.pianshen.com/article/41642047038/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://link.jianshu.com?t=http://blog.qt.digia.com/blog/2010/05/18/a-qt-scenegraph/",target:"_blank",rel:"noopener noreferrer"},D={href:"https://link.jianshu.com?t=http://qt.gitorious.org/qt/qtdeclarative/blobs/master/src/quick/items/qquickview.h#line59",target:"_blank",rel:"noopener noreferrer"},B={href:"https://link.jianshu.com?t=http://www.kdab.com",target:"_blank",rel:"noopener noreferrer"},y={href:"https://link.jianshu.com?t=http://www.kdab.com/kdab-products/gammaray/",target:"_blank",rel:"noopener noreferrer"},T={href:"https://link.jianshu.com?t=http://blog.qt.digia.com/blog/2012/02/07/qml-profiler-update/",target:"_blank",rel:"noopener noreferrer"},I={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/parser/qqmljs.g",target:"_blank",rel:"noopener noreferrer"},S={href:"https://link.jianshu.com?t=http://qt.gitorious.org/qt/qtdeclarative/blobs/master/src/qml/qml/qqmlscript_p.h#line299",target:"_blank",rel:"noopener noreferrer"},j={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlscript_p.h#line230",target:"_blank",rel:"noopener noreferrer"},P={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlscript_p.h#line183",target:"_blank",rel:"noopener noreferrer"},F={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlcompiler_p.h#line283",target:"_blank",rel:"noopener noreferrer"},U={href:"https://link.jianshu.com?t=https://qt.gitorious.org/qt/qtdeclarative/source/master:src/qml/qml/qqmlvme_p.h",target:"_blank",rel:"noopener noreferrer"},V={href:"https://www.jianshu.com/p/9b277a3ee613",target:"_blank",rel:"noopener noreferrer"};function N(J,l){const i=o("ExternalLinkIcon"),r=o("Mermaid");return p(),u("div",null,[l[81]||(l[81]=s('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="qml-编程简概" tabindex="-1"><a class="header-anchor" href="#qml-编程简概"><span>QML 编程简概</span></a></h1><p>参考：</p>',4)),t("ul",null,[t("li",null,[t("a",m,[l[0]||(l[0]=n("【C语言中文网】学习QML还是C++？")),e(i)])]),l[1]||(l[1]=t("li",null,[n("QML文档： "),t("ul",null,[t("li",null,"个人博客：https://robinsea.github.io/2020/09/16/QmlBook/quick_starter/README/")])],-1))]),l[82]||(l[82]=t("h2",{id:"简概-qt-quick项目",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#简概-qt-quick项目"},[t("span",null,"简概 - Qt Quick项目")])],-1)),l[83]||(l[83]=t("h3",{id:"qml与qtquick",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#qml与qtquick"},[t("span",null,"QML与QtQuick")])],-1)),t("ul",null,[t("li",null,[l[8]||(l[8]=t("p",null,"QML",-1)),t("ul",null,[l[6]||(l[6]=t("li",null,[t("p",null,"概念"),t("ul",null,[t("li",null,[n("QML（Qt Meta Language，Qt元语言）是一种用来描述应用程序界面的"),t("strong",null,"声明式脚本语言"),n("（这是标记语言吧）。自Qt4.7引用")])])],-1)),l[7]||(l[7]=t("li",null,[t("p",null,"优点"),t("ul",null,[t("li",null,"良好的易读性。以可视化组件及其交互和相互关联的方式来描述界面，使组件能在动态行为中互相连接")])],-1)),t("li",null,[l[5]||(l[5]=t("p",null,"原理",-1)),t("ul",null,[l[4]||(l[4]=t("li",null,[t("p",null,"通过Qt QML引擎在程序运行时解析并运行的")],-1)),t("li",null,[l[2]||(l[2]=t("p",null,"(旧) 编译器通道",-1)),e(r,{id:"mermaid-81",code:"eJxLL0osyFDwCeJy1PAK1g/09dHU1bXj8kmtSC3SD0gsKk4tin+xvvfZ5qkv1q8Fkk872p7NmwBS4pyfkpqemhf/ZPfi5wsan0+Z/6wDLO5fUJKZm1kF1Pdkz4ynPdNAYpy++SUZ8Z7FqTlAnlNlSWoyUHP807XTX3Q1ATVj1+PlGQLT4lhcnJqblFMZ/2Jx68vW3qd7Jz1buBhFhXN+bkFmTmJJZn5efGheZkn8s43tz/dMe9o79WlrMxcA44JmWQ=="})]),t("li",null,[l[3]||(l[3]=t("p",null,"(新) 编译器通道",-1)),e(r,{id:"mermaid-87",code:"eJxLL0osyFDwCeJy1PAK1g/09dHU1bXj8kmtSC3SD0gsKk4tin+xvvfZ5qkv1q8Fkk872p7NmwBS4pyfkpqemhf/ZPfi5wsan0+Z/6wDLM7pVFmSmgyUjH+6dvqLriagJFjYyzMETDsWF6fmJuVUxr9Y3Pqytffp3knPFi7GYRpIvXN+bkFmTmJJZn5efGheZkn8s43tz/dMe9o79WlrMxcAdbNX0A=="})])])])])]),l[9]||(l[9]=s("<li><p>Qt Quick</p><ul><li>概念 <ul><li>是Qt为QML提供的一套类库，由QML标准类型和功能组成</li><li>包括可视化类型、交互类型、动画类型、模型和视图、粒子系统和渲染效果等</li></ul></li><li>优点 <ul><li>易于使用，在编程时只需要一条import语句就能访问这些功能</li><li>易于开发UI界面</li></ul></li></ul></li><li><p>比较 QML C++</p><ul><li>并列称为Qt的首选编程语言</li></ul></li>",2))]),l[84]||(l[84]=s(`<h3 id="创建qt-quick工程" tabindex="-1"><a class="header-anchor" href="#创建qt-quick工程"><span>创建Qt Quick工程</span></a></h3><p>详见 简概 &gt; 开发流程 - 创建</p><p>创建 - 选项配置</p><ul><li>其他和普通项目选项差不多，主要注意一个新选项 <ul><li>Define Project Details：选择最低适应的Qt版本</li></ul></li></ul><h3 id="项目基本结构" tabindex="-1"><a class="header-anchor" href="#项目基本结构"><span>项目基本结构</span></a></h3><ul><li>QtQuickTest.pro</li><li>main.cpp</li><li>qml.qrc</li><li>main.qml（该文件视为qrc资源文件）</li></ul><p>pro</p><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">QT</span> <span class="token value attr-value">+= quick</span>

<span class="token key attr-name">CONFIG</span> <span class="token value attr-value">+= c++11</span>

<span class="token comment"># You can make your code fail to compile if it uses deprecated APIs.</span>
<span class="token comment"># In order to do so, uncomment the following line.</span>
<span class="token comment">#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0</span>

<span class="token key attr-name">SOURCES</span> <span class="token value attr-value">+= \\
        main.cpp</span>

<span class="token key attr-name">RESOURCES</span> <span class="token value attr-value">+= qml.qrc</span>

<span class="token comment"># Additional import path used to resolve QML modules in Qt Creator&#39;s code model</span>
<span class="token key attr-name">QML_IMPORT_PATH</span> <span class="token value attr-value">=</span>

<span class="token comment"># Additional import path used to resolve QML modules just for Qt Quick Designer</span>
<span class="token key attr-name">QML_DESIGNER_IMPORT_PATH</span> <span class="token value attr-value">=</span>

<span class="token comment"># Default rules for deployment.</span>
<span class="token key attr-name">qnx</span><span class="token punctuation">:</span> <span class="token value attr-value">target.path = /tmp/$\${TARGET}/bin</span>
<span class="token key attr-name">else</span><span class="token punctuation">:</span> <span class="token value attr-value">unix:!android: target.path = /opt/$\${TARGET}/bin</span>
<span class="token comment">!isEmpty(target.path): INSTALLS += target</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>main.cpp</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;QGuiApplication&gt;
#include &lt;QQmlApplicationEngine&gt;

int main(int argc, char *argv[])
{
#if QT_VERSION &lt; QT_VERSION_CHECK(6, 0, 0)
    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
#endif

    QGuiApplication app(argc, argv);

    QQmlApplicationEngine engine;                                       // QML引擎
    const QUrl url(QStringLiteral(&quot;qrc:/main.qml&quot;));                    // 需要加载的qml
    QObject::connect(&amp;engine, &amp;QQmlApplicationEngine::objectCreated,	// 将引擎结果关联到lambda上
                     &amp;app, [url](QObject *obj, const QUrl &amp;objUrl) {
        if (!obj &amp;&amp; url == objUrl)
            QCoreApplication::exit(-1);                                 // 无法加载则退出程序
    }, Qt::QueuedConnection);
    engine.load(url);                                                   // 用QML引擎加载qml文档

    return app.exec();                                                  // 消息循环
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>qml</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token comment">/* import部分 */</span>
import QtQuick <span class="token number">2.12</span>					<span class="token comment">// 导入Qt Quick 2.7库</span>
import QtQuick.Window <span class="token number">2.12</span>			<span class="token comment">// 导入Qt Quick 窗体库</span>

<span class="token comment">/* 对象声明部分 */</span>
Window <span class="token punctuation">{</span>							<span class="token comment">// 对象、根对象</span>
    width<span class="token operator">:</span> <span class="token number">640</span>						<span class="token comment">// 宽度属性</span>
    height<span class="token operator">:</span> <span class="token number">480</span>						<span class="token comment">// 高度属性</span>
    visible<span class="token operator">:</span> <span class="token boolean">true</span>					<span class="token comment">// 可见性属性</span>
    title<span class="token operator">:</span> qsTr(<span class="token string">&quot;Hello World&quot;</span>)		<span class="token comment">// 标题属性</span>
	MainForm <span class="token punctuation">{</span>						<span class="token comment">// 子对象</span>
        anchor.fill<span class="token operator">:</span> parent
        mouseArea.onClicked<span class="token operator">:</span> <span class="token punctuation">{</span>		<span class="token comment">// 点击的回调函数</span>
            console.log(qsTr(&#39;Clicked on background. Text<span class="token operator">:</span> <span class="token string">&quot;&#39; + textEdit.text +&#39;&quot;</span>&#39;))
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="项目分析" tabindex="-1"><a class="header-anchor" href="#项目分析"><span>项目分析</span></a></h3><p>要点如下：</p><ul><li>cpp：<code>#include &lt;QtQml&gt; </code>，包含模块类的定义</li><li>.qml：<code>import QtQml 2.15 </code>，能使用QML类型</li><li>.pro：<code>QT += qml</code>，链接模块</li></ul><h2 id="简概-qt-widgets项目" tabindex="-1"><a class="header-anchor" href="#简概-qt-widgets项目"><span>简概 - Qt Widgets项目</span></a></h2><h3 id="创建-qml-文件" tabindex="-1"><a class="header-anchor" href="#创建-qml-文件"><span>创建 QML 文件</span></a></h3><p>项目右键 &gt; Add new &gt; Qt &gt;</p><ul><li>Qt <ul><li>QML File (Qt Quick 2)，创建<code>.qml</code>QML文件 （需要注意的是，一般会将默认创建的qml放入qrc资源文件，然后可以将.pro 中 DISTFILES 列表中的qml文件删掉）</li><li><s>QtQuick UI File，创建两个文件 <code>xxx.qml</code> <code>xxxFrom.ui.qml</code></s><s>（需要注意的是，一般会将默认创建的qml放入qrc资源文件，然后可以将.pro 中 DISTFILES 列表中的qml文件删掉）</s> （新版Qt Creator把这个选项给删了）</li></ul></li></ul><h3 id="qml-与-ui-qml-区别-现在-ui-qml选项已经被删了" tabindex="-1"><a class="header-anchor" href="#qml-与-ui-qml-区别-现在-ui-qml选项已经被删了"><span><s>.qml 与 .ui.qml 区别</s>（现在.ui.qml选项已经被删了）</span></a></h3><p>简单来说就是后者有助于UI和业务分离，有点类似于这个比喻：（不确定我理解得对不对）</p><blockquote><p>.qml 类似于 .html，你可以在里面写标签和Script，也可以只写标签、另建一个文件写Script .ui.qml 类似于声明了一种新的 .html，你不能在里面写Script</p></blockquote><p>当然我个人的想法是更类似于Vue那种设计的，组件分离 First，UI业务分离 Second，两者都需要分离。</p>`,23)),t("div",Q,[l[28]||(l[28]=s('<div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-quote"><path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"></path><path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"></path></svg></div><div class="callout-title-inner">https://www.zhihu.com/question/55353497</div></div>',1)),t("div",v,[l[24]||(l[24]=t("p",null,null,-1)),l[25]||(l[25]=t("p",null,".qml文件，就叫QML文件。.ui.qml文件，叫QtQuick UI文件",-1)),l[26]||(l[26]=t("p",null,[n("对于"),t("code",null,".ui.qml"),n("文件来说，不支持以下特性：")],-1)),t("p",null,[l[12]||(l[12]=n("（1）JavaScript块代码。 （2）纯表达式之外的其他绑定。 （3）信号处理。 （4）在")),t("a",c,[l[10]||(l[10]=n("根组件")),e(i)]),l[13]||(l[13]=n("之外的其他组件中的状态。 （5）不是从QQuickItem或Item派生的根组件。 （6）引用根组件的")),t("a",k,[l[11]||(l[11]=n("父组件")),e(i)]),l[14]||(l[14]=n("。"))]),l[27]||(l[27]=s("<p>在<code>.ui.qml</code>文件中，不支持下列组件类型： （1）Behavior （2）Binding （3）Canvas （4）Shader Effect （5）Timer （6）Transform</p><p>在<code>.ui.qml</code>文件中，支持的方法如下『JavaScript 函数』：</p><p>这 <code>.ui.qml</code>文件的存在是为了帮助 Qt Quick Designer。 例如，普通 QML 文件可以包含 JavaScript 表达式，但 Qt Quick Designer 很难使用这些表达式。 另一方面，普通 QML 并不那么困难，并且更接近于等价于的小部件 <code>.ui</code>文件 - 详细说明用户界面中的一组项目的文档，而不是它们背后的逻辑。</p><p>用处：</p>",4)),t("p",null,[l[17]||(l[17]=n("将UI与")),t("a",q,[l[15]||(l[15]=n("应用程序")),e(i)]),l[18]||(l[18]=n("逻辑分离是一种较好的开发方式。一般来说，设计人员应该使用UI文件(")),l[19]||(l[19]=t("code",null,".ui.qml",-1)),l[20]||(l[20]=n(")，而开发人员应该使用相应的实现文件(")),l[21]||(l[21]=t("code",null,".qml",-1)),l[22]||(l[22]=n(")来定义编程行为或编写JavaScript代码。通过这种方式，可以使得")),t("a",b,[l[16]||(l[16]=n("设计端")),e(i)]),l[23]||(l[23]=n("和开发端都可以进行迭代，而不会出现覆盖彼此工作的问题。"))])])]),t("div",g,[l[38]||(l[38]=s('<div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-quote"><path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"></path><path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"></path></svg></div><div class="callout-title-inner">https://stackoverflow.com/questions/30652537/what-is-the-use-of-the-ui-qml-files-in-qt5-qml</div></div>',1)),t("div",h,[l[32]||(l[32]=t("p",null,null,-1)),l[33]||(l[33]=t("p",null,[n("这 "),t("code",null,".ui.qml"),n("文件的存在是为了帮助 Qt Quick Designer。 例如，普通 QML 文件可以包含 JavaScript 表达式，但 Qt Quick Designer 很难使用这些表达式。 另一方面，普通 QML 并不那么困难，并且更接近于等价于的小部件 "),t("code",null,".ui"),n("文件 - 详细说明用户界面中的一组项目的文档，而不是它们背后的逻辑。")],-1)),l[34]||(l[34]=t("p",null,"该功能 是几年前在博客上提出的",-1)),l[35]||(l[35]=t("blockquote",null,[t("p",null,"经典的 Widget Designer 是围绕声明式和命令式逻辑之间的区别构建的。 声明形式是可设计的并存储在 .ui 文件中。"),t("p",null,"在 Qml 中，很容易混合声明式代码和命令式代码。 如果您向 Qml 文件添加命令式指令（影响视觉方面），它们不再是纯粹的声明式，并且可视化编辑器中的可视化表示将会中断。 可视化编辑器需要一种方法将可视化描述转换回文本描述。 对于命令式代码，这通常是不可能的，Qt Quick Designer 甚至不会尝试。")],-1)),t("p",null,[t("a",M,[l[29]||(l[29]=n("QML 文档 ")),e(i)]),l[30]||(l[30]=n("文档指出"))]),l[36]||(l[36]=t("blockquote",null,[t("p",null,"从 Qt 5.4 开始，文档也可以有文件扩展名“.ui.qml”。 QML 引擎像处理标准 .qml 文件一样处理这些文件，并忽略扩展名的 .ui 部分。 Qt Creator 将这些文件作为 Qt Quick Designer 的 UI 表单处理。 这些文件只能包含 Qt Creator 定义的 QML 语言的一个子集。")],-1)),t("p",null,[t("a",f,[l[31]||(l[31]=n("Qt Quick UI 表单 ")),e(i)])]),l[37]||(l[37]=s("<blockquote><p>您可以使用 Qt Creator 向导创建文件扩展名为 .ui.qml 的 UI 表单。 UI 表单包含 QML 语言的纯声明子集。 建议您在设计模式下编辑表单。 但是，将项目导出为别名属性是一项仅供商业使用的功能，因此如果您使用 Qt Creator 的开源版本，则必须使用编辑模式来执行此操作。 Qt Creator 通过显示错误消息强制使用支持的 QML 功能。</p><p>不支持以下功能：</p><ul><li>JavaScript 块</li><li>函数定义</li><li>函数调用（qsTr 除外）</li><li>纯表达式以外的其他绑定</li><li>信号处理器</li><li>根项以外的其他项中的状态</li><li>不是从 QQuickItem 或 Item 派生的根项</li></ul><p>不支持以下类型：</p><ul><li>Behavior，行为</li><li>Binding，捆绑</li><li>Canvas，帆布</li><li>Component，零件</li><li>Shader Effect，着色效果</li><li>Timer，计时器</li><li>Transform，转换</li><li>Transition，过渡</li></ul></blockquote>",1))])]),l[85]||(l[85]=s('<div class="callout" data-callout="quote"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-quote"><path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"></path><path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"></path></svg></div><div class="callout-title-inner">Qt Assistant：qthelp://org.qt-project.qtqml.5128/qtqml/qtqml-index.html</div></div><div class="callout-content"><p></p><p>从Qt 5.4开始，文档也可以有扩展名为&quot; .ui.qml &quot;的文件。QML引擎像处理标准的. QML文件一样处理这些文件，而忽略扩展名的.ui部分。Qt Creator将这些文件作为Qt Quick Designer的UI表单处理。这些文件只能包含Qt Creator定义的QML语言的一个子集。</p></div></div><h2 id="qml底层原理" tabindex="-1"><a class="header-anchor" href="#qml底层原理"><span>QML底层原理</span></a></h2><p>参考</p>',3)),t("ul",null,[t("li",null,[t("a",L,[l[39]||(l[39]=n("【Qt官网文档】Qt QML")),e(i)])]),t("li",null,[t("a",E,[l[40]||(l[40]=n("【简书】[翻译] 深入解析QML引擎， 第1部分:QML文件加载")),e(i)]),l[42]||(l[42]=n(" （原文 ")),t("a",C,[l[41]||(l[41]=n("QML Engine Internals, Part 1: QML File Loading")),e(i)]),l[43]||(l[43]=n("，这个解析QML引擎的文章共4篇）"))]),t("li",null,[t("a",w,[l[44]||(l[44]=n("【CSDN】Qml运行机制的理解（原创）")),e(i)])]),t("li",null,[t("a",A,[l[45]||(l[45]=n("qml 引擎（V8）原理总结")),e(i)])])]),l[86]||(l[86]=t("h3",{id:"基本原理",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#基本原理"},[t("span",null,"基本原理")])],-1)),t("ul",null,[l[61]||(l[61]=t("li",null,[n("QML生成C++类 "),t("ul",null,[t("li",null,"QML文件中每个元素都对应于一个C++类。QML引擎在加载QML文件时，会为文件中的所有元素以某种方式创建相应的C++对象")])],-1)),t("li",null,[l[57]||(l[57]=n("绘制C++对象树 ")),t("ul",null,[t("li",null,[l[48]||(l[48]=n("这些元素将被绘制在一个")),t("a",x,[l[46]||(l[46]=n("OpenGL scenegraph")),e(i)]),l[49]||(l[49]=n("中，绘制及事件处理都是由")),t("a",D,[l[47]||(l[47]=n("QQuickView")),e(i)]),l[50]||(l[50]=n("控制的"))]),t("li",null,[l[53]||(l[53]=n("我们可以利用")),t("a",B,[l[51]||(l[51]=n("KDAB")),e(i)]),l[54]||(l[54]=n("的Qt自检工具")),t("a",y,[l[52]||(l[52]=n("GammaRay")),e(i)]),l[55]||(l[55]=n("来验证QML文件对应的C++对象树"))]),l[56]||(l[56]=t("li",null,"![img](01.%20QML 编程简概.assets/438086-2eb1771ce04b1370.png)",-1))])]),t("li",null,[l[59]||(l[59]=n("用")),t("a",T,[l[58]||(l[58]=n("QML分析器（QML profiler）")),e(i)]),l[60]||(l[60]=n("来运行并分析"))])]),l[87]||(l[87]=t("h3",{id:"qml文件加载步骤",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#qml文件加载步骤"},[t("span",null,"QML文件加载步骤")])],-1)),l[88]||(l[88]=t("p",null,"探寻QML引擎从解析QML文件开始，到形成一棵完整的C++对象树的整个过程",-1)),l[89]||(l[89]=t("p",null,"当加载QML文件时，会执行三个不同的步骤，接下来我们将深入研究这些步骤：",-1)),l[90]||(l[90]=t("ol",null,[t("li",null,"解析"),t("li",null,"编译"),t("li",null,"创建")],-1)),l[91]||(l[91]=t("h4",{id:"解析",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#解析"},[t("span",null,"解析")])],-1)),t("p",null,[l[63]||(l[63]=n("首先，QML文件是由QQmlScript::Parser这个解析器来解析的。该解析器内部的绝大多数内容都是由��")),t("a",I,[l[62]||(l[62]=n("语法文件")),e(i)]),l[64]||(l[64]=n("自动生成的。我们这个例子的抽象语法树（AST）看起来是这样的："))]),l[92]||(l[92]=t("p",null,"![img](01.%20QML 编程简概.assets/438086-608a25f403cf24b7.png)",-1)),t("p",null,[l[68]||(l[68]=n("这个AST是比较底层的东西，紧接着，它将被转换成更高层级结构的")),t("a",S,[l[65]||(l[65]=n("对象")),e(i)]),l[69]||(l[69]=n("，")),t("a",j,[l[66]||(l[66]=n("属性")),e(i)]),l[70]||(l[70]=n("和")),t("a",P,[l[67]||(l[67]=n("值")),e(i)]),l[71]||(l[71]=n("。这是通过使用一个访问器遍历AST来完成的。这一步的对象就和QML中的元素一一对应上了，且对象的属性/值和QML元素的属性/值也一一对应上。我们的例子中Rectangle元素的属性“color”，其对应的值是“lightsteelblue”，它们就是属性/值的关系。即使像onClicked这样的信号处理程序也被看作只是属性/值的关系，属性是onClicked，值就是JavaScript函数体。"))]),l[93]||(l[93]=t("h4",{id:"编译",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#编译"},[t("span",null,"编译")])],-1)),t("p",null,[l[73]||(l[73]=n("在理论上，对象，属性和值已经足够用于创建对应的C++对象，并给属性赋上对应的值。但这些对象，属性和值依然过于原始，在创建C++对象之前，还需要进行一些后置处理。这些后置处理是由")),t("a",F,[l[72]||(l[72]=n("QQmlCompiler")),e(i)]),l[74]||(l[74]=n("来完成的，这对应于QML分析器（QML profiler）输出中看到的编译阶段。该编译器会为QML文件创建了一个QQmlCompiledData对象。 用QQmlCompiledData创建C++对象比直接使用对象、属性和值来创建C++对象快了很多。当多次使用同一个QML文件，该文件也只会编译一次。比如在一个工程中，其他所有的QML文件都会用到的Button.qml，编译时Button.qml只会被编译一次。Button.qml的QQmlCompiledData会一直保存，每次使用该按钮组件时，都会根据这个Button.qml的QQmlCompiledData来创建C++对象。在编译之后，就是创建阶段，这在QML分析器（QML profiler）的输出中可以看到。"))]),l[94]||(l[94]=t("p",null,"综上所述：解析和编译QML文件都只会做一次，在此之后，都是直接使用QQmlCompiledData对象来快速创建C++对象。",-1)),l[95]||(l[95]=t("h4",{id:"创建",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#创建"},[t("span",null,"创建")])],-1)),l[96]||(l[96]=t("p",null,"我不会深入研究QQmlCompiledData的细节，但有一个东西可能会引起你的注意：“QByteArray bytecode”成员变量。实际上，创建C++对象并给它的属性赋值的指令会被编译为了字节码，之后由字节码解析器解析！字节码包含了一堆指令，当这些指令执行时，QQmlCompiledData的其余部分仅是辅助数据。",-1)),t("p",null,[l[76]||(l[76]=n("在创建阶段，字节码是由")),t("a",U,[l[75]||(l[75]=n("QQmlVME")),e(i)]),l[77]||(l[77]=n("类解析的。阅读QQmlVME::run（）这个函数的代码，里面有一个循环用于遍历字节码包含的所有指令，在循环体内部，有一个很大的判定不同指令类型的switch语句。运行带有QML_COMPILER_DUMP=1的例子程序，我们可以看到字节码所包含的每个指令："))]),l[97]||(l[97]=t("p",null,"（略）",-1)),l[98]||(l[98]=t("h4",{id:"结论",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#结论"},[t("span",null,"结论")])],-1)),l[99]||(l[99]=t("p",null,"在这篇博文的最后，我们已经揭示了一个QML文件是如何进行解析、处理、编译的，以及VME是如何创建对象的。我希望你已经更加深入地理解了QML引擎。",-1)),t("p",null,[l[79]||(l[79]=n("下一篇的博文（")),t("a",V,[l[78]||(l[78]=n("绑定(Bindings)")),e(i)]),l[80]||(l[80]=n("）将进一步探讨属性绑定是如何进行的，敬请关注！"))])])}const z=a(d,[["render",N],["__file","01. QML 编程简概.html.vue"]]),Z=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/02.%20QtGUI%E7%B1%BB/02.%20QtQuick/01.%20QML/01.%20QML%20%E7%BC%96%E7%A8%8B%E7%AE%80%E6%A6%82.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 QML 编程简概 参考： 【C语言中文网】学习QML还是C++？ QML文档： 个人博客：https://robinsea.github.io/2020/09/16/QmlBook/quick_starter/README/ 简概 - Qt Quick项目 QML与QtQuick QML 概念 QML（Qt Meta Language，Qt...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/02.%20QtGUI%E7%B1%BB/02.%20QtQuick/01.%20QML/01.%20QML%20%E7%BC%96%E7%A8%8B%E7%AE%80%E6%A6%82.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 QML 编程简概 参考： 【C语言中文网】学习QML还是C++？ QML文档： 个人博客：https://robinsea.github.io/2020/09/16/QmlBook/quick_starter/README/ 简概 - Qt Quick项目 QML与QtQuick QML 概念 QML（Qt Meta Language，Qt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"QML 编程简概","slug":"qml-编程简概","link":"#qml-编程简概","children":[{"level":2,"title":"简概 - Qt Quick项目","slug":"简概-qt-quick项目","link":"#简概-qt-quick项目","children":[{"level":3,"title":"QML与QtQuick","slug":"qml与qtquick","link":"#qml与qtquick","children":[]},{"level":3,"title":"创建Qt Quick工程","slug":"创建qt-quick工程","link":"#创建qt-quick工程","children":[]},{"level":3,"title":"项目基本结构","slug":"项目基本结构","link":"#项目基本结构","children":[]},{"level":3,"title":"项目分析","slug":"项目分析","link":"#项目分析","children":[]}]},{"level":2,"title":"简概 - Qt Widgets项目","slug":"简概-qt-widgets项目","link":"#简概-qt-widgets项目","children":[{"level":3,"title":"创建 QML 文件","slug":"创建-qml-文件","link":"#创建-qml-文件","children":[]},{"level":3,"title":".qml 与 .ui.qml 区别（现在.ui.qml选项已经被删了）","slug":"qml-与-ui-qml-区别-现在-ui-qml选项已经被删了","link":"#qml-与-ui-qml-区别-现在-ui-qml选项已经被删了","children":[]}]},{"level":2,"title":"QML底层原理","slug":"qml底层原理","link":"#qml底层原理","children":[{"level":3,"title":"基本原理","slug":"基本原理","link":"#基本原理","children":[]},{"level":3,"title":"QML文件加载步骤","slug":"qml文件加载步骤","link":"#qml文件加载步骤","children":[{"level":4,"title":"解析","slug":"解析","link":"#解析","children":[]},{"level":4,"title":"编译","slug":"编译","link":"#编译","children":[]},{"level":4,"title":"创建","slug":"创建","link":"#创建","children":[]},{"level":4,"title":"结论","slug":"结论","link":"#结论","children":[]}]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":11.21,"words":3364},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/02. QtGUI类/02. QtQuick/01. QML/01. QML 编程简概.md","excerpt":"\\n<h1>目录</h1>\\n<h1>QML 编程简概</h1>\\n<p>参考：</p>\\n<ul>\\n<li><a href=\\"http://c.biancheng.net/view/3877.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【C语言中文网】学习QML还是C++？</a></li>\\n<li>QML文档：\\n<ul>\\n<li>个人博客：https://robinsea.github.io/2020/09/16/QmlBook/quick_starter/README/</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>简概 - Qt Quick项目</h2>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/02. QtGUI类/02. QtQuick/01. QML/01. QML 编程简概.md","value":{"title":"01. QML 编程简概","path":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/02. QtGUI类/02. QtQuick/01. QML/01. QML 编程简概.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{z as comp,Z as data};
