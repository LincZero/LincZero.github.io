import{_ as d,e as s,g as n,o as a}from"./app-EuS-Ookm.js";const e={};function i(l,t){return a(),s("div",null,t[0]||(t[0]=[n(`<h1 id="computersystems" tabindex="-1"><a class="header-anchor" href="#computersystems"><span>ComputerSystems</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="算术和逻辑操作" tabindex="-1"><a class="header-anchor" href="#算术和逻辑操作"><span>算术和逻辑操作</span></a></h1><p>整数算术操作（分为<strong>4组</strong>：加载有效地址、一元操作、二元操作、移位）</p><table><thead><tr><th>指令</th><th>单词</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>leaq</td><td></td><td>S、D</td><td>D &lt; &amp;S</td><td>加载有效地址</td></tr><tr><td>——————</td><td></td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td>INC</td><td>increase</td><td>D</td><td>D &lt; D+1</td><td>加1</td></tr><tr><td>EDC</td><td>decrease</td><td>D</td><td>D &lt; D-1</td><td>减1</td></tr><tr><td>NEG</td><td>negative</td><td>D</td><td>D &lt; -D</td><td>取负（-D=~D+1）</td></tr><tr><td>NOT</td><td>not</td><td>D</td><td>D &lt; ~D</td><td>取补（D+~D=-1）</td></tr><tr><td>——————</td><td></td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td>ADD</td><td>add</td><td>S、D</td><td>D &lt; D+S</td><td>加</td></tr><tr><td>SUB</td><td>subtraction</td><td>S、D</td><td>D &lt; D-S</td><td>减</td></tr><tr><td>IMUL</td><td>multiply</td><td>S、D</td><td>D &lt; D*S</td><td>乘</td></tr><tr><td>XOR</td><td>exclusive or</td><td>S、D</td><td>D &lt; D^S</td><td>异或</td></tr><tr><td>OR</td><td>or</td><td>S、D</td><td>D &lt; D|S</td><td>或</td></tr><tr><td>AND</td><td>and</td><td>S、D</td><td>D &lt; D&amp;S</td><td>与</td></tr><tr><td>——————</td><td></td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td>SAL</td><td></td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移</td></tr><tr><td>SHL</td><td></td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移（等同SAL）</td></tr><tr><td>SAR</td><td></td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>A</sub>k</td><td>算术右移</td></tr><tr><td>SHR</td><td></td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>L</sub>k</td><td>逻辑右移</td></tr></tbody></table><p>具体还可细分指令类，如：指令类ADD由四条加法指令组成：addb、addw、addl、addq</p><h2 id="加载有效地址" tabindex="-1"><a class="header-anchor" href="#加载有效地址"><span>加载有效地址</span></a></h2><table><thead><tr><th>指令</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>leaq</td><td>S、D</td><td>D &lt; &amp;S</td><td>加载有效地址</td></tr></tbody></table><ul><li>加载有效地址（load effective address）<code>leaq</code>： <ul><li>是<code>movq</code>指令（传送四字（8字节））的变形，<code>leaq S,D</code>相当于C语言中的<code>D = &amp;S</code><br> 即<code>leaq S,D</code>等同于<code>movq S的地址,D</code></li><li>妙用：能执行有限形式的2加法&amp;1乘法，如<code>leaq (%rdi,%rsi,4), %rax</code>，十分方便</li></ul></li></ul><h2 id="一元操作" tabindex="-1"><a class="header-anchor" href="#一元操作"><span>一元操作</span></a></h2><table><thead><tr><th>指令</th><th>单词</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>INC</td><td>increase</td><td>D</td><td>D &lt; D+1</td><td>加1</td></tr><tr><td>EDC</td><td>decrease</td><td>D</td><td>D &lt; D-1</td><td>减1</td></tr><tr><td>NEG</td><td>negative</td><td>D</td><td>D &lt; -D</td><td>取负（-D=~D+1）</td></tr><tr><td>NOT</td><td>not</td><td>D</td><td>D &lt; ~D</td><td>取补（D+~D=-1）</td></tr></tbody></table><ul><li><p>一元：inc和dec类似于C语言中的加1运算符和减1运算符</p><ul><li>操作数为寄存器或内存地址</li></ul></li><li><p>地址+1也是加长度而非1，如：<code>incq (%rsp)</code></p></li></ul><h3 id="inc-dec" tabindex="-1"><a class="header-anchor" href="#inc-dec"><span>inc/dec</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>inc reg/mem		; = add ax 1</span></span>
<span class="line"><span>dec reg/mem		; = sub ax 1</span></span>
<span class="line"><span>; 注意：他们不影响eflags的CF符号位</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mul-div" tabindex="-1"><a class="header-anchor" href="#mul-div"><span>mul/div</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mul reg/mem		; 操作数应是8/16位</span></span>
<span class="line"><span>div reg/mem		; 操作数应是8/16位</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>mul/div</p><ul><li>只有一个操作数，所以会有一些指定的寄存器，要预先将数放进去</li><li>mul/div操作数都是无符号的 (不能处理负数)，而add/sub/adc/sbb这些都可以处理有符号数</li></ul><p>mul，注意结果会影响标志位</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>reg/mem8</td><td>al</td><td>ah:al</td></tr><tr><td>reg/mem16</td><td>dx</td><td>dx:ax</td></tr></tbody></table><p>div，注意结果不会影响标志位</p><table><thead><tr><th>被除数</th><th>除数</th><th>余数</th><th>商</th></tr></thead><tbody><tr><td>ax</td><td>reg8/mrm8</td><td>ah</td><td>al</td></tr><tr><td>dx:ax</td><td>reg16/mem16</td><td>dx</td><td>ax</td></tr></tbody></table><p>实战：</p><p>如果需要做一些高位除法，例如32位除以16位的除法，则需要自己写汇编代码</p><p>例如：0x00090006除以2 = 0x00048003余0</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>; 准备</span></span>
<span class="line"><span>mov dx, 0x0009	; 高16位</span></span>
<span class="line"><span>mov ax, 0x0006	; 低16位</span></span>
<span class="line"><span>mov cx, 0x0002	; </span></span>
<span class="line"><span>push ax			; 低16位入栈</span></span>
<span class="line"><span>mov ax, dx		; 高16位放到ax</span></span>
<span class="line"><span>mov dx, 0		; dx置为0</span></span>
<span class="line"><span>; ax=0x0009, bx=0x????, cx=0x0002, dx=0x0000, 栈=[0x0006]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; 高位除法</span></span>
<span class="line"><span>div cx			; 先做高位除法</span></span>
<span class="line"><span>mov bx, ax		; 商保存至bx</span></span>
<span class="line"><span>pop ax</span></span>
<span class="line"><span>; ax=0x0006, bx=0x0004, cx=0x0002, dx=0x0001, 栈=[]</span></span>
<span class="line"><span>; 注意一下这里的dx是参与在被除数中的，即被除数是0x00010006，结果是不溢出的16位</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; 低位除法</span></span>
<span class="line"><span>div cx			;</span></span>
<span class="line"><span>; ax=0x8003, bx=0x0004, cx=0x0002, dx=0x0000, 栈=[]</span></span>
<span class="line"><span>; 最终计算结果 = bx:ax余dx = 0x00048003余0，符合</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二元操作" tabindex="-1"><a class="header-anchor" href="#二元操作"><span>二元操作</span></a></h2><table><thead><tr><th>指令</th><th>单词</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>ADD</td><td>add</td><td>S、D</td><td>D &lt; D+S</td><td>加</td></tr><tr><td>SUB</td><td>subtraction</td><td>S、D</td><td>D &lt; D-S</td><td>减</td></tr><tr><td>IMUL</td><td>multiply</td><td>S、D</td><td>D &lt; D*S</td><td>乘</td></tr><tr><td>XOR</td><td>exclusive or</td><td>S、D</td><td>D &lt; D^S</td><td>异或</td></tr><tr><td>OR</td><td>or</td><td>S、D</td><td>D &lt; D|S</td><td>或</td></tr><tr><td>AND</td><td>and</td><td>S、D</td><td>D &lt; D&amp;S</td><td>与</td></tr></tbody></table><ul><li><p>二元：add和sub类似于C语言中的x+=a和x-=a</p></li><li><p>第一个操作数为立即数、寄存器或内存地址</p><ul><li>第二个操作数为寄存器或内存地址。为内存时：处理器会先读出值、执行操作、再把结果写回内存</li></ul></li></ul><h3 id="add-sub" tabindex="-1"><a class="header-anchor" href="#add-sub"><span>add/sub</span></a></h3><p>基本使用</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>add reg/men reg/mem/imm		;加法，两操作数分别应是8/16位</span></span>
<span class="line"><span>sub	reg/men reg/mem/imm		;减法，两操作数分别应是8/16位</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; 注意add或sub会产生借位或进位，必须将借位或进位保存下来</span></span>
<span class="line"><span>; CPU内部有一个标志寄存器(eflags)，第0位是CF位，用来保存进位和借位</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证：addsub.asm</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>;不产生进位的加法</span></span>
<span class="line"><span>mov ax, 0x0001</span></span>
<span class="line"><span>mov bx, 0x0002</span></span>
<span class="line"><span>add ax, bx</span></span>
<span class="line"><span>;产生进位的加法</span></span>
<span class="line"><span>mov ax, 0xf000</span></span>
<span class="line"><span>mov bx, 0x1000</span></span>
<span class="line"><span>add ax, bx</span></span>
<span class="line"><span>;不产生进位的减法</span></span>
<span class="line"><span>mov cx, 0x0003</span></span>
<span class="line"><span>mov dx, 0x0001</span></span>
<span class="line"><span>sub cx, dx</span></span>
<span class="line"><span>;产生进位的减法</span></span>
<span class="line"><span>mov cx, 0x0001</span></span>
<span class="line"><span>mov dx, 0x0002</span></span>
<span class="line"><span>sub cx, dx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>xh: jmp xh	; xh是自定义命名</span></span>
<span class="line"><span>times 510($-$$) db 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="add-sub衍生指令-adc-sbb" tabindex="-1"><a class="header-anchor" href="#add-sub衍生指令-adc-sbb"><span>add/sub衍生指令 adc/sbb</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>adc = add with carry = 被加数+加数+CF</span></span>
<span class="line"><span>sbb = sub with carry = 被减数-减数-CF</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>应用场景：处理高位的加减法</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>; 例如计算0x0001f000 + 0x000101000，但只有4位寄存器</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; bx:ax=0x0001f000</span></span>
<span class="line"><span>mov bx, 0x0001</span></span>
<span class="line"><span>mov ax, 0xf000</span></span>
<span class="line"><span>; dx:cx=0x00101000</span></span>
<span class="line"><span>mov dx, 0x0010</span></span>
<span class="line"><span>mov cx, 0x1000</span></span>
<span class="line"><span>; 低位相加。此时CF=0，可不用adc</span></span>
<span class="line"><span>add ax, cx</span></span>
<span class="line"><span>; 高位相加。此时使用adc，若CF=1则会加上CF</span></span>
<span class="line"><span>adc bx, dx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>jmp $</span></span>
<span class="line"><span>times 510($-$$) db 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; 结果为bx:ax=0x00120000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="and" tabindex="-1"><a class="header-anchor" href="#and"><span>and/</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>and dest目的(reg/mem) source源(reg/mem/imm)</span></span>
<span class="line"><span>or dest目的(reg/mem) source源(reg/mem/imm)</span></span>
<span class="line"><span>not reg/mem</span></span>
<span class="line"><span>xor dest目的(reg/mem) source源(reg/mem/imm)	; 会影响标志位</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>骚操作</p><ul><li>当仅取某一位时，用一个数 (如1100) 来与其进行and运算，有1的部分才会保留</li><li>当想将某一位强制变1，用一个数 (如0010) 来与其进行or运算，有1的部分强制变1</li><li>可以用来匹配两个数是否相同，若是则结果全0。可以用来置零</li></ul><h2 id="移位操作" tabindex="-1"><a class="header-anchor" href="#移位操作"><span>移位操作</span></a></h2><table><thead><tr><th>指令</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>SAL</td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移</td></tr><tr><td>SHL</td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移（等同SAL）</td></tr><tr><td>SAR</td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>A</sub>k</td><td>算术右移</td></tr><tr><td>SHR</td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>L</sub>k</td><td>逻辑右移</td></tr></tbody></table><p>骚操作</p><ul><li>当乘或除以一个2^n数时，直接左移或右移</li></ul><h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h1><h2 id="讨论" tabindex="-1"><a class="header-anchor" href="#讨论"><span>讨论</span></a></h2><h2 id="cmp-比较指令" tabindex="-1"><a class="header-anchor" href="#cmp-比较指令"><span>cmp 比较指令</span></a></h2><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>cmp dest(reg/mem) source(reg/mem/imm)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="特殊的算术操作" tabindex="-1"><a class="header-anchor" href="#特殊的算术操作"><span>特殊的算术操作</span></a></h2>`,51)]))}const p=d(e,[["render",i],["__file","03. 算术和逻辑操作.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/03.%20%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.html","title":"ComputerSystems","lang":"zh-CN","frontmatter":{"description":"ComputerSystems 目录 算术和逻辑操作 整数算术操作（分为4组：加载有效地址、一元操作、二元操作、移位） 具体还可细分指令类，如：指令类ADD由四条加法指令组成：addb、addw、addl、addq 加载有效地址 加载有效地址（load effective address）leaq： 是movq指令（传送四字（8字节））的变形，leaq...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/03.%20%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"ComputerSystems"}],["meta",{"property":"og:description","content":"ComputerSystems 目录 算术和逻辑操作 整数算术操作（分为4组：加载有效地址、一元操作、二元操作、移位） 具体还可细分指令类，如：指令类ADD由四条加法指令组成：addb、addw、addl、addq 加载有效地址 加载有效地址（load effective address）leaq： 是movq指令（传送四字（8字节））的变形，leaq..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ComputerSystems\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":4.71,"words":1412},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/03. 算术和逻辑操作.md","excerpt":"\\n<h1>目录</h1>\\n<h1>算术和逻辑操作</h1>\\n<p>整数算术操作（分为<strong>4组</strong>：加载有效地址、一元操作、二元操作、移位）</p>\\n<table>\\n<thead>\\n<tr>\\n<th>指令</th>\\n<th>单词</th>\\n<th>操作数</th>\\n<th>效果</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>leaq</td>\\n<td></td>\\n<td>S、D</td>\\n<td>D &lt; &amp;S</td>\\n<td>加载有效地址</td>\\n</tr>\\n<tr>\\n<td>——————</td>\\n<td></td>\\n<td>——————</td>\\n<td>——————</td>\\n<td>——————</td>\\n</tr>\\n<tr>\\n<td>INC</td>\\n<td>increase</td>\\n<td>D</td>\\n<td>D &lt; D+1</td>\\n<td>加1</td>\\n</tr>\\n<tr>\\n<td>EDC</td>\\n<td>decrease</td>\\n<td>D</td>\\n<td>D &lt; D-1</td>\\n<td>减1</td>\\n</tr>\\n<tr>\\n<td>NEG</td>\\n<td>negative</td>\\n<td>D</td>\\n<td>D &lt; -D</td>\\n<td>取负（-D=~D+1）</td>\\n</tr>\\n<tr>\\n<td>NOT</td>\\n<td>not</td>\\n<td>D</td>\\n<td>D &lt; ~D</td>\\n<td>取补（D+~D=-1）</td>\\n</tr>\\n<tr>\\n<td>——————</td>\\n<td></td>\\n<td>——————</td>\\n<td>——————</td>\\n<td>——————</td>\\n</tr>\\n<tr>\\n<td>ADD</td>\\n<td>add</td>\\n<td>S、D</td>\\n<td>D &lt; D+S</td>\\n<td>加</td>\\n</tr>\\n<tr>\\n<td>SUB</td>\\n<td>subtraction</td>\\n<td>S、D</td>\\n<td>D &lt; D-S</td>\\n<td>减</td>\\n</tr>\\n<tr>\\n<td>IMUL</td>\\n<td>multiply</td>\\n<td>S、D</td>\\n<td>D &lt; D*S</td>\\n<td>乘</td>\\n</tr>\\n<tr>\\n<td>XOR</td>\\n<td>exclusive or</td>\\n<td>S、D</td>\\n<td>D &lt; D^S</td>\\n<td>异或</td>\\n</tr>\\n<tr>\\n<td>OR</td>\\n<td>or</td>\\n<td>S、D</td>\\n<td>D &lt; D|S</td>\\n<td>或</td>\\n</tr>\\n<tr>\\n<td>AND</td>\\n<td>and</td>\\n<td>S、D</td>\\n<td>D &lt; D&amp;S</td>\\n<td>与</td>\\n</tr>\\n<tr>\\n<td>——————</td>\\n<td></td>\\n<td>——————</td>\\n<td>——————</td>\\n<td>——————</td>\\n</tr>\\n<tr>\\n<td>SAL</td>\\n<td></td>\\n<td>k、D</td>\\n<td>D &lt; D&lt;&lt;k</td>\\n<td>左移</td>\\n</tr>\\n<tr>\\n<td>SHL</td>\\n<td></td>\\n<td>k、D</td>\\n<td>D &lt; D&lt;&lt;k</td>\\n<td>左移（等同SAL）</td>\\n</tr>\\n<tr>\\n<td>SAR</td>\\n<td></td>\\n<td>k、D</td>\\n<td>D &lt; D&gt;&gt;<sub>A</sub>k</td>\\n<td>算术右移</td>\\n</tr>\\n<tr>\\n<td>SHR</td>\\n<td></td>\\n<td>k、D</td>\\n<td>D &lt; D&gt;&gt;<sub>L</sub>k</td>\\n<td>逻辑右移</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/03. 算术和逻辑操作.md","value":{"title":"03. 算术和逻辑操作","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/03. 算术和逻辑操作.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{p as comp,c as data};
