import{_ as t,c as l,e as o,o as i}from"./app-CZqDObZ4.js";const d={};function a(n,e){return i(),l("div",null,e[0]||(e[0]=[o('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>QT</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="qdialog" tabindex="-1"><a class="header-anchor" href="#qdialog"><span>QDialog</span></a></h1><h2 id="qdialog-模态和非模态对话框" tabindex="-1"><a class="header-anchor" href="#qdialog-模态和非模态对话框"><span>QDialog 模态和非模态对话框</span></a></h2><ul><li><p>头文件</p><ul><li><code>#include &lt;QDialog&gt;</code></li></ul></li><li><p>区别</p><ul><li>模态对话框：不可用对其他窗口进行操作（对话框弹出时会阻塞）</li><li>非模块对话框：可以对其他窗口进行操作</li></ul></li><li><p>使用【模态对话框】（单线程嘛）</p><ul><li><code>QDialog dlg1(this); dlg1.exec();</code>，exec()，表示接替了主窗口的消息循环。关闭时应该是回栈，把控制器还给主窗口</li></ul></li><li><p>使用【非模块对话框】</p><ul><li><p><s><code>QDialog dlg2(this); dlg2.show();</code>，如果在函数，新窗口一闪而过、马上被释放而不可用</s></p></li><li><p><s><code>QDialog * dlg2 = new QDialog(this); dlg2-&gt;show();</code>，如果在函数，新窗口并没有被析构，会造成内存泄露</s></p></li><li><p><s><code>QDialog * dlg2 = new QDialog(this); dlg2-&gt;show(); delete dlg2;</code>，新窗口一闪而过、马上被释放而不可用</s></p></li><li><p><code>QDialog * dlg2 = new QDialog(this); dlg2-&gt;show(); dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose);</code></p><p>最后一行代码的表示当关闭窗口时自动释放堆内存，否则应该是只析构（不相当于Vue中<code>&lt;router-view&gt;</code>外包裹的<code>&lt;keep-alive&gt;</code>）</p><p><code>setAttribute(Qt::WA_DeleteOnClose);</code>也可以直接写在对话框的构造函数中</p></li></ul></li></ul><h2 id="qmessagebox-信息对话框" tabindex="-1"><a class="header-anchor" href="#qmessagebox-信息对话框"><span>QMessageBox 信息对话框</span></a></h2><ul><li><p>头文件</p><ul><li><code>#include &lt;QMessageBox&gt;</code></li></ul></li><li><p>使用</p><ul><li><p>错误对话框：<code>QMessageBox::critical(this, &quot;ErrorTitle&quot;, &quot;错误信息&quot;);</code></p></li><li><p>信息对话框：<code>QMessageBox::information(this, &quot;InfoTitle&quot;, &quot;信息&quot;);</code></p></li><li><p>警告对话框：<code>QMessageBox::warning(this, &quot;WarningTitle&quot;, &quot;警告信息&quot;);</code></p></li><li><p>提问对话框：<code>QMessageBox::question(this, &quot;QuesTitle&quot;, &quot;提问信息&quot;, QMessageBox::Save|QMessageBox::Cancel);</code></p><p>（第四个参数默认是选Yes和No）返回枚举型，可用于比较</p></li></ul></li></ul><h2 id="其他标准对话框" tabindex="-1"><a class="header-anchor" href="#其他标准对话框"><span>其他标准对话框</span></a></h2><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h3><p>Qt的内置对话框大致分以下几类（都是QDialog的后代）</p><table><thead><tr><th>对话框</th><th>说明</th></tr></thead><tbody><tr><td>QColorDialog</td><td>选择颜色</td></tr><tr><td>QFileDialog</td><td>选择文件或目录（详见文件交互一章）</td></tr><tr><td>QFontDialog</td><td>选择字体</td></tr><tr><td>QInputDialog</td><td>允许用户输入一个值，并将值返回</td></tr><tr><td><strong>QMessageBox</strong></td><td>模态对话框，显示信息、询问等</td></tr><tr><td>QPageSetupDialog</td><td>为打印机提供纸张相关的选项</td></tr><tr><td>QPrintDialog</td><td>打印机配置（详见绘图一章）</td></tr><tr><td>QPrintPreviewDialog</td><td>打印预览</td></tr><tr><td>QProgressDialog</td><td>显示操作过程</td></tr></tbody></table><p>使用</p><table><thead><tr><th>类名</th><th>使用示例</th></tr></thead><tbody><tr><td><code>QColorDialog</code></td><td><code>QColor color = QColorDialog::getColor(QColor(255,0,0));</code></td></tr><tr><td><code>QFileDialog</code></td><td><code>QString str = QFileDialog::getOpenFileName(this, &quot;OpenFile&quot;, &quot;默认路径&quot;, &quot;(*.txt)&quot;);</code></td></tr><tr><td><code>QFontDialog</code></td><td><code>QFont font = QFontDialog::getFont(&amp;布尔变量, QFont(&quot;黑体&quot;,16));</code></td></tr></tbody></table><p>补充</p><ul><li><code>QColor</code>属性：<code>color.red()</code>、<code>color.green()</code>、<code>color.blue()</code></li><li><code>QFont</code>属性：<code>font.family().toUtf8().data()</code>、<code>font.pointSize()</code>、<code>font.bold()</code>、<code>font.italic()</code></li></ul><h2 id="自定义信息框" tabindex="-1"><a class="header-anchor" href="#自定义信息框"><span>自定义信息框</span></a></h2>',16)]))}const g=t(d,[["render",a],["__file","03. QDialog对话框.html.vue"]]),s=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/02.%20QtGUI%E7%B1%BB/01.%20Widget/01.%20%E7%AA%97%E5%8F%A3%E7%B1%BB/03.%20QDialog%E5%AF%B9%E8%AF%9D%E6%A1%86.html","title":"QT","lang":"zh-CN","frontmatter":{"description":"QT 目录 QDialog QDialog 模态和非模态对话框 头文件 #include <QDialog> 区别 模态对话框：不可用对其他窗口进行操作（对话框弹出时会阻塞） 非模块对话框：可以对其他窗口进行操作 使用【模态对话框】（单线程嘛） QDialog dlg1(this); dlg1.exec();，exec()，表示接替了主窗口的消息循环。...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/02.%20QtGUI%E7%B1%BB/01.%20Widget/01.%20%E7%AA%97%E5%8F%A3%E7%B1%BB/03.%20QDialog%E5%AF%B9%E8%AF%9D%E6%A1%86.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"QT"}],["meta",{"property":"og:description","content":"QT 目录 QDialog QDialog 模态和非模态对话框 头文件 #include <QDialog> 区别 模态对话框：不可用对其他窗口进行操作（对话框弹出时会阻塞） 非模块对话框：可以对其他窗口进行操作 使用【模态对话框】（单线程嘛） QDialog dlg1(this); dlg1.exec();，exec()，表示接替了主窗口的消息循环。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"QT\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"QT","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"QDialog","slug":"qdialog","link":"#qdialog","children":[{"level":2,"title":"QDialog 模态和非模态对话框","slug":"qdialog-模态和非模态对话框","link":"#qdialog-模态和非模态对话框","children":[]},{"level":2,"title":"QMessageBox 信息对话框","slug":"qmessagebox-信息对话框","link":"#qmessagebox-信息对话框","children":[]},{"level":2,"title":"其他标准对话框","slug":"其他标准对话框","link":"#其他标准对话框","children":[{"level":3,"title":"分类","slug":"分类","link":"#分类","children":[]}]},{"level":2,"title":"自定义信息框","slug":"自定义信息框","link":"#自定义信息框","children":[]}]}],"git":{},"readingTime":{"minutes":1.83,"words":550},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/02. QtGUI类/01. Widget/01. 窗口类/03. QDialog对话框.md","excerpt":"\\n<h1>目录</h1>\\n<h1>QDialog</h1>\\n<h2>QDialog 模态和非模态对话框</h2>\\n<ul>\\n<li>\\n<p>头文件</p>\\n<ul>\\n<li><code>#include &lt;QDialog&gt;</code></li>\\n</ul>\\n</li>\\n<li>\\n<p>区别</p>\\n<ul>\\n<li>模态对话框：不可用对其他窗口进行操作（对话框弹出时会阻塞）</li>\\n<li>非模块对话框：可以对其他窗口进行操作</li>\\n</ul>\\n</li>\\n<li>\\n<p>使用【模态对话框】（单线程嘛）</p>\\n<ul>\\n<li><code>QDialog dlg1(this); dlg1.exec();</code>，exec()，表示接替了主窗口的消息循环。关闭时应该是回栈，把控制器还给主窗口</li>\\n</ul>\\n</li>\\n<li>\\n<p>使用【非模块对话框】</p>\\n<ul>\\n<li>\\n<p><s><code>QDialog dlg2(this); dlg2.show();</code>，如果在函数，新窗口一闪而过、马上被释放而不可用</s></p>\\n</li>\\n<li>\\n<p><s><code>QDialog * dlg2 = new QDialog(this); dlg2-&gt;show();</code>，如果在函数，新窗口并没有被析构，会造成内存泄露</s></p>\\n</li>\\n<li>\\n<p><s><code>QDialog * dlg2 = new QDialog(this); dlg2-&gt;show(); delete dlg2;</code>，新窗口一闪而过、马上被释放而不可用</s></p>\\n</li>\\n<li>\\n<p><code>QDialog * dlg2 = new QDialog(this); dlg2-&gt;show(); dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose);</code></p>\\n<p>最后一行代码的表示当关闭窗口时自动释放堆内存，否则应该是只析构（不相当于Vue中<code>&lt;router-view&gt;</code>外包裹的<code>&lt;keep-alive&gt;</code>）</p>\\n<p><code>setAttribute(Qt::WA_DeleteOnClose);</code>也可以直接写在对话框的构造函数中</p>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/02. QtGUI类/01. Widget/01. 窗口类/03. QDialog对话框.md","value":{"title":"03. QDialog对话框","path":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/02. QtGUI类/01. Widget/01. 窗口类/03. QDialog对话框.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{g as comp,s as data};
