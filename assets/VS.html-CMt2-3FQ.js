import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as d,c as r,b as e,e as l,d as a,a as n}from"./app-BAt33Ddg.js";const o="/assets/image-20201124163331957-B-nLG91O.png",c="/assets/985127-20200712222759129-976055030-BSI24IVo.gif",h="/assets/985127-20200712222801313-1252964731-DEb1uVBe.png",u="/assets/985127-20200712222800909-2058689877-16530793095934-BEI1APlz.gif",p="/assets/985127-20200712222802591-1717021126-DOvutNSQ.gif",g="/assets/985127-20200712222803557-250517868-DBqa6gWt.png",v="/assets/985127-20200712222803908-1710693840-hykcstJT.png",b={},m=n('<h1 id="vs" tabindex="-1"><a class="header-anchor" href="#vs"><span>VS</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="安装" tabindex="-1"><a class="header-anchor" href="#安装"><span>安装</span></a></h1><h2 id="费用" tabindex="-1"><a class="header-anchor" href="#费用"><span>费用</span></a></h2><h2 id="占用" tabindex="-1"><a class="header-anchor" href="#占用"><span>占用</span></a></h2><p>系统驱动器（这个很烦）</p><figure><img src="'+o+'" alt="image-20201124163331957" tabindex="0" loading="lazy"><figcaption>image-20201124163331957</figcaption></figure><h2 id="vs安装后如何添加工作负载" tabindex="-1"><a class="header-anchor" href="#vs安装后如何添加工作负载"><span>VS安装后如何添加工作负载</span></a></h2><blockquote><h3 id="方法1" tabindex="-1"><a class="header-anchor" href="#方法1"><span>方法1</span></a></h3></blockquote><p>重新打开安装程序，会出现添加删除组件的界面，勾选即可</p><blockquote><h3 id="方法2" tabindex="-1"><a class="header-anchor" href="#方法2"><span>方法2</span></a></h3></blockquote><p>打开软件时选择菜单栏的 工具 &gt; 获取工具和功能</p><h1 id="开发辅助工具-好用的" tabindex="-1"><a class="header-anchor" href="#开发辅助工具-好用的"><span>开发辅助工具（好用的）</span></a></h1><h2 id="编辑器工具" tabindex="-1"><a class="header-anchor" href="#编辑器工具"><span>编辑器工具</span></a></h2><h2 id="文档工具" tabindex="-1"><a class="header-anchor" href="#文档工具"><span>文档工具</span></a></h2><ul><li>如何查看C/C++头文件内容？ <ul><li>光标选中头文件所在行 &gt; 右键 &gt; 转到文档（F12）</li></ul></li><li>定义的函数工具 <ul><li>光标选中函数定义所在行 &gt; 右键 &gt; <ul><li>速览定义（Alt+F12），【弹出小窗口的方式】可以快速浏览函数原型、函数所属的头文件</li><li>转到定义（F12），【显示文件列表的方式，可跳转至对应行】</li><li>转到声明（Ctrl+F12），【显示文件列表的方式，可跳转至对应行】，好像和上一个差不多啊</li><li>查找所有引用（Shift+F12），【显示文件列表的方式，可跳转至对应行】</li></ul></li></ul></li></ul><h1 id="打开" tabindex="-1"><a class="header-anchor" href="#打开"><span>打开</span></a></h1><p>有个很坑的点，例如我想用VS打开一个CLion项目，或CMakeList.txt的其他项目。</p><p>一开始打开的选项里只有打开sln等，或直接打开文件夹。但都是错的。</p><p>要先按 &quot;继续，但无需代码&quot;，进去主页面后再按 <code>文件&gt;打开</code>，此时才能看到一个 <code>CMake</code> 的选项，此时才能打开CMake</p><h1 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h1><p>2022 社区版为例，顶部工具栏有几个编译相关的工具</p><ul><li>设备/部署：本地计算机</li><li>工具集：下拉 &gt; 管理配置，即可设置。可设置： <ul><li>minGW、MSVC、Clang 等</li><li>Debug / Release / Other</li><li>x64 / x86 等</li><li>输出路径</li></ul></li><li>目标：Sln / CMakeLists的设置多个目标 (可执行文件或库)</li><li>Debug/Release</li></ul><p>工具集补充：</p><ul><li>与CLion不同，这会生成一个CMakeSetting.json。而在 工具 &gt; 选项 &gt; CMake &gt; 常规 中，有个选项：CMake配置文件 <ul><li>始终使用 CMake 预设 (CMakePresets.json)</li><li>如果可用，请使用 CMake 预设，否则使用 CMakeSettings.json (默认)</li><li>从不使用 CMake 预设</li></ul></li><li>而 CMakePresets.json 是更通用的一种格式，推荐优先使用，详细内容见 CMakePresets.json 的相关笔记</li></ul><h1 id="调试" tabindex="-1"><a class="header-anchor" href="#调试"><span>调试</span></a></h1><p>VS调试工具是出了名的好用，比起其他IDE软件有更多更强大的功能</p><p>参考</p>',28),f={href:"https://docs.microsoft.com/en-US/visualstudio/debugger/debugger-tips-and-tricks?view=vs-2019",target:"_blank",rel:"noopener noreferrer"},k=e("h2",{id:"调试工具",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#调试工具"},[e("span",null,"调试工具")])],-1),x=e("p",null,"参考",-1),_={href:"https://www.cnblogs.com/lazycoding/archive/2012/10/03/2710738.html",target:"_blank",rel:"noopener noreferrer"},F=n('<h3 id="step-into、step-over-step-out区别" tabindex="-1"><a class="header-anchor" href="#step-into、step-over-step-out区别"><span>Step Into、Step Over，Step Out区别</span></a></h3><table><thead><tr><th>调试方式</th><th>快捷键</th><th>作用/区别</th></tr></thead><tbody><tr><td>Step Into</td><td>F11/F5</td><td>单步执行，遇到子函数就进入并且继续单步执行</td></tr><tr><td>Step Over</td><td>F10/F6</td><td>在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，<br>而是将子函数整个执行完在停止，也就是把子函数整个作为一步</td></tr><tr><td>Step Return</td><td>Shift+F11/F7</td><td>在单步执行到子函数内时，用Step Return就可以执行完子函数余下部分，并返回上一层函数</td></tr></tbody></table><p>括号左侧为 visual studio 的快捷键，右侧为 eclipse 的快捷键。</p><h3 id="悬停鼠标查看表达式" tabindex="-1"><a class="header-anchor" href="#悬停鼠标查看表达式"><span>悬停鼠标查看表达式</span></a></h3><h3 id="实时改变值" tabindex="-1"><a class="header-anchor" href="#实时改变值"><span>实时改变值</span></a></h3><h3 id="设置下一条语句" tabindex="-1"><a class="header-anchor" href="#设置下一条语句"><span>设置下一条语句</span></a></h3><h3 id="编辑然后继续" tabindex="-1"><a class="header-anchor" href="#编辑然后继续"><span>编辑然后继续</span></a></h3><h3 id="方便的监视窗口" tabindex="-1"><a class="header-anchor" href="#方便的监视窗口"><span>方便的监视窗口</span></a></h3><h3 id="带注释的反汇编" tabindex="-1"><a class="header-anchor" href="#带注释的反汇编"><span>带注释的反汇编</span></a></h3><h3 id="带有栈的线程窗口" tabindex="-1"><a class="header-anchor" href="#带有栈的线程窗口"><span>带有栈的线程窗口</span></a></h3><h3 id="条件断点" tabindex="-1"><a class="header-anchor" href="#条件断点"><span>条件断点</span></a></h3><h3 id="内存窗口" tabindex="-1"><a class="header-anchor" href="#内存窗口"><span>内存窗口</span></a></h3><h3 id="转到定义" tabindex="-1"><a class="header-anchor" href="#转到定义"><span>转到定义</span></a></h3><h3 id="命令窗口" tabindex="-1"><a class="header-anchor" href="#命令窗口"><span>命令窗口</span></a></h3><h2 id="调试工具-高级" tabindex="-1"><a class="header-anchor" href="#调试工具-高级"><span>调试工具 - 高级</span></a></h2><p>参考</p>',16),C={href:"https://www.cnblogs.com/bianchengnan/p/13290366.html",target:"_blank",rel:"noopener noreferrer"},q=n('<h3 id="并行堆栈" tabindex="-1"><a class="header-anchor" href="#并行堆栈"><span>并行堆栈</span></a></h3><blockquote><h4 id="打开方式" tabindex="-1"><a class="header-anchor" href="#打开方式"><span>打开方式</span></a></h4></blockquote><p>调试 -&gt; 窗口 -&gt; 并行堆栈 (Call Stack)</p><p>快捷键：是 <code>ctrl + shift + d, s</code>（按住 <code>ctrl + shift</code>，再按 <code>d</code>，松开 <code>ctrl, shift</code> 后再按 <code>s</code>） （VS的快捷键按起来确实奇怪）</p><blockquote><h4 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h4></blockquote><p>（调用堆栈窗口 的进化版 —— 并行堆栈窗口）</p><p>我们可以通过调用堆栈窗口查看当前线程的调用栈，<strong>局限是只能查看某个线程的调用栈</strong>，要想查看每个线程的调用栈得<strong>切来切去</strong>的，太麻烦。 如果我们想<strong>同时</strong>查看多个线程的调用情况，我们可以使用并行堆栈窗口。</p><p>顾名思义，并行堆栈窗口可以同时查看多个线程的调用栈。 如果程序中的某个线程死循环了，我们想确定是哪个，这时候可以中断到 <code>vs</code> 中，然后打开并行堆栈窗口进行查看，基本上可以很快定位到出问题的代码。</p><figure><img src="'+c+'" alt="parallel-stack" tabindex="0" loading="lazy"><figcaption>parallel-stack</figcaption></figure><h3 id="并行监视" tabindex="-1"><a class="header-anchor" href="#并行监视"><span>并行监视</span></a></h3><blockquote><h4 id="打开方式-1" tabindex="-1"><a class="header-anchor" href="#打开方式-1"><span>打开方式</span></a></h4></blockquote><p>菜单 -&gt; 调试 -&gt; 窗口 -&gt; 并行监视 -&gt; 并行监视1/2/3/4</p><p>即可打开对应的并行监视窗口。和监视窗口一样可以同时打开四个。</p><p>在 <code>vs2013</code> 中对应的快捷键是 <code>ctrl + shift + d, 1/2/3/4</code> 。注意是按住 <code>ctrl + shift</code>，再按 <code>d</code>，松开 <code>ctrl, shift</code> 后再按 <code>1/2/3/4</code>。</p><blockquote><h4 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1"><span>作用</span></a></h4></blockquote><p>（监视窗口 的进化版 —— 并行监视窗口）</p><p>相信，大家经常使用<strong>监视窗口</strong>查看变量，当我们想查看每个栈帧的局部变量的时候，我们<strong>需要切换到对应栈帧才能看到对应的值</strong>，是不是比较麻烦？ <strong>并行监视窗口</strong>了解下</p><table><thead><tr><th>调用方法</th><th>作用效果（单监视窗口）</th></tr></thead><tbody><tr><td><img src="'+h+'" alt="parallel-watch-setting" loading="lazy"></td><td><img src="'+u+'" alt="parallel-watch" loading="lazy"></td></tr></tbody></table><h3 id="自动窗口" tabindex="-1"><a class="header-anchor" href="#自动窗口"><span>自动窗口</span></a></h3><blockquote><h4 id="打开方式-2" tabindex="-1"><a class="header-anchor" href="#打开方式-2"><span>打开方式</span></a></h4></blockquote><p>菜单 -&gt; 调试 -&gt; 窗口 -&gt; 自动窗口</p><p>快捷键： <code>ctrl + alt + v, s</code> 。注意是按住 <code>ctrl + alt</code>，再按 <code>v</code>，松开 <code>ctrl, alt</code> 后再按 <code>s</code>。</p><blockquote><h4 id="作用-2" tabindex="-1"><a class="header-anchor" href="#作用-2"><span>作用</span></a></h4></blockquote><p>除了可以查看函数参数，局部变量的值意外，更有用的功能是查看函数调用的返回值</p><figure><img src="'+p+'" alt="auto-window" tabindex="0" loading="lazy"><figcaption>auto-window</figcaption></figure><h3 id="混合调试" tabindex="-1"><a class="header-anchor" href="#混合调试"><span>混合调试</span></a></h3><blockquote><h4 id="打开方式-3" tabindex="-1"><a class="header-anchor" href="#打开方式-3"><span>打开方式</span></a></h4></blockquote><p>通过 <code>F5</code> 调试时的设置方法</p><figure><img src="'+g+'" alt="debug-with-f5" tabindex="0" loading="lazy"><figcaption>debug-with-f5</figcaption></figure><p>通过附加进程进行调试时的设置方法</p><figure><img src="'+v+`" alt="attach-debug-setting" tabindex="0" loading="lazy"><figcaption>attach-debug-setting</figcaption></figure><p><strong>务必注意：</strong> 有时候我们设置断点不生效，可以检查一下调试方式是否选对了。如果我们只想调试 <code>C++</code> 代码，可以只勾选 <code>Native</code>，如果只想调 <code>.NET</code> 代码，可以根据实际情况勾选 <code>Managed(v4.5, v4.0)</code> 或者 <code>Managed(v3.5, v3.0, v2.0)</code>，如果都想调那就都勾选</p><blockquote><h4 id="作用-3" tabindex="-1"><a class="header-anchor" href="#作用-3"><span>作用</span></a></h4></blockquote><p>当我们需要调试的程序中有 <code>.NET</code> 代码，也有 <code>c++</code> 代码时，开启混合调试非常有必要</p><h3 id="使用断点修改变量的值" tabindex="-1"><a class="header-anchor" href="#使用断点修改变量的值"><span>使用断点修改变量的值</span></a></h3><p><strong>注意：</strong></p><p>1、 表达式不要加分号！！！</p><p>2、 高版本的 <code>vs</code> 才支持，<code>vs2019</code> 亲测有效</p><blockquote><h4 id="作用-4" tabindex="-1"><a class="header-anchor" href="#作用-4"><span>作用</span></a></h4></blockquote><p>相信大家在调试的时候都设置过断点，但是你是否知道我们可以<strong>在调试的时候通过断点来改变变量的值</strong></p><p>调查问题时，想手动修改值来验证一下我们的想法是否正确，但是又不想修改代码，也不想中断下来后，手动修改，因为可能需要手动修改 <code>N</code> 次，改过的小伙伴儿应该有体会。我们可以通过这个小技巧来自动帮我们改变变量的值</p><h1 id="踩坑" tabindex="-1"><a class="header-anchor" href="#踩坑"><span>踩坑</span></a></h1><h2 id="debug和release区别" tabindex="-1"><a class="header-anchor" href="#debug和release区别"><span>Debug和Release区别</span></a></h2><blockquote><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h3></blockquote><ul><li>Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序</li><li>Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用</li><li>Debug 和 Release 的真正区别，在于一组编译选项</li></ul><h3 id="栈的方向" tabindex="-1"><a class="header-anchor" href="#栈的方向"><span>栈的方向</span></a></h3><h4 id="从大到小分配的栈的结构" tabindex="-1"><a class="header-anchor" href="#从大到小分配的栈的结构"><span><strong>从大到小</strong>分配的栈的结构</span></a></h4><p>Linux进程的虚拟地址空间设计：（地址从下往上增大）</p><table><thead><tr><th style="text-align:center;">虚拟地址空间</th><th>补充说明</th></tr></thead><tbody><tr><td style="text-align:center;">内核虚拟内存</td><td>【顶部区域】不允许应用程序读写和调用，必须通过调用内核来执行这些操作</td></tr><tr><td style="text-align:center;">用户栈<br>（往下增长）</td><td>运行时创建<br>【动态大小】每次调用函数栈增长，函数返回时栈会收缩</td></tr><tr><td style="text-align:center;">↕</td><td></td></tr><tr><td style="text-align:center;">共享库的内存映射区域<br>（往上增长）</td><td>【动态大小】存放像C标准库和数学库这样共享库代码和数据的地方</td></tr><tr><td style="text-align:center;">↑</td><td></td></tr><tr><td style="text-align:center;">运行时堆<br>（往上增长）</td><td>运行时由malloc创建<br>【动态大小】调用malloc和free这样的C标准库函数时可动态扩展和收缩</td></tr><tr><td style="text-align:center;">读/写数据</td><td>从hello可执行文件加载进来的程序代码和数据</td></tr><tr><td style="text-align:center;">只读的代码和数据</td><td>【开始区域】从hello可执行文件加载进来的程序代码和数据</td></tr></tbody></table><figure><img src="https://img-blog.csdn.net/20170815232720915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV3VfUm9j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><h4 id="区别举例-连续定义下的地址的紧凑程度" tabindex="-1"><a class="header-anchor" href="#区别举例-连续定义下的地址的紧凑程度"><span>区别举例：连续定义下的地址的紧凑程度</span></a></h4><ul><li><strong>操作</strong><ul><li>连续定义了2个整型和2个浮点型2个整型指针，再依次取地址</li></ul></li><li><strong>Debug下的x86架构指令集</strong><ul><li>取地址：003BF7<strong>F4</strong>，003BF7<strong>E8</strong>，003BF7<strong>DC</strong>，003BF7<strong>D0</strong>，00A1D020，00A21FB8</li><li>规律：4字节存储地址，地址递减，整型和浮点型后间隔<mark>12</mark>个地址，指针地址随机？</li></ul></li><li><strong>Debug下的x64架构指令集</strong><ul><li>取地址：000000ABD00FFA<strong>74</strong>，000000ABD00FFA<strong>94</strong>，000000ABD00FFA<strong>B4</strong>，000000ABD00FFA<strong>D4</strong>，000001F1900B1<strong>0</strong>F0，000001F1900B1<strong>1</strong>F0</li><li>规律：8字节存储地址，地址递增，整型和浮点型后间隔<mark>2*16</mark>个地址，指针地址随机？</li></ul></li><li><strong>Release下的x86架构指令集</strong><ul><li>取地址：00DAFE<strong>F0</strong>，00DAFE<strong>EC</strong>，00DAFE<strong>E8</strong>，00DAFE<strong>E4</strong>，0157DFE0，0157E130</li><li>规律：4字节存储地址，地址递减，整型和浮点型后间隔<mark>4</mark>个地址（整型和浮点型均占<mark>4字节</mark>），指针地址随机？</li></ul></li><li><strong>Release下的x64架构指令集</strong><ul><li>取地址：00000099000FFA<strong>E0</strong>，00000099000FFA<strong>E4</strong>，00000099000FFA<strong>E8</strong>，00000099000FFA<strong>EC</strong>，000001FE3EE4F820，000001FE3EE4F7D0</li><li>规律：8字节存储地址，地址递增，整型和浮点型后间隔<mark>4</mark>个地址（整型和浮点型均占<mark>4字节</mark>），指针地址随机？</li></ul></li><li><strong>补充</strong><ul><li>好像无论x86还是x64，栈都是往下增长的。方向不同可能是以为编译的缘故？？？</li></ul></li></ul><h4 id="代码验证" tabindex="-1"><a class="header-anchor" href="#代码验证"><span>代码验证</span></a></h4><div class="language-C++ line-numbers-mode" data-ext="C++" data-title="C++"><pre class="language-C++"><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    char ac_dog1[] = { &quot;dog&quot; };
    char ac_dog2[4] = { &quot;dog&quot; };
    char ac_dog3[4] = { &#39;d&#39;,&#39;o&#39;,&#39;g&#39;,&#39;\\0&#39; };
    char ac_dog4[4] = { &#39;c&#39;,&#39;o&#39; };
    char ac_dog5[4] = { &#39;d&#39;,&#39;o&#39;,&#39;g&#39;,&#39;s&#39; };
    char ac_dog6[4];
    cout &lt;&lt; ac_dog1 &lt;&lt; &quot;\\t&quot; &lt;&lt; &amp;ac_dog1 &lt;&lt; endl;
    cout &lt;&lt; ac_dog2 &lt;&lt; &quot;\\t&quot; &lt;&lt; &amp;ac_dog2 &lt;&lt; endl;
    cout &lt;&lt; ac_dog3 &lt;&lt; &quot;\\t&quot; &lt;&lt; &amp;ac_dog3 &lt;&lt; endl;
    cout &lt;&lt; ac_dog4 &lt;&lt; &quot;\\t&quot; &lt;&lt; &amp;ac_dog4 &lt;&lt; endl;
    cout &lt;&lt; ac_dog5 &lt;&lt; &quot;\\t&quot; &lt;&lt; &amp;ac_dog5 &lt;&lt; endl;
    cout &lt;&lt; ac_dog6 &lt;&lt; &quot;\\t&quot; &lt;&lt; &amp;ac_dog6 &lt;&lt; endl;
    cout &lt;&lt; endl;
    cout &lt;&lt; &amp;ac_dog4 &lt;&lt; endl;
    printf(&quot;元素\\t+法取地址\\tASCII\\t元素取地址\\n&quot;);
    cout &lt;&lt; ac_dog4[0] &lt;&lt; &quot;\\t&quot;
        &lt;&lt; &amp;ac_dog4 + 0 &lt;&lt; &quot;\\t&quot;
        &lt;&lt; int(ac_dog4[0]) &lt;&lt; &quot;\\t&quot;
        &lt;&lt; hex &lt;&lt; long(&amp;ac_dog4[0]) &lt;&lt; dec &lt;&lt; endl;
    cout &lt;&lt; ac_dog4[1] &lt;&lt; &quot;\\t&quot;
        &lt;&lt; &amp;ac_dog4 + 1 &lt;&lt; &quot;\\t&quot;
        &lt;&lt; int(ac_dog4[1]) &lt;&lt; &quot;\\t&quot;
        &lt;&lt; hex &lt;&lt; long(&amp;ac_dog4[1]) &lt;&lt; dec &lt;&lt; endl;
    cout &lt;&lt; ac_dog4[2] &lt;&lt; &quot;\\t&quot;
        &lt;&lt; &amp;ac_dog4 + 2 &lt;&lt; &quot;\\t&quot;
        &lt;&lt; int(ac_dog4[2]) &lt;&lt; &quot;\\t&quot;
        &lt;&lt; hex &lt;&lt; long(&amp;ac_dog4[2]) &lt;&lt; dec &lt;&lt; endl;
    cout &lt;&lt; ac_dog4[3] &lt;&lt; &quot;\\t&quot;
        &lt;&lt; &amp;ac_dog4 + 3 &lt;&lt; &quot;\\t&quot;
        &lt;&lt; int(ac_dog4[3]) &lt;&lt; &quot;\\t&quot;
        &lt;&lt; hex &lt;&lt; long(&amp;ac_dog4[3]) &lt;&lt; dec &lt;&lt; endl;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Debug x86模式输出（看来Debug模式才会显示“烫”）</p><p>连续定义时地址依次变小</p><div class="language-C++ line-numbers-mode" data-ext="C++" data-title="C++"><pre class="language-C++"><code>/* 输出
dog     0079FD70
dog     0079FD64
dog     0079FD58
co      0079FD4C
dogs烫烫烫烫co  0079FD40
烫烫烫烫烫烫dogs烫烫烫烫co      0079FD34

元素    +法取地址       ASCII   元素取地址
c       0079FD4C        99      79fd4c
o       0079FD50        111     79fd4d
        0079FD54        0       79fd4e
        0079FD58        0       79fd4f
*/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Release x86模式输出</p><p>连续定义时地址忽大忽小，<mark>很奇怪</mark></p><div class="language-C++ line-numbers-mode" data-ext="C++" data-title="C++"><pre class="language-C++"><code>/* 输出
dog     0053FC18
dog     0053FC1C
dog     0053FC10
co      0053FC08
dogsdog 0053FC14
C     0053FC20

0053FC08
元素    +法取地址       ASCII   元素取地址
c       0053FC08        99      53fc08
o       0053FC0C        111     53fc09
        0053FC10        0       53fc0a
        0053FC14        0       53fc0b
*/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="大端or小端" tabindex="-1"><a class="header-anchor" href="#大端or小端"><span>大端or小端</span></a></h2><p>无论是Debug还是Release，x86还是x64，windows均使用的是小端法</p><p>验证代码：</p><div class="language-C line-numbers-mode" data-ext="C" data-title="C"><pre class="language-C"><code>char* p = (char*)&amp;i;
    if (*p == 1)
        printf(&quot;小端模式&quot;);
    else // (*p == 0)
        printf(&quot;大端模式&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h1><h2 id="解决方案资源管理器" tabindex="-1"><a class="header-anchor" href="#解决方案资源管理器"><span>解决方案资源管理器</span></a></h2><p>结构</p><ul><li>解决方案（包含n个项目） <ul><li>ConsoleApplication（项目名，一个解决方案可以有多个项目） <ul><li>引用</li><li>外部依赖项</li><li>头文件（.h）</li><li>源文件（.cpp）</li><li>资源文件</li></ul></li></ul></li></ul><h2 id="快捷键" tabindex="-1"><a class="header-anchor" href="#快捷键"><span>快捷键</span></a></h2><p>Ctrl+F5，运行</p><p>Shift+F9，调试时快速监视</p><p>注释快捷键非常诡异</p><ul><li>注释：ctrl+k+c</li><li>取消注释：ctrl+k+u</li></ul>`,73);function E(S,D){const t=s("ExternalLinkIcon");return d(),r("div",null,[m,e("ul",null,[e("li",null,[e("a",f,[l("【Microsoft 官方文档】了解 Visual Studio 中调试器的生产力提示和技巧"),a(t)])])]),k,x,e("ul",null,[e("li",null,[e("a",_,[l("【博客园】原译 - 11个高效的VS调试技巧"),a(t)])])]),F,e("ul",null,[e("li",null,[e("a",C,[l("【博客园】5 个非常实用的 vs 调试技巧"),a(t)]),l("（Main）")])]),q])}const B=i(b,[["render",E],["__file","VS.html.vue"]]),V=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/10.%20%E4%B8%93%E9%A2%98/IDESoft/VS.html","title":"VS","lang":"zh-CN","frontmatter":{"description":"VS 目录 安装 费用 占用 系统驱动器（这个很烦） image-20201124163331957image-20201124163331957 VS安装后如何添加工作负载 方法1 重新打开安装程序，会出现添加删除组件的界面，勾选即可 方法2 打开软件时选择菜单栏的 工具 > 获取工具和功能 开发辅助工具（好用的） 编辑器工具 文档工具 如何查看C/...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/10.%20%E4%B8%93%E9%A2%98/IDESoft/VS.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"VS"}],["meta",{"property":"og:description","content":"VS 目录 安装 费用 占用 系统驱动器（这个很烦） image-20201124163331957image-20201124163331957 VS安装后如何添加工作负载 方法1 重新打开安装程序，会出现添加删除组件的界面，勾选即可 方法2 打开软件时选择菜单栏的 工具 > 获取工具和功能 开发辅助工具（好用的） 编辑器工具 文档工具 如何查看C/..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img-blog.csdn.net/20170815232720915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV3VfUm9j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"VS\\",\\"image\\":[\\"https://img-blog.csdn.net/20170815232720915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV3VfUm9j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"VS","slug":"vs","link":"#vs","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"安装","slug":"安装","link":"#安装","children":[{"level":2,"title":"费用","slug":"费用","link":"#费用","children":[]},{"level":2,"title":"占用","slug":"占用","link":"#占用","children":[]},{"level":2,"title":"VS安装后如何添加工作负载","slug":"vs安装后如何添加工作负载","link":"#vs安装后如何添加工作负载","children":[]}]},{"level":1,"title":"开发辅助工具（好用的）","slug":"开发辅助工具-好用的","link":"#开发辅助工具-好用的","children":[{"level":2,"title":"编辑器工具","slug":"编辑器工具","link":"#编辑器工具","children":[]},{"level":2,"title":"文档工具","slug":"文档工具","link":"#文档工具","children":[]}]},{"level":1,"title":"打开","slug":"打开","link":"#打开","children":[]},{"level":1,"title":"编译","slug":"编译","link":"#编译","children":[]},{"level":1,"title":"调试","slug":"调试","link":"#调试","children":[{"level":2,"title":"调试工具","slug":"调试工具","link":"#调试工具","children":[{"level":3,"title":"Step Into、Step Over，Step Out区别","slug":"step-into、step-over-step-out区别","link":"#step-into、step-over-step-out区别","children":[]},{"level":3,"title":"悬停鼠标查看表达式","slug":"悬停鼠标查看表达式","link":"#悬停鼠标查看表达式","children":[]},{"level":3,"title":"实时改变值","slug":"实时改变值","link":"#实时改变值","children":[]},{"level":3,"title":"设置下一条语句","slug":"设置下一条语句","link":"#设置下一条语句","children":[]},{"level":3,"title":"编辑然后继续","slug":"编辑然后继续","link":"#编辑然后继续","children":[]},{"level":3,"title":"方便的监视窗口","slug":"方便的监视窗口","link":"#方便的监视窗口","children":[]},{"level":3,"title":"带注释的反汇编","slug":"带注释的反汇编","link":"#带注释的反汇编","children":[]},{"level":3,"title":"带有栈的线程窗口","slug":"带有栈的线程窗口","link":"#带有栈的线程窗口","children":[]},{"level":3,"title":"条件断点","slug":"条件断点","link":"#条件断点","children":[]},{"level":3,"title":"内存窗口","slug":"内存窗口","link":"#内存窗口","children":[]},{"level":3,"title":"转到定义","slug":"转到定义","link":"#转到定义","children":[]},{"level":3,"title":"命令窗口","slug":"命令窗口","link":"#命令窗口","children":[]}]},{"level":2,"title":"调试工具 - 高级","slug":"调试工具-高级","link":"#调试工具-高级","children":[{"level":3,"title":"并行堆栈","slug":"并行堆栈","link":"#并行堆栈","children":[]},{"level":3,"title":"并行监视","slug":"并行监视","link":"#并行监视","children":[]},{"level":3,"title":"自动窗口","slug":"自动窗口","link":"#自动窗口","children":[]},{"level":3,"title":"混合调试","slug":"混合调试","link":"#混合调试","children":[]},{"level":3,"title":"使用断点修改变量的值","slug":"使用断点修改变量的值","link":"#使用断点修改变量的值","children":[]}]}]},{"level":1,"title":"踩坑","slug":"踩坑","link":"#踩坑","children":[{"level":2,"title":"Debug和Release区别","slug":"debug和release区别","link":"#debug和release区别","children":[{"level":3,"title":"栈的方向","slug":"栈的方向","link":"#栈的方向","children":[{"level":4,"title":"从大到小分配的栈的结构","slug":"从大到小分配的栈的结构","link":"#从大到小分配的栈的结构","children":[]},{"level":4,"title":"区别举例：连续定义下的地址的紧凑程度","slug":"区别举例-连续定义下的地址的紧凑程度","link":"#区别举例-连续定义下的地址的紧凑程度","children":[]},{"level":4,"title":"代码验证","slug":"代码验证","link":"#代码验证","children":[]}]}]},{"level":2,"title":"大端or小端","slug":"大端or小端","link":"#大端or小端","children":[]}]},{"level":1,"title":"使用","slug":"使用","link":"#使用","children":[{"level":2,"title":"解决方案资源管理器","slug":"解决方案资源管理器","link":"#解决方案资源管理器","children":[]},{"level":2,"title":"快捷键","slug":"快捷键","link":"#快捷键","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":9.67,"words":2902},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/10. 专题/IDESoft/VS.md","autoDesc":true}');export{B as comp,V as data};
