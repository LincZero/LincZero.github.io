import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o,c as l,a as n,b as s,d as t,e}from"./app-yixEWCFr.js";const i={},u=e(`<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="函数传递" tabindex="-1"><a class="header-anchor" href="#函数传递"><span>函数传递</span></a></h1><h2 id="函数指针传递-的方式-java" tabindex="-1"><a class="header-anchor" href="#函数指针传递-的方式-java"><span>“函数指针传递” 的方式（Java）</span></a></h2><p>有几种方法</p><h3 id="_1-接口方法" tabindex="-1"><a class="header-anchor" href="#_1-接口方法"><span>① 接口方法</span></a></h3><p>例如通过实现接口的方式，本质是传递一个实现了接口的类</p><p>举两个例子：</p><p><strong>①</strong> 接口实现：事件监听器</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">ActionsListener</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">AxtionEvent</span> event<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// do some work</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>②</strong> 接口实现：比较器 compare方法不是立即调用。实际上，在数组完成排序之前，sort方法会一直调用compare方法</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">LengthComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compar</span><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Strings</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LengthComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个例子有一些共同点，</p><p>都是将一个代码块传递到某个对象（一个定时器，或者一个sort方法）。这个代码块会在将来某个时间调用。</p><h3 id="_2-lambda表达式" tabindex="-1"><a class="header-anchor" href="#_2-lambda表达式"><span>② Lambda表达式</span></a></h3><p>Lambda表达式也可以做到类似的作用，并且方式更加简单</p><blockquote><p>Q：思考：Java为什么引入lambda表达式</p><p>A：lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。 先来看看没有Lambda表达式时，Java是怎么传递 “函数指针的”。一般通过类似于接口+观察者模式来实现</p></blockquote><h3 id="_3-传递方法引用" tabindex="-1"><a class="header-anchor" href="#_3-传递方法引用"><span>③ 传递方法引用</span></a></h3><p>普通方法引用</p><p>构造器引用</p><h3 id="与c-不同-传递代码段的方式" tabindex="-1"><a class="header-anchor" href="#与c-不同-传递代码段的方式"><span><mark>与C++不同</mark>（传递代码段的方式）</span></a></h3><ul><li>Java <ul><li><strong>Java很难传递代码段</strong></li><li>在Java中传递一个代码段并不容易，不能直接传递代码段。 Java是一种纯面向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。</li><li>问题已经不是是否增强Java来支持函数式编程，而是要如何做到这一点。 设计者们做了多年的尝试，终于找到一种适合Java的设计 —— Lambda表达式（Java SE 8引入）</li></ul></li><li>其他语言 <ul><li>在其他语言中可以直接处理代码块。</li><li>Java设计者很长时间以来一直拒绝增加这个特性。Java非常重视其简单性和一致性。 他们认为如果只要一个特性能够让代码稍简洁一些，就把这个特性增加到语言中，这个语言很快就会变得一团糟，无法管理。</li></ul></li></ul><h2 id="lambda表达式-java-se-8" tabindex="-1"><a class="header-anchor" href="#lambda表达式-java-se-8"><span>Lambda表达式（Java SE 8）</span></a></h2><p>Lambda主要学习目的：</p><ul><li>如何生成lambda表达式</li><li>如何把lambda表达式传递到需要一个函数式接口的方法</li><li>如何编写方法处理lambda表达式</li></ul><h3 id="定义方法" tabindex="-1"><a class="header-anchor" href="#定义方法"><span>定义方法</span></a></h3><p>定义方法</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span>
	<span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        
<span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token comment">// 写法上有点像js的箭头函数，即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类型自动推导</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp
    <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span>  <span class="token comment">// 相当于 (String first, String second)</span>
    	<span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。</span>
<span class="token comment">// 在这里，编译器可以推导出first和second必然是字符串，因为这个lambda表达式将赋给一个字符串比较器。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>省略小括号</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The time is &quot;</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 相当于 (event) -&gt; ... or (ActionEvent event) -&gt; ...</span>

<span class="token comment">// 如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动推导返回类型</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出</span>
<span class="token comment">// 例如下面这句可以在需要int类型结果的上下文中使用</span>
<span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动推倒返回类型时，要确保返回唯一性</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的</span>
<span class="token comment">// 例如下面这句是不合法的</span>
<span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用举例" tabindex="-1"><a class="header-anchor" href="#使用举例"><span>使用举例</span></a></h3><p>如何在一个比较器和一个动作监听器中使用lambda表达式</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">lambda</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>swing<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>swing<span class="token punctuation">.</span></span><span class="token class-name">Timer</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 此程序演示如何使用lambda表达式
 * <span class="token keyword">@version</span> 1.0 2015-05-12
 * <span class="token keyword">@author</span> Cay Horstmann
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaTest</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Lambda作为比较器参数传入</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> planets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sting</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">&quot;水星&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;金星&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;地球&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;火星&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;木星&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;土星&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;天王星&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;海王星&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Attays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">Planets</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;按字典名称排序:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>planets<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>planets<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;按长度排序:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>planets<span class="token punctuation">,</span> <span class="token punctuation">(</span>first，second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// Lambda的使用1</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>planets<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// Lambda表达式作为监听器参数传入</span>
        <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>
            <span class="token number">1000</span><span class="token punctuation">,</span>
        	event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>					<span class="token comment">// Lambda的使用2</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 保持程序运行，直到用户选择 &quot;Ok&quot;</span>
        <span class="token class-name">J0ptionPane</span><span class="token punctuation">.</span> <span class="token function">showMessageDialog</span><span class="token punctuation">(</span>nul1，<span class="token string">&quot;是否要退出程序？&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token class-name">O</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="与c-不同-概念上" tabindex="-1"><a class="header-anchor" href="#与c-不同-概念上"><span><mark>与C++不同</mark>（概念上）</span></a></h3><p>Lambda表达式【区别还挺大的】</p><ul><li>Java <ul><li>lambda表达式所能做的也只是能转换为函数式接口。函数式接口这个概念其他语言也似乎是没有的</li></ul></li><li>其他语言 <ul><li>（这里指其他支持<strong>函数字面量</strong>的程序设计语言）</li><li>可以声明函数类型（如<code>(String, String) -&gt; int</code>）、声明这些类型的变量，还可以使用变量保存函数表达式。 不过，Java设计者还是决定保持我们熟悉的接口概念，<strong>没有为Java语言增加函数类型</strong>。</li></ul></li></ul><h3 id="与c-不同-写法上" tabindex="-1"><a class="header-anchor" href="#与c-不同-写法上"><span><mark>与C++不同</mark>（写法上）</span></a></h3><ul><li><p>Java（区别极大）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 这里用了类型自动推导。另外，最重要的一点是：</span>
<span class="token comment">// 这里表示可以用来代替函数式接口来使用，而不是真的赋值、保存Lambda表达式</span>
<span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
<span class="token punctuation">{</span>
    first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用BiFunction倒是可以保存一个Lambda表达式到BiFunction变量中，但这没有什么用</span>
<span class="token comment">// 例如：没有哪个Arrays.sort方法想要接收一个BiFunction</span>
<span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Sting</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> comp
    <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Predicate接口才是专门用来传递lambda表达式</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// 语法
[捕获列表] (形参列表) mutable 异常列表-&gt; 返回类型
{
    函数体
}

/*
    捕获列表：捕获外部变量，捕获的变量可以在函数体中使用，可以省略，即不捕获外部变量。
    形参列表：和普通函数的形参列表一样。可省略，即无参数列表
    mutable：mutable 关键字，如果有，则表示在函数体中可以修改捕获变量，根据具体需求决定是否需要省略。
    异常列表：noexcept / throw(...),和普通函数的异常列表一样，可省略，即代表可能抛出任何类型的异常。
    返回类型：和函数的返回类型一样。可省略，如省略，编译器将自动推导返回类型。
    函数体：代码实现。可省略，但是没意义。
*/

// 举例
auto l = [](int x) -&gt; bool {
	// ...  
};

auto lambda = [a, b](int x, int y)mutable throw() -&gt; bool
{
    return a + b &gt; x + y;
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Python</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>self<span class="token punctuation">.</span>aboutAct <span class="token operator">=</span> QAction<span class="token punctuation">(</span><span class="token string">&quot;关于&quot;</span><span class="token punctuation">,</span> self<span class="token punctuation">,</span> statusTip<span class="token operator">=</span><span class="token string">&quot;关于界面&quot;</span>
                        <span class="token punctuation">,</span> triggered<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> QMessageBox<span class="token punctuation">.</span>about<span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">&quot;About MDI&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;WWWWWWWWWWWWW&quot;</span><span class="token punctuation">)</span>
                        <span class="token punctuation">)</span>  <span class="token comment"># def about(self);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>JavaScript</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token function-variable function">max</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token operator">&gt;</span>b<span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">;</span>
<span class="token comment">// 也可用es6的箭头写</span>
<span class="token keyword">let</span> <span class="token function-variable function">max</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> a<span class="token operator">&gt;</span>b<span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="函数式接口-functional-interface" tabindex="-1"><a class="header-anchor" href="#函数式接口-functional-interface"><span>函数式接口 (Functional Interface)</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><p>函数式接口 (Functional Interface)</p><ul><li>概念 <ul><li>就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口（Runoob的解释）</li></ul></li><li>特点 <ul><li>函数式接口可以被隐式转换为 lambda 表达式</li></ul></li><li>举例 <ul><li>Java中已经有很多封装代码块的接口，如ActionListener或Comparator。 lambda表达式与这些接口是兼容的。</li><li>不能把lambda表达式赋给类型为Object的变量，Object不是一个函数式接口</li></ul></li></ul><h3 id="几个概念的区别" tabindex="-1"><a class="header-anchor" href="#几个概念的区别"><span>几个概念的区别</span></a></h3><p>三者区别（接口、函数式接口、Lambda表达式、函数、内联函数）</p><ul><li>函数式接口 &amp; 接口 &amp; Lambda <ul><li><strong>函数式接口</strong>是一种特殊的<strong>接口</strong></li><li><strong>函数式接口</strong>可以隐式地转换为<strong>Lambda表达式</strong>（普通接口则不行）</li></ul></li><li>Lambda &amp; 函数 <ul><li>其他语言：Lambda是一种特殊的函数、类似于匿名闭包函数的概念</li><li>Java：没有函数这个概念，Lambda是一种可以用来代替函数式接口的东西</li></ul></li><li>原理上 <ul><li>C++：lambda表达式可以理解为一个匿名的内联函数</li></ul></li></ul><h3 id="使用举例-1" tabindex="-1"><a class="header-anchor" href="#使用举例-1"><span>使用举例</span></a></h3><p>展示如何转换为函数式接口</p><h4 id="举例-arrays-sort-方法" tabindex="-1"><a class="header-anchor" href="#举例-arrays-sort-方法"><span>举例：Arrays.sort()方法</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>
    words<span class="token punctuation">,</span>
    <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Arrays.sort 简明原理</span>
<span class="token comment">// 原本它的第二个参数需要一个Comparator实例，方法会接收实现Comparator&lt;String&gt;的某个类的对象</span>
<span class="token comment">// 而Comparator只有一个方法的接口，属于函数式借口，所以可以提供一个lambda表达式</span>
<span class="token comment">// 在这个对象上调用compare方法会自动执行这个lambda表达式。这也是为什么函数式接口要求有且只有一个抽象方法</span>

<span class="token comment">// 最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="举例-timer定时器" tabindex="-1"><a class="header-anchor" href="#举例-timer定时器"><span>举例：Timer定时器</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> event <span class="token operator">-&gt;</span>
	<span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;At the tone, the time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 原本它的第二个参数要传入一个实现了ActionListener接口的类</span>
<span class="token comment">// 而这个类只有一个方法的接口</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些对象和类的管理完全取决于具体实现，与使用传统的内联类相比，这样可能要高效得多。？？？（这句话不太懂）</p><h3 id="java库举例" tabindex="-1"><a class="header-anchor" href="#java库举例"><span>Java库举例</span></a></h3><p>后面 “处理Lambda” 表达式一章会详细讲</p><h4 id="bifunction-保存lambda表达式到变量" tabindex="-1"><a class="header-anchor" href="#bifunction-保存lambda表达式到变量"><span>BiFunction，保存Lambda表达式到变量</span></a></h4><p>Java API在java.util.function包中定义了很多非常通用的函数式接口</p><p>其中一个接口<code>BiFunction&lt;T，U，R&gt;</code>描述了<strong>参数类型为T和U而且返回类型为R的函数</strong>。可以把我们的字符串比较lambda表达式保存在这个类型的变量中</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Sting</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> comp
    <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，这对于排序并没有帮助。没有哪个Arrays.sort方法想要接收一个BiFunction</p><p>这与其他函数式程序语言不同。如果你之前用过某种函数式程序设计语言，可能会发现这很奇怪</p><h4 id="predicate" tabindex="-1"><a class="header-anchor" href="#predicate"><span>Predicate</span></a></h4><p>java.util.function包中有一个尤其有用的接口<code>Predicate</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 附加默认项和静态方法</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ArrayList类有一个removeIf方法，它的参数就是一个Predicate。<strong>这个接口专门用来传递lambda表达式</strong>。</p><p>例如，下面的语句将从一个数组列表删除所有null值：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>list<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="方法引用-method-reference" tabindex="-1"><a class="header-anchor" href="#方法引用-method-reference"><span>方法引用（Method Reference）</span></a></h2><ul><li>普通方法引用（Method Reference）</li><li>构造器引用（Construct Reference）</li></ul><h3 id="使用举例-2" tabindex="-1"><a class="header-anchor" href="#使用举例-2"><span>使用举例</span></a></h3><h4 id="举例-timer定时器-1" tabindex="-1"><a class="header-anchor" href="#举例-timer定时器-1"><span>举例：Timer定时器</span></a></h4><p>例如，假设你希望只要出现一个定时器事件就打印这个事件对象</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 方案一：传入Lambda表达式</span>
<span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 方案二：直接把println方法传递到Timer构造器</span>
<span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="举例-arrays-sort-方法-1" tabindex="-1"><a class="header-anchor" href="#举例-arrays-sort-方法-1"><span>举例：Arrays.sort()方法</span></a></h4><p>假设你想对字符串排序，而不考虑字母的大小写。可以传递以下方法表达式</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="其他补充" tabindex="-1"><a class="header-anchor" href="#其他补充"><span>其他补充</span></a></h3><h4 id="等价的lambda表达式" tabindex="-1"><a class="header-anchor" href="#等价的lambda表达式"><span>等价的Lambda表达式</span></a></h4><p>上面的 “举例：Timer定时器“ 中</p><p><code>System.out::println</code>是一个<code>方法引用</code>（method reference）， 它等价于lambda表达式：<code>x-&gt;System.out.println(x)</code></p><h4 id="函数重载问题" tabindex="-1"><a class="header-anchor" href="#函数重载问题"><span>函数重载问题</span></a></h4><p>如果有多个同名的重载方法，编译器就会尝试从上下文中找出你指的那一个方法。</p><p>例如，Math.max方法有两个版本，一个用于整数，另一个用于double值。选择哪一个版本取决于 Math::max 转换为哪个函数式接口的方法参数。</p><h4 id="操作符小总结" tabindex="-1"><a class="header-anchor" href="#操作符小总结"><span><code>::</code>操作符小总结</span></a></h4><p>要用<code>::</code>操作符分隔方法名与对象或类名。主要有3种情况</p><ul><li>object::instanceMethod</li><li>Class::staticMethod</li><li>Class::instanceMethod</li></ul><p>在前2种情况中，方法引用等价于提供方法参数的lambda表达式</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 情况一。例如：</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span>			<span class="token comment">/*等价于*/</span>		x<span class="token operator">-&gt;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>

<span class="token comment">// 情况二。例如：</span>
<span class="token class-name">Math</span><span class="token operator">::</span><span class="token function">pow</span>					<span class="token comment">/*等价于*/</span>		<span class="token punctuation">(</span>x，y<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>x，y<span class="token punctuation">)</span>

<span class="token comment">// 情况三。例如：</span>
<span class="token class-name">String</span><span class="token operator">::</span><span class="token function">compareToIgnoreCase</span>	<span class="token comment">/*等同于*/</span>		<span class="token punctuation">(</span>x，y<span class="token punctuation">)</span><span class="token operator">-&gt;</span>x<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>  <span class="token comment">// 其中第1个参数会成为方法的实例</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="结合this-super参数" tabindex="-1"><a class="header-anchor" href="#结合this-super参数"><span>结合<code>this</code>/<code>super</code>参数</span></a></h4><p>可以在方法引用中使用this参数。例如，<code>this::equals</code>等同于<code>x-&gt;this.equals(x)</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">super</span><span class="token operator">::</span><span class="token function">instanceMethod</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例子</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">TimedGreeter</span> <span class="token keyword">extends</span> <span class="token class-name">Greeter</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// TimedGreeter.greet方法开始执行时，会构造一个Timer，它会在每次定时器滴答时执行super::greet方法</span>
        <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token keyword">super</span><span class="token operator">::</span><span class="token function">greet</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="构造器引用-construct-reference" tabindex="-1"><a class="header-anchor" href="#构造器引用-construct-reference"><span>构造器引用（Construct Reference）</span></a></h2><p>构造器引用与方法引用很类似，只不过方法名为new</p><p>例如：Person::new是Person构造器的一个引用</p><h3 id="使用举例-3" tabindex="-1"><a class="header-anchor" href="#使用举例-3"><span>使用举例</span></a></h3><p>假设你有一个字符串列表。可以把它转换为一个Person对象数组 为此要在各个字符串上调用构造器，调用如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 传入构造器引用。</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> people <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// map方法会为各个列表元素调用Person(String)构造器</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="其他补充-1" tabindex="-1"><a class="header-anchor" href="#其他补充-1"><span>其他补充</span></a></h3><h4 id="等价的lambda表达式-1" tabindex="-1"><a class="header-anchor" href="#等价的lambda表达式-1"><span>等价的Lambda表达式</span></a></h4><p>可以用数组类型建立构造器引用。</p><p>例如，<code>int[]::new</code>是一个构造器引用，它有一个参数：即数组的长度。这等价于lambda表达式<code>x-&gt;new int[x]</code></p><h4 id="函数重载问题-1" tabindex="-1"><a class="header-anchor" href="#函数重载问题-1"><span>函数重载问题</span></a></h4><p>例如在上面的例子中</p><p>如果有多个Person构造器，编译器会选择有一个String参数的构造器，因为它从上下文推导出这是在对一个字符串调用构造器。</p><h4 id="妙用-构造泛型类型t的数组" tabindex="-1"><a class="header-anchor" href="#妙用-构造泛型类型t的数组"><span>妙用：构造泛型类型T的数组</span></a></h4><p>Java有一个限制，无法构造泛型类型T的数组。数组构造器引用对于克服这个限制很有用。表达式new T[n]会产生错误，因为这会改为new Object[n]</p><p>例如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 假设我们需要一个Person对象数组。Stream接口有一个toArray方法可以返回Object数组：</span>
<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 不过，这并不让人满意。用户希望得到一个Person引用数组，而不是Object引用数组</span>

<span class="token comment">// 流库利用构造器引用解决了这个问题。可以把Person[]::new传入toArray方法</span>
<span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people <span class="token operator">=</span> steam<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// toArray方法调用这个构造器来得到一个正确类型的数组。然后填充这个数组并返回。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="闭包问题-lambda变量作用域" tabindex="-1"><a class="header-anchor" href="#闭包问题-lambda变量作用域"><span>闭包问题（Lambda变量作用域）</span></a></h2><h3 id="写法-访问外部方法或变量" tabindex="-1"><a class="header-anchor" href="#写法-访问外部方法或变量"><span>写法 - 访问外部方法或变量</span></a></h3><p>通常，你可能希望能够在lambda表达式中访问外围方法或类中的变量 其他编程语言的Lambda基本都有这个功能</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 注意这里的text变量</span>
        <span class="token comment">//     不是在这个lambda表达式中定义的，是repeatMessage方法的一个参数变量</span>
        <span class="token comment">// 这里会有问题：</span>
        <span class="token comment">//     lambda表达式的代码可能会在repeatMessage调用返回很久以后才运行，而那时这个参数变量已经不存在了。</span>
        <span class="token comment">// 如何保留text变量呢？</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印：Hello every 1,000 milliseconds</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="原理-lambda如何保留变量" tabindex="-1"><a class="header-anchor" href="#原理-lambda如何保留变量"><span>原理 - Lambda如何保留变量？</span></a></h3><p>下面来巩固我们对lambda表达式的理解。lambda表达式有3个部分：</p><ol><li>一个代码块</li><li>参数</li><li>自由变量的值。这是指非参数而且不在代码中定义的变量</li></ol><p>我们说它被lambda表达式<strong>捕获（captured）</strong></p><p>_</p><p>关于代码块以及自由变量值有一个术语：<strong>闭包（closure）</strong>。在Java中，lambda表达式就是闭包。</p><h3 id="写法限制" tabindex="-1"><a class="header-anchor" href="#写法限制"><span>写法限制</span></a></h3><p>lambda表达式可以捕获外围作用域中变量的值，但是会有一些限制</p><blockquote><h5 id="_1-只能引用值不会改变的变量" tabindex="-1"><a class="header-anchor" href="#_1-只能引用值不会改变的变量"><span>① 只能引用值不会改变的变量</span></a></h5></blockquote><p>原因：因为如果在lambda表达式中改变变量，并发执行多个动作时就会不安全</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 例如，下面的写法是不合法的</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
    <span class="token punctuation">{</span>
        start<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 错误: 不能修改捕获的变量</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> lestener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><h5 id="_2-不能引用可能在外部被改变的变量" tabindex="-1"><a class="header-anchor" href="#_2-不能引用可能在外部被改变的变量"><span>② 不能引用可能在外部被改变的变量</span></a></h5></blockquote><p>如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的</p><p>lambda表达式中捕获的变量必须实际上是<strong>最终变量（effectively final）</strong>。最终变量是指：这个变量初始化之后就不会再为它赋新值</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 例如，下面的写法是不合法的</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
        <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">&quot;: &quot;</span><span class="token operator">+</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 报错：不能引用可能被在外部改变的变量</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><h5 id="_3-不能声明同名变量" tabindex="-1"><a class="header-anchor" href="#_3-不能声明同名变量"><span>③ 不能声明同名变量</span></a></h5></blockquote><p>在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的</p><p>这里同样适用命名冲突和遮蔽的有关规则</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 例如，下面的写法是不合法的</span>
<span class="token class-name">Path</span> first <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/usr/bin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span> 
    <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错：变量“first”已经被定义过了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><h5 id="_4-this的含义" tabindex="-1"><a class="header-anchor" href="#_4-this的含义"><span>④ this的含义</span></a></h5></blockquote><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数 这点有点像 js 箭头函数中 this 的使用</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 这里的this.toString()</span>
            <span class="token comment">// 会调用Application对象的toString方法，而不是ActionListener实例的方法</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="与c-不同-闭包与变量捕获" tabindex="-1"><a class="header-anchor" href="#与c-不同-闭包与变量捕获"><span><mark>与C++不同</mark>（闭包与变量捕获）</span></a></h3><p>首先，**闭包 (closure）**是什么？</p>`,143),d=n("p",null,"参考：",-1),r={href:"https://zh.m.wikipedia.org/zh-hans/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)",target:"_blank",rel:"noopener noreferrer"},k={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures",target:"_blank",rel:"noopener noreferrer"},v={href:"https://baike.baidu.com/item/%E9%97%AD%E5%8C%85/10908873?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},m=e("<p>百度百科解释：</p><p>**（功能上.）**闭包就是能够读取其他函数内部变量的函数。</p><p>**（使用上.）**例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。</p><p>**（本质上.）**在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><hr><p>mozilla解释：</p><p>**（组成上.）**闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。</p><p>**（功能上.）**换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。</p><p>**（使用上.）**在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p><hr><p>Wiki：</p><p><strong>（概念上.）<strong>在计算机科学中，<strong>闭包（Closure）</strong>，又称</strong>词法闭包（Lexical Closure）<strong>或</strong>函数闭包（function closures）</strong>。 是在支持头等函数的编程语言中实现词法绑定的一种技术。</p><p><strong>（组成/实现上.）<strong>闭包是一个结构体，它存储了一个</strong>函数</strong>（通常是其入口地址）和一个关联的<strong>环境</strong>（相当于一个符号查找表）。 环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。</p><p>**（语言上.）**最早实现闭包的程序语言是Scheme。 之后，闭包被广泛使用于函数式编程语言 (如ML语言和LISP)，很多命令式程序语言也开始支持闭包。</p><p>**（区分闭包和　函数　.）**它们最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。 捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）。</p><p>**（区分闭包和匿名函数.）**它们经常被用作同义词。但严格来说，匿名函数就是字面意义上没有被赋予名称的函数，而闭包则实际上是一个函数的实例，也就是说它是存在于内存里的某个结构体。</p>",16),b=e(`<p>各种语言中（类似）闭包的结构</p><ul><li><h4 id="c语言" tabindex="-1"><a class="header-anchor" href="#c语言"><span>C语言</span></a></h4><ul><li><p>C语言的回调函数</p><blockquote><p>在C语言中，支持回调函数的库有时在注册时需要两个参数：一个函数指针，一个独立的<code>void*</code>指针用以保存用户数据。 这样的做法允许回调函数恢复其调用时的状态。这样的惯用法在功能上类似于闭包，但语法上有所不同。</p></blockquote></li><li><p>gcc对C语言的扩展</p><blockquote><p>gcc编译器对C语言实现了一种闭包的程序特性。</p></blockquote></li><li><p>C语言扩展：Blocks</p><blockquote><p>略</p></blockquote></li></ul></li><li><h4 id="c-函数对象" tabindex="-1"><a class="header-anchor" href="#c-函数对象"><span>C++函数对象</span></a></h4><ul><li><p>早期标准</p><blockquote><p>早期标准允许通过重载<code>operator()</code>来定义函数对象。这种对象的行为在某种程度上与函数式编程语言中的函数类似。</p><p>它们可以在运行时动态创建、保存状态，但是不能如闭包一般方便地隐式获取局部变量，并且有“专物专用”的繁琐问题——对于每一段闭包代码都要单独写一个函数对象类。</p></blockquote></li><li><p>C++11</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// C++11标准已经支持了闭包，这是一种特殊的函数对象，由特殊的语言结构——lambda表达式自动构建
void foo(string myname) {
	typedef vector&lt;string&gt; names;
	int y;
	names n;
	// ...
	names::iterator i =
	 find_if(n.begin(), n.end(), [&amp;](const string&amp; s){return s != myname &amp;&amp; s.size() &gt; y;});	
	// &#39;i&#39; 现在是&#39;n.end()&#39;或指向&#39;n&#39;中第一个
	// 不等于&#39;myname&#39;且长度大于&#39;y&#39;的字符串
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><h4 id="java-1" tabindex="-1"><a class="header-anchor" href="#java-1"><span>Java</span></a></h4><ul><li><p>Java SE 8 引入Lambda，可以用Lambda来实现闭包</p></li><li><p>注意事项</p><ul><li>① 只能引用值不会改变的变量</li><li>② 不能引用可能在外部被改变的变量</li><li>③ 不能声明同名变量</li><li>④ this的含义</li></ul></li><li><p>代码举例</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 这里捕获了text变量。不怕函数结束时该变量被销毁</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印：Hello every 1,000 milliseconds</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><h4 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript"><span>JavaScript</span></a></h4><ul><li><p>JavaScript 在闭包上要简单许多 Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量 JavaScript 变量可以是局部变量或全局变量。私有变量可以用到闭包。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 实例1，a 是一个 局部 变量</span>
<span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实例2，a 是一个 全局 变量</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="处理lambda表达式" tabindex="-1"><a class="header-anchor" href="#处理lambda表达式"><span>处理Lambda表达式</span></a></h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h3><p>使用lambda表达式的重点是<strong>延迟执行（deferred execution）</strong> 毕竟，如果想要立即执行代码，完全可以直接执行，而无需把它包装在一个lambda表达式中</p><h3 id="写法" tabindex="-1"><a class="header-anchor" href="#写法"><span>写法</span></a></h3><p>① 写法（使用默认的函数式接口：Runnable）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 【目的】</span>
<span class="token comment">// 假设你想要重复一个动作n次</span>

<span class="token comment">// 【方法定义】</span>
<span class="token comment">// 要接受这个lambda表达式，需要选择（偶尔可能需要提供）一个函数式接口</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> action<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> action<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用 action.run() 时会执行这个lambda</span>
<span class="token punctuation">}</span>

<span class="token comment">// 【调用】</span>
<span class="token comment">// 将这个动作和重复次数传递到一个repeat方法：</span>
<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>② 改进版本（使用自定义的函数式接口：IntConsumer）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 【目的】</span>
<span class="token comment">// 现在让这个例子更复杂一些。我们希望告诉这个动作它出现在哪一次迭代中。</span>

<span class="token comment">// 【函数式接口定义】</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IntConsumer</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 【方法定义】</span>
<span class="token comment">// 这里使用函数式接口：IntConsumer</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">IntConsumer</span> action<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 【调用】</span>
<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> i <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Countdown: &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常用函数式接口" tabindex="-1"><a class="header-anchor" href="#常用函数式接口"><span>常用函数式接口</span></a></h3><h4 id="常用函数式接口-表一" tabindex="-1"><a class="header-anchor" href="#常用函数式接口-表一"><span>常用函数式接口（表一）</span></a></h4><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>抽象方法名</th><th>描述</th><th>其他方法</th></tr></thead><tbody><tr><td><code>Runnable</code></td><td>none</td><td>void</td><td>run</td><td><strong>作为无参数或返回值的动作运行</strong></td><td></td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td>none</td><td>T</td><td>get</td><td>提供一个T类型的值</td><td></td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td>T</td><td>void</td><td>accept</td><td><strong>处理一个T类型的值</strong></td><td>andThen</td></tr><tr><td><code>BiConsumer&lt;T, U&gt;</code></td><td>T, U</td><td>void</td><td>accept</td><td><strong>处理T和U类型的值</strong></td><td>andThen</td></tr><tr><td><code>Function&lt;T, R&gt;</code></td><td>T</td><td>R</td><td>apply</td><td>有一个T类型参数的函数</td><td>compose, andThen, identity</td></tr><tr><td><code>BiFunction&lt;T, U, R&gt;</code></td><td>T, U</td><td>R</td><td>apply</td><td>有T和U类型参数的函数</td><td>andThen</td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td>T</td><td>T</td><td>apply</td><td>类型T上的一元操作符</td><td>compose, andThen, identity</td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td>T, T</td><td>T</td><td>apply</td><td>类型T上的二元操作符</td><td>andThen, maxBy, minBy</td></tr><tr><td><code>Predicate&lt;T&gt;</code></td><td>T</td><td>boolean</td><td>test</td><td><strong>布尔值函数</strong></td><td>and, or ,negate, isEqual</td></tr><tr><td><code>BiPredicate&lt;T, U&gt;</code></td><td>T, U</td><td>boolean</td><td>test</td><td>有两个参数的布尔值函数</td><td>and, or, negate</td></tr></tbody></table><h4 id="基本类型的函数式接口-表二" tabindex="-1"><a class="header-anchor" href="#基本类型的函数式接口-表二"><span>基本类型的函数式接口（表二）</span></a></h4><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>抽象方法名</th><th>描述-------------------------------------------------------------------------------------</th></tr></thead><tbody><tr><td>BooleanSupplier</td><td>none</td><td>boolean</td><td>getAsBoolean</td><td></td></tr><tr><td>PSupplier</td><td>none</td><td>p</td><td>getAsP</td><td></td></tr><tr><td><strong>PConsumer</strong></td><td>p</td><td>void</td><td>accept</td><td></td></tr><tr><td><code>ObjPConsumer&lt;T&gt;</code></td><td>T, p</td><td>void</td><td>accept</td><td></td></tr><tr><td><code>PFunction&lt;T&gt;</code></td><td>p</td><td>T</td><td>apply</td><td></td></tr><tr><td>PToQFunction</td><td>p</td><td>q</td><td>applyAsQ</td><td></td></tr><tr><td><code>ToPFunction&lt;T&gt;</code></td><td>T</td><td>p</td><td>applyAsP</td><td></td></tr><tr><td><code>ToPBiFunction&lt;T, U&gt;</code></td><td>T, U</td><td>P</td><td>applyAsP</td><td></td></tr><tr><td>PUnaryOperator</td><td>p</td><td>P</td><td>applyAsP</td><td></td></tr><tr><td>PBinaryOperator</td><td>p, p</td><td>P</td><td>applyAsP</td><td></td></tr><tr><td>PPredicate</td><td>p</td><td>boolean</td><td>test</td><td></td></tr></tbody></table><p>注：p，q为int，long，double；P，Q为Int，Long，Double</p><h4 id="常用函数式接口的注意要点" tabindex="-1"><a class="header-anchor" href="#常用函数式接口的注意要点"><span>常用函数式接口的注意要点</span></a></h4><blockquote><h5 id="使用优先级" tabindex="-1"><a class="header-anchor" href="#使用优先级"><span>使用优先级</span></a></h5></blockquote><p>① 最好优先使用上面表中的接口</p><p>例如：假设要编写一个方法来处理满足某个特定条件的文件。 虽然有一个遗留接口java.io.FileFilter，不过最好使用标准的 <code>Predicate&lt;File&gt;</code>。 只有一种情况下可以不这么做，那就是你已经有很多有用的方法可以生成FileFilter实例</p><p>② 最好优先使用表二的接口</p><p>使用特殊化规范来减少自动装箱（即使用下面的表二而不是表一） 出于这个原因，前面的例子中使用了<code>IntConsumer</code>而不是<code>Consumer&lt;Integer&gt;</code></p><blockquote><h5 id="非抽象方法来生成或合并函数" tabindex="-1"><a class="header-anchor" href="#非抽象方法来生成或合并函数"><span>非抽象方法来生成或合并函数</span></a></h5></blockquote><p>大多数标准函数式接口都提供了非抽象方法来生成或合并函数</p><p>生成函数，例如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Predicate</span><span class="token punctuation">.</span><span class="token function">isEqual</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token comment">// 等同于</span>
a<span class="token operator">::</span><span class="token function">equals</span>
<span class="token comment">// 不过如果a为null也能正常工作。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>合并函数，例如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 提供了默认方法 and、or和negate 来合并谓词</span>
<span class="token class-name">Predicate</span><span class="token punctuation">.</span><span class="token function">isEqual</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token punctuation">.</span><span class="token function">isEqual</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 等同于</span>
x<span class="token operator">-&gt;</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">||</span>b<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><h5 id="functionalinterface-注解" tabindex="-1"><a class="header-anchor" href="#functionalinterface-注解"><span>@FunctionalInterface 注解</span></a></h5></blockquote><p>如果设计你自己的接口，其中只有一个抽象方法，可以用<code>@FunctionalInterface</code>注解来标记这个接口。</p><p>这样做有两个优点</p><p>① 如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息</p><p>② 另外javadoc页里会指出你的接口是一个函数式接口。</p><p>并不是必须使用注解。根据定义，任何有一个抽象方法的接口都是函数式接口。不过使用@FunctionalInterface注解确实是一个很好的做法</p><h2 id="实例-再谈comparator" tabindex="-1"><a class="header-anchor" href="#实例-再谈comparator"><span>实例 - 再谈Comparator</span></a></h2><p>Comparator接口包含很多方便的静态方法<strong>来创建比较器</strong>。这些方法可以用于lambda表达式或方法引用。</p><h3 id="静态comparing方法" tabindex="-1"><a class="header-anchor" href="#静态comparing方法"><span>静态comparing方法</span></a></h3><p>可以取一个“键提取器”函数，它将类型T映射为一个可比较的类型（如String）。</p><p>对要比较的对象应用这个函数，然后对返回的键完成比较。</p><h3 id="代码举例" tabindex="-1"><a class="header-anchor" href="#代码举例"><span>代码举例</span></a></h3><p>假设有一个Person对象数组</p><p>可以按名字对这些对象排序：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>
    people<span class="token punctuation">,</span>
    <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span>	<span class="token comment">// 与手动实现一个Comparator相比，这当然要容易得多。</span>
											<span class="token comment">// 另外，代码也更为清晰，因为显然我们都希望按人名来进行比较。</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以先比较姓再比较名：（把比较器与thenComparing方法串起来实现）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>sort
<span class="token punctuation">(</span>
    people<span class="token punctuation">,</span>
    <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getLastName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getFirstName</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果两个人的姓相同，就会使用第二个比较器</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以根据人名长度完成排序：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>sort
<span class="token punctuation">(</span>
    people<span class="token punctuation">,</span>
    <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>
        <span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span> 
        <span class="token punctuation">(</span>s<span class="token punctuation">,</span>t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码还有一种更容易的做法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>sort
<span class="token punctuation">(</span>
    people<span class="token punctuation">,</span>
    <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按可能为null的中名进行排序：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 如果键函数可以返回null，可能就要用到nullsFirst和nullsLast适配器</span>
<span class="token comment">// 原理：这些静态方法会修改现有的比较器，从而在遇到null值时不会抛出异常，而是将这个值标记为小于或大于正常值。</span>
<span class="token comment">// 例如，假设一个人没有中名时getMiddleName会返回一个null，就可以使用</span>
<span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getMiddleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">nullsFirst</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
<span class="token comment">// 下面是一个完整的调用，可以按可能为null的中名进行排序。</span>
<span class="token comment">// 这里使用了一个静态导入java.util.Comparator.*，以便理解这个表达式</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>sort
<span class="token punctuation">(</span>
    people<span class="token punctuation">,</span>
    <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getMiddleName</span><span class="token punctuation">,</span> <span class="token function">nullsFirst</span><span class="token punctuation">(</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他</p><p>静态reverseOrder方法会提供自然顺序的逆序。要让比较器逆序比较，可以使用reversed实例方法。</p><p>例如 <code>naturalOrder().reversed()</code> 等同于 <code>reverseOrder()</code></p>`,54);function h(g,f){const a=c("ExternalLinkIcon");return o(),l("div",null,[u,n("blockquote",null,[d,n("ul",null,[n("li",null,[n("a",r,[s("【Wiki】闭包 (计算机科学)"),t(a)])]),n("li",null,[n("a",k,[s("【Mozilla】闭包"),t(a)])]),n("li",null,[n("a",v,[s("【百度百科】闭包"),t(a)])])]),m]),b])}const x=p(i,[["render",h],["__file","01. 函数传递.html.vue"]]),w=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/05.%20%E5%B0%81%E8%A3%85/01.%20%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92.html","title":"Java","lang":"zh-CN","frontmatter":{"description":"Java 目录 函数传递 “函数指针传递” 的方式（Java） 有几种方法 ① 接口方法 例如通过实现接口的方式，本质是传递一个实现了接口的类 举两个例子： ① 接口实现：事件监听器 ② 接口实现：比较器 compare方法不是立即调用。实际上，在数组完成排序之前，sort方法会一直调用compare方法 这两个例子有一些共同点， 都是将一个代码块传递...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Java/05.%20%E5%B0%81%E8%A3%85/01.%20%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Java"}],["meta",{"property":"og:description","content":"Java 目录 函数传递 “函数指针传递” 的方式（Java） 有几种方法 ① 接口方法 例如通过实现接口的方式，本质是传递一个实现了接口的类 举两个例子： ① 接口实现：事件监听器 ② 接口实现：比较器 compare方法不是立即调用。实际上，在数组完成排序之前，sort方法会一直调用compare方法 这两个例子有一些共同点， 都是将一个代码块传递..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Java","slug":"java","link":"#java","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"函数传递","slug":"函数传递","link":"#函数传递","children":[{"level":2,"title":"“函数指针传递” 的方式（Java）","slug":"函数指针传递-的方式-java","link":"#函数指针传递-的方式-java","children":[{"level":3,"title":"① 接口方法","slug":"_1-接口方法","link":"#_1-接口方法","children":[]},{"level":3,"title":"② Lambda表达式","slug":"_2-lambda表达式","link":"#_2-lambda表达式","children":[]},{"level":3,"title":"③ 传递方法引用","slug":"_3-传递方法引用","link":"#_3-传递方法引用","children":[]},{"level":3,"title":"与C++不同（传递代码段的方式）","slug":"与c-不同-传递代码段的方式","link":"#与c-不同-传递代码段的方式","children":[]}]},{"level":2,"title":"Lambda表达式（Java SE 8）","slug":"lambda表达式-java-se-8","link":"#lambda表达式-java-se-8","children":[{"level":3,"title":"定义方法","slug":"定义方法","link":"#定义方法","children":[]},{"level":3,"title":"使用举例","slug":"使用举例","link":"#使用举例","children":[]},{"level":3,"title":"与C++不同（概念上）","slug":"与c-不同-概念上","link":"#与c-不同-概念上","children":[]},{"level":3,"title":"与C++不同（写法上）","slug":"与c-不同-写法上","link":"#与c-不同-写法上","children":[]}]},{"level":2,"title":"函数式接口 (Functional Interface)","slug":"函数式接口-functional-interface","link":"#函数式接口-functional-interface","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"几个概念的区别","slug":"几个概念的区别","link":"#几个概念的区别","children":[]},{"level":3,"title":"使用举例","slug":"使用举例-1","link":"#使用举例-1","children":[{"level":4,"title":"举例：Arrays.sort()方法","slug":"举例-arrays-sort-方法","link":"#举例-arrays-sort-方法","children":[]},{"level":4,"title":"举例：Timer定时器","slug":"举例-timer定时器","link":"#举例-timer定时器","children":[]}]},{"level":3,"title":"Java库举例","slug":"java库举例","link":"#java库举例","children":[{"level":4,"title":"BiFunction，保存Lambda表达式到变量","slug":"bifunction-保存lambda表达式到变量","link":"#bifunction-保存lambda表达式到变量","children":[]},{"level":4,"title":"Predicate","slug":"predicate","link":"#predicate","children":[]}]}]},{"level":2,"title":"方法引用（Method Reference）","slug":"方法引用-method-reference","link":"#方法引用-method-reference","children":[{"level":3,"title":"使用举例","slug":"使用举例-2","link":"#使用举例-2","children":[{"level":4,"title":"举例：Timer定时器","slug":"举例-timer定时器-1","link":"#举例-timer定时器-1","children":[]},{"level":4,"title":"举例：Arrays.sort()方法","slug":"举例-arrays-sort-方法-1","link":"#举例-arrays-sort-方法-1","children":[]}]},{"level":3,"title":"其他补充","slug":"其他补充","link":"#其他补充","children":[{"level":4,"title":"等价的Lambda表达式","slug":"等价的lambda表达式","link":"#等价的lambda表达式","children":[]},{"level":4,"title":"函数重载问题","slug":"函数重载问题","link":"#函数重载问题","children":[]},{"level":4,"title":"::操作符小总结","slug":"操作符小总结","link":"#操作符小总结","children":[]},{"level":4,"title":"结合this/super参数","slug":"结合this-super参数","link":"#结合this-super参数","children":[]}]}]},{"level":2,"title":"构造器引用（Construct Reference）","slug":"构造器引用-construct-reference","link":"#构造器引用-construct-reference","children":[{"level":3,"title":"使用举例","slug":"使用举例-3","link":"#使用举例-3","children":[]},{"level":3,"title":"其他补充","slug":"其他补充-1","link":"#其他补充-1","children":[{"level":4,"title":"等价的Lambda表达式","slug":"等价的lambda表达式-1","link":"#等价的lambda表达式-1","children":[]},{"level":4,"title":"函数重载问题","slug":"函数重载问题-1","link":"#函数重载问题-1","children":[]},{"level":4,"title":"妙用：构造泛型类型T的数组","slug":"妙用-构造泛型类型t的数组","link":"#妙用-构造泛型类型t的数组","children":[]}]}]},{"level":2,"title":"闭包问题（Lambda变量作用域）","slug":"闭包问题-lambda变量作用域","link":"#闭包问题-lambda变量作用域","children":[{"level":3,"title":"写法 - 访问外部方法或变量","slug":"写法-访问外部方法或变量","link":"#写法-访问外部方法或变量","children":[]},{"level":3,"title":"原理 - Lambda如何保留变量？","slug":"原理-lambda如何保留变量","link":"#原理-lambda如何保留变量","children":[]},{"level":3,"title":"写法限制","slug":"写法限制","link":"#写法限制","children":[]},{"level":3,"title":"与C++不同（闭包与变量捕获）","slug":"与c-不同-闭包与变量捕获","link":"#与c-不同-闭包与变量捕获","children":[]}]},{"level":2,"title":"处理Lambda表达式","slug":"处理lambda表达式","link":"#处理lambda表达式","children":[{"level":3,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":3,"title":"写法","slug":"写法","link":"#写法","children":[]},{"level":3,"title":"常用函数式接口","slug":"常用函数式接口","link":"#常用函数式接口","children":[{"level":4,"title":"常用函数式接口（表一）","slug":"常用函数式接口-表一","link":"#常用函数式接口-表一","children":[]},{"level":4,"title":"基本类型的函数式接口（表二）","slug":"基本类型的函数式接口-表二","link":"#基本类型的函数式接口-表二","children":[]},{"level":4,"title":"常用函数式接口的注意要点","slug":"常用函数式接口的注意要点","link":"#常用函数式接口的注意要点","children":[]}]}]},{"level":2,"title":"实例 - 再谈Comparator","slug":"实例-再谈comparator","link":"#实例-再谈comparator","children":[{"level":3,"title":"静态comparing方法","slug":"静态comparing方法","link":"#静态comparing方法","children":[]},{"level":3,"title":"代码举例","slug":"代码举例","link":"#代码举例","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":23.69,"words":7106},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Java/05. 封装/01. 函数传递.md","autoDesc":true}');export{x as comp,w as data};
