import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as p,c as d,a as n,d as l,b as a,e as s}from"./app-DtBZtuIa.js";const o={},c=s('<h1 id="dll-compiled-by-all-language" tabindex="-1"><a class="header-anchor" href="#dll-compiled-by-all-language"><span>DLL Compiled By All Language</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="python-dll-use" tabindex="-1"><a class="header-anchor" href="#python-dll-use"><span>Python_Dll_Use</span></a></h1><p>参考：</p>',4),r={href:"https://blog.csdn.net/lf8289/article/details/2322550",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.cnblogs.com/baihuitestsoftware/articles/5345089.html",target:"_blank",rel:"noopener noreferrer"},h=s(`<h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="ctypes模块" tabindex="-1"><a class="header-anchor" href="#ctypes模块"><span>ctypes模块</span></a></h3><p>调用约定：加载的时候要根据你将要调用的函数是符合什么调用约定的。</p><p>stdcall调用约定：两种加载方式</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>Objdll <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>windll<span class="token punctuation">.</span>LoadLibrary<span class="token punctuation">(</span><span class="token string">&quot;dllpath&quot;</span><span class="token punctuation">)</span> 
Objdll <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>WinDLL<span class="token punctuation">(</span><span class="token string">&quot;dllpath&quot;</span><span class="token punctuation">)</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>cdecl调用约定：也有两种加载方式</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>Objdll <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>cdll<span class="token punctuation">.</span>LoadLibrary<span class="token punctuation">(</span><span class="token string">&quot;dllpath&quot;</span><span class="token punctuation">)</span> 
Objdll <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>CDLL<span class="token punctuation">(</span><span class="token string">&quot;dllpath&quot;</span><span class="token punctuation">)</span> 
<span class="token operator">/</span><span class="token operator">*</span>其实windll和cdll分别是WinDLL类和CDll类的对象。<span class="token operator">*</span><span class="token operator">/</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加载dll的时候会返回一个DLL对象，利用该对象就可以调用dll中的方法</p><h3 id="注意python位数" tabindex="-1"><a class="header-anchor" href="#注意python位数"><span>注意Python位数</span></a></h3><p>可使用IDLE或者CMD查看</p><ul><li><p>打开IDLE,看第一行提示</p><p>例如64位（**不要看win32，看MSC后面的！**被坑过一次了）： Python 3.7.8 (tags/v3.7.8:4b47a5b6ba, Jun 28 2020, 08:53:46) [MSC v.1916 <strong>64 bit</strong> (<strong>AMD64</strong>)] on <s>win32</s></p></li><li><p>CMD，输入python。也会显示上述命令</p></li></ul><p>要编译与之对应的dll位数</p><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h2><h3 id="参考案例" tabindex="-1"><a class="header-anchor" href="#参考案例"><span>参考案例</span></a></h3><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span>  ctypes
dll  <span class="token operator">=</span>  ctypes<span class="token punctuation">.</span>windll<span class="token punctuation">.</span>LoadLibrary<span class="token punctuation">(</span> <span class="token string">&#39;test.dll&#39;</span><span class="token punctuation">)</span>
<span class="token comment"># 或 dll  =  ctypes.WinDll(&#39;test.dll&#39;)</span>
<span class="token comment"># 然后通过dll对象调用dll文件</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用之前开发的cpp-dll" tabindex="-1"><a class="header-anchor" href="#使用之前开发的cpp-dll"><span>使用之前开发的cpp_dll</span></a></h3><p>（注意位数要对应）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>import ctypes
dll  =  ctypes.windll.LoadLibrary( &#39;Dll1.dll&#39;)

# nRst = dll.fibonacci_current(5)
dll.fibonacci_init(1,1);
for i in range(50):
    print(str(dll.fibonacci_index())+&quot;:&quot;+str(dll.fibonacci_current()))
    dll.fibonacci_next();

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>体外话：</p><p>原c程序是返回unsigned long long类型，python3没有long类型（python2有），python3中int类型是动态内存，理论支持无限大的数字</p><p>这个dll在cpp程序中被调用时，能打印到：92: 12200160415121876738，93溢出了</p><p>而在python中被调用时，能打印到：45:1836311903，46:-1323752223，46溢出变为负数。也就是说，python在使用dll时返回类型是个4字节的signed int？</p><p>个人猜测长整型可能需要使用字符串来传递</p><h2 id="bug逐步调试" tabindex="-1"><a class="header-anchor" href="#bug逐步调试"><span>Bug逐步调试</span></a></h2><p>如果出bug的话非常麻烦，建议一步一步来检查</p><h3 id="c语言对python环境的链接" tabindex="-1"><a class="header-anchor" href="#c语言对python环境的链接"><span>C语言对python环境的链接</span></a></h3><p>这个测试和C++调用Python程序的测试也是一样的</p><p>pythonIniti.c</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &quot;stdafx.h&quot;
#include &lt;python.h&gt;

int main()
{
    Py_Initialize();  //调用Py_Initialize()进行初始化
    PyRun_SimpleString(&quot;print(&#39;Hello World!!&#39;)&quot;);
    Py_Finalize(); //调用Py_Finalize，和Py_Initialize相对应的.
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="编译报错-无法解析的外部符号" tabindex="-1"><a class="header-anchor" href="#编译报错-无法解析的外部符号"><span>编译报错：无法解析的外部符号</span></a></h4><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>pythonIniti.obj <span class="token builtin class-name">:</span> error LNK2019: 无法解析的外部符号 __imp___Py_NegativeRefcount，该符号在函数 <span class="token string">&quot;public: __thiscall boost::python::api::object_base::~object_base(void)&quot;</span> <span class="token punctuation">(</span>??1object_base@api@python@boost@@QAE@XZ<span class="token punctuation">)</span> 中被引用
pythonIniti.obj <span class="token builtin class-name">:</span> error LNK2001: 无法解析的外部符号 __imp___Py_RefTotal
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法忘了</p><h4 id="运行报错-有未经处理的异常-请求了严重的程序退出" tabindex="-1"><a class="header-anchor" href="#运行报错-有未经处理的异常-请求了严重的程序退出"><span>运行报错：有未经处理的异常: 请求了严重的程序退出</span></a></h4><p>执行到<code>Py_Initialize()</code>时报错： 0x00007FFE0337286E (ucrtbase.dll) (c_testdll.exe 中)处有未经处理的异常: 请求了严重的程序退出。</p><p>和之前在QT用c++调用Python环境崩溃是同一个问题，解决方法如下</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>/* 不加则运行时崩溃：
 * initfsencoding: unable to load the file system codec
 * 参考：https://www.cnblogs.com/2008nmj/p/8027430.html
 * 两个方法:
 * 一个就是补全python的环境变量。但不知道为什么我的环境变量设置没用，还是报错
 * 另一个就是手动设置初始化函数的搜寻路径(也就是加载路径)
 */
Py_SetPythonHome(L&quot;D:\\\\Soft\\\\Dev\\\\All\\\\Python_Anaconda&quot;); // 方法二
/** Python系统初始化 */
Py_Initialize();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="编译报错-无法打开pyconfig-h" tabindex="-1"><a class="header-anchor" href="#编译报错-无法打开pyconfig-h"><span>编译报错：无法打开pyconfig.h</span></a></h4><p>对比了一下我下载的Python源码的Include文件和Anaconda目录下的Include文件</p><p>发现前者比后者少了5个项目（分别是101和106个项目）</p><ul><li>文件夹 greenlet</li><li>文件夹 LIEF</li><li>json.hpp，578KB</li><li>pyconfig.h，20KB</li><li>sip.h，68KB</li></ul><blockquote><p>1249,623-569,289 = 591,107+20,054+69,143+(30) 应该还有一个文件是不同的，但只相差30B太难要判断是哪个文件有区别太困难了，而且没意义，应该就是修bug了</p></blockquote><p>结论：用Anaconda的那个就行，32/64位，debug和release都是用的同一个Include文件夹</p><h4 id="编译报错-lnk2019无法解析的外部符号-imp-py-initialize-函数-main-中引用了该符号" tabindex="-1"><a class="header-anchor" href="#编译报错-lnk2019无法解析的外部符号-imp-py-initialize-函数-main-中引用了该符号"><span>编译报错：LNK2019 无法解析的外部符号 <code>__imp__Py_Initialize</code>，函数 _main 中引用了该符号</span></a></h4><p>这是由于调用的python版本与活动解决方案平台的版本不一致导致的</p><p>将项目设置 &gt; 包含库设置为32位的python37.lib所在的路径即可</p><p>重新生成解决方案会得到下面的报错</p><h4 id="运行弹窗-程序应用无法正常启动0xc000007b。请点击确定关闭程序" tabindex="-1"><a class="header-anchor" href="#运行弹窗-程序应用无法正常启动0xc000007b。请点击确定关闭程序"><span>运行弹窗：程序应用无法正常启动0xc000007b。请点击确定关闭程序</span></a></h4><p>debug/x64、release/x64 都能运行但 debug/x86、release/x86 不能运行</p><p>然后报错前最后一个加载的dll为： debug： C:\\Windows\\SysWOW64\\msvcp140d.dll release：C:\\Windows\\SysWOW64\\ucrtbase.dll</p><blockquote><h5 id="尝试1-——-替换dll文件" tabindex="-1"><a class="header-anchor" href="#尝试1-——-替换dll文件"><span>尝试1 —— 替换dll文件</span></a></h5></blockquote><p>刚开始参考了https://blog.csdn.net/kone0611/article/details/79238139，把这个dll文件换成了下面这两个位置的文件 D:\\Soft\\Dev\\All\\Edit_Microsoft_VS\\IDE\\VC\\Redist\\MSVC\\14.28.29325\\onecore\\debug_nonredist\\x86\\Microsoft.VC142.DebugCRT D:\\Soft\\Dev\\All\\Edit_Microsoft_VS\\IDE\\VC\\Redist\\MSVC\\14.28.29325\\debug_nonredist\\x86\\Microsoft.VC142.DebugCRT 但没有解决</p><blockquote><h5 id="尝试2-——-查看dll位数" tabindex="-1"><a class="header-anchor" href="#尝试2-——-查看dll位数"><span>尝试2 —— 查看dll位数</span></a></h5></blockquote><p>参考https://blog.csdn.net/qq_41350775/article/details/119935088</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>dumpbin /headers C:<span class="token punctuation">\\</span>Windows<span class="token punctuation">\\</span>SysWOW64<span class="token punctuation">\\</span>msvcp140d.dll  <span class="token comment"># x86</span>
dumpbin /headers C:<span class="token punctuation">\\</span>Windows<span class="token punctuation">\\</span>SysWOW64<span class="token punctuation">\\</span>ucrtbase.dll	<span class="token comment"># x86</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>都是32位的，没有解决问题</p><p>尚未修复</p><h3 id="生成的c语言文件是否能运行" tabindex="-1"><a class="header-anchor" href="#生成的c语言文件是否能运行"><span>生成的C语言文件是否能运行</span></a></h3><h3 id="调用dll" tabindex="-1"><a class="header-anchor" href="#调用dll"><span>调用DLL</span></a></h3><h4 id="运行错误-无法找到指定dll库文件-中的输出命令" tabindex="-1"><a class="header-anchor" href="#运行错误-无法找到指定dll库文件-中的输出命令"><span>运行错误：无法找到指定DLL库文件...中的输出命令...</span></a></h4><p>先检查前面的有没有错，不要嫌麻烦、多建个工程用一下这个dll。首先要排除DLL文件是否出错</p>`,60);function b(v,m){const e=t("ExternalLinkIcon");return p(),d("div",null,[c,n("ul",null,[n("li",null,[n("a",r,[l("【CSDN】python调用dll方法"),a(e)])]),n("li",null,[n("a",u,[l("【博客园】Python调用windows下DLL详解 - ctypes库的使用"),a(e)])])]),h])}const _=i(o,[["render",b],["__file","Python_Dll_Use.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Type/DLL/DLL%20Compiled%20By%20All%20Language/Python_Dll_Use.html","title":"DLL Compiled By All Language","lang":"zh-CN","frontmatter":{"description":"DLL Compiled By All Language 目录 Python_Dll_Use 参考： 【CSDN】python调用dll方法 【博客园】Python调用windows下DLL详解 - ctypes库的使用 原理 ctypes模块 调用约定：加载的时候要根据你将要调用的函数是符合什么调用约定的。 stdcall调用约定：两种加载方式 cd...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Type/DLL/DLL%20Compiled%20By%20All%20Language/Python_Dll_Use.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"DLL Compiled By All Language"}],["meta",{"property":"og:description","content":"DLL Compiled By All Language 目录 Python_Dll_Use 参考： 【CSDN】python调用dll方法 【博客园】Python调用windows下DLL详解 - ctypes库的使用 原理 ctypes模块 调用约定：加载的时候要根据你将要调用的函数是符合什么调用约定的。 stdcall调用约定：两种加载方式 cd..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"DLL Compiled By All Language\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"DLL Compiled By All Language","slug":"dll-compiled-by-all-language","link":"#dll-compiled-by-all-language","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"Python_Dll_Use","slug":"python-dll-use","link":"#python-dll-use","children":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"ctypes模块","slug":"ctypes模块","link":"#ctypes模块","children":[]},{"level":3,"title":"注意Python位数","slug":"注意python位数","link":"#注意python位数","children":[]}]},{"level":2,"title":"使用","slug":"使用","link":"#使用","children":[{"level":3,"title":"参考案例","slug":"参考案例","link":"#参考案例","children":[]},{"level":3,"title":"使用之前开发的cpp_dll","slug":"使用之前开发的cpp-dll","link":"#使用之前开发的cpp-dll","children":[]}]},{"level":2,"title":"Bug逐步调试","slug":"bug逐步调试","link":"#bug逐步调试","children":[{"level":3,"title":"C语言对python环境的链接","slug":"c语言对python环境的链接","link":"#c语言对python环境的链接","children":[{"level":4,"title":"编译报错：无法解析的外部符号","slug":"编译报错-无法解析的外部符号","link":"#编译报错-无法解析的外部符号","children":[]},{"level":4,"title":"运行报错：有未经处理的异常: 请求了严重的程序退出","slug":"运行报错-有未经处理的异常-请求了严重的程序退出","link":"#运行报错-有未经处理的异常-请求了严重的程序退出","children":[]},{"level":4,"title":"编译报错：无法打开pyconfig.h","slug":"编译报错-无法打开pyconfig-h","link":"#编译报错-无法打开pyconfig-h","children":[]},{"level":4,"title":"编译报错：LNK2019\\t无法解析的外部符号 __imp__Py_Initialize，函数 _main 中引用了该符号","slug":"编译报错-lnk2019无法解析的外部符号-imp-py-initialize-函数-main-中引用了该符号","link":"#编译报错-lnk2019无法解析的外部符号-imp-py-initialize-函数-main-中引用了该符号","children":[]},{"level":4,"title":"运行弹窗：程序应用无法正常启动0xc000007b。请点击确定关闭程序","slug":"运行弹窗-程序应用无法正常启动0xc000007b。请点击确定关闭程序","link":"#运行弹窗-程序应用无法正常启动0xc000007b。请点击确定关闭程序","children":[]}]},{"level":3,"title":"生成的C语言文件是否能运行","slug":"生成的c语言文件是否能运行","link":"#生成的c语言文件是否能运行","children":[]},{"level":3,"title":"调用DLL","slug":"调用dll","link":"#调用dll","children":[{"level":4,"title":"运行错误：无法找到指定DLL库文件...中的输出命令...","slug":"运行错误-无法找到指定dll库文件-中的输出命令","link":"#运行错误-无法找到指定dll库文件-中的输出命令","children":[]}]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.21,"words":1263},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/04. Project/Type/DLL/DLL Compiled By All Language/Python_Dll_Use.md","autoDesc":true}');export{_ as comp,k as data};
