import{_ as e,c as s,e as t,o as a}from"./app-D9x9tU0e.js";const i={};function l(d,n){return a(),s("div",null,n[0]||(n[0]=[t(`<h3 id="为什么要初始化" tabindex="-1"><a class="header-anchor" href="#为什么要初始化"><span>为什么要初始化</span></a></h3><p>如果你这么写:</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>int x;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在某些语境下x保证被初始化(为0),但在其他语境中却不保证</p><p>而最佳处理办法就是:永远在使用对象之前先将它初始化。对于无任何成员的内置类型,你必须手工完成此事。例如:</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 								<span class="token comment">// 对int进行手工初始化</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> text <span class="token operator">=</span> <span class="token string">&quot;A C-style string&quot;</span><span class="token punctuation">;</span> 	<span class="token comment">// 对指针进行手工初始化</span>
										<span class="token comment">// 〔亦见条款3)</span>
<span class="token keyword">double</span> d<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> d<span class="token punctuation">;</span> 							<span class="token comment">// 以读取input stream的方式完成初始化.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="别混淆了赋值-assignment-和初始化-initialization" tabindex="-1"><a class="header-anchor" href="#别混淆了赋值-assignment-和初始化-initialization"><span>别混淆了赋值(assignment)和初始化(initialization)</span></a></h3><p>这个规则很容易奉行,重要的是别混淆了赋值(assignment)和初始化(initialization)。</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class PhoneNumber { ... };
class ABEntry { 			// ABEntry = “Address Book Entry”
public:
	ABEntry (const std::string&amp; name, const std::string&amp; address,
			 const std::list&lt;PhoneNumber&gt;&amp; phones);
private:
	std::string theName;
	std::string theAddress;
	std: :1ist&lt;PhoneNumber&gt; thePhones;
	int numTimesConsulted;
};
ABEntry::ABEntry (const std::string&amp; name, const std::string# address,
				  const std::list&lt;PhoneNumber&gt;&amp; phones)
{
    theName = name; 		// 这 些 都 是 赋 值 (assignments) ,
    theAddress = address; 	// 而 非 初 始 化 (initializations) 。
    thePhones = phones;
    numTimesConsulted = 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C++规定,对象的成员变量的初始化动作发生在进入构造函数本体之前前。在ABEntry构造函数内,theName,theaddress和thephones都不是被初始化,而是被赋值。初始化的发生时间更早。</p><p>ABEntry构造函数的一个较佳与法是,使用所谓的member initialization list (成员初值列) 替换赋值动作</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>RBEntry::RBEntfYy (const std::stringg name, const std::string&amp; address,
				   const std::1ist&lt;PhoneNumber&gt;8 phones)
	:theName (name) ,
    theAddress (address), 	// 现 在 , 这 些 都 是 初 始 化 (initializations)
    thePhones (phones),
    numTimesConsulted (0)
{ } // 现 在 , 构 造 函 数 本 体 不 必 有 任 何动 作
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>所以说，<strong>列表初始化</strong> 是真正的初始化，会在构造函数前发生。而构造函数内赋值，则只是<strong>赋值</strong>而已。</mark></p><p>假设RBEntry有一个光参数构造出数,我们可将它实现如下:</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>ABEntry::ABEntry()
	:theName () , // 调 用 theName 的 default 构 造 函 数 :
	theAddress () , // 为 theaddress 做 类 做 动 作 :
	thePhones () , // 为 thePhones 做 类 似 动 作 ;
	numTimesConsulted (0) // 记 得 将 numTimesConsul ted 显 式 初 始 化 为 0
{};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C++有着十分固定的“成员初始化次序“。是的,次序总是相同:baseclasses更早于其derivedclasses被初始化(见条款12),而class的成员变量总是以其声明次序被初始化。</p>`,16)]))}const o=e(i,[["render",l],["__file","04. 确定对象被使用前已先被初始化.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/08.%20C__%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E3%80%8AEffective%20C__%20%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E3%80%8B/01.%20%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC__/04.%20%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96.html","title":"","lang":"zh-CN","frontmatter":{"description":"为什么要初始化 如果你这么写: 在某些语境下x保证被初始化(为0),但在其他语境中却不保证 而最佳处理办法就是:永远在使用对象之前先将它初始化。对于无任何成员的内置类型,你必须手工完成此事。例如: 别混淆了赋值(assignment)和初始化(initialization) 这个规则很容易奉行,重要的是别混淆了赋值(assignment)和初始化(in...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/08.%20C__%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E3%80%8AEffective%20C__%20%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E3%80%8B/01.%20%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC__/04.%20%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:description","content":"为什么要初始化 如果你这么写: 在某些语境下x保证被初始化(为0),但在其他语境中却不保证 而最佳处理办法就是:永远在使用对象之前先将它初始化。对于无任何成员的内置类型,你必须手工完成此事。例如: 别混淆了赋值(assignment)和初始化(initialization) 这个规则很容易奉行,重要的是别混淆了赋值(assignment)和初始化(in..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":3,"title":"为什么要初始化","slug":"为什么要初始化","link":"#为什么要初始化","children":[]},{"level":3,"title":"别混淆了赋值(assignment)和初始化(initialization)","slug":"别混淆了赋值-assignment-和初始化-initialization","link":"#别混淆了赋值-assignment-和初始化-initialization","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.91,"words":572},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/08. C++高级编程/《Effective C++ 改善程序与设计的55个具体做法》/01. 让自己习惯C++/04. 确定对象被使用前已先被初始化.md","excerpt":"<h3>为什么要初始化</h3>\\n<p>如果你这么写:</p>\\n<div class=\\"language-c++\\" data-ext=\\"c++\\" data-title=\\"c++\\"><pre class=\\"language-c++\\"><code>int x;\\n</code></pre></div><p>在某些语境下x保证被初始化(为0),但在其他语境中却不保证</p>\\n<p>而最佳处理办法就是:永远在使用对象之前先将它初始化。对于无任何成员的内置类型,你必须手工完成此事。例如:</p>\\n<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">int</span> x <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span> \\t\\t\\t\\t\\t\\t\\t\\t<span class=\\"token comment\\">// 对int进行手工初始化</span>\\n<span class=\\"token keyword\\">const</span> <span class=\\"token keyword\\">char</span><span class=\\"token operator\\">*</span> text <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"A C-style string\\"</span><span class=\\"token punctuation\\">;</span> \\t<span class=\\"token comment\\">// 对指针进行手工初始化</span>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<span class=\\"token comment\\">// 〔亦见条款3)</span>\\n<span class=\\"token keyword\\">double</span> d<span class=\\"token punctuation\\">;</span>\\nstd<span class=\\"token double-colon punctuation\\">::</span>cin <span class=\\"token operator\\">&gt;&gt;</span> d<span class=\\"token punctuation\\">;</span> \\t\\t\\t\\t\\t\\t\\t<span class=\\"token comment\\">// 以读取input stream的方式完成初始化.</span>\\n</code></pre></div>","autoDesc":true}');export{o as comp,r as data};
