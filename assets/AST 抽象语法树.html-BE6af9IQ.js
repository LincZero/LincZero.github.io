import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as l,c,b as n,e as s,d as t,a as e}from"./app-IRYUHD7s.js";const i={},r=e('<h1 id="ast-抽象语法树" tabindex="-1"><a class="header-anchor" href="#ast-抽象语法树"><span>AST 抽象语法树</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="ast-抽象语法树-1" tabindex="-1"><a class="header-anchor" href="#ast-抽象语法树-1"><span>AST 抽象语法树</span></a></h1><h2 id="ast-abstract-syntax-tree-抽象语法树" tabindex="-1"><a class="header-anchor" href="#ast-abstract-syntax-tree-抽象语法树"><span>AST (Abstract Syntax Tree，抽象语法树)</span></a></h2><p>参考：</p>',5),u={href:"https://www.jianshu.com/p/6fa90ee14d0e",target:"_blank",rel:"noopener noreferrer"},d={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md",target:"_blank",rel:"noopener noreferrer"},k={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fblog.arvinh.info%2F2018%2F08%2F25%2Fvisit-ast-with-babel-plugin%2F",target:"_blank",rel:"noopener noreferrer"},h={href:"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.imooc.com%2Farticle%2F290884",target:"_blank",rel:"noopener noreferrer"},b=e(`<h3 id="什么是ast" tabindex="-1"><a class="header-anchor" href="#什么是ast"><span>什么是AST？</span></a></h3><p>AST (Abstract Syntax Tree，抽象语法树) ，是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。</p><p>它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型来区分，常见的类型有： Identifier(标识符)，BinaryExpression(二元表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。</p><p>AST是编译器看的。编译器会将源码转化成AST。如下源码:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">addA</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">addA</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会换转化成这样的AST:</p><p>![image-20221108155858091](AST 抽象语法树.assets/image-20221108155858091.png)</p><h3 id="ast-的使用场景" tabindex="-1"><a class="header-anchor" href="#ast-的使用场景"><span>AST 的使用场景？</span></a></h3><p><strong>TypeScript、babel、webpack、vue-cli</strong> 得都是依赖 AST 进行开发的。</p><p>通过AST，可以将代码转化后，再输出。比如：</p>`,10),m=n("li",null,"代码压缩。删除没用的空格，未使用的语句，变量名替换等。",-1),v=n("li",null,"代码高亮。",-1),_=n("li",null,"将 ES6 代码转换成 ES5 代码。",-1),g=n("li",null,[s("给 CSS 中的某些属性加浏览器前缀"),n("code",null,"-webkit-"),s("。")],-1),f=n("li",null,"将 CSS 中的px转化成rem。",-1),A={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fpro.ant.design%2Findex-cn",target:"_blank",rel:"noopener noreferrer"},F={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fumijs.org%2F",target:"_blank",rel:"noopener noreferrer"},T=n("h3",{id:"需要学习-ast-的哪些知识",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#需要学习-ast-的哪些知识"},[n("span",null,"需要学习 AST 的哪些知识？")])],-1),S=n("blockquote",null,[n("h5",{id:"了解ast常见节点的结构",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#了解ast常见节点的结构"},[n("span",null,"了解AST常见节点的结构")])])],-1),y={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmaster%2Fpackages%2Fbabel-parser%2Fast%2Fspec.md",target:"_blank",rel:"noopener noreferrer"},w=n("blockquote",null,[n("h5",{id:"源码解析",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#源码解析"},[n("span",null,"源码解析")])])],-1),x=n("p",null,"将源码转化为AST。该步骤分为词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。",-1),E={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-parser.html",target:"_blank",rel:"noopener noreferrer"},j={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabylon",target:"_blank",rel:"noopener noreferrer"},B=n("blockquote",null,[n("h5",{id:"转换",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#转换"},[n("span",null,"转换")])])],-1),N=n("p",null,"在遍历AST时，对指定的AST节点做新增，修改或删除操作。",-1),L={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-traverse.html",target:"_blank",rel:"noopener noreferrer"},M={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-types.html",target:"_blank",rel:"noopener noreferrer"},D={href:"https://www.jianshu.com/p/b66593151f0f",target:"_blank",rel:"noopener noreferrer"},C=n("blockquote",null,[n("h5",{id:"生成目标代码",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#生成目标代码"},[n("span",null,"生成目标代码")])])],-1),I=n("p",null,"将上一步转换过的AST，转化为目标代码，并生成源码映射（source maps）。",-1),P={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-generator.html",target:"_blank",rel:"noopener noreferrer"},R=n("h3",{id:"工具",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#工具"},[n("span",null,"工具")])],-1),V={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fastexplorer.net%2F",target:"_blank",rel:"noopener noreferrer"},q={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fresources.jointjs.com%2Fdemos%2Frappid%2Fapps%2FAst%2Findex.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbenjamn%2Frecast",target:"_blank",rel:"noopener noreferrer"},z={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-template.html",target:"_blank",rel:"noopener noreferrer"},G=n("h2",{id:"md解析原理-lute工具",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#md解析原理-lute工具"},[n("span",null,"Md解析原理（Lute工具）")])],-1),H={href:"https://88250.b3log.org/articles/2020/04/23/1587637426085.html",target:"_blank",rel:"noopener noreferrer"},J=n("h3",{id:"这篇文章中涉及的开源项目",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#这篇文章中涉及的开源项目"},[n("span",null,"这篇文章中涉及的开源项目")])],-1),Z={href:"https://github.com/commonmark/commonmark-spec",target:"_blank",rel:"noopener noreferrer"},U={href:"https://github.com/88250/lute",target:"_blank",rel:"noopener noreferrer"},K={href:"https://github.com/Vanessa219/vditor",target:"_blank",rel:"noopener noreferrer"},Q=e(`<h3 id="编译原理" tabindex="-1"><a class="header-anchor" href="#编译原理"><span>编译原理</span></a></h3><p>我们通过编译原理实现了 Lute ，大致步骤是 ① 预处理、② 词法分析、③ 语法分析、④ 代码生成 这几个步骤。</p><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h3><p>Lute 的使用</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Markdown 将 markdown 文本字节数组处理为相应的 html 字节数组。</span>
<span class="token comment">// name 参数仅用于标识文本，比如可传入 id 或者标题，也可以传入 &quot;&quot;。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>lute <span class="token operator">*</span>Lute<span class="token punctuation">)</span> <span class="token function">Markdown</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> markdown <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>html <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	tree <span class="token operator">:=</span> parse<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> markdown<span class="token punctuation">,</span> lute<span class="token punctuation">.</span>Options<span class="token punctuation">)</span>
	renderer <span class="token operator">:=</span> render<span class="token punctuation">.</span><span class="token function">NewHtmlRenderer</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span>
	html <span class="token operator">=</span> renderer<span class="token punctuation">.</span><span class="token function">Render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析过程用于从 Markdown 原文构造抽象语法树。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Parse 会将 markdown 原始文本字节数组解析为一颗语法树。</span>
<span class="token keyword">func</span> <span class="token function">Parse</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> markdown <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> options <span class="token operator">*</span>Options<span class="token punctuation">)</span> <span class="token punctuation">(</span>tree <span class="token operator">*</span>Tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	tree <span class="token operator">=</span> <span class="token operator">&amp;</span>Tree<span class="token punctuation">{</span>Name<span class="token punctuation">:</span> name<span class="token punctuation">,</span> Context<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Context<span class="token punctuation">{</span>Option<span class="token punctuation">:</span> options<span class="token punctuation">}</span><span class="token punctuation">}</span>
	tree<span class="token punctuation">.</span>Context<span class="token punctuation">.</span>Tree <span class="token operator">=</span> tree
	tree<span class="token punctuation">.</span>lexer <span class="token operator">=</span> lex<span class="token punctuation">.</span><span class="token function">NewLexer</span><span class="token punctuation">(</span>markdown<span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span>Root <span class="token operator">=</span> <span class="token operator">&amp;</span>ast<span class="token punctuation">.</span>Node<span class="token punctuation">{</span>Type<span class="token punctuation">:</span> ast<span class="token punctuation">.</span>NodeDocument<span class="token punctuation">}</span>
	tree<span class="token punctuation">.</span><span class="token function">parseBlocks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span><span class="token function">parseInlines</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span>lexer <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码结构方面我们分为两部分：解析和渲染</p><ul><li>渲染过程将遍历语法树生成 HTML 代码，本文略过</li><li>解析过程下面我们将着重介绍，从预处理阶段开始</li></ul><h4 id="_1-预处理" tabindex="-1"><a class="header-anchor" href="#_1-预处理"><span>① 预处理</span></a></h4><p>预处理阶段主要是将输入的 Markdown 文本字节数组结尾添加换行符 <code>\\n</code>，以方便后续解析可以统一按行读取。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// NewLexer 创建一个词法分析器。</span>
<span class="token keyword">func</span> <span class="token function">NewLexer</span><span class="token punctuation">(</span>input <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ret <span class="token operator">*</span>Lexer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ret <span class="token operator">=</span> <span class="token operator">&amp;</span>Lexer<span class="token punctuation">{</span><span class="token punctuation">}</span>
	ret<span class="token punctuation">.</span>input <span class="token operator">=</span> input
	ret<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> ret<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> ItemNewline <span class="token operator">!=</span> ret<span class="token punctuation">.</span>input<span class="token punctuation">[</span>ret<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
		<span class="token comment">// 以 \\n 结尾预处理</span>
		ret<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>input<span class="token punctuation">,</span> ItemNewline<span class="token punctuation">)</span>
		ret<span class="token punctuation">.</span>length<span class="token operator">++</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-词法分析" tabindex="-1"><a class="header-anchor" href="#_2-词法分析"><span>② 词法分析</span></a></h4><p>词法分析的目的是将 Markdown 文本转换为 token 数组。标准的编译原理中词法分析产生的 token 将带有如下这样一些属性：</p><ul><li>类型（token type），比如标识符、操作符、数字、字符等</li><li>词素（lexeme），原始的文本字节数组</li><li>位置（pos），该 token 的第一个字节相对于整个文本字节数组的下标</li></ul><p>Markdown 的词法分析进行了简化，仅返回词素作为 token，因为：</p>`,16),W=n("li",null,[s("Markdown 解析不需要类型信息，使用的标记符（比如 "),n("code",null,"#"),s("、"),n("code",null,"*"),s(" 等）本身就是 token 类型和词素")],-1),X={href:"https://88250.b3log.org/articles/2020/04/23/1587637426085.html#sourcemap",target:"_blank",rel:"noopener noreferrer"},Y=n("li",null,"提升性能",-1),$=e(`<p>另外，编译原理教科书中是将词法分析和语法分析完全分开介绍的，即词法分析器产生 token 数组后作为参数传入语法分析器，而实际工程上因为性能考虑，是在语法分析中调用词法分析来按需获得 token 数组，这样可以减少内存分配。</p><p>Markdown 词法分析的具体实现是按行进行处理的，每次处理后词法分析器会记录当前读取位置，以便下次继续按行处理。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Lexer 描述了词法分析器结构。</span>
<span class="token keyword">type</span> Lexer <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	input  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token comment">// 输入的文本字节数组</span>
	length <span class="token builtin">int</span>    <span class="token comment">// 输入的文本字节数组的长度</span>
	offset <span class="token builtin">int</span>    <span class="token comment">// 当前读取字节位置</span>
	width  <span class="token builtin">int</span>    <span class="token comment">// 最新一个字符的长度（字节数）</span>
<span class="token punctuation">}</span>

<span class="token comment">// NextLine 返回下一行。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Lexer<span class="token punctuation">)</span> <span class="token function">NextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ret <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> l<span class="token punctuation">.</span>offset <span class="token operator">&gt;=</span> l<span class="token punctuation">.</span>length <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> b<span class="token punctuation">,</span> nb <span class="token builtin">byte</span>
	i <span class="token operator">:=</span> l<span class="token punctuation">.</span>offset
	<span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> l<span class="token punctuation">.</span>width <span class="token punctuation">{</span>
		b <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> ItemNewline <span class="token operator">==</span> b <span class="token punctuation">{</span>
			i<span class="token operator">++</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> ItemCarriageReturn <span class="token operator">==</span> b <span class="token punctuation">{</span>
			<span class="token comment">// 处理 \\r</span>
			<span class="token keyword">if</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
				nb <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
				<span class="token keyword">if</span> ItemNewline <span class="token operator">==</span> nb <span class="token punctuation">{</span>
					l<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 移除 \\r，依靠下一个的 \\n 切行</span>
					l<span class="token punctuation">.</span>length<span class="token operator">--</span>                                      <span class="token comment">// 重新计算总长</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			i<span class="token operator">++</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token char">&#39;\\u0000&#39;</span> <span class="token operator">==</span> b <span class="token punctuation">{</span>
			<span class="token comment">// 将 \\u0000 替换为 \\uFFFD</span>
			l<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token function">copy</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token comment">// \\uFFFD 的 UTF-8 编码为 \\xEF\\xBF\\xBD 共三个字节</span>
			l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;\\xEF&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;\\xBF&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;\\xBD&#39;</span>
			l<span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token number">2</span> <span class="token comment">// 重新计算总长</span>
			l<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">3</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> utf8<span class="token punctuation">.</span>RuneSelf <span class="token operator">&lt;=</span> b <span class="token punctuation">{</span> <span class="token comment">// 说明占用多个字节</span>
			<span class="token boolean">_</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>width <span class="token operator">=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRune</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			l<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">1</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	ret <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>l<span class="token punctuation">.</span>offset<span class="token punctuation">:</span>i<span class="token punctuation">]</span>
	l<span class="token punctuation">.</span>offset <span class="token operator">=</span> i
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-语法分析" tabindex="-1"><a class="header-anchor" href="#_3-语法分析"><span>③ 语法分析</span></a></h4>`,4),nn={href:"https://spec.commonmark.org/0.29/#appendix-a-parsing-strategy",target:"_blank",rel:"noopener noreferrer"},sn=n("ol",null,[n("li",null,"构造所有块级节点，包括标题、块引用、代码块、分隔线、列表、段落等，还需要构造好链接引用定义映射表"),n("li",null,"遍历每个块级节点，构造行级节点，包括文本、链接、强调、加粗等，链接的处理可能会需要查找步骤 1 中构造好的链接引用定义映射表")],-1),an={href:"https://hacpai.com/article/1566893557720",target:"_blank",rel:"noopener noreferrer"},tn={href:"https://hacpai.com/article/1567062979327",target:"_blank",rel:"noopener noreferrer"},en=e('<h4 id="_4-代码生成" tabindex="-1"><a class="header-anchor" href="#_4-代码生成"><span>④ 代码生成</span></a></h4><h3 id="抽象语法树" tabindex="-1"><a class="header-anchor" href="#抽象语法树"><span>抽象语法树</span></a></h3><p>Markdown 抽象语法树是由节点构成的树，从包含关系来说节点可以分为四类：</p><ol><li>根节点，可以包含所有其他任意节点</li><li>块级容器节点，可以包含非根节点的其他任意节点，比如列表项包含段落</li><li>块级节点，可以包含行级节点，比如段落包含强调</li><li>行级节点，可以包含行级节点，比如强调包含文本</li></ol><p>我们在实现 Lute 时做了“最细粒度”的节点结构，比如对于超链接 <code>[foo](bar)</code> 形成的节点结构包含了左方括号 <code>[</code>、链接文本 <code>foo</code>、右方括号 <code>]</code>、左圆括号 <code>(</code>、链接地址 <code>bar</code> 和右圆括号 <code>)</code>。这样做的优点是方便处理细致的节点操作，缺点是性能稍差，因为需要构造和遍历更多的节点。</p>',5),pn={href:"https://github.com/Vanessa219/vditor",target:"_blank",rel:"noopener noreferrer"},on={href:"https://hacpai.com/guide/markdown",target:"_blank",rel:"noopener noreferrer"},ln={href:"https://github.com/88250/lute/blob/master/ast/node.go",target:"_blank",rel:"noopener noreferrer"};function cn(rn,un){const a=o("ExternalLinkIcon");return l(),c("div",null,[r,n("ul",null,[n("li",null,[n("p",null,[n("a",u,[s("【简书】AST 介绍"),t(a)]),s(" 资源&文章推荐")]),n("ul",null,[n("li",null,[n("p",null,[n("a",d,[s("Babel 插件手册"),t(a)])])]),n("li",null,[n("p",null,[n("a",k,[s("透過製作 Babel-plugin 初訪 AST"),t(a)])])]),n("li",null,[n("p",null,[n("a",h,[s("AST 与前端工程化实战"),t(a)])])])])])]),b,n("ul",null,[m,v,_,g,f,n("li",null,[s("生成代码。最近用了"),n("a",A,[s("ANT DESIGN PRO"),t(a)]),s("。 ANT DESIGN PRO 中的 "),n("a",F,[s("umi"),t(a)]),s(" 可以在生成页面的代码和路由时，修改路由配置的js。umi 这种方式，用户体验很好。因此，我准备用这种方式来改造我之前做的代码生成工具。修改路由配置需要通过AST来转换代码。")])]),T,S,n("p",null,[s("了解AST常见节点的结构推荐通读下"),n("a",y,[s("AST node 规范"),t(a)]),s("。")]),w,x,n("p",null,[s("解析 JavaScript 可以用"),n("a",E,[s("@babel/parser"),t(a)]),s("(以前叫 "),n("a",j,[s("Babylon"),t(a)]),s(")。")]),B,N,n("p",null,[s("转换可以用"),n("a",L,[s("@babel/traverse"),t(a)]),s("。")]),n("p",null,[s("创建和验证节点可以用"),n("a",M,[s("@babel/types"),t(a)]),s("。创建AST节点代码示例见"),n("a",D,[s("这里"),t(a)]),s("。")]),C,I,n("p",null,[s("生成目标代码可以用"),n("a",P,[s("@babel/generator"),t(a)])]),R,n("ul",null,[n("li",null,[n("a",V,[s("AST 浏览器"),t(a)])]),n("li",null,[n("a",q,[s("AST 可视化工具"),t(a)])]),n("li",null,[s("npm 包 "),n("ul",null,[n("li",null,[n("a",O,[s("recast"),t(a)]),s(" AST工具库。解析AST(parse)，遍历AST，修改AST，生成代码。官方文档太简单了。")]),n("li",null,[n("a",z,[s("@babel/template"),t(a)]),s(" 它能让你编写字符串形式且带有占位符的代码来代替手动编码， 尤其是生成的大规模 AST的时候。 在计算机科学中，这种能力被称为准引用（quasiquotes）。")])])])]),G,n("p",null,[s("参考："),n("a",H,[s("Markdown 解析原理详解和 Markdown AST 描述"),t(a)])]),J,n("ul",null,[n("li",null,[n("a",Z,[s("CommonMark Spec"),t(a)])]),n("li",null,[n("a",U,[s("Lute"),t(a)]),s(" 一款对中文语境优化的 Markdown 引擎，支持 Go 和 JavaScript")]),n("li",null,[n("a",K,[s("Vditor"),t(a)]),s(" 一款浏览器端的 Markdown 编辑器，支持所见即所得、即时渲染（类似 Typora）和分屏预览模式")])]),Q,n("ul",null,[W,n("li",null,[s("大部分场景下的 Markdown 解析不需要实现"),n("a",X,[s("源码映射"),t(a)])]),Y]),$,n("p",null,[s("CommonMark 规范中介绍了一种"),n("a",nn,[s("解析算法"),t(a)]),s("，分为两个阶段：")]),sn,n("p",null,[s("关于 CommonMark 规范的一些实现细节可参考我之前的笔记（"),n("a",an,[s("CommonMark 规范要点解读"),t(a)]),s("、"),n("a",tn,[s("Lute 实现后记"),t(a)]),s("），这里就不展开了，如果感兴趣欢迎跟帖讨论。")]),en,n("p",null,[s("如果你想看到较粗粒度的语法树，可以通过 "),n("a",pn,[s("Vditor Markdown 编辑器"),t(a)]),s("的开发者工具来查看，请"),n("a",on,[s("到此"),t(a)]),s("进行测试（点击编辑器工具栏上的“开发者工具”按钮就可以看到根据输入进行实时渲染的语法树了）。")]),n("p",null,[s("下面我们按 Lute 源码中的"),n("a",ln,[s("节点"),t(a)]),s("类型常量顺序来逐一描述。")])])}const hn=p(i,[["render",cn],["__file","AST 抽象语法树.html.vue"]]),bn=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Type/Doc/AST%20%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.html","title":"AST 抽象语法树","lang":"zh-CN","frontmatter":{"description":"AST 抽象语法树 目录 AST 抽象语法树 AST (Abstract Syntax Tree，抽象语法树) 参考： 【简书】AST 介绍 资源&文章推荐 Babel 插件手册 透過製作 Babel-plugin 初訪 AST AST 与前端工程化实战 什么是AST？ AST (Abstract Syntax Tree，抽象语法树) ，是源代码语法结...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Type/Doc/AST%20%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"AST 抽象语法树"}],["meta",{"property":"og:description","content":"AST 抽象语法树 目录 AST 抽象语法树 AST (Abstract Syntax Tree，抽象语法树) 参考： 【简书】AST 介绍 资源&文章推荐 Babel 插件手册 透過製作 Babel-plugin 初訪 AST AST 与前端工程化实战 什么是AST？ AST (Abstract Syntax Tree，抽象语法树) ，是源代码语法结..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AST 抽象语法树\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"AST 抽象语法树","slug":"ast-抽象语法树","link":"#ast-抽象语法树","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"AST 抽象语法树","slug":"ast-抽象语法树-1","link":"#ast-抽象语法树-1","children":[{"level":2,"title":"AST (Abstract Syntax Tree，抽象语法树)","slug":"ast-abstract-syntax-tree-抽象语法树","link":"#ast-abstract-syntax-tree-抽象语法树","children":[{"level":3,"title":"什么是AST？","slug":"什么是ast","link":"#什么是ast","children":[]},{"level":3,"title":"AST 的使用场景？","slug":"ast-的使用场景","link":"#ast-的使用场景","children":[]},{"level":3,"title":"需要学习 AST 的哪些知识？","slug":"需要学习-ast-的哪些知识","link":"#需要学习-ast-的哪些知识","children":[]},{"level":3,"title":"工具","slug":"工具","link":"#工具","children":[]}]},{"level":2,"title":"Md解析原理（Lute工具）","slug":"md解析原理-lute工具","link":"#md解析原理-lute工具","children":[{"level":3,"title":"这篇文章中涉及的开源项目","slug":"这篇文章中涉及的开源项目","link":"#这篇文章中涉及的开源项目","children":[]},{"level":3,"title":"编译原理","slug":"编译原理","link":"#编译原理","children":[]},{"level":3,"title":"解析","slug":"解析","link":"#解析","children":[{"level":4,"title":"① 预处理","slug":"_1-预处理","link":"#_1-预处理","children":[]},{"level":4,"title":"② 词法分析","slug":"_2-词法分析","link":"#_2-词法分析","children":[]},{"level":4,"title":"③ 语法分析","slug":"_3-语法分析","link":"#_3-语法分析","children":[]},{"level":4,"title":"④ 代码生成","slug":"_4-代码生成","link":"#_4-代码生成","children":[]}]},{"level":3,"title":"抽象语法树","slug":"抽象语法树","link":"#抽象语法树","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.92,"words":2377},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Type/Doc/AST 抽象语法树.md","autoDesc":true}');export{hn as comp,bn as data};
