import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o as s,c as l,a as e,b as t,d,e as i}from"./app-CoO7IlkE.js";const c={},o=i(`<h1 id="内核中的网络参数" tabindex="-1"><a class="header-anchor" href="#内核中的网络参数"><span>内核中的网络参数</span></a></h1><h2 id="nf-conntrack" tabindex="-1"><a class="header-anchor" href="#nf-conntrack"><span>nf_conntrack</span></a></h2><p><code>nf_conntrack</code>是Linux内核连接跟踪的模块，常用在<code>iptables</code>中，比如</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>-A INPUT -m state --state RELATED,ESTABLISHED  -j RETURN
-A INPUT -m state --state INVALID -j DROP
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以通过<code>cat /proc/net/nf_conntrack</code>来查看当前跟踪的连接信息，这些信息以哈希形式（用链地址法处理冲突）存在内存中，并且每条记录大约占300B空间。</p><p>与<code>nf_conntrack</code>相关的内核参数有三个：</p><ul><li><code>nf_conntrack_max</code>：连接跟踪表的大小，建议根据内存计算该值<code>CONNTRACK_MAX = RAMSIZE (in bytes) / 16384 / (x / 32)</code>，并满足<code>nf_conntrack_max=4*nf_conntrack_buckets</code>，默认262144</li><li><code>nf_conntrack_buckets</code>：哈希表的大小，(<code>nf_conntrack_max/nf_conntrack_buckets</code>就是每条哈希记录链表的长度)，默认65536</li><li><code>nf_conntrack_tcp_timeout_established</code>：tcp会话的超时时间，默认是432000 (5天)</li></ul><p>比如，对64G内存的机器，推荐配置：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>net.netfilter.nf_conntrack_max=4194304
net.netfilter.nf_conntrack_tcp_timeout_established=300
net.netfilter.nf_conntrack_buckets=1048576
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bridge-nf" tabindex="-1"><a class="header-anchor" href="#bridge-nf"><span>bridge-nf</span></a></h2>`,10),u=e("code",null,"net.bridge.bridge-nf-call-iptables＝1",-1),v={href:"https://bugzilla.redhat.com/show_bug.cgi?id=512206",target:"_blank",rel:"noopener noreferrer"},p=i(`<p>常用的选项包括</p><ul><li><code>net.bridge.bridge-nf-call-arptables</code>：是否在<code>arptables</code>的FORWARD中过滤网桥的ARP包</li><li><code>net.bridge.bridge-nf-call-ip6tables</code>：是否在<code>ip6tables</code>链中过滤IPv6包</li><li><code>net.bridge.bridge-nf-call-iptables</code>：是否在<code>iptables</code>链中过滤IPv4包</li><li><code>net.bridge.bridge-nf-filter-vlan-tagged</code>：是否在i<code>ptables/arptables</code>中过滤打了vlan标签的包</li></ul><p>当然，也可以通过<code>/sys/devices/virtual/net/&lt;bridge-name&gt;/bridge/nf_call_iptables</code>来设置，但要注意内核是取两者中大的生效。</p><p>有时，可能只希望部分网桥禁止bridge-nf，而其他网桥都开启（比如CNI网络插件中一般要求bridge-nf-call-iptables选项开启，而有时又希望禁止某个网桥的bridge-nf），这时可以改用iptables的方法：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>iptables <span class="token parameter variable">-t</span> raw <span class="token parameter variable">-I</span> PREROUTING <span class="token parameter variable">-i</span> <span class="token operator">&lt;</span>bridge-name<span class="token operator">&gt;</span> <span class="token parameter variable">-j</span> NOTRACK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="反向路径过滤" tabindex="-1"><a class="header-anchor" href="#反向路径过滤"><span>反向路径过滤</span></a></h2><p>反向路径过滤可用于防止数据包从一接口传入，又从另一不同的接口传出（这有时被称为 “非对称路由” ）。除非必要，否则最好将其关闭，因为它可防止来自子网络的用户采用 IP 地址欺骗手段，并减少 DDoS （分布式拒绝服务）攻击的机会。</p><p>通过 rp_filter 选项启用反向路径过滤，比如 <code>sysctl -w net.ipv4.conf.default.rp_filter=INTEGER</code>。支持三种选项：</p><ul><li>0 ——未进行源验证。</li><li>1 ——处于如 RFC3704 所定义的严格模式。</li><li>2 ——处于如 RFC3704 所定义的松散模式。</li></ul><p>可以通过 <code>net.ipv4.interface.rp_filter</code>可实现对每一网络接口设置的覆盖。</p><h2 id="tcp相关" tabindex="-1"><a class="header-anchor" href="#tcp相关"><span>TCP相关</span></a></h2><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>默认值</strong></th><th><strong>优化值</strong></th></tr></thead><tbody><tr><td><code>net.core.rmem_default</code></td><td>默认的TCP数据接收窗口大小（字节）</td><td>212992</td><td></td></tr><tr><td><code>net.core.rmem_max</code></td><td>最大的TCP数据接收窗口（字节）。</td><td>212992</td><td></td></tr><tr><td><code>net.core.wmem_default</code></td><td>默认的TCP数据发送窗口大小（字节）。</td><td>212992</td><td></td></tr><tr><td><code>net.core.wmem_max</code></td><td>最大的TCP数据发送窗口（字节）。</td><td>212992</td><td></td></tr><tr><td><code>net.core.netdev_max_backlog</code></td><td>在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</td><td>1000</td><td>10000</td></tr><tr><td><code>net.core.somaxconn</code></td><td>定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数。</td><td>128</td><td>2048</td></tr><tr><td><code>net.core.optmem_max</code></td><td>表示每个套接字所允许的最大缓冲区的大小。</td><td>20480</td><td>81920</td></tr><tr><td><code>net.ipv4.tcp_mem</code></td><td>确定TCP栈应该如何反映内存使用，每个值的单位都是内存页（通常是4KB）。第一个值是内存使用的下限；第二个值是内存压力模式开始对缓冲区使用应用压力的上限；第三个值是内存使用的上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的BDP可以增大这些值（注意，其单位是内存页而不是字节）。</td><td>5814 7754 11628</td><td></td></tr><tr><td><code>net.ipv4.tcp_rmem</code></td><td>为自动调优定义socket使用的内存。第一个值是为socket接收缓冲区分配的最少字节数；第二个值是默认值（该值会被<code>rmem_default</code>覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是接收缓冲区空间的最大字节数（该值会被<code>rmem_max</code>覆盖）。</td><td>4096 87380 3970528</td><td></td></tr><tr><td><code>net.ipv4.tcp_wmem</code></td><td>为自动调优定义socket使用的内存。第一个值是为socket发送缓冲区分配的最少字节数；第二个值是默认值（该值会被<code>wmem_default</code>覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是发送缓冲区空间的最大字节数（该值会被<code>wmem_max</code>覆盖）。</td><td>4096 16384 3970528</td><td></td></tr><tr><td><code>net.ipv4.tcp_keepalive_time</code></td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。</td><td>7200</td><td>1800</td></tr><tr><td><code>net.ipv4.tcp_keepalive_intvl</code></td><td>探测消息未获得响应时，重发该消息的间隔时间（秒）</td><td>75</td><td>30</td></tr><tr><td><code>net.ipv4.tcp_keepalive_probes</code></td><td>在认定TCP连接失效之前，最多发送多少个keepalive探测消息。</td><td>9</td><td>3</td></tr><tr><td><code>net.ipv4.tcp_sack</code></td><td>启用有选择的应答（1表示启用），通过有选择地应答乱序接收到的报文来提高性能，让发送者只发送丢失的报文段，（对于广域网通信来说）这个选项应该启用，但是会增加对CPU的占用。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_fack</code></td><td>启用转发应答，可以进行有选择应答（SACK）从而减少拥塞情况的发生，这个选项也应该启用。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_timestamps</code></td><td>TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_window_scaling</code></td><td>启用RFC 1323定义的window scaling，要支持超过64KB的TCP窗口，必须启用该值（1表示启用），TCP窗口最大至1GB，TCP连接双方都启用时才生效。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_syncookies</code></td><td>表示是否打开TCP同步标签（syncookie），内核必须打开了<code>CONFIG_SYN_COOKIES</code>项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_tw_reuse</code></td><td>表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 。</td><td>0</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_tw_recycle</code></td><td>能够更快地回收TIME-WAIT套接字。</td><td>0</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_fin_timeout</code></td><td>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。</td><td>60</td><td>30</td></tr><tr><td><code>net.ipv4.ip_local_port_range</code></td><td>表示TCP/UDP协议允许使用的本地端口号</td><td>32768 60999</td><td>1024 65000</td></tr><tr><td><code>net.ipv4.tcp_max_syn_backlog</code></td><td>对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字。</td><td>128</td><td></td></tr><tr><td><code>net.ipv4.tcp_low_latency</code></td><td>允许TCP/IP栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用。</td><td>0</td><td>0</td></tr></tbody></table><h2 id="arp相关" tabindex="-1"><a class="header-anchor" href="#arp相关"><span>ARP相关</span></a></h2><h3 id="arp回收" tabindex="-1"><a class="header-anchor" href="#arp回收"><span>ARP回收</span></a></h3><ul><li><code>gc_stale_time</code> 每次检查neighbour记录的有效性的周期。当neighbour记录失效时，将在给它发送数据前再解析一次。缺省值是60秒。</li><li><code>gc_thresh1</code> 存在于ARP高速缓存中的最少记录数，如果少于这个数，垃圾收集器将不会运行。缺省值是128。</li><li><code>gc_thresh2</code> 存在 ARP 高速缓存中的最多的记录软限制。垃圾收集器在开始收集前，允许记录数超过这个数字 5 秒。缺省值是 512。</li><li><code>gc_thresh3</code> 保存在 ARP 高速缓存中的最多记录的硬限制，一旦高速缓存中的数目高于此，垃圾收集器将马上运行。缺省值是1024。</li></ul><p>比如可以增大为</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>net.ipv4.neigh.default.gc_thresh1=1024
net.ipv4.neigh.default.gc_thresh2=4096
net.ipv4.neigh.default.gc_thresh3=8192
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="arp过滤" tabindex="-1"><a class="header-anchor" href="#arp过滤"><span>ARP过滤</span></a></h3><p>arp_filter - BOOLEAN</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>1 - Allows you to have multiple network interfaces on the same
subnet, and have the ARPs for each interface be answered
based on whether or not the kernel would route a packet from
the ARP&#39;d IP out that interface (therefore you must use source
based routing for this to work). In other words it allows control
of which cards (usually 1) will respond to an arp request.

0 - (default) The kernel can respond to arp requests with addresses
from other interfaces. This may seem wrong but it usually makes
sense, because it increases the chance of successful communication.
IP addresses are owned by the complete host on Linux, not by
particular interfaces. Only for more complex setups like load-
balancing, does this behaviour cause problems.

arp_filter for the interface will be enabled if at least one of
conf/{all,interface}/arp_filter is set to TRUE,
it will be disabled otherwise
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_announce - INTEGER</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Define different restriction levels for announcing the local
source IP address from IP packets in ARP requests sent on
interface:
0 - (default) Use any local address, configured on any interface
1 - Try to avoid local addresses that are not in the target&#39;s
subnet for this interface. This mode is useful when target
hosts reachable via this interface require the source IP
address in ARP requests to be part of their logical network
configured on the receiving interface. When we generate the
request we will check all our subnets that include the
target IP and will preserve the source address if it is from
such subnet. If there is no such subnet we select source
address according to the rules for level 2.
2 - Always use the best local address for this target.
In this mode we ignore the source address in the IP packet
and try to select local address that we prefer for talks with
the target host. Such local address is selected by looking
for primary IP addresses on all our subnets on the outgoing
interface that include the target IP address. If no suitable
local address is found we select the first local address
we have on the outgoing interface or on all other interfaces,
with the hope we will receive reply for our request and
even sometimes no matter the source IP address we announce.

The max value from conf/{all,interface}/arp_announce is used.

Increasing the restriction level gives more chance for
receiving answer from the resolved target while decreasing
the level announces more valid sender&#39;s information.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_ignore - INTEGER</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Define different modes for sending replies in response to
received ARP requests that resolve local target IP addresses:
0 - (default): reply for any local target IP address, configured
on any interface
1 - reply only if the target IP address is local address
configured on the incoming interface
2 - reply only if the target IP address is local address
configured on the incoming interface and both with the
sender&#39;s IP address are part from same subnet on this interface
3 - do not reply for local addresses configured with scope host,
only resolutions for global and link addresses are replied
4-7 - reserved
8 - do not reply for all local addresses

The max value from conf/{all,interface}/arp_ignore is used
when ARP request is received on the {interface}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_notify - BOOLEAN</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Define mode for notification of address and device changes.
0 - (default): do nothing
1 - Generate gratuitous arp requests when device is brought up
    or hardware address changes.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_accept - BOOLEAN</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Define behavior for gratuitous ARP frames who&#39;s IP is not
already present in the ARP table:
0 - don&#39;t create new entries in the ARP table
1 - create new entries in the ARP table

Both replies and requests type gratuitous arp will trigger the
ARP table to be updated, if this setting is on.

If the ARP table already contains the IP address of the
gratuitous arp frame, the arp table will be updated regardless
if this setting is on or off.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2>`,29),h={href:"https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt",target:"_blank",rel:"noopener noreferrer"};function m(b,f){const n=r("ExternalLinkIcon");return s(),l("div",null,[o,e("p",null,[t("bridge-nf使得netfilter可以对Linux网桥上的IPv4/ARP/IPv6包过滤。比如，设置"),u,t("后，二层的网桥在转发包时也会被iptables的FORWARD规则所过滤，这样有时会出现L3层的iptables rules去过滤L2的帧的问题（见"),e("a",v,[t("这里"),d(n)]),t("）。")]),p,e("ul",null,[e("li",null,[e("a",h,[t("Linux Kernel ip sysctl documentation"),d(n)])])])])}const E=a(c,[["render",m],["__file","10. 内核网络参数.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8B/03.%20Linux%E7%BD%91%E7%BB%9C/10.%20%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0.html","title":"内核中的网络参数","lang":"zh-CN","frontmatter":{"description":"内核中的网络参数 nf_conntrack nf_conntrack是Linux内核连接跟踪的模块，常用在iptables中，比如 可以通过cat /proc/net/nf_conntrack来查看当前跟踪的连接信息，这些信息以哈希形式（用链地址法处理冲突）存在内存中，并且每条记录大约占300B空间。 与nf_conntrack相关的内核参数有三个： ...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8B/03.%20Linux%E7%BD%91%E7%BB%9C/10.%20%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"内核中的网络参数"}],["meta",{"property":"og:description","content":"内核中的网络参数 nf_conntrack nf_conntrack是Linux内核连接跟踪的模块，常用在iptables中，比如 可以通过cat /proc/net/nf_conntrack来查看当前跟踪的连接信息，这些信息以哈希形式（用链地址法处理冲突）存在内存中，并且每条记录大约占300B空间。 与nf_conntrack相关的内核参数有三个： ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内核中的网络参数\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"内核中的网络参数","slug":"内核中的网络参数","link":"#内核中的网络参数","children":[{"level":2,"title":"nf_conntrack","slug":"nf-conntrack","link":"#nf-conntrack","children":[]},{"level":2,"title":"bridge-nf","slug":"bridge-nf","link":"#bridge-nf","children":[]},{"level":2,"title":"反向路径过滤","slug":"反向路径过滤","link":"#反向路径过滤","children":[]},{"level":2,"title":"TCP相关","slug":"tcp相关","link":"#tcp相关","children":[]},{"level":2,"title":"ARP相关","slug":"arp相关","link":"#arp相关","children":[{"level":3,"title":"ARP回收","slug":"arp回收","link":"#arp回收","children":[]},{"level":3,"title":"ARP过滤","slug":"arp过滤","link":"#arp过滤","children":[]}]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.59,"words":2578},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》/03. Linux网络/10. 内核网络参数.md","autoDesc":true}');export{E as comp,k as data};
