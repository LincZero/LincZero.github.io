import{_ as a,c as l,e as n,o as h}from"./app-_6RECMRt.js";const i={};function t(s,e){return h(),l("div",null,e[0]||(e[0]=[n('<h1 id="优化程序性能" tabindex="-1"><a class="header-anchor" href="#优化程序性能"><span>优化程序性能</span></a></h1><h2 id="优化编译器的能力和局限性" tabindex="-1"><a class="header-anchor" href="#优化编译器的能力和局限性"><span>优化编译器的能力和局限性</span></a></h2><h2 id="表示程序性能" tabindex="-1"><a class="header-anchor" href="#表示程序性能"><span>表示程序性能</span></a></h2><h2 id="程序示例" tabindex="-1"><a class="header-anchor" href="#程序示例"><span>程序示例</span></a></h2><h2 id="消除循环的低效率" tabindex="-1"><a class="header-anchor" href="#消除循环的低效率"><span>消除循环的低效率</span></a></h2><h2 id="减少过程调用" tabindex="-1"><a class="header-anchor" href="#减少过程调用"><span>减少过程调用</span></a></h2><h2 id="消除不必要的内存引用" tabindex="-1"><a class="header-anchor" href="#消除不必要的内存引用"><span>消除不必要的内存引用</span></a></h2><h2 id="理解现代处理器" tabindex="-1"><a class="header-anchor" href="#理解现代处理器"><span>理解现代处理器</span></a></h2><h3 id="整体操作" tabindex="-1"><a class="header-anchor" href="#整体操作"><span>整体操作</span></a></h3><h3 id="功能单元的性能" tabindex="-1"><a class="header-anchor" href="#功能单元的性能"><span>功能单元的性能</span></a></h3><h3 id="处理器操作的抽象模型" tabindex="-1"><a class="header-anchor" href="#处理器操作的抽象模型"><span>处理器操作的抽象模型</span></a></h3><h2 id="循环展开" tabindex="-1"><a class="header-anchor" href="#循环展开"><span>循环展开</span></a></h2><h2 id="提高并行性" tabindex="-1"><a class="header-anchor" href="#提高并行性"><span>提高并行性</span></a></h2><h3 id="多个累计变量" tabindex="-1"><a class="header-anchor" href="#多个累计变量"><span>多个累计变量</span></a></h3><h3 id="重新结合变换" tabindex="-1"><a class="header-anchor" href="#重新结合变换"><span>重新结合变换</span></a></h3><h2 id="优化合并代码的结果小结" tabindex="-1"><a class="header-anchor" href="#优化合并代码的结果小结"><span>优化合并代码的结果小结</span></a></h2><h2 id="一些限制因素" tabindex="-1"><a class="header-anchor" href="#一些限制因素"><span>一些限制因素</span></a></h2><h3 id="寄存器溢出" tabindex="-1"><a class="header-anchor" href="#寄存器溢出"><span>寄存器溢出</span></a></h3><h3 id="分支预测和预测错误处罚" tabindex="-1"><a class="header-anchor" href="#分支预测和预测错误处罚"><span>分支预测和预测错误处罚</span></a></h3><h2 id="理解内存性能" tabindex="-1"><a class="header-anchor" href="#理解内存性能"><span>理解内存性能</span></a></h2><h3 id="加载的性能" tabindex="-1"><a class="header-anchor" href="#加载的性能"><span>加载的性能</span></a></h3><h3 id="存储的性能" tabindex="-1"><a class="header-anchor" href="#存储的性能"><span>存储的性能</span></a></h3><h2 id="应用-性能提高技术" tabindex="-1"><a class="header-anchor" href="#应用-性能提高技术"><span>应用：性能提高技术</span></a></h2><h2 id="确定和消除性能瓶颈" tabindex="-1"><a class="header-anchor" href="#确定和消除性能瓶颈"><span>确定和消除性能瓶颈</span></a></h2><h3 id="程序剖析" tabindex="-1"><a class="header-anchor" href="#程序剖析"><span>程序剖析</span></a></h3><h3 id="使用剖析程序来指导优化" tabindex="-1"><a class="header-anchor" href="#使用剖析程序来指导优化"><span>使用剖析程序来指导优化</span></a></h3><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2>',27)]))}const d=a(i,[["render",t],["__file","05. 优化程序性能.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/01.%20%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C/05.%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD.html","title":"优化程序性能","lang":"zh-CN","frontmatter":{"description":"优化程序性能 优化编译器的能力和局限性 表示程序性能 程序示例 消除循环的低效率 减少过程调用 消除不必要的内存引用 理解现代处理器 整体操作 功能单元的性能 处理器操作的抽象模型 循环展开 提高并行性 多个累计变量 重新结合变换 优化合并代码的结果小结 一些限制因素 寄存器溢出 分支预测和预测错误处罚 理解内存性能 加载的性能 存储的性能 应用：性能...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/01.%20%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C/05.%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"优化程序性能"}],["meta",{"property":"og:description","content":"优化程序性能 优化编译器的能力和局限性 表示程序性能 程序示例 消除循环的低效率 减少过程调用 消除不必要的内存引用 理解现代处理器 整体操作 功能单元的性能 处理器操作的抽象模型 循环展开 提高并行性 多个累计变量 重新结合变换 优化合并代码的结果小结 一些限制因素 寄存器溢出 分支预测和预测错误处罚 理解内存性能 加载的性能 存储的性能 应用：性能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"优化程序性能\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"优化程序性能","slug":"优化程序性能","link":"#优化程序性能","children":[{"level":2,"title":"优化编译器的能力和局限性","slug":"优化编译器的能力和局限性","link":"#优化编译器的能力和局限性","children":[]},{"level":2,"title":"表示程序性能","slug":"表示程序性能","link":"#表示程序性能","children":[]},{"level":2,"title":"程序示例","slug":"程序示例","link":"#程序示例","children":[]},{"level":2,"title":"消除循环的低效率","slug":"消除循环的低效率","link":"#消除循环的低效率","children":[]},{"level":2,"title":"减少过程调用","slug":"减少过程调用","link":"#减少过程调用","children":[]},{"level":2,"title":"消除不必要的内存引用","slug":"消除不必要的内存引用","link":"#消除不必要的内存引用","children":[]},{"level":2,"title":"理解现代处理器","slug":"理解现代处理器","link":"#理解现代处理器","children":[{"level":3,"title":"整体操作","slug":"整体操作","link":"#整体操作","children":[]},{"level":3,"title":"功能单元的性能","slug":"功能单元的性能","link":"#功能单元的性能","children":[]},{"level":3,"title":"处理器操作的抽象模型","slug":"处理器操作的抽象模型","link":"#处理器操作的抽象模型","children":[]}]},{"level":2,"title":"循环展开","slug":"循环展开","link":"#循环展开","children":[]},{"level":2,"title":"提高并行性","slug":"提高并行性","link":"#提高并行性","children":[{"level":3,"title":"多个累计变量","slug":"多个累计变量","link":"#多个累计变量","children":[]},{"level":3,"title":"重新结合变换","slug":"重新结合变换","link":"#重新结合变换","children":[]}]},{"level":2,"title":"优化合并代码的结果小结","slug":"优化合并代码的结果小结","link":"#优化合并代码的结果小结","children":[]},{"level":2,"title":"一些限制因素","slug":"一些限制因素","link":"#一些限制因素","children":[{"level":3,"title":"寄存器溢出","slug":"寄存器溢出","link":"#寄存器溢出","children":[]},{"level":3,"title":"分支预测和预测错误处罚","slug":"分支预测和预测错误处罚","link":"#分支预测和预测错误处罚","children":[]}]},{"level":2,"title":"理解内存性能","slug":"理解内存性能","link":"#理解内存性能","children":[{"level":3,"title":"加载的性能","slug":"加载的性能","link":"#加载的性能","children":[]},{"level":3,"title":"存储的性能","slug":"存储的性能","link":"#存储的性能","children":[]}]},{"level":2,"title":"应用：性能提高技术","slug":"应用-性能提高技术","link":"#应用-性能提高技术","children":[]},{"level":2,"title":"确定和消除性能瓶颈","slug":"确定和消除性能瓶颈","link":"#确定和消除性能瓶颈","children":[{"level":3,"title":"程序剖析","slug":"程序剖析","link":"#程序剖析","children":[]},{"level":3,"title":"使用剖析程序来指导优化","slug":"使用剖析程序来指导优化","link":"#使用剖析程序来指导优化","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}]}],"git":{},"readingTime":{"minutes":0.61,"words":184},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《深入理解计算机系统》/01. 程序结构和执行/05. 优化程序性能.md","excerpt":"\\n<h2>优化编译器的能力和局限性</h2>\\n<h2>表示程序性能</h2>\\n<h2>程序示例</h2>\\n<h2>消除循环的低效率</h2>\\n<h2>减少过程调用</h2>\\n<h2>消除不必要的内存引用</h2>\\n<h2>理解现代处理器</h2>\\n<h3>整体操作</h3>\\n<h3>功能单元的性能</h3>\\n<h3>处理器操作的抽象模型</h3>\\n<h2>循环展开</h2>\\n<h2>提高并行性</h2>\\n<h3>多个累计变量</h3>\\n<h3>重新结合变换</h3>\\n<h2>优化合并代码的结果小结</h2>\\n<h2>一些限制因素</h2>\\n<h3>寄存器溢出</h3>\\n<h3>分支预测和预测错误处罚</h3>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《深入理解计算机系统》/01. 程序结构和执行/05. 优化程序性能.md","value":{"title":"05. 优化程序性能","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《深入理解计算机系统》/01. 程序结构和执行/05. 优化程序性能.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{d as comp,c as data};
