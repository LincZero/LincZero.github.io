import{_ as s,c as a,e as l,o as e}from"./app-Dnpl954R.js";const n={};function t(h,i){return e(),a("div",null,i[0]||(i[0]=[l(`<h1 id="different" tabindex="-1"><a class="header-anchor" href="#different"><span>Different</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="类中函数" tabindex="-1"><a class="header-anchor" href="#类中函数"><span>类中函数</span></a></h1><h2 id="成员-方法访问控制" tabindex="-1"><a class="header-anchor" href="#成员-方法访问控制"><span>成员/方法访问控制</span></a></h2><h3 id="访问控制关键字" tabindex="-1"><a class="header-anchor" href="#访问控制关键字"><span>访问控制关键字</span></a></h3><ul><li>C++ <ul><li>public、private关键字写在一组实例域和方法之前</li><li>访问控制关键字写在头文件而不写在实现文件中</li></ul></li><li>Java <ul><li>public、private关键字写在每一个实例和方法之前</li><li>没有头文件、访问控制关键字直接写在实现文件中</li></ul></li></ul><h3 id="static-静态方法" tabindex="-1"><a class="header-anchor" href="#static-静态方法"><span>static 静态方法</span></a></h3><p>好像C++中只有static方法才能操作static成员，但Java中似乎没有此限制</p><p>Java中的静态域与静态方法在功能上与C++相同。但是，语法书写上却稍有所不同。</p><ul><li>Java：无需构造对象。使用<code>.</code>操作符直接访问，如<code>Math.pow</code></li><li>C++：无需构造对象。使用<code>::</code>操作符访问自身作用域之外的静态域和静态方法，如<code>Math::PI</code></li></ul><h2 id="构造和析构函数" tabindex="-1"><a class="header-anchor" href="#构造和析构函数"><span>构造和析构函数</span></a></h2><h3 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数"><span>构造函数</span></a></h3><p>构造器名</p><ul><li>C++、Java：构造器名和类同名</li><li>Java：构造器名为<code>init</code></li></ul><h4 id="显式域初始化" tabindex="-1"><a class="header-anchor" href="#显式域初始化"><span>显式域初始化</span></a></h4><p>与C++相似地：</p><ul><li><p>Java：可以在执行构造器之前，先执行赋值操作</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Employee</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++：</p><p>C++11也可以进行<code>类内初始化</code>（C++前不能），也有功能相似的<code>成员初始化列表</code>（Java没有）</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Employee</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Employee::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Employee</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(String n, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> y, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> d)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        :</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">salary</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hireDay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(y,m,d)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ...    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="参数名命名习惯" tabindex="-1"><a class="header-anchor" href="#参数名命名习惯"><span>参数名命名习惯</span></a></h4><p><mark>与C/C++不同</mark>：成员函数参数命名习惯</p><ul><li><p>C++</p><ul><li>经常用下划线或某个固定的字母（一般选用m或x）作为实例域的前缀</li><li>例如，_salary、mSalary或xSalary</li></ul></li><li><p>Java</p><ul><li><p>程序员则喜欢在每个参数前面加上一个前缀“a”</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Employee</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> aName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> aSalary)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> aName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    salary </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> aSalary</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>还一种常用的技巧，它基于这样的事实：参数变量用同样的名字将实例域屏蔽起来</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Employee</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> salary)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">salary</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> salary</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h4 id="构造器调用构造器" tabindex="-1"><a class="header-anchor" href="#构造器调用构造器"><span>构造器调用构造器</span></a></h4><ul><li>C++：一个构造器不能调用另一个构造器（你确定不能？）。在C++中，必须将抽取出的公共初始化代码编写成一个独立的方法</li><li>Java：可以，调用构造器的具体处理步骤如下 <ol><li>所有数据域被初始化为默认值（0、false或null）</li><li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li><li>执行这个构造器的主体</li></ol></li></ul><h3 id="析构函数" tabindex="-1"><a class="header-anchor" href="#析构函数"><span>析构函数</span></a></h3><ul><li><p>C++：有显式的析构器方法：<code>~</code>+类名</p></li><li><p>Java：有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器</p><p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p><p>可以为任何一个类添加<code>finalize</code>方法。finalize方法将在垃圾回收器清除对象之前调用</p></li></ul><h2 id="其他函数" tabindex="-1"><a class="header-anchor" href="#其他函数"><span>其他函数</span></a></h2><h3 id="更改器方法与访问器方法-c-中的const成员函数" tabindex="-1"><a class="header-anchor" href="#更改器方法与访问器方法-c-中的const成员函数"><span>更改器方法与访问器方法（C++中的const成员函数）</span></a></h3><p>访问器方法和静态方法</p><ul><li>Java：只访问对象而不修改对象的方法有时称为<code>访问器方法</code>（accessor method） 例如：LocalDate.getYear和GregorianCalendar.get就是访问器方法。 在Java语言中，访问器方法与更改器方法在<strong>语法上没有明显的区别</strong></li><li>C++：带有const后缀的方法是访问器方法；默认为更改器方法。 但C++中似乎没有这种叫法，只是简单称为const成员函数</li></ul><h3 id="内联方法" tabindex="-1"><a class="header-anchor" href="#内联方法"><span>内联方法？</span></a></h3><ul><li>C++ <ul><li>通常在类的外面定义方法</li><li>如果在类的内部定义方法，这个方法将自动地成为内联（inline）方法。</li></ul></li><li>Java <ul><li>所有的方法都必须在类的内部定义</li><li>但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。 即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。</li></ul></li></ul><h3 id="方法参数" tabindex="-1"><a class="header-anchor" href="#方法参数"><span>方法参数</span></a></h3><ul><li><p>Java：程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝。方法不能修改传递给它的任何参数变量的内容</p><p>但注意的是：Java的对象实例本来就是对象的引用，按值引用后依然是对象的引用。可以通过对象方法修改对象实例所引用的对象</p></li><li><p>C++：可以自由选择按值调用（call by value）或按引用调用（call by reference）</p><p>例如：<code>void tripleValue(double&amp;x)</code>，一个方法是按值调用还是按引用调用需要看函数原型才能知道</p></li><li><p>不可单纯将Java的对象实例理解为C++的引用，而必须要看成指针</p><ul><li>比如：不能编写一个交换两个雇员对象的方法，因为交换的只是拷贝进方法中的两个对象实例的地址，而并不能改变外部的两个对象实例的地址</li></ul></li></ul>`,32)]))}const d=s(n,[["render",t],["__file","02. 类中函数.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/Different/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.%20%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0.html","title":"Different","lang":"zh-CN","frontmatter":{"description":"Different 目录 类中函数 成员/方法访问控制 访问控制关键字 C++ public、private关键字写在一组实例域和方法之前 访问控制关键字写在头文件而不写在实现文件中 Java public、private关键字写在每一个实例和方法之前 没有头文件、访问控制关键字直接写在实现文件中 static 静态方法 好像C++中只有static方...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/Different/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.%20%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9/02.%20%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Different"}],["meta",{"property":"og:description","content":"Different 目录 类中函数 成员/方法访问控制 访问控制关键字 C++ public、private关键字写在一组实例域和方法之前 访问控制关键字写在头文件而不写在实现文件中 Java public、private关键字写在每一个实例和方法之前 没有头文件、访问控制关键字直接写在实现文件中 static 静态方法 好像C++中只有static方..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Different\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Different","slug":"different","link":"#different","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"类中函数","slug":"类中函数","link":"#类中函数","children":[{"level":2,"title":"成员/方法访问控制","slug":"成员-方法访问控制","link":"#成员-方法访问控制","children":[{"level":3,"title":"访问控制关键字","slug":"访问控制关键字","link":"#访问控制关键字","children":[]},{"level":3,"title":"static 静态方法","slug":"static-静态方法","link":"#static-静态方法","children":[]}]},{"level":2,"title":"构造和析构函数","slug":"构造和析构函数","link":"#构造和析构函数","children":[{"level":3,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[{"level":4,"title":"显式域初始化","slug":"显式域初始化","link":"#显式域初始化","children":[]},{"level":4,"title":"参数名命名习惯","slug":"参数名命名习惯","link":"#参数名命名习惯","children":[]},{"level":4,"title":"构造器调用构造器","slug":"构造器调用构造器","link":"#构造器调用构造器","children":[]}]},{"level":3,"title":"析构函数","slug":"析构函数","link":"#析构函数","children":[]}]},{"level":2,"title":"其他函数","slug":"其他函数","link":"#其他函数","children":[{"level":3,"title":"更改器方法与访问器方法（C++中的const成员函数）","slug":"更改器方法与访问器方法-c-中的const成员函数","link":"#更改器方法与访问器方法-c-中的const成员函数","children":[]},{"level":3,"title":"内联方法？","slug":"内联方法","link":"#内联方法","children":[]},{"level":3,"title":"方法参数","slug":"方法参数","link":"#方法参数","children":[]}]}]}],"git":{},"readingTime":{"minutes":4.34,"words":1303},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/Different/06. 面向对象/02. 类的内容/02. 类中函数.md","excerpt":"\\n<h1>目录</h1>\\n<h1>类中函数</h1>\\n<h2>成员/方法访问控制</h2>\\n<h3>访问控制关键字</h3>\\n<ul>\\n<li>C++\\n<ul>\\n<li>public、private关键字写在一组实例域和方法之前</li>\\n<li>访问控制关键字写在头文件而不写在实现文件中</li>\\n</ul>\\n</li>\\n<li>Java\\n<ul>\\n<li>public、private关键字写在每一个实例和方法之前</li>\\n<li>没有头文件、访问控制关键字直接写在实现文件中</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>static 静态方法</h3>\\n<p>好像C++中只有static方法才能操作static成员，但Java中似乎没有此限制</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/Different/06. 面向对象/02. 类的内容/02. 类中函数.md","value":{"title":"02. 类中函数","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/Different/06. 面向对象/02. 类的内容/02. 类中函数.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{d as comp,r as data};
