import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,e as i}from"./app-zmL0UxYu.js";const a={},n=i('<h1 id="包含和嵌套" tabindex="-1"><a class="header-anchor" href="#包含和嵌套"><span>包含和嵌套</span></a></h1><h2 id="_1-包含" tabindex="-1"><a class="header-anchor" href="#_1-包含"><span>(1) 包含</span></a></h2><ul><li>简概 <ul><li>包含（<em>contaionment</em>）、组合（<em>composition</em>）或层次化（<em>layering</em>）</li><li>被包含的类也叫组件类</li></ul></li><li>使用 <ul><li>在类中声明其他类的实例，调用时通过成员运算符访问其他类的接口方法</li></ul></li><li>使用场景 <ul><li>包含、私有继承，均可实现has-a关系</li><li>设计模式推荐使用包含（组合）代替继承</li></ul></li></ul><h2 id="_2-嵌套类-nested-class" tabindex="-1"><a class="header-anchor" href="#_2-嵌套类-nested-class"><span>(2) 嵌套类（<em>nested class</em>）</span></a></h2><h3 id="嵌套在类中结构声明-类-x-结构、类、枚举" tabindex="-1"><a class="header-anchor" href="#嵌套在类中结构声明-类-x-结构、类、枚举"><span>嵌套在类中结构声明（类 x 结构、类、枚举）</span></a></h3><ul><li>嵌套在类中 <ul><li>在类声明中声明结构、类、枚举，被称为被嵌套在类中</li><li>这里嵌套的不是具体的数据对象，而是模板，不会创建数据对象，<strong>而只是指定了可以在类中使用这种类型</strong></li></ul></li><li>使用 <ul><li>如果在私有部分声明，则只能在这个类使用被声明的类型</li><li>如果在公有部分声明，则可以用类的外部通过作用域解析运算符使用 <ul><li>例如：如果结构体<code>Node</code>在<code>Queue</code>的公有部分声明，则可以在类的外面声明<code>Queue::Node</code>类型的变量</li></ul></li></ul></li></ul>',6),o=[n];function s(c,r){return t(),l("div",null,o)}const p=e(a,[["render",s],["__file","03. 包含和嵌套.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/03.%20%E5%8C%85%E5%90%AB%E5%92%8C%E5%B5%8C%E5%A5%97.html","title":"包含和嵌套","lang":"zh-CN","frontmatter":{"description":"包含和嵌套 (1) 包含 简概 包含（contaionment）、组合（composition）或层次化（layering） 被包含的类也叫组件类 使用 在类中声明其他类的实例，调用时通过成员运算符访问其他类的接口方法 使用场景 包含、私有继承，均可实现has-a关系 设计模式推荐使用包含（组合）代替继承 (2) 嵌套类（nested class） 嵌...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/03.%20%E5%8C%85%E5%90%AB%E5%92%8C%E5%B5%8C%E5%A5%97.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"包含和嵌套"}],["meta",{"property":"og:description","content":"包含和嵌套 (1) 包含 简概 包含（contaionment）、组合（composition）或层次化（layering） 被包含的类也叫组件类 使用 在类中声明其他类的实例，调用时通过成员运算符访问其他类的接口方法 使用场景 包含、私有继承，均可实现has-a关系 设计模式推荐使用包含（组合）代替继承 (2) 嵌套类（nested class） 嵌..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"包含和嵌套\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"包含和嵌套","slug":"包含和嵌套","link":"#包含和嵌套","children":[{"level":2,"title":"(1) 包含","slug":"_1-包含","link":"#_1-包含","children":[]},{"level":2,"title":"(2) 嵌套类（nested class）","slug":"_2-嵌套类-nested-class","link":"#_2-嵌套类-nested-class","children":[{"level":3,"title":"嵌套在类中结构声明（类 x 结构、类、枚举）","slug":"嵌套在类中结构声明-类-x-结构、类、枚举","link":"#嵌套在类中结构声明-类-x-结构、类、枚举","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.93,"words":278},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/06. 面向对象/03. 类的重用/03. 包含和嵌套.md","autoDesc":true}');export{p as comp,h as data};
