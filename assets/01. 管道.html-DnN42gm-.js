import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,a as n}from"./app-5ajJQ-aM.js";const l="/assets/5-管道-pipe-DYbDHzf9.jpg",t="/assets/6-管道-pipe-fork-DZLp-wtC.jpg",i="/assets/7-管道-pipe-fork-单向通信-d_UwcuD0.jpg",o="/assets/8-管道-pipe-shell-Kshvyrvt.jpg",r={},p=n(`<h1 id="管道" tabindex="-1"><a class="header-anchor" href="#管道"><span>管道</span></a></h1><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h2><h3 id="shell版" tabindex="-1"><a class="header-anchor" href="#shell版"><span>Shell版</span></a></h3><h4 id="匿名管道" tabindex="-1"><a class="header-anchor" href="#匿名管道"><span>匿名管道</span></a></h4><p>如果你学过 Linux 命令，那你肯定很熟悉「<code>|</code>」这个竖线。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">ps</span> auxf <span class="token operator">|</span> <span class="token function">grep</span> mysql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入。 从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</p><h4 id="命名管道" tabindex="-1"><a class="header-anchor" href="#命名管道"><span>命名管道</span></a></h4><p>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p><p>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">mkfifo</span> myPipe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以<strong>管道也是以文件的方式存在</strong>，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span>
prw-r--r--. <span class="token number">1</span> root    root         <span class="token number">0</span> Jul <span class="token number">17</span> 02:45 myPipe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们往 myPipe 这个管道写入数据：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;hello&quot;</span> <span class="token operator">&gt;</span> myPipe  	<span class="token comment"># 将数据写进管道</span>
                         	<span class="token comment"># 停住了 ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">cat</span> <span class="token operator">&lt;</span> myPipe  			<span class="token comment"># 读取管道里的数据</span>
hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p><h3 id="系统调用版" tabindex="-1"><a class="header-anchor" href="#系统调用版"><span>系统调用版</span></a></h3><h4 id="匿名管道-1" tabindex="-1"><a class="header-anchor" href="#匿名管道-1"><span>匿名管道</span></a></h4><p>匿名管道的创建，需要通过下面这个系统调用：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。</p><p>注意，这个匿名管道是 <strong>特殊的文件，只存在于内存，不存于文件系统中</strong>。</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="系统调用版-1" tabindex="-1"><a class="header-anchor" href="#系统调用版-1"><span>系统调用版</span></a></h3><p>通过下面几个步骤来看：</p><h4 id="_1-创建管道" tabindex="-1"><a class="header-anchor" href="#_1-创建管道"><span>(1) 创建管道</span></a></h4><figure><img src="`+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><h4 id="_2-fork-复制文件符" tabindex="-1"><a class="header-anchor" href="#_2-fork-复制文件符"><span>(2) fork 复制文件符</span></a></h4><p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><figure><img src="'+t+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="_3-简化" tabindex="-1"><a class="header-anchor" href="#_3-简化"><span>(3) 简化</span></a></h4><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><figure><img src="'+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>所以说如果需要双向通信，则应该创建两个管道。</p><h3 id="shell版-1" tabindex="-1"><a class="header-anchor" href="#shell版-1"><span>shell版</span></a></h3><p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><h2 id="管道总结" tabindex="-1"><a class="header-anchor" href="#管道总结"><span>管道总结</span></a></h2><p>我们可以看出管道这种方式：</p><ul><li>缺点：<strong>效率低</strong>。管道这种通信方式效率低，不适合进程间频繁地交换数据。</li><li>优点：<strong>简单</strong>。同时也我们很容易得知管道里的数据已经被另一个进程读取了。</li><li>特点：传输的数据是<strong>无格式</strong>的流且<strong>大小受限</strong>、先进先出、不支持 lseek 之类的文件定位操作。本质是内核中的一串缓存</li></ul>',52),c=[p];function d(h,g){return a(),s("div",null,c)}const m=e(r,[["render",d],["__file","01. 管道.html.vue"]]),f=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/02.%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/01.%20%E7%AE%A1%E9%81%93.html","title":"管道","lang":"zh-CN","frontmatter":{"description":"管道 使用 Shell版 匿名管道 如果你学过 Linux 命令，那你肯定很熟悉「|」这个竖线。 上面命令行里的「|」竖线就是一个管道，它的功能是将前一个命令（ps auxf）的输出，作为后一个命令（grep mysql）的输入。 从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。 同时，我们得知上面这种管道是没有名...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/02.%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/01.%20%E7%AE%A1%E9%81%93.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"管道"}],["meta",{"property":"og:description","content":"管道 使用 Shell版 匿名管道 如果你学过 Linux 命令，那你肯定很熟悉「|」这个竖线。 上面命令行里的「|」竖线就是一个管道，它的功能是将前一个命令（ps auxf）的输出，作为后一个命令（grep mysql）的输入。 从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。 同时，我们得知上面这种管道是没有名..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"管道\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"管道","slug":"管道","link":"#管道","children":[{"level":2,"title":"使用","slug":"使用","link":"#使用","children":[{"level":3,"title":"Shell版","slug":"shell版","link":"#shell版","children":[{"level":4,"title":"匿名管道","slug":"匿名管道","link":"#匿名管道","children":[]},{"level":4,"title":"命名管道","slug":"命名管道","link":"#命名管道","children":[]}]},{"level":3,"title":"系统调用版","slug":"系统调用版","link":"#系统调用版","children":[{"level":4,"title":"匿名管道","slug":"匿名管道-1","link":"#匿名管道-1","children":[]}]}]},{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"系统调用版","slug":"系统调用版-1","link":"#系统调用版-1","children":[{"level":4,"title":"(1) 创建管道","slug":"_1-创建管道","link":"#_1-创建管道","children":[]},{"level":4,"title":"(2) fork 复制文件符","slug":"_2-fork-复制文件符","link":"#_2-fork-复制文件符","children":[]},{"level":4,"title":"(3) 简化","slug":"_3-简化","link":"#_3-简化","children":[]}]},{"level":3,"title":"shell版","slug":"shell版-1","link":"#shell版-1","children":[]}]},{"level":2,"title":"管道总结","slug":"管道总结","link":"#管道总结","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.01,"words":1503},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/02. 通信方式/01. 管道.md","autoDesc":true}');export{m as comp,f as data};
