import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,e as l}from"./app-DtBZtuIa.js";const d={},a=l(`<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="容器类" tabindex="-1"><a class="header-anchor" href="#容器类"><span>容器类</span></a></h1><h2 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h2><p>复习一下C++标准模板库的一些常见容器</p><ul><li>序列容器类 <ul><li>vector - 计算机矢量，deque - 双端队列，list - 链表（单向or双向），forward_list - 向前链表（C++11）</li></ul></li><li>适配器类 <ul><li>queue - 队列，priority_queue - 优先队列，stack</li></ul></li><li>关联容器 <ul><li>set，multimap</li></ul></li><li>无序关联容器 <ul><li>unordered_set，unordered_multiset，unordered_map，unordered_multimap</li></ul></li></ul><p>Qt容器类对比C++标准库中的容器类</p><ul><li>更轻量、更安全、更易用。速度、内存消耗和内联（inline）代码等方面进行了优化</li><li>存储在Qt容器中的数据必须是可赋值数据类型。即这种数据类型必须提供默认构造函数、复制构造函数、赋值操作运算符</li><li>Qt的Object及其子类必能够存储在容器中，但可以存储他们的指针</li><li>Qt的容器类可以嵌套，例如<code>QHash&lt;QString, QList&lt;double&gt; &gt;</code></li></ul><p>Qt容器类的遍历有两种方法</p><ul><li>Java风格的迭代器（<em>Java-style iterators</em>），使用起来更简单方便，但以轻微性能损耗为代价的</li><li>STL风格的迭代器（<em>STL-style iterators</em>），能够同Qt和STL通用算法一起使用，效率上略胜一筹</li></ul><h2 id="qlist、qlinkedlist、qvector" tabindex="-1"><a class="header-anchor" href="#qlist、qlinkedlist、qvector"><span>QList、QLinkedList、QVector</span></a></h2><table><thead><tr><th>容器类</th><th>查找</th><th>插入</th><th>头部添加</th><th>尾部添加</th></tr></thead><tbody><tr><td>QList</td><td>O(1)</td><td>O(n)</td><td>Amort.O(1)</td><td>Amort.O(1)</td></tr><tr><td>QLinkedList</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>QVector</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>Amort.O(1)</td></tr></tbody></table><p>其中，Amort.O(1)表示如果仅完成一次操作，可能会有O(n)行为，但如果完成多次操作（如n次），平均结果将会是O(1)</p><h3 id="qlist类" tabindex="-1"><a class="header-anchor" href="#qlist类"><span>QList类</span></a></h3><ul><li>简概：<code>QList&lt;T&gt;</code>是迄今为止最常用的容器类</li><li>子类：QItemSelection、QQueue、QSignalSpy、QStringList、QTestEventList</li><li>函数：<code>QList::append()</code>、<code>QList::prepend()</code>、<code>QList::insert()</code></li><li>性质：对于不同数据类型，<code>QList&lt;T&gt;</code>采用不同的存储策略 <ul><li>(1) 如果T是一个指针类型或指针大小的基本类型，会将数值直接存储在它的数组中</li><li>(2) 如果T是存储对象的指针，则该指针指向实际存储的对象</li><li>例子：</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;QDebug&gt;
int main(int argc,char *argv[]){
  QList&lt;QString&gt; list;						// 声明一个QList&lt;QString&gt;栈对象
  {
    QString str(&quot;This is a test string&quot;);
    list &lt;&lt; str;								// 将字符串存储在该列表中
  }											// 使用花括号，为验证这里是复制了对象
  qDebug()&lt;&lt;list[0]&lt;&lt;&quot;How are you!&quot;;
}
// 输出结果：&quot;This is a test string&quot; How are you!
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="qlinkedlist类" tabindex="-1"><a class="header-anchor" href="#qlinkedlist类"><span>QLinkedList类</span></a></h3><ul><li>简概：<code>QLinkedList&lt;T&gt;</code>是一个链式列表，以非连续的内存块保存数据</li></ul><h3 id="qvector类" tabindex="-1"><a class="header-anchor" href="#qvector类"><span>QVector类</span></a></h3><ul><li>简概：<code>QVector&lt;T&gt;</code>在相邻的内存中存储给定数据类型T的一组数值（不太懂）</li><li>子类：QPloygon、QPolygonF、QStack</li></ul><h3 id="java风格迭代器遍历容器" tabindex="-1"><a class="header-anchor" href="#java风格迭代器遍历容器"><span>Java风格迭代器遍历容器</span></a></h3><ul><li><p>只读迭代器和读写迭代器</p><ul><li>两种类型的Java风格迭代器数据类型，只读更快所以应尽可能使用只读迭代器</li><li><table><thead><tr><th>容器类</th><th>只读迭代器类</th><th>读写迭代器类</th></tr></thead><tbody><tr><td><code>QList&lt;T&gt;</code>、<code>QQueue&lt;T&gt;</code></td><td><code>QListIterator&lt;T&gt;</code></td><td><code>QMutableListIteraotr&lt;T&gt;</code></td></tr><tr><td><code>QLinkedList&lt;T&gt;</code></td><td><code>QLinkedListIterator&lt;T&gt;</code></td><td><code>QMutableLinkedListIterator&lt;T&gt;</code></td></tr><tr><td><code>QVector&lt;T&gt;</code>、<code>&lt;QStack&lt;T&gt;</code></td><td><code>QVectorIterator&lt;T&gt;</code></td><td><code>QMutableVectorIterator&lt;T&gt;</code></td></tr><tr><td><code>QMap&lt;Key,T&gt;</code>、<code>QMultiMap&lt;Key,T&gt;</code></td><td><code>QMapIteraotr&lt;Key,T&gt;</code></td><td><code>QMutableMapIterator&lt;Key,T&gt;</code></td></tr><tr><td><code>QHash&lt;Key,T&gt;</code>、<code>QMultiHash&lt;Key,T&gt;</code></td><td><code>QHashIterator&lt;Key,T&gt;</code></td><td><code>QMutableHashIterator&lt;Key,T&gt;</code></td></tr></tbody></table></li></ul></li><li><p>迭代点补充</p><ul><li>不同于STL风格的迭代器，Java风格迭代器的<code>迭代点</code>（<em>Java-style iterators point</em>）位于列表项的<strong>中间</strong>，而不是直接指向某个列表项</li></ul></li><li><p>只读迭代器例程</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;QCoreApplication&gt;
#include &lt;QDebug&gt;					// 包括了QList头文件，不需要 \`#include &lt;QList&gt;\`
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    QList&lt;int&gt; list;					// 声明容器类对象
    list&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5;
    QListIterator&lt;int&gt; i(list);			// 以list为参数初始化一个QListIterator只读迭代器对象i
    for(;i.hasNext();)
        qDebug()&lt;&lt;i.next();
    return a.exec();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>只读迭代器函数</p><ul><li><code>QListIterator&lt;T&gt;::toBack()</code>，将迭代点移动到最后一个列表项后面</li><li><code>QListIterator&lt;T&gt;::next()</code>，返回后一个列表项的内容<strong>并</strong>将迭代点移动到前一个列表项之前</li><li><code>QListIterator&lt;T&gt;::previous()</code>，返回前一个列表项的内容<strong>并</strong>将迭代点移动到前一个列表项之前</li><li><code>QListIterator&lt;T&gt;::hasNext()</code>，检查当前迭代点之后是否具有列表项</li><li><code>QListIterator&lt;T&gt;::hasPrevious()</code>，检查当前迭代点之前是否具有列表项</li><li><code>toFront()</code>，移动迭代点到列表的前端（第一个列表项前面）</li><li><code>peekNext()</code>，返回下一个列表项，但不移动迭代点</li><li><code>peekPrevious()</code>，返回前一个列表项，但不移动迭代点</li><li><code>findNext()</code>，从当前迭代点向后查找的列表项。若找到则返回true且迭代点位于匹配项后面，否则false且迭代点在列表的后端</li><li><code>findPrevious()</code>，与findNext类似，向前查找</li></ul></li><li><p>读写迭代器例程</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>  #include &lt;QCoreApplication&gt;
  #include &lt;QDebug&gt;
  int main(int argc, char *argv[])
  {
      QCoreApplication a(argc, argv);
      QList&lt;int&gt; list;					// 声明容器类对象
      QMutableListIterator&lt;int&gt; i(list);	// 根据容器类list创建读写迭代器
      for(int j=0;j&lt;10;++j)				// 插入，填充容器类内容
          i.insert(j);
      for(i.toFront();i.hasNext();)		// 向后遍历，并打印，输出：0 1 2 3 4 5 6 7 8 9
          qDebug()&lt;&lt;i.next();
      for(i.toBack();i.hasPrevious();) 	// 向前遍历，并移除和修改值
      {
          if(i.previous()%2==0)
              i.remove();
          else
              i.setValue(i.peekNext()*10);
      }
      for(i.toFront();i.hasNext();)		// 向后遍历，并打印，输出：10 30 50 70 90
          qDebug()&lt;&lt;i.next();
      return a.exec();
  } 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>读写迭代器函数（新增）</p><ul><li><code>insert()</code>，插入操作函数</li><li><code>remove()</code>，删除操作函数</li><li><code>setValue()</code>，修改数据函数</li></ul></li></ul><h3 id="stl风格迭代器遍历容器" tabindex="-1"><a class="header-anchor" href="#stl风格迭代器遍历容器"><span>STL风格迭代器遍历容器</span></a></h3><ul><li><p>只读迭代器和读写迭代器</p><ul><li><p>两种类型的STL风格迭代器数据类型，只读更快所以应尽可能使用只读迭代器</p></li><li><p>STL风格迭代器的API建立在指针操作基础上</p></li><li><table><thead><tr><th>容器类</th><th>只读迭代器</th><th>读写迭代器</th></tr></thead><tbody><tr><td><code>QList&lt;T&gt;</code>、<code>QQueue&lt;T&gt;</code></td><td><code>QList&lt;T&gt;::coust_iterator</code></td><td><code>QList&lt;T&gt;::iterator</code></td></tr><tr><td><code>QLinkedList&lt;T&gt;</code></td><td><code>QLinkedList&lt;T&gt;::coust_iterator</code></td><td><code>QLinkedList&lt;T&gt;::iterator</code></td></tr><tr><td><code>QVector&lt;T&gt;</code>、<code>QStack&lt;T&gt;</code></td><td><code>QVector&lt;T&gt;::const_iterator</code></td><td><code>QVector&lt;T&gt;::iterator</code></td></tr><tr><td><code>QMap&lt;Key,T&gt;</code>、<code>QMultiMap&lt;Key,T&gt;</code></td><td><code>QMapIteraotr&lt;Key,T&gt;</code></td><td><code>QMutableMapIterator&lt;Key,T&gt;</code></td></tr><tr><td><code>QHash&lt;Key,T&gt;</code>、<code>QMultiHash&lt;Key,T&gt;</code></td><td><code>QHashIterator&lt;Key,T&gt;</code></td><td><code>QMutableHashIterator&lt;Key,T&gt;</code></td></tr></tbody></table></li></ul></li><li><p>迭代点补充</p><ul><li>不同于Java风格的迭代器，STL风格迭代器的迭代点直接指向列表项</li></ul></li><li><p>STL迭代器例程</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>  #include &lt;QCoreApplication&gt;
  #include &lt;QDebug&gt;
  int main(int argc, char *argv[])
  {
      QCoreApplication a(argc, argv);
      QList&lt;int&gt; list;						// 初始化一个空的QList&lt;int&gt;列表
      for(int j=0;j&lt;10;j++)					// 填充容器
          list.insert(list.end(),j);
      QList&lt;int&gt;::iterator i;					// 初始化一个QList&lt;int&gt;::iterator读写迭代器（未赋值）
      for(i=list.begin();i!=list.end();++i)	// 往后遍历并调试输出并修改值
      {
             qDebug()&lt;&lt;(*i);					// 输出：0 1 2 3 4 5 6 7 8 9
             *i=(*i)*10;
      }
      QList&lt;int&gt;::const_iterator ci;			// 初始化一个QList&lt;int&gt;:: const_iterator读写迭代器
      for(ci=list.constBegin();ci!=list.constEnd();++ci)
              qDebug()&lt;&lt;*ci;					// 在控制台输出列表的所有值：0 10 20 30 40 50 60 70 80 90
      return a.exec();
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>STL迭代器函数</p><ul><li><code>*QList&lt;T&gt;::iterator</code>，迭代器本质是指针，可以通过迭代器指向列表项并修改列表项</li><li>返回<code>QList&lt;T&gt;::iterator</code>迭代器的函数 <ul><li><code>QList&lt;T&gt;::begin()</code>，返回指向第一个列表项的迭代器</li><li><code>QList&lt;T&gt;::end()</code>，返回指向最后一个列表项的迭代器</li><li><code>QList&lt;T&gt;::insert()</code>，第一个参数是迭代器<code>QList&lt;T&gt;::iterator</code></li></ul></li><li>返回<code>QList&lt;T&gt;::const_iterator</code>迭代器的函数 <ul><li><code>QList&lt;T&gt;::constBegin()</code>，返回指向第一个列表项的迭代器</li><li><code>QList&lt;T&gt;::constEnd()</code>，返回指向最后一个列表项的迭代器</li></ul></li></ul></li></ul><h2 id="qmap、qhash" tabindex="-1"><a class="header-anchor" href="#qmap、qhash"><span>QMap、QHash</span></a></h2><h3 id="qmap类" tabindex="-1"><a class="header-anchor" href="#qmap类"><span>QMap类</span></a></h3><h3 id="qhash类" tabindex="-1"><a class="header-anchor" href="#qhash类"><span>QHash类</span></a></h3><h3 id="java风格迭代器遍历容器-1" tabindex="-1"><a class="header-anchor" href="#java风格迭代器遍历容器-1"><span>Java风格迭代器遍历容器</span></a></h3><h3 id="stl风格迭代器遍历容器-1" tabindex="-1"><a class="header-anchor" href="#stl风格迭代器遍历容器-1"><span>STL风格迭代器遍历容器</span></a></h3>`,28),n=[a];function s(r,c){return e(),i("div",null,n)}const v=t(d,[["render",s],["__file","Qt容器类.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/00.%20%E6%8A%BD%E8%B1%A1%E7%B1%BB/Qt%E5%AE%B9%E5%99%A8%E7%B1%BB.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 容器类 简概 复习一下C++标准模板库的一些常见容器 序列容器类 vector - 计算机矢量，deque - 双端队列，list - 链表（单向or双向），forward_list - 向前链表（C++11） 适配器类 queue - 队列，priority_queue - 优先队列，stack 关联容器 set，multimap 无序关...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/00.%20%E6%8A%BD%E8%B1%A1%E7%B1%BB/Qt%E5%AE%B9%E5%99%A8%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 容器类 简概 复习一下C++标准模板库的一些常见容器 序列容器类 vector - 计算机矢量，deque - 双端队列，list - 链表（单向or双向），forward_list - 向前链表（C++11） 适配器类 queue - 队列，priority_queue - 优先队列，stack 关联容器 set，multimap 无序关..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"容器类","slug":"容器类","link":"#容器类","children":[{"level":2,"title":"简概","slug":"简概","link":"#简概","children":[]},{"level":2,"title":"QList、QLinkedList、QVector","slug":"qlist、qlinkedlist、qvector","link":"#qlist、qlinkedlist、qvector","children":[{"level":3,"title":"QList类","slug":"qlist类","link":"#qlist类","children":[]},{"level":3,"title":"QLinkedList类","slug":"qlinkedlist类","link":"#qlinkedlist类","children":[]},{"level":3,"title":"QVector类","slug":"qvector类","link":"#qvector类","children":[]},{"level":3,"title":"Java风格迭代器遍历容器","slug":"java风格迭代器遍历容器","link":"#java风格迭代器遍历容器","children":[]},{"level":3,"title":"STL风格迭代器遍历容器","slug":"stl风格迭代器遍历容器","link":"#stl风格迭代器遍历容器","children":[]}]},{"level":2,"title":"QMap、QHash","slug":"qmap、qhash","link":"#qmap、qhash","children":[{"level":3,"title":"QMap类","slug":"qmap类","link":"#qmap类","children":[]},{"level":3,"title":"QHash类","slug":"qhash类","link":"#qhash类","children":[]},{"level":3,"title":"Java风格迭代器遍历容器","slug":"java风格迭代器遍历容器-1","link":"#java风格迭代器遍历容器-1","children":[]},{"level":3,"title":"STL风格迭代器遍历容器","slug":"stl风格迭代器遍历容器-1","link":"#stl风格迭代器遍历容器-1","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.94,"words":1782},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/04. Project/Platform/Multi/QT（Cpp）/03. Qt其他类（按功能）/00. 抽象类/Qt容器类.md","autoDesc":true}');export{v as comp,h as data};
