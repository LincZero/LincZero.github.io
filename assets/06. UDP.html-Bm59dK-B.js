import{_ as o,c as d,e as c,o as t}from"./app-CAfWfcmi.js";const a={};function n(i,e){return t(),d("div",null,e[0]||(e[0]=[c('<h1 id="udp" tabindex="-1"><a class="header-anchor" href="#udp"><span>UDP</span></a></h1><h2 id="udp-格式" tabindex="-1"><a class="header-anchor" href="#udp-格式"><span>UDP 格式</span></a></h2><p><code>UDP</code>是一种对象数据报的传输层协议，它不提供可靠性，其数据报被封装在<code>IP</code>数据报中，封装格式如下图所示：</p><p>![UDP封装格式](06. UDP.assets/UDP-packaging-format.png)</p><p>首部格式为</p><p>![UDP头](06. UDP.assets/UDP-header.jpg)</p><ul><li>源端口号和目的端口号分表表示了发送进程和接收进程</li><li><code>UDP</code>长度字段包括了<code>UDP</code>首部和<code>UDP</code>数据的字节长度</li><li><code>UDP</code>检验和覆盖了<code>UDP</code>首部和<code>UDP</code>数据（<code>IP</code>首部检验和只覆盖了<code>IP</code>首部，不覆盖数据报中的任何数据）</li><li><code>UDP</code>数据报的长度可以为奇数字节，但是检验和算法是把若干个<code>16bit</code>字相加。解决方法是必要时在最后增加填充字节0，</li></ul><p>这只是为了检验和的计算。<code>UDP</code>数据报和<code>TCP</code>段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含<code>IP</code>首部一些字段。</p><h2 id="ip-分片" tabindex="-1"><a class="header-anchor" href="#ip-分片"><span>IP 分片</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><p>以太网和<code>802.3</code>对数据帧的长度都有一个限制，其最大值分别是<code>1500</code>和<code>1492</code>个字节。链路层的这个特性称作 MTU。不同类型的网络大多数都有一个上限。如果IP层有一个数据要传，且数据的长度比链路层的 MTU 还大，那么 IP 层就要进行分片（fragmentation），把数据报分成若干片，这样每一个分片都小于 MTU。当 IP 数据报被分片后，每一片都成为一个分组，具有自己的 IP 首部，并在选择路由时与其他分组独立。</p><p>把一份 IP 数据报进行分片以后，由到达目的端的 IP 层来进行重新组装，其目的是使分片和重新组装过程对运输层（TCP/UDP）是透明的。由于每一分片都是一个独立的包，当这些数据报的片到达目的端时有可能会失序，但是在 IP 首部中有足够的信息让接收端能正确组装这些数据报片。</p><h3 id="缺点-丢片要全部重传" tabindex="-1"><a class="header-anchor" href="#缺点-丢片要全部重传"><span>缺点：丢片要全部重传</span></a></h3><p>尽管 IP 分片过程看起来透明的，但有一点让人不想使用它：即使<em>只丢失一片数据也要重新传整个数据报</em></p><p>why？因为 IP 层本身没有超时重传机制------由更高层（比如 TCP）来负责超时和重传。当来自 TCP 报文段的某一片丢失后，TCP 在超时后会重发整个TCP报文段，该报文段对应于一份 IP 数据报（而不是一个分片），没有办法只重传数据报中的一个数据分片。</p><h3 id="tcp分片能避免ip分片-udp不能" tabindex="-1"><a class="header-anchor" href="#tcp分片能避免ip分片-udp不能"><span>TCP分片能避免IP分片，UDP不能</span></a></h3><p>使用 UDP 很容易导致 IP 分片，TCP 试图避免 IP 分片。那么 TCP 是如何试图避免 IP 分片的呢？</p><p>其实说白了，采用 TCP 协议进行数传输是不会造成 IP 分片的，因为一旦 TCP 数据过大，超过了 MSS，则在传输层会对 TCP 包进行分段（如何分，见下文！），自然到了 IP 层的数据报肯定不会超过 MTU，当然也就不用分片了。而对于 UDP 数据报，如果 UDP 组成的IP数据报长度超过了 1500，那么 IP 数据报显然就要进行分片，因为 UDP 不能像 TCP 一样自己进行分段。</p><h3 id="最大分段大小-mss-maxitum-segment-size" tabindex="-1"><a class="header-anchor" href="#最大分段大小-mss-maxitum-segment-size"><span>最大分段大小（MSS, Maxitum Segment Size）</span></a></h3><p>MSS（Maxitum Segment Size）最大分段大小的缩写，是 TCP 协议里面的一个概念</p><h4 id="确定mss大小" tabindex="-1"><a class="header-anchor" href="#确定mss大小"><span>确定MSS大小</span></a></h4><p><code>MSS</code>就是TCP数据包每次能够传输的最大数据分段。为了达到最佳的传输效能<code>TCP</code>协议在建立连接的时候通常要协商双方的<code>MSS</code>值，这个值<code>TCP</code>协议在实现的时候往往用<code>MTU</code>值代替（需要减去<code>IP</code>数据包包头的大小<code>20Bytes</code>和<code>TCP</code>数据段的包头<code>20Bytes</code>）所以往往<code>MSS</code>为<code>1460</code>。通讯双方会根据双方提供的<code>MSS</code>值得最小值确定为这次连接的最大MSS值。</p><h4 id="如何实现分段" tabindex="-1"><a class="header-anchor" href="#如何实现分段"><span>如何实现分段</span></a></h4><p>相信看到这里，还有最后一个问题：<code>TCP</code>是如何实现分段的呢？其实<code>TCP</code>无所谓分段，因为每个<code>TCP</code>数据报在组成前其大小就已经被<code>MSS</code>限制了，所以<code>TCP</code>数据报的长度是不可能大于<code>MSS</code>的，当然由它形成的IP包的长度也就不会大于<code>MTU</code>，自然也就不用<code>IP</code>分片了。</p><p>![UDP和IP](06. UDP.assets/UDP-and-IP.png)</p><ul><li>发生 ICMP 不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在 IP 首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小 MTU 是多少—称作路径<code>MTU</code>发现机制，那么这个差错就可以被该程序使用。</li><li>理论上，UDP 数据的最大长度为：<code>65535-20</code>字节 IP 首部长度<code>-8</code>字节 UDP 首部长度=<code>65507</code>。但是大多是实现都比这个值小，主要是受限于<code>socket</code>接口以及 TCP/IP 内核的限制。大部分系统都默认提供了可读写大于<code>8192</code>字节的 UDP 数据报。</li><li>当目标主机的处理速度赶不上数据接收的速度，因为接受主机的 IP 层缓存会被占满，所以主机就会发出一个 ICMP 源站抑制差错报文。</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://en.wikipedia.org/wiki/User_Datagram_Protoco" target="_blank" rel="noopener noreferrer">User Datagram Protocol</a></li><li><a href="https://www.ietf.org/rfc/rfc768.txt" target="_blank" rel="noopener noreferrer">UDP - IETF</a></li></ul>',28)]))}const P=o(a,[["render",n],["__file","06. UDP.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8Btonydeng/02.%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/06.%20UDP.html","title":"UDP","lang":"zh-CN","frontmatter":{"description":"UDP UDP 格式 UDP是一种对象数据报的传输层协议，它不提供可靠性，其数据报被封装在IP数据报中，封装格式如下图所示： ![UDP封装格式](06. UDP.assets/UDP-packaging-format.png) 首部格式为 ![UDP头](06. UDP.assets/UDP-header.jpg) 源端口号和目的端口号分表表示了发送...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8Btonydeng/02.%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/06.%20UDP.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"UDP"}],["meta",{"property":"og:description","content":"UDP UDP 格式 UDP是一种对象数据报的传输层协议，它不提供可靠性，其数据报被封装在IP数据报中，封装格式如下图所示： ![UDP封装格式](06. UDP.assets/UDP-packaging-format.png) 首部格式为 ![UDP头](06. UDP.assets/UDP-header.jpg) 源端口号和目的端口号分表表示了发送..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"UDP\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"UDP","slug":"udp","link":"#udp","children":[{"level":2,"title":"UDP 格式","slug":"udp-格式","link":"#udp-格式","children":[]},{"level":2,"title":"IP 分片","slug":"ip-分片","link":"#ip-分片","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"缺点：丢片要全部重传","slug":"缺点-丢片要全部重传","link":"#缺点-丢片要全部重传","children":[]},{"level":3,"title":"TCP分片能避免IP分片，UDP不能","slug":"tcp分片能避免ip分片-udp不能","link":"#tcp分片能避免ip分片-udp不能","children":[]},{"level":3,"title":"最大分段大小（MSS, Maxitum Segment Size）","slug":"最大分段大小-mss-maxitum-segment-size","link":"#最大分段大小-mss-maxitum-segment-size","children":[{"level":4,"title":"确定MSS大小","slug":"确定mss大小","link":"#确定mss大小","children":[]},{"level":4,"title":"如何实现分段","slug":"如何实现分段","link":"#如何实现分段","children":[]}]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}]}],"git":{},"readingTime":{"minutes":4.62,"words":1387},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》tonydeng/02. 网络基础理论/06. UDP.md","excerpt":"\\n<h2>UDP 格式</h2>\\n<p><code>UDP</code>是一种对象数据报的传输层协议，它不提供可靠性，其数据报被封装在<code>IP</code>数据报中，封装格式如下图所示：</p>\\n<p>![UDP封装格式](06. UDP.assets/UDP-packaging-format.png)</p>\\n<p>首部格式为</p>\\n<p>![UDP头](06. UDP.assets/UDP-header.jpg)</p>\\n<ul>\\n<li>源端口号和目的端口号分表表示了发送进程和接收进程</li>\\n<li><code>UDP</code>长度字段包括了<code>UDP</code>首部和<code>UDP</code>数据的字节长度</li>\\n<li><code>UDP</code>检验和覆盖了<code>UDP</code>首部和<code>UDP</code>数据（<code>IP</code>首部检验和只覆盖了<code>IP</code>首部，不覆盖数据报中的任何数据）</li>\\n<li><code>UDP</code>数据报的长度可以为奇数字节，但是检验和算法是把若干个<code>16bit</code>字相加。解决方法是必要时在最后增加填充字节0，</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》tonydeng/02. 网络基础理论/06. UDP.md","value":{"title":"06. UDP","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》tonydeng/02. 网络基础理论/06. UDP.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{P as comp,p as data};
