import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as s,e as a}from"./app-yixEWCFr.js";const p="/assets/块组-CSWFR7up.png",i={},l=a('<h1 id="文件系统的结构" tabindex="-1"><a class="header-anchor" href="#文件系统的结构"><span>文件系统的结构</span></a></h1><p>前面提到 Linux 是用位图的方式管理空闲空间。</p><ol><li>创建新文件时分配inode：用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配</li><li>存储数据时分配块：要存储数据时，会通过块的位图找到空闲的块，并分配</li></ol><h2 id="大文件问题-——-块组" tabindex="-1"><a class="header-anchor" href="#大文件问题-——-块组"><span>大文件问题 —— 块组</span></a></h2><p>先区分一下</p><ul><li>逻辑块/块 (大小单位)</li><li>超级块：Size 1块，存全局信息</li><li>数据块：Size N块，（存文件内容？文件块？）</li><li>块组：见后</li></ul><p>原方案</p><p>但仔细计算一下还是有问题的</p><p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 <code>4 * 1024 * 8 = 2^15</code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 <code>2^15 * 4 * 1024 = 2^27</code> 个 byte，也就是 128M。</p><p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。</p><p>块组方案</p><p>在 Linux 文件系统，把这个结构称为一个<strong>块组</strong>，那么有 N 多的块组，就能够表示 N 大的文件（哈？是N个块组还是块组里有N个数据块？表示的是N这么大还是N个大的文件）</p><p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：</p><figure><img src="'+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：</p><ul><li><p><em>超级块（全局、重复）</em>，包含的是文件系统的重要信息，比如 <strong>inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等</strong>。</p><ul><li><p>这个可以通过命令 <code>df -i</code> 和 <code>df -l</code> 查看</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">df</span> <span class="token parameter variable">-i</span>
文件系统        Inodes  已用I   可用I 已用I% 挂载点
tmpfs          <span class="token number">2031005</span>   <span class="token number">1482</span> <span class="token number">2029523</span>     <span class="token number">1</span>% /run
/dev/sda5      <span class="token number">7749632</span> <span class="token number">246137</span> <span class="token number">7503495</span>     <span class="token number">4</span>% /
tmpfs          <span class="token number">2031005</span>      <span class="token number">1</span> <span class="token number">2031004</span>     <span class="token number">1</span>% /dev/shm
tmpfs          <span class="token number">2031005</span>      <span class="token number">4</span> <span class="token number">2031001</span>     <span class="token number">1</span>% /run/lock
/dev/sda2            <span class="token number">0</span>      <span class="token number">0</span>       <span class="token number">0</span>      - /boot/efi
tmpfs           <span class="token number">406201</span>    <span class="token number">159</span>  <span class="token number">406042</span>     <span class="token number">1</span>% /run/user/1000
$ <span class="token function">df</span> <span class="token parameter variable">-l</span>
文件系统          1K的块     已用      可用 已用% 挂载点
tmpfs            <span class="token number">1624804</span>     <span class="token number">2244</span>   <span class="token number">1622560</span>    <span class="token number">1</span>% /run
/dev/sda5      <span class="token number">121451184</span> <span class="token number">14523436</span> <span class="token number">100712224</span>   <span class="token number">13</span>% /
tmpfs            <span class="token number">8124020</span>        <span class="token number">0</span>   <span class="token number">8124020</span>    <span class="token number">0</span>% /dev/shm
tmpfs               <span class="token number">5120</span>        <span class="token number">4</span>      <span class="token number">5116</span>    <span class="token number">1</span>% /run/lock
/dev/sda2         <span class="token number">524252</span>     <span class="token number">6220</span>    <span class="token number">518032</span>    <span class="token number">2</span>% /boot/efi
tmpfs            <span class="token number">1624804</span>      <span class="token number">120</span>   <span class="token number">1624684</span>    <span class="token number">1</span>% /run/user/1000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><em>块组描述符（全局、重复）</em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</p></li><li><p><em>数据位图和 inode 位图</em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</p></li><li><p><em>inode 列表</em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</p></li><li><p><em>数据块</em>，包含文件的有用数据。</p></li></ul><h2 id="重复信息-为什么重复、优化方案" tabindex="-1"><a class="header-anchor" href="#重复信息-为什么重复、优化方案"><span>重复信息（为什么重复、优化方案）</span></a></h2><p>你可以会发现每个块组里有很多重复的信息，比如 <strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要</strong>，这么做是有两个原因：</p><ul><li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。</li><li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</li></ul><p>不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。</p>`,20),t=[l];function o(r,c){return e(),s("div",null,t)}const u=n(i,[["render",o],["__file","06. 文件系统的结构.html.vue"]]),E=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/07.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/06.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84.html","title":"文件系统的结构","lang":"zh-CN","frontmatter":{"description":"文件系统的结构 前面提到 Linux 是用位图的方式管理空闲空间。 创建新文件时分配inode：用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配 存储数据时分配块：要存储数据时，会通过块的位图找到空闲的块，并分配 大文件问题 —— 块组 先区分一下 逻辑块/块 (大小单位) 超级块：Size 1块...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/07.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/06.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"文件系统的结构"}],["meta",{"property":"og:description","content":"文件系统的结构 前面提到 Linux 是用位图的方式管理空闲空间。 创建新文件时分配inode：用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配 存储数据时分配块：要存储数据时，会通过块的位图找到空闲的块，并分配 大文件问题 —— 块组 先区分一下 逻辑块/块 (大小单位) 超级块：Size 1块..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文件系统的结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"文件系统的结构","slug":"文件系统的结构","link":"#文件系统的结构","children":[{"level":2,"title":"大文件问题 —— 块组","slug":"大文件问题-——-块组","link":"#大文件问题-——-块组","children":[]},{"level":2,"title":"重复信息（为什么重复、优化方案）","slug":"重复信息-为什么重复、优化方案","link":"#重复信息-为什么重复、优化方案","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.48,"words":1045},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/07. 文件系统/06. 文件系统的结构.md","autoDesc":true}');export{u as comp,E as data};
