import{_ as n,e as a,g as i,o as e}from"./app-HvNDXJEG.js";const l={};function p(d,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h1><p>大话设计模式-职责链模式</p><p>https://localhost.blog.csdn.net/article/details/90202435</p><p>大话设计模式-系列文章(共50篇)：</p><p>https://blog.csdn.net/qq_41113081/category_8723350.html</p><h2 id="错题" tabindex="-1"><a class="header-anchor" href="#错题"><span>错题</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>以下哪个模式可以利用一个对象，快速地生成一批对象？（）</span></span>
<span class="line"><span>抽象工厂模式</span></span>
<span class="line"><span>单例模式</span></span>
<span class="line"><span>原型模式.</span></span>
<span class="line"><span>简单工厂模式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答案C。我选D，看错题了，是利用对象生成对象而不是利用类生成对象</p><h3 id="傻逼题" tabindex="-1"><a class="header-anchor" href="#傻逼题"><span>（傻逼题）</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>通过电视机遥控器可以实现对电视机频道进行选择，其实选择电视机频道就是对存放频道的集合进行遍历操作。所以可以使用（ ）模拟电视机遥控器的实现</span></span>
<span class="line"><span></span></span>
<span class="line"><span>命令模式</span></span>
<span class="line"><span>观察者模式</span></span>
<span class="line"><span>迭代器模式</span></span>
<span class="line"><span>单例模式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正确答案：C，你的答案：A/B。</p><p>重点是对集合进行遍历操作，遍历操作，遍历操作。</p><p>迭代器模式使用场景：</p><p>1、访问聚合对象的内容不需要暴露其内部表示。2、需要为聚合对象提供多种遍历方式。3、为了遍历不同的聚合结构对象提供统一的接口。</p><p>感觉有点low，评论争议比较大</p><h3 id="访问者模式" tabindex="-1"><a class="header-anchor" href="#访问者模式"><span>访问者模式</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>某高校奖励审批系统可以实现教师奖励和学生奖励的审批(AwardCheck)，如果教师发表论文数超过10篇或者学生论文超过2篇可以评选科研奖，如果教师教学反馈分大于等于90分或者学生平均成绩大于等于90分可以评选成绩优秀奖。奖励审批系统可以使用（）设计该系统，以判断候选人集合中的教师或学生是否符合某种获奖要求。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>工厂方法模式</span></span>
<span class="line"><span>访问者模式</span></span>
<span class="line"><span>模板方法模式</span></span>
<span class="line"><span>责任链</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正确答案：B，你的答案：D</p><p>学生和老师是两个不同的访问者</p><p>访问者模式是将数据结构与对数据的操作分离开来，适用于数据结构稳定，但数据操作多变的系统，题中对于获取成绩优秀奖的数据结构是稳定的，但访问者有多个，比如学生，老师，所以适用访问者设计模式</p><p>访问者模式实际上就是把数据和对数据的访问解耦，数据的存储是一致的：论文发表数和分数，对数据的访问方式(是否获奖)却不同，因此使用访问者模式。</p><h3 id="几种工厂模式" tabindex="-1"><a class="header-anchor" href="#几种工厂模式"><span>几种工厂模式</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>下面的选项中哪些属于工厂模式()</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>静态工厂模式</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>工厂方法模式</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>抽象工厂模式</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>简单工厂模式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正确答案：BCD，你的答案：ABCD。为什么静态工厂模式不算？</p><p>工厂模式可理解为：当客户获取产品时，工厂模式作为获取产品的接口。</p><p>1、简单工厂模式：由接口直接负责获取产品</p><p>2、工厂方法模式：客户必须清楚地指出想获取哪种产品；由接口的子类负责获取产品</p><p>3、抽象工厂模式：客户不知道其想获取哪种产品；由接口中判断调用哪个子类，通过子类获取产品。</p><h2 id="不确定" tabindex="-1"><a class="header-anchor" href="#不确定"><span>不确定</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>现在大多数软件都有撤销(Undo)的功能，快捷键一般都是Ctrl+Z。这些软件可能使用了（）模式来进行。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>备忘录模式</span></span>
<span class="line"><span>访问者模式</span></span>
<span class="line"><span>模板方法模式</span></span>
<span class="line"><span>责任链</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>购物车设计：顾客在超市中将选择的商品，如苹果、图书等放在购物车中，然后到收银员处付款。在购物过程中，顾客需要对这些商品进行访问，以便确认这些商品的质量，之后收银员计算价格时也需要访问购物车内顾客所选择的商品。购物车设计可以使用（）来设计该购物过程。</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>工厂方法模式</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>访问者模式</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>模板方法模式</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>责任链</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我B</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>如果让你来实现前端的MVVM框架，View层需要支持不同终端的不同交互，下面哪些设计模式不太适合用来实现这个需求（）</span></span>
<span class="line"><span>单例模式</span></span>
<span class="line"><span>观察者模式</span></span>
<span class="line"><span>适配器模式</span></span>
<span class="line"><span>代理模式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>在现实生活中，居民身份证号码具有唯一性，居民可以申请身份证号码或补办身份证号码（还是使用原来的身份证号码，不会产生新的号码）。我们可以使用（）来模拟实现居民身份证号码办理。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>命令模式</span></span>
<span class="line"><span>桥接</span></span>
<span class="line"><span>单例模式</span></span>
<span class="line"><span>责任链</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>都不像的样子……C。评论都说这题很抽象</p><h2 id="不会" tabindex="-1"><a class="header-anchor" href="#不会"><span>不会</span></a></h2><h3 id="打印池" tabindex="-1"><a class="header-anchor" href="#打印池"><span>打印池</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>打印池在操作系统中是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级。我们可以使用（）来模拟实现打印池的设计</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>命令模式</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>桥接</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>责任链</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>单例模式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果居然是D</p><p>一个系统只允许存在一个打印池对象，打印池是管理多台打印机的作用，看到池就想享元是不对的</p><h3 id="外观模式" tabindex="-1"><a class="header-anchor" href="#外观模式"><span>外观模式</span></a></h3><p>下列描述中，哪些是外观模式的特点（ ），多选</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A</span></span>
<span class="line"><span>对客户端屏蔽了子系统组件</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>实现了子系统与客户端之间的紧耦合关系</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>单个子系统的修改不影响其他子系统</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>子系统类变化时，只需要修改外观类即可</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ACD，蒙对了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>以下关于外观模式的叙述中正确是（      ）</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>外观模式符合单一职责原则</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>在外观模式中，一个子系统的外部与内部通信通过统一的外观对象进行</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>在外观模式中，客户类只需要直接与外观对象进行交互</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>外观模式是迪米特法则的一种具体实现</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BCD蒙对了，不过D是什么东西</p><p>迪米特法则：最小知识原则，一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>假设一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备，可以使用（) 来模拟设计该系统。</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>外观模式</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>观察者模式</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>迭代器模式</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>单例模式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正确答案：A，你的答案：C</p><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p><p>电源总开关是四盏灯、一个风扇、一台空调和一台电视机的外观。有了外观以后，启动和关闭这些电器设备都简化了。</p><p>直接 new 一个总开关。</p><p>在 new 总开关的同时把灯、风扇、空调和电视机都初始化好并且接好线。</p><p>对外暴露方法（打开总开关，关闭总开关）。</p><p>打开总开关（按一下开关键）：打开灯、风扇、空调和电视机</p><p>关闭总开关（按一下开关键）：关闭灯、风扇、空调和电视机</p><h3 id="解释器模式" tabindex="-1"><a class="header-anchor" href="#解释器模式"><span>解释器模式</span></a></h3><h3 id="责任链" tabindex="-1"><a class="header-anchor" href="#责任链"><span><s>责任链</s></span></a></h3><p>解释器重在解释；<br> 装饰器重在扩展；<br> 桥联重在连接不同的东西；<br> 责任链重在<strong>传递请求</strong>，这个Handler传到ConcreteHandler能明显看出是责任链了；</p><h2 id="怪题" tabindex="-1"><a class="header-anchor" href="#怪题"><span>怪题</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> 策略模式的结构中包括三种角色上下文、具体策略和抽象策略。抽象策略角色是一个（ ）</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>类</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>抽象类</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>接口</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>子类</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正确答案：C，你的答案：B</p><p>这个题目有点问题。抽象策略角色，在C++中是抽象类，在Java中是接口</p><h2 id="复习" tabindex="-1"><a class="header-anchor" href="#复习"><span>复习</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> 某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络中的最大子网个数、每个子网内的最大可分配地址个数分别是（）。</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>32，8</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>32，6</span></span>
<span class="line"><span>C</span></span>
<span class="line"><span>8，32</span></span>
<span class="line"><span>D</span></span>
<span class="line"><span>8，30</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>B。主机需去掉全0和全1</p>`,68)]))}const r=n(l,[["render",p],["__file","设计模式.html.vue"]]),t=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/10.%20%E9%9D%A2%E8%AF%95/%E7%89%9B%E5%AE%A2/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","title":"设计模式","lang":"zh-CN","frontmatter":{"description":"设计模式 大话设计模式-职责链模式 https://localhost.blog.csdn.net/article/details/90202435 大话设计模式-系列文章(共50篇)： https://blog.csdn.net/qq_41113081/category_8723350.html 错题 答案C。我选D，看错题了，是利用对象生成对象而不...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/10.%20%E9%9D%A2%E8%AF%95/%E7%89%9B%E5%AE%A2/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"设计模式"}],["meta",{"property":"og:description","content":"设计模式 大话设计模式-职责链模式 https://localhost.blog.csdn.net/article/details/90202435 大话设计模式-系列文章(共50篇)： https://blog.csdn.net/qq_41113081/category_8723350.html 错题 答案C。我选D，看错题了，是利用对象生成对象而不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":6.94,"words":2083},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/10. 面试/牛客/设计模式.md","excerpt":"\\n<p>大话设计模式-职责链模式</p>\\n<p>https://localhost.blog.csdn.net/article/details/90202435</p>\\n<p>大话设计模式-系列文章(共50篇)：</p>\\n<p>https://blog.csdn.net/qq_41113081/category_8723350.html</p>\\n<h2>错题</h2>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>以下哪个模式可以利用一个对象，快速地生成一批对象？（）</span></span>\\n<span class=\\"line\\"><span>抽象工厂模式</span></span>\\n<span class=\\"line\\"><span>单例模式</span></span>\\n<span class=\\"line\\"><span>原型模式.</span></span>\\n<span class=\\"line\\"><span>简单工厂模式</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/10. 面试/牛客/设计模式.md","value":{"title":"设计模式","path":"MdNote_Public/01. DesignAndDevelop/Develop/10. 面试/牛客/设计模式.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{r as comp,t as data};
