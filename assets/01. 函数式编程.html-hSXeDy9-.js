import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,e as d}from"./app-DtBZtuIa.js";const a={},c=d(`<h1 id="函数式编程" tabindex="-1"><a class="header-anchor" href="#函数式编程"><span>函数式编程</span></a></h1><h2 id="自定义函数" tabindex="-1"><a class="header-anchor" href="#自定义函数"><span>自定义函数</span></a></h2><h3 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h3><ul><li>使用函数要素 <ul><li>提供函数定义 + 提供函数原型 + 调用函数</li><li>函数原型可隐藏于头文件中</li></ul></li><li>定义和使用的位置 <ul><li>总结就是：函数定义在前还是在后都无所谓（解释型语言必须放在前面），但函数原型声明需要放在使用前（解释型语言不需要声明函数原型）</li></ul></li><li>函数原型的作用 <ul><li>作用：描述了<code>编译器的接口</code><ul><li>编译器正确处理函数返回值（知道如何从寄存器或内存中检索多少字节以及如何解释它们）</li><li>编译器检查参数数目是否正确</li><li>编译器检查参数类型是否正确，如果不匹配则尝试自动类型转换</li></ul></li><li>补充 <ul><li>原型的参数列表可以包括也可以不包括变量名，而且其变量名相当于占位符，可以与函数定义的变量名不同（即可用于备注说明）</li><li>ANSI C中，原型是可选的。但在C++中，原型是必须的</li><li>在编译阶段进行的原型化被称为<code>静态类型检查</code>（<em>static type checking</em>），可捕获去躲在运行阶段难以捕获的错误</li></ul></li></ul></li><li>返回值的底层原理 <ul><li>做法 <ul><li>函数通过将返回值赋值到指定的CPU寄存器或内存单元（主存）中将其返回</li><li>随后调用程序将查看该内存单元，并以函数原型所声明的类型返回出去</li></ul></li><li>原因 <ul><li>为什么不能放在原来的内存？因为函数周期结束后函数栈会连同内部的数据一起被销毁（局部变量的生命周期的原理）</li><li>为什么返回值不能是数组？因为怕数组太大？</li></ul></li></ul></li></ul><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><h4 id="使用-1" tabindex="-1"><a class="header-anchor" href="#使用-1"><span>使用</span></a></h4><ul><li><p>通用</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void functionName(parameterList)
{
    statement(s)
    return;
}
// 或
typeName  functionName(parameterList)
{
    statement(s)
    return value;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>举例</p><div class="language-C++ line-numbers-mode" data-ext="C++" data-title="C++"><pre class="language-C++"><code>include &lt;iostream&gt;
using namespace std;

int main()
{
    void simon(int);
    simon(3);
    return 0;
}
void simon(int n)
{
    cout &lt;&lt; n &lt;&lt; endl;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="不同的类型" tabindex="-1"><a class="header-anchor" href="#不同的类型"><span>不同的类型</span></a></h4><ul><li>不接受参数 <ul><li>显式声明：<code>int rand(void)</code></li><li>隐式声明：<code>int rand()</code></li></ul></li><li>函数返回值 <ul><li>无返回值：<code>void functionName(parameterList)</code></li><li>有返回值：<code>typeName functionName(parameterList)</code></li><li>但注意返回值类型不能是数组（可以是整型、浮点数、指针、甚至结构和对象）（故可以通过将数组作为结构或对象组成部分来返回）</li></ul></li></ul><h2 id="递归思想" tabindex="-1"><a class="header-anchor" href="#递归思想"><span>递归思想</span></a></h2><p>递归：C++函数可以自己调用自己，形成调用链（C++中<code>main()</code>不能调用自己而C可以）</p><p>递归中的一些情况：每次递归会有一个内存单元，同一个变量名在不同的内存单元中可能不同</p><p>尾调用：有的编译器/解释器还会进行一个<code>尾调用优化</code>，以优化栈内存，防止栈溢出</p><h2 id="c-函数新特性-与c不同" tabindex="-1"><a class="header-anchor" href="#c-函数新特性-与c不同"><span>C++函数新特性（与C不同）</span></a></h2><table><thead><tr><th>新特性</th><th>目的</th></tr></thead><tbody><tr><td>内联函数</td><td>提高效率</td></tr><tr><td>按引用传递变量</td><td>简化指针表示、提高传参效率和返回效率、适用于结构/类</td></tr><tr><td>默认的参数值</td><td>方便</td></tr><tr><td>函数重载（多态）</td><td>允许有多个同名函数</td></tr><tr><td>模板函数</td><td>函数重载的更简便版本</td></tr></tbody></table><h3 id="内联函数" tabindex="-1"><a class="header-anchor" href="#内联函数"><span>内联函数</span></a></h3><ul><li><p>底层原理：操作系统将指令载入到内存中，每条指令都有特定的内存地址。计算机执行这些指令，有时跳过一些指令，向前或向后跳到特定地址</p><ul><li>非内联函数：函数调用时会跳到函数的地址，并在函数结束时返回 函数调用后立即存储该指令的内存地址，并将函数参数赋值到堆栈，调到标记函数起点的内存单元，执行函数（有时还传入返回值），然后调到地址被保存的指令处 来回跳转意味着需要一定的开销</li><li>内敛函数：使用响应的函数代码<strong>替换函数调用</strong>。使用的是预处理机制</li></ul></li><li><p>比较</p><ul><li>内联函数：稍微快，但占用更多内存（每调用一次函数就生成一个函数副本）</li><li>Q：如果是这个原因的话，默认构造函数和空析构函数写成内联函数会不会比在cpp中实现更好？（虽说直接不写最好）</li></ul></li><li><p>选择</p><ul><li>执行函数代码时间比处理函数调用机制的时间长，则节省时间短，无必要</li></ul></li><li><p>使用</p><ul><li><p>在函数声明和函数定义前加上关键字<code>inline</code></p></li><li><p>一般做法是将定义凡在原本提供原型的地方（可以是在函数头）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>inline double square(double x) {return x*x;}
double  = square(5.0);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>注意</p><ul><li>当在类中定义时，可以不加关键字<code>inline</code></li><li>在类中声明并定义的函数，编译器都会视作内联函数</li></ul></li></ul><h3 id="引用变量——按引用传递变量" tabindex="-1"><a class="header-anchor" href="#引用变量——按引用传递变量"><span>引用变量——按引用传递变量</span></a></h3><h4 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用"><span>基本使用</span></a></h4><ul><li><p>引用变量</p><ul><li>是已定义变量的别名。可以交替使用原名和别名来表示变量</li></ul></li><li><p>使用</p><ul><li>举例：<code>int rats; int &amp; rodents = rats;</code></li></ul></li><li><p>初始化注意</p><ul><li>注意在调用时必须进行初始化</li><li>而且对引用变量来说，赋值相当于给原变量赋值，这也是为什么引用变量更像是const的指针</li></ul></li><li><p>本质</p><ul><li>看上去是伪装的const指针，或者const指针的语法糖，而并非指针 <code>int &amp; rodents = rats;</code>与<code>int * const pr = &amp;rats;</code>等价</li></ul></li><li><p>使用原因</p><ul><li>修改调用函数中的数据对象</li><li>提高运行速度</li></ul></li><li><p>何时使用</p><ul><li>不作修改时 <ul><li>数组：<code>const指针</code>（指针是唯一选择）</li><li>数据对象：较小时使用按值传递。较大时使用<code>const指针</code>或<code>const引用</code></li><li>类对象：<code>const引用</code>（而不是指针，类设计的语义常常要求使用引用）</li></ul></li><li>需作修改时 <ul><li>内置数据类型：<code>指针</code></li><li>数组：只能使用<code>指针</code></li><li>结构：<code>引用或指针</code></li><li>类对象：<code>引用</code>（而不是指针，类设计的语义常常要求使用引用）</li></ul></li></ul></li></ul><h4 id="左值引用-rvalue-reference" tabindex="-1"><a class="header-anchor" href="#左值引用-rvalue-reference"><span>左值引用（<em>rvalue reference</em>）</span></a></h4><ul><li>使用 <ul><li>举例：<code>double &amp;&amp; rref = std::sqrt(36.00)</code></li></ul></li><li>特点 <ul><li>这种引用可以指向<code>右值</code>，而普通引用只能指向<code>左值</code></li><li>右值引用可以用来实现移动语义</li></ul></li></ul><h4 id="引用-x-函数" tabindex="-1"><a class="header-anchor" href="#引用-x-函数"><span>引用 x 函数</span></a></h4><ul><li>用处（作函数引用值） <ul><li>可以用来传递函数参数和作为返回值（本质是传递指针参数）</li><li>举例：<code>swapr(&amp;arg1, &amp;arg2){}</code>函数原型，在被调用时，看上去与普通调用一样==（只能通过原型或函数定义才能知道是按引用传递）== <ul><li>普通调用：<code>void swapr(int a, int b){};</code>，<code>swapr(arg1, arg2);</code></li><li>按引用传递：<code>void swapr(int &amp; a, int &amp; b){};</code>，<code>swapr(arg1, arg2);</code></li></ul></li></ul></li><li>临时变量 <ul><li>描述 <ul><li>如果实参与引用参数不匹配，C++将生成临时变量</li></ul></li><li>生成临时变量的条件 <ul><li>旧版C++条件 <ul><li>实参类型正确，但不是<code>左值</code></li><li>实参类型不正确，但可以转换为正确的类型</li></ul></li><li>新版C++附加条件 <ul><li>参数为const引用</li></ul></li></ul></li><li>举例 <ul><li><code>void swapr(int &amp; a, int &amp; b){}; swapr(3L, 5L);</code></li></ul></li><li>什么时候用 <ul><li>意图是修改作为参数传递的变量，则不用，创建临时变量会阻止这种意图的实现</li></ul></li></ul></li><li>函数参数应该尽可能地使用const的理由 <ul><li>避免无意中修改数据的编程错误</li><li>能处理const和非const实参，否则只能接受非const数据</li><li>使用const引用，使函数<strong>能够正确生成并使用</strong>临时变量</li></ul></li><li><mark>Lambda补充</mark><ul><li>Lambda特点是根据传入参数不同自动生成不同的函数原型 <ul><li><code>[=,&amp;a]</code>时相当于函数原型为<code>fn(int &amp;a);</code></li><li><code>[=,a]</code>时相当于函数原型为<code>fn(int a);</code></li></ul></li><li>此时<code>&amp;</code>被赋予了新的意义，被用于指定函数原型，传入参数为<code>&amp;a</code>时不表示传入a的取地址</li></ul></li></ul><h4 id="引用-x-结构" tabindex="-1"><a class="header-anchor" href="#引用-x-结构"><span>引用 x 结构</span></a></h4><ul><li>结构作参 <ul><li>写法：<code>typeName fnName(const 结构名 &amp; 结构变量);</code></li><li>好处：本质是指针传值，性能高</li></ul></li><li>结构作返回值 <ul><li>写法：<code>结构名 &amp; fnName(argument);</code></li><li>好处1：可以写成<code>fn1(fn2(结构变量))</code>，等价于<code>fn2(结构变量); fn1(结构变量)</code>，更简便</li><li>好处2：可以写成<code>fn(结构变量1) = 结构变量2</code>，等价于<code>fn(结构变量1); 结构变量1 = 结构变量2</code></li></ul></li><li>注意要点 <ul><li>应该避免返回函数终止时不再存在的内存单元引用</li></ul></li></ul><h4 id="引用-x-对象、继承" tabindex="-1"><a class="header-anchor" href="#引用-x-对象、继承"><span>引用 x 对象、继承</span></a></h4><ul><li>引用类的特性 <ul><li>基类引用可以指向派生类对象，而无需进行强制类型转换。但非引用则不行</li><li>举例：<code>ofstream</code>类继承了<code>ostream</code>类，前者是<code>派生类</code>，而后者是<code>基类</code>。参数类型为<code>ostream &amp;</code>的函数还可以接受<code>ofstream</code>对象</li><li>即<code>ostream &amp;</code>参数可接受其<code>派生类</code></li></ul></li></ul><h4 id="捋一下" tabindex="-1"><a class="header-anchor" href="#捋一下"><span><mark>捋一下</mark> <code>&amp;*</code></span></a></h4><ul><li>区别 <ul><li>左侧的<code>&amp;</code>在这里不是地址运算符，而是类型标识符的一部分，就像<code>char*</code>是表示指向char的指针一样</li><li>即等号左侧的符号和右侧的符号的性质是不一样的！！！<mark>必须要捋清这一点</mark></li></ul></li><li>引用 <ul><li><code>int rats; int &amp; rodents = rats;</code>看作<code>(int &amp;) (rodents = rats) 且 (*rodents = *rats)</code></li><li>故<code>rodents = rats = 值</code>，<code>*rodents = *rats = 地址</code></li></ul></li><li>指针 <ul><li><code>int * pi_e = &amp;i_e</code>看作<code>(int * 类型) (pi_e = &amp;i_e)</code>而非<code>int (*pi_e) = (&amp;i_e)</code></li><li>故<code>pi_e = &amp;i_e = 地址</code>，<code>*pi_e = *&amp;i_e = i_e = 值</code></li></ul></li><li>传参 <ul><li>......</li></ul></li></ul><h3 id="默认的参数值" tabindex="-1"><a class="header-anchor" href="#默认的参数值"><span>默认的参数值</span></a></h3><ul><li>使用：通过函数原型 <ul><li>举例：<code>char * left(const char*str, int n = 1);</code></li></ul></li></ul><h3 id="函数重载-多态" tabindex="-1"><a class="header-anchor" href="#函数重载-多态"><span>函数重载（多态）</span></a></h3><p>术语<code>多态</code>指是有多种形式，<code>函数多态（函数重载）</code>可以使用多个同名函数。他们使用参数列表（也叫<code>函数特征标</code>（<em>function signature</em>））区分</p><ul><li>使用：编写多个原型与多个定义</li><li>使用场景：不要滥用，仅当函数基本执行相同任务但使用不同形式的数据时才应该使用</li><li>底层原理——名称修饰 <ul><li>C++如何跟踪每一个重载函数？ <ul><li>C++编译器对函数进行<code>名称修饰</code>（<em>name decoration</em>）或<code>名称校正</code>（<em>name mangling</em>）</li><li>它根据函数原型中指定的形参类型对每个函数名进行加密</li><li>比如<code>long MyFunctionFoo(int, float);</code>的函数名可能被修饰为<code>?MyFunctionFoo@@YAXH</code></li></ul></li><li><mark>名称修饰</mark>所带来的一些影响 <ul><li>链接程序可能无法链接不同编译器所编译的库 <ul><li>解决方案：见模块系统一章</li></ul></li><li>C++使用C的库文件中预编译的函数时，可能找不到（C语言不允许函数重载，并没有名称修饰） <ul><li>解决方案：用函数原型来指出要使用的约定：</li><li><code>extern &quot;C&quot; void spiff(int);</code>，使用C语言链接性 查找函数名</li><li><code>extern void spoff(int);</code>，默认使用C++语言链接性 查找函数名</li><li><code>extern &quot;C++&quot; void spoff(int);</code>，显示使用C++语言链接性 查找函数名</li></ul></li></ul></li></ul></li><li>其他注意项 <ul><li>一些看起来不同的特征标不能共存，比如<code>(double x)</code>和<code>(double &amp;x)</code>，编译器无法确定究竟使用哪个原型</li><li>若有两个原型：const指针与常规指针，则编译器根据实参是否为const决定使用哪个原型（const变量作为非const的参数）</li></ul></li></ul><h2 id="【功能扩展】函数" tabindex="-1"><a class="header-anchor" href="#【功能扩展】函数"><span>【功能扩展】函数</span></a></h2><h3 id="【功能扩展】函数参-x-指针和指针-作参" tabindex="-1"><a class="header-anchor" href="#【功能扩展】函数参-x-指针和指针-作参"><span>【功能扩展】函数参 x 指针和指针（作参）</span></a></h3><ul><li>写法（数组作参和指针作参） <ul><li>数组作参：例如<code>int sum_arr(int arr[], int n){}</code></li><li>指针作参：例如<code>int sum_arr(int *arr, int n){}</code></li><li>字符串作参：例如<code>int sum_arr(char * str, char ch)</code></li><li>多维数组作参：例如<code>int sum(int ar2[][4], int size)</code>（表示只接受4列的数据，不然4可省略）</li><li>多维指针作参：例如<code>int sum(int (*ar2)[4], int size)</code>（表示只接受4列的数据，不然4可省略）</li><li>字符串返回值：例如<code>char * buildstr(char c, int n)</code></li></ul></li><li>函数原型中（可省略函数名），这些写法是等价的： <ul><li><code>const double * f1(const double ar[], int n)</code></li><li><code>const double * f2(const double [], int n)</code></li><li><code>const double * f3(const double *, int n)</code></li></ul></li><li>其他数组代替品 <ul><li>string对象：与结构更相似</li><li>array对象：例如<code>void show(std::array&lt;double, 整型常量&gt; da)</code></li></ul></li><li>区别（数组作参和指针作参） <ul><li>注意：<code>int arr[]</code>和<code>int *arr</code>完全等价，前者并没有拷贝整个数组（开销大），两者都是赋值地址</li><li><mark>注意：当且仅当用于函数头或函数原型中，<code>int *arr</code>和<code>int arr[]</code>的含义才是相同的</mark>（或者说后者的含义被改为了前者） <code>*(arr+i) == arr[i]</code>，但<code>int * pn != int arr[]</code></li></ul></li></ul><blockquote><h4 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点"><span>注意点</span></a></h4></blockquote><ul><li><p>通常数组作参时还要传递第二个参数获知数组的元素数量</p></li><li><p>或者也可以指定元素区间，分别传递数组头和数组尾这两个指针</p></li><li><p>数组/指针与普通参数的区别：</p><ul><li>普通参数按值传递数据，函数使用数据的副本。但接受数组名的函数将使用原始数据</li><li>数据保护：但有时应防止函数无意中修改数组内容，可在声明形参时使用关键字const 如：<code>void show_array(const double ar[], int n);</code></li></ul></li></ul><h3 id="【功能扩展】函数参-x-结构体-作参" tabindex="-1"><a class="header-anchor" href="#【功能扩展】函数参-x-结构体-作参"><span>【功能扩展】函数参 x 结构体（作参）</span></a></h3><p>比数组更简单，对象被视作一个整体，可以按值传递</p><ul><li>结构传值 <ul><li>可以按值传递（但需要内存大，速度慢，适用于结构较小时使用，使用句点成员运算符） <ul><li><code>struct structName{...}; structName val={...}; typeName fn(structName val) {}; fn(val)</code></li></ul></li><li>可以传递结构的地址（C程序员常用的方法，使用间接成员运算符<code>-&gt;</code>使用成员） <ul><li><code>struct structName{...}; structName val={...}; typeName fn(structName *val) {}; fn(&amp;val)</code></li></ul></li><li>可以按引用传递==（C++新增方法）==</li></ul></li></ul><h3 id="【功能扩展】函数-x-指针-函数指针" tabindex="-1"><a class="header-anchor" href="#【功能扩展】函数-x-指针-函数指针"><span>【功能扩展】函数 x 指针（函数指针）</span></a></h3><ul><li>函数地址：函数名表示函数地址</li><li>声明函数指针：类似于声明原型，比如： <ul><li>声明函数指针：<code>double (*pf)(int);</code></li><li>声明函数原型：<code>double pam(int);</code></li></ul></li><li>使用函数指针调用函数 <ul><li>把<code>functionName</code>改为<code>*functionPoint</code>即可（或使用<code>functionPoint</code>也可以）</li><li>即<code>pf</code>和<code>(*pf)</code>等价，正如函数名（地址）与函数本身等价一样</li></ul></li></ul><h3 id="【功能扩展】函数-x-模板-模板函数" tabindex="-1"><a class="header-anchor" href="#【功能扩展】函数-x-模板-模板函数"><span>【功能扩展】函数 x 模板 = 模板函数</span></a></h3><h4 id="基本使用-1" tabindex="-1"><a class="header-anchor" href="#基本使用-1"><span>基本使用</span></a></h4><ul><li><p>简概</p><ul><li><code>函数模板</code>是通用的函数描述，即使用<code>泛型</code>来定义函数 模板允许以<code>泛型</code>（而不是具体类型）的方式类编写程序，因此有时也被称为<code>通用编程</code> 由于类型是用参数表示的，因此有时也被称为<code>参数化类型</code>（<em>parameterized types</em>）</li></ul></li><li><p>底层原理</p><ul><li>函数模板之所以是函数模板，因为它本身并不产生函数定义，只是一个生成函数定义的方案</li><li>只有在使用时才生成（隐式或显式实例化）函数定义的<code>模板实例</code>（<em>instantiation</em>）</li><li>这也是为什么函数模板的定义可以放在头文件中，而普通的函数定义不行 （普通函数在头文件会导致多个文件定义同一个函数（预处理机制），不符合单一定义原则）</li></ul></li><li><p>使用</p><ul><li><p>举例</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>template &lt;typename T&gt;
vpid Swap(T &amp;a, T &amp;b);
// ...
template &lt;typename AnyType&gt; // 指出建立一个模板，并将类型命名为AnyType
void Swap (AnyType &amp;a, AnyType &amp;b)
{/**/}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用补充：<code>typename</code>关键字是C++98添加的，在此之前使用关键字<code>class</code>来创建模板（两者等价，只是后者的单词不直观） 为书写方便，通常将<code>T</code>而不是<code>AnyType</code>用作类型参数</p></li></ul></li><li><p>好处</p><ul><li>使生成多个函数定义更简单、更可靠</li></ul></li><li><p>使用场景</p><ul><li>需要对多个不同类型使用同一种算法的函数时，可使用模板</li></ul></li><li><p>重载的模板</p></li><li><p>即模板函数可以像普通函数一样，也定义多个模板（使用不同的参数数量来作为<code>函数特征标</code>）</p></li><li><p>模板的局限性</p><ul><li>局限性：无法兼顾所有类型，比如 <ul><li>如果T为结构，不能进行<code>&gt;</code>运算符</li><li>如果T为数组名，则<code>&gt;</code>运算符比较的是数组的地址，这可能不是函数设计的本意</li><li>如果T为数组、指针、结构，则<code>*</code>运算符可能会出错</li></ul></li><li>解决方案（两种） <ul><li>重载运算符，比如重载<code>+</code>，以便能够将其用于特定的结构或类</li><li>为特定类型提供具体化的模板定义</li></ul></li></ul></li></ul><h4 id="具体化" tabindex="-1"><a class="header-anchor" href="#具体化"><span>具体化</span></a></h4><p>第三代具体化</p><ul><li>使用： <ul><li><code>template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;);</code><code>template &lt;&gt; void Swap(job &amp;, job &amp;);</code>（<code>&lt;job&gt;</code>可有可无）</li></ul></li></ul><h4 id="显式实例化和隐式实例化" tabindex="-1"><a class="header-anchor" href="#显式实例化和隐式实例化"><span>显式实例化和隐式实例化</span></a></h4><ul><li>底层原理：详见模板函数的底层原理</li><li>使用： <ul><li><code>template void Swap&lt;int&gt;(int &amp;, int&amp;)</code></li><li><code>Swap&lt;job&gt;(job1, job2)</code>（也可以在调用时显式实例化）</li></ul></li></ul><h3 id="【专题】普通函数、函数重载、模板函数、具体化-优先级" tabindex="-1"><a class="header-anchor" href="#【专题】普通函数、函数重载、模板函数、具体化-优先级"><span>【专题】普通函数、函数重载、模板函数、具体化（优先级）</span></a></h3><ul><li><p>各种函数（使用总结）</p><ul><li>种类：使用对于给定的函数名，可以有<code>非模板函数</code>、<code>模板函数</code>、和<code>显式具体化模板</code>、以及<code>它们的重载版本</code></li><li>写法区别： <ul><li>非模板函数：<code>void Swap(job &amp;, job&amp;);</code></li><li>显式具体化模板：<code>template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;);</code>或<code>template &lt;&gt; void Swap(job &amp;, job &amp;);</code></li><li>显式实例化模板：<code>template void Swap&lt;job&gt;(job &amp;, job&amp;);</code>或<code>Swap&lt;job&gt;(job1, job2);</code>（调用时）</li><li>模板函数（隐式实例化）：<code>template &lt;typename T&gt; \\n void Swap (T &amp;, T &amp;)</code>（由模板自动生成函数定义）</li></ul></li></ul></li><li><p>比较（比较总结）</p><ul><li>具体化本质 <ul><li>两个问题 <ul><li>实例化和具体化区别</li><li>既然普通函数的优先级&gt;模板函数，那为什么还要具体化，而不用普通函数来表示</li></ul></li><li>回答 <ul><li>具体化应该依然是模板，而只是比较具体的模板而已，而并非实例</li><li>所以具体化的定义可能是可以放在头文件的，而普通函数定义可能无法放在头文件</li></ul></li></ul></li></ul></li><li><p>优先级（优先级总结）——编译器如何选择使用哪个函数版本</p><ul><li>重载解析（底层原理）：编译器选择函数版本的过程称为<code>重载解析</code>（<em>overloading resolution</em>）</li></ul></li><li><p>重载解析过程</p><ul><li>首先 <ul><li>创建候选函数列表</li><li>使用候选函数列表创建可行函数列表（数目正确、参数可转换匹配）</li><li>确定是否有最佳的可行函数，如果没有则报错，如果有则选用</li></ul></li><li>第三部中判断最佳可行函数（优先级如下） <ul><li>完全匹配（有些无关紧要的匹配也视为完全匹配，参见下表）</li><li>提升转换</li><li>标准转换</li><li>用户定义的转换（如类声明中定义的转换）</li></ul></li><li>如果有多个完全匹配的 <ul><li>有最佳可可行函数 <ul><li>非const指针和引用<strong>优先</strong>与非const指针和引用参数参数匹配</li><li>非模板函数 &gt; 显式具体化的模板函数 &gt; 普通模板函数</li></ul></li><li>没有最佳可行函数 <ul><li>若以上两点均不符合，则产生二义性（<em>ambiguous</em>），错误</li></ul></li></ul></li><li>多个参数的情况 <ul><li>情况非常复杂。编译器必须考虑所有参数的匹配情况</li><li>若一个函数要比其他函数都何时，其所有参数的匹配程度都必须不比其他函数差，同时至少有一个参数的匹配程度比其他函数都高</li></ul></li></ul></li></ul><p>完全匹配允许的无关紧要转换表</p><table><thead><tr><th>从实参</th><th>到形参</th></tr></thead><tbody><tr><td><code>Type</code></td><td><code>Type &amp;</code></td></tr><tr><td><code>Type &amp;</code></td><td><code>Type</code></td></tr><tr><td><code>Type []</code></td><td><code>* Type</code></td></tr><tr><td><code>Type (argument-list)</code></td><td><code>Type （*） (argument-list)</code></td></tr><tr><td><code>Type</code></td><td><code>const Type</code></td></tr><tr><td><code>Type</code></td><td><code>volatile Type</code></td></tr><tr><td><code>Type *</code></td><td><code>const Type</code></td></tr><tr><td><code>Type *</code></td><td><code>volatile Type *</code></td></tr></tbody></table>`,57),t=[c];function o(n,r){return e(),i("div",null,t)}const p=l(a,[["render",o],["__file","01. 函数式编程.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/05.%20%E5%B0%81%E8%A3%85/01.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html","title":"函数式编程","lang":"zh-CN","frontmatter":{"description":"函数式编程 自定义函数 简概 使用函数要素 提供函数定义 + 提供函数原型 + 调用函数 函数原型可隐藏于头文件中 定义和使用的位置 总结就是：函数定义在前还是在后都无所谓（解释型语言必须放在前面），但函数原型声明需要放在使用前（解释型语言不需要声明函数原型） 函数原型的作用 作用：描述了编译器的接口 编译器正确处理函数返回值（知道如何从寄存器或内存中...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/05.%20%E5%B0%81%E8%A3%85/01.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"函数式编程"}],["meta",{"property":"og:description","content":"函数式编程 自定义函数 简概 使用函数要素 提供函数定义 + 提供函数原型 + 调用函数 函数原型可隐藏于头文件中 定义和使用的位置 总结就是：函数定义在前还是在后都无所谓（解释型语言必须放在前面），但函数原型声明需要放在使用前（解释型语言不需要声明函数原型） 函数原型的作用 作用：描述了编译器的接口 编译器正确处理函数返回值（知道如何从寄存器或内存中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"函数式编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"函数式编程","slug":"函数式编程","link":"#函数式编程","children":[{"level":2,"title":"自定义函数","slug":"自定义函数","link":"#自定义函数","children":[{"level":3,"title":"简概","slug":"简概","link":"#简概","children":[]},{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[{"level":4,"title":"使用","slug":"使用-1","link":"#使用-1","children":[]},{"level":4,"title":"不同的类型","slug":"不同的类型","link":"#不同的类型","children":[]}]}]},{"level":2,"title":"递归思想","slug":"递归思想","link":"#递归思想","children":[]},{"level":2,"title":"C++函数新特性（与C不同）","slug":"c-函数新特性-与c不同","link":"#c-函数新特性-与c不同","children":[{"level":3,"title":"内联函数","slug":"内联函数","link":"#内联函数","children":[]},{"level":3,"title":"引用变量——按引用传递变量","slug":"引用变量——按引用传递变量","link":"#引用变量——按引用传递变量","children":[{"level":4,"title":"基本使用","slug":"基本使用","link":"#基本使用","children":[]},{"level":4,"title":"左值引用（rvalue reference）","slug":"左值引用-rvalue-reference","link":"#左值引用-rvalue-reference","children":[]},{"level":4,"title":"引用 x 函数","slug":"引用-x-函数","link":"#引用-x-函数","children":[]},{"level":4,"title":"引用 x 结构","slug":"引用-x-结构","link":"#引用-x-结构","children":[]},{"level":4,"title":"引用 x 对象、继承","slug":"引用-x-对象、继承","link":"#引用-x-对象、继承","children":[]},{"level":4,"title":"捋一下 &*","slug":"捋一下","link":"#捋一下","children":[]}]},{"level":3,"title":"默认的参数值","slug":"默认的参数值","link":"#默认的参数值","children":[]},{"level":3,"title":"函数重载（多态）","slug":"函数重载-多态","link":"#函数重载-多态","children":[]}]},{"level":2,"title":"【功能扩展】函数","slug":"【功能扩展】函数","link":"#【功能扩展】函数","children":[{"level":3,"title":"【功能扩展】函数参 x 指针和指针（作参）","slug":"【功能扩展】函数参-x-指针和指针-作参","link":"#【功能扩展】函数参-x-指针和指针-作参","children":[]},{"level":3,"title":"【功能扩展】函数参 x 结构体（作参）","slug":"【功能扩展】函数参-x-结构体-作参","link":"#【功能扩展】函数参-x-结构体-作参","children":[]},{"level":3,"title":"【功能扩展】函数 x 指针（函数指针）","slug":"【功能扩展】函数-x-指针-函数指针","link":"#【功能扩展】函数-x-指针-函数指针","children":[]},{"level":3,"title":"【功能扩展】函数 x 模板 = 模板函数","slug":"【功能扩展】函数-x-模板-模板函数","link":"#【功能扩展】函数-x-模板-模板函数","children":[{"level":4,"title":"基本使用","slug":"基本使用-1","link":"#基本使用-1","children":[]},{"level":4,"title":"具体化","slug":"具体化","link":"#具体化","children":[]},{"level":4,"title":"显式实例化和隐式实例化","slug":"显式实例化和隐式实例化","link":"#显式实例化和隐式实例化","children":[]}]},{"level":3,"title":"【专题】普通函数、函数重载、模板函数、具体化（优先级）","slug":"【专题】普通函数、函数重载、模板函数、具体化-优先级","link":"#【专题】普通函数、函数重载、模板函数、具体化-优先级","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":15.88,"words":4764},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/05. 封装/01. 函数式编程.md","autoDesc":true}');export{p as comp,m as data};
