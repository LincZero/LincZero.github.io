import{_ as i,c as e,e as o,o as n}from"./app-CAfWfcmi.js";const t="/assets/%E9%98%BB%E5%A1%9E%20I_O-ojlhL5TL.png",s="/assets/%E5%9F%BA%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-GQlhGVta.png",a="/assets/%E5%BC%82%E6%AD%A5%20I_O-CEL-xsCk.png",r="/assets/%E5%90%8C%E6%AD%A5VS%E5%BC%82%E6%AD%A5IO-BRSzs6EW.png",p={};function O(c,l){return n(),e("div",null,l[0]||(l[0]=[o('<h1 id="文件-i-o" tabindex="-1"><a class="header-anchor" href="#文件-i-o"><span>文件 I/O</span></a></h1><p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有</p><ul><li>缓冲与非缓冲 I/O</li><li>直接与非直接 I/O</li><li>阻塞与非阻塞 I/O VS 同步与异步 I/O</li></ul><p>接下来，分别对这些分类讨论讨论。</p><h2 id="提前总结" tabindex="-1"><a class="header-anchor" href="#提前总结"><span>提前总结</span></a></h2><ul><li>非缓冲与<strong>缓冲</strong> I/O <ul><li>本质区别：是否利用标准库缓冲</li><li>使用区别：使用 <code>带缓存的IO库</code></li><li>性能区别：缓冲I/O利用标准库缓存，可以减少系统调用次数，以减少上下文开销</li></ul></li><li>直接与<strong>非直接</strong> I/O <ul><li>本质区别：是否利用操作系统缓存 (页缓存)</li><li>使用区别：调用文件类系统函数时是否指定 <code>O_DIRECT</code> (直接IO) 标志</li><li>性能区别：非直接I/O利用操作系统缓存，应该也是和前面的同理，减少调用次数，减少上下文开销。 （不过前面的主要是用户态和内核态的切换，这里似乎是进程的上下文切换）</li></ul></li><li>阻塞与<strong>非阻塞</strong><ul><li>本质区别：在两个阻塞等待过程中 (内核数据准备好、数据从内核态拷贝到用户态)，非阻塞取消了第一个等待</li><li>使用区别：是否指定 <code>O_NONBLOCK</code> (非阻塞) 标志</li><li>性能区别：非阻塞I/O取消了等待一（内核数据准备时间）</li></ul></li><li>基于非阻塞的<strong>多路服用</strong><ul><li>本质原理：通过 I/O 事件分发。当内核数据准备好时，再以事件通知应用程序进行操作</li><li>使用：<code>select、poll</code> 等</li><li>性能区别：优势在于能在一个线程内同时处理多个 socket 的 IO 请求，且无需轮训</li></ul></li><li>同步与<strong>异步</strong> I/O <ul><li>本质区别：在两个阻塞等待过程中 (内核数据准备好、数据从内核态拷贝到用户态)，异步IO再取消第二个等待</li><li>使用：<code>aio_uring</code> 等</li><li>性能区别：异步I/O取消了等待二（内核态拷贝到用户态）</li></ul></li></ul><h2 id="_1-缓冲与非缓冲-i-o" tabindex="-1"><a class="header-anchor" href="#_1-缓冲与非缓冲-i-o"><span>(1) 缓冲与非缓冲 I/O</span></a></h2><p>文件操作的标准库是可以实现数据的缓存，那么 <strong>根据「是否利用标准库缓冲」</strong>，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：</p><ul><li>缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件</li><li>非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。</li></ul><p>这里所说的「缓冲」特指标准库内部实现的缓冲。</p><p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p><blockquote><p>什么时候输出缓存：</p><p>一般是换行？</p></blockquote><h2 id="_2-直接与非直接-i-o" tabindex="-1"><a class="header-anchor" href="#_2-直接与非直接-i-o"><span>(2) 直接与非直接 I/O</span></a></h2><p>我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。</p><p>那么，<strong>根据「是否利用操作系统的缓存 (页缓存)」</strong>，可以把文件 I/O 分为直接 I/O 与非直接 I/O：</p><ul><li>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</li><li>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</li></ul><p>如果你在使用文件操作类的系统调用函数时，指定了 <code>O_DIRECT</code> 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。</p><blockquote><p>什么时候输出缓存：</p><p>如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？</p><p>以下几种场景会触发内核缓存的数据写入磁盘：</p><ul><li>主动输出：用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li><li>超时输出：内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li><li>过多输出：在调用 <code>write</code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li><li>内存紧张：当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li></ul></blockquote><h2 id="阻塞与非阻塞-i-o-vs-同步与异步-i-o" tabindex="-1"><a class="header-anchor" href="#阻塞与非阻塞-i-o-vs-同步与异步-i-o"><span>阻塞与非阻塞 I/O VS 同步与异步 I/O</span></a></h2><p>为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。</p><h3 id="_3-阻塞与非阻塞-i-o" tabindex="-1"><a class="header-anchor" href="#_3-阻塞与非阻塞-i-o"><span>(3) 阻塞与非阻塞 I/O</span></a></h3><p>先来看看<strong>阻塞 I/O</strong>，当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</p><p>注意，<strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</strong>。过程如下图：</p><p><img src="'+t+'" alt="阻塞 I/O" loading="lazy"></p><p>知道了阻塞 I/O ，来看看<strong>非阻塞 I/O</strong>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，<code>read</code> 调用才可以获取到结果。过程如下图：</p><p>![非阻塞 I/O](09.%20文件IO.assets/非阻塞%20I_O .png)</p><p>注意：<strong>这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</strong></p><p>举个例子，访问管道或 socket 时，如果设置了 <code>O_NONBLOCK</code> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。</p><h3 id="_4-基于非阻塞-i-o-的多路复用" tabindex="-1"><a class="header-anchor" href="#_4-基于非阻塞-i-o-的多路复用"><span>(4) 基于非阻塞 I/O 的多路复用</span></a></h3><p>应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。</p><p>为了解决这种傻乎乎轮询方式，于是 <strong>I/O 多路复用</strong>技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。</p><p>这个做法大大改善了 CPU 的利用率，因为当调用了 I/O 多路复用接口，如果没有事件发生，那么当前线程就会发生阻塞，这时 CPU 会切换其他线程执行任务，等内核发现有事件到来的时候，会唤醒阻塞在 I/O 多路复用接口的线程，然后用户可以进行后续的事件处理。</p><p>整个流程要比阻塞 IO 要复杂，似乎也更浪费性能。但 <strong>I/O 多路复用接口最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求</strong>（参见：<a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html" target="_blank" rel="noopener noreferrer">I/O 多路复用：select/poll/epoll</a>）。用户可以注册多个 socket，然后不断地调用 I/O 多路复用接口读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p>下图是使用 select I/O 多路复用过程。注意，<code>read</code> 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个<strong>同步的过程</strong>，需要等待：</p><p><img src="'+s+'" alt="I/O 多路复用" loading="lazy"></p><p>实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用 <strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</strong></p><h3 id="_5-同步与异步-i-o" tabindex="-1"><a class="header-anchor" href="#_5-同步与异步-i-o"><span>(5) 同步与异步 I/O</span></a></h3><p>而真正的<strong>异步 I/O</strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。</p><p>当我们发起 <code>aio_read</code> 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：</p><p><img src="'+a+'" alt="异步 I/O" loading="lazy"></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较</span></a></h3><p>下面这张图，总结了以上几种 I/O 模型：</p><p><img src="'+r+'" alt="img" loading="lazy"></p><h3 id="比较-两个阻塞" tabindex="-1"><a class="header-anchor" href="#比较-两个阻塞"><span>比较 - 两个阻塞</span></a></h3><p>在前面我们知道了，I/O 是分为两个过程的：</p><ol><li>数据准备的过程</li><li>数据从内核空间拷贝到用户进程缓冲区的过程</li></ol><p>其中：</p><ul><li>同步IO <ul><li>阻塞 I/O：会阻塞在「过程 1 」和「过程 2」</li><li>非阻塞 I/O： 只会阻塞在「过程 2」</li><li>基于非阻塞 I/O 的多路复用：只会阻塞在「过程 2」</li></ul></li><li>异步 I/O <ul><li>「过程 1 」和「过程 2 」都不会阻塞</li></ul></li></ul><h3 id="用故事去理解这几种-i-o-模型" tabindex="-1"><a class="header-anchor" href="#用故事去理解这几种-i-o-模型"><span>用故事去理解这几种 I/O 模型</span></a></h3><p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。</p><ul><li>阻塞 I/O：你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。</li><li>非阻塞 I/O：你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。</li><li>基于非阻塞的 I/O 多路复用：你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（<code>select</code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。</li><li>异步 I/O：好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。</li></ul>',52)]))}const d=i(p,[["render",O],["__file","09. 文件IO.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/07.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/09.%20%E6%96%87%E4%BB%B6IO.html","title":"文件 I/O","lang":"zh-CN","frontmatter":{"description":"文件 I/O 文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有 缓冲与非缓冲 I/O 直接与非直接 I/O 阻塞与非阻塞 I/O VS 同步与异步 I/O 接下来，分别对这些分类讨论讨论。 提前总结 非缓冲与缓冲 I/O 本质区别：是否利用标准库缓冲 使用区别：使用 带缓存的IO库 性能区别：缓冲I/O利用标准库缓存，可以减少系统调用...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/07.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/09.%20%E6%96%87%E4%BB%B6IO.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"文件 I/O"}],["meta",{"property":"og:description","content":"文件 I/O 文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有 缓冲与非缓冲 I/O 直接与非直接 I/O 阻塞与非阻塞 I/O VS 同步与异步 I/O 接下来，分别对这些分类讨论讨论。 提前总结 非缓冲与缓冲 I/O 本质区别：是否利用标准库缓冲 使用区别：使用 带缓存的IO库 性能区别：缓冲I/O利用标准库缓存，可以减少系统调用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文件 I/O\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"文件 I/O","slug":"文件-i-o","link":"#文件-i-o","children":[{"level":2,"title":"提前总结","slug":"提前总结","link":"#提前总结","children":[]},{"level":2,"title":"(1) 缓冲与非缓冲 I/O","slug":"_1-缓冲与非缓冲-i-o","link":"#_1-缓冲与非缓冲-i-o","children":[]},{"level":2,"title":"(2) 直接与非直接 I/O","slug":"_2-直接与非直接-i-o","link":"#_2-直接与非直接-i-o","children":[]},{"level":2,"title":"阻塞与非阻塞 I/O VS 同步与异步 I/O","slug":"阻塞与非阻塞-i-o-vs-同步与异步-i-o","link":"#阻塞与非阻塞-i-o-vs-同步与异步-i-o","children":[{"level":3,"title":"(3) 阻塞与非阻塞 I/O","slug":"_3-阻塞与非阻塞-i-o","link":"#_3-阻塞与非阻塞-i-o","children":[]},{"level":3,"title":"(4) 基于非阻塞 I/O 的多路复用","slug":"_4-基于非阻塞-i-o-的多路复用","link":"#_4-基于非阻塞-i-o-的多路复用","children":[]},{"level":3,"title":"(5) 同步与异步 I/O","slug":"_5-同步与异步-i-o","link":"#_5-同步与异步-i-o","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"比较","slug":"比较","link":"#比较","children":[]},{"level":3,"title":"比较 - 两个阻塞","slug":"比较-两个阻塞","link":"#比较-两个阻塞","children":[]},{"level":3,"title":"用故事去理解这几种 I/O 模型","slug":"用故事去理解这几种-i-o-模型","link":"#用故事去理解这几种-i-o-模型","children":[]}]}]}],"git":{},"readingTime":{"minutes":9.55,"words":2866},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/07. 文件系统/09. 文件IO.md","excerpt":"\\n<p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有</p>\\n<ul>\\n<li>缓冲与非缓冲 I/O</li>\\n<li>直接与非直接 I/O</li>\\n<li>阻塞与非阻塞 I/O VS 同步与异步 I/O</li>\\n</ul>\\n<p>接下来，分别对这些分类讨论讨论。</p>\\n<h2>提前总结</h2>\\n<ul>\\n<li>非缓冲与<strong>缓冲</strong> I/O\\n<ul>\\n<li>本质区别：是否利用标准库缓冲</li>\\n<li>使用区别：使用 <code>带缓存的IO库</code></li>\\n<li>性能区别：缓冲I/O利用标准库缓存，可以减少系统调用次数，以减少上下文开销</li>\\n</ul>\\n</li>\\n<li>直接与<strong>非直接</strong> I/O\\n<ul>\\n<li>本质区别：是否利用操作系统缓存 (页缓存)</li>\\n<li>使用区别：调用文件类系统函数时是否指定 <code>O_DIRECT</code> (直接IO) 标志</li>\\n<li>性能区别：非直接I/O利用操作系统缓存，应该也是和前面的同理，减少调用次数，减少上下文开销。\\n（不过前面的主要是用户态和内核态的切换，这里似乎是进程的上下文切换）</li>\\n</ul>\\n</li>\\n<li>阻塞与<strong>非阻塞</strong>\\n<ul>\\n<li>本质区别：在两个阻塞等待过程中 (内核数据准备好、数据从内核态拷贝到用户态)，非阻塞取消了第一个等待</li>\\n<li>使用区别：是否指定 <code>O_NONBLOCK</code> (非阻塞) 标志</li>\\n<li>性能区别：非阻塞I/O取消了等待一（内核数据准备时间）</li>\\n</ul>\\n</li>\\n<li>基于非阻塞的<strong>多路服用</strong>\\n<ul>\\n<li>本质原理：通过 I/O 事件分发。当内核数据准备好时，再以事件通知应用程序进行操作</li>\\n<li>使用：<code>select、poll</code> 等</li>\\n<li>性能区别：优势在于能在一个线程内同时处理多个 socket 的 IO 请求，且无需轮训</li>\\n</ul>\\n</li>\\n<li>同步与<strong>异步</strong> I/O\\n<ul>\\n<li>本质区别：在两个阻塞等待过程中 (内核数据准备好、数据从内核态拷贝到用户态)，异步IO再取消第二个等待</li>\\n<li>使用：<code>aio_uring</code> 等</li>\\n<li>性能区别：异步I/O取消了等待二（内核态拷贝到用户态）</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/07. 文件系统/09. 文件IO.md","value":{"title":"09. 文件IO","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/07. 文件系统/09. 文件IO.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{d as comp,h as data};
