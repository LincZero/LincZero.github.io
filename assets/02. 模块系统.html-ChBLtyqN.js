import{_ as s,e as l,g as n,o as a}from"./app-CuJixpuN.js";const e={};function t(d,i){return a(),l("div",null,i[0]||(i[0]=[n(`<h1 id="_02-模块系统" tabindex="-1"><a class="header-anchor" href="#_02-模块系统"><span>02. 模块系统</span></a></h1><h2 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h2><h3 id="概念、底层原理-c" tabindex="-1"><a class="header-anchor" href="#概念、底层原理-c"><span>概念、底层原理（C++）</span></a></h3><ul><li><p><strong>C++库函数</strong></p><ul><li>C++库函数存储在库文件中，编译程序时会自动在库文件搜索你使用的函数（但好像还是要写头文件？）</li><li>即库文件包括很多头文件咯。库文件是工具仓库，头文件（库）是工具箱，头文件函数是工具</li></ul></li><li><p><a href="https://www.runoob.com/w3cnote/cpp-header.html" target="_blank" rel="noopener noreferrer">理解 C++ 中的<strong>头文件</strong>和源文件的<strong>作用</strong></a></p><ul><li><p>模块系统的作用：</p></li><li><p>提供函数原型的作用：简单来讲，头文件包括了库的函数原型的声明</p></li><li><p><strong>为什么C/C++中有标准库头文件</strong></p><ul><li><p>这也是由于C/C++相较于其他一些语言的一个不同所导致的，C/C++使用函数前需要先声明函数原型</p><p>而头文件除了提供模块以外，另一个作用是提高声明函数原型</p></li><li><p>而像Python这种不需要写函数原型声明的语言，其直接使用解释器内嵌的内置函数，就不需要标准库的存在了</p><p>只有使用非内置函数、使用其他模块时，才需要声明</p></li><li><p>C/C++没有编译时自动加入标准库的操作，说是“标准库”，但其实不存在真正意义上的标准库</p><p>stdio/iostream里最重要的其实还是输入输出流，但并不必须。有的文件并不需要引入</p></li></ul></li><li><p><strong>C++中不使用头文件cmath，也能运行sqrt函数？</strong></p><ul><li>MSVC STL在实现iostream的数值输入/输出时用了<code>&lt;cmath&gt;</code>中的一些函数（比如<code>ldexp</code>），所以<code>&lt;iostream&gt;</code>间接包含了<code>&lt;cmath&gt;</code></li><li>不过这是实现细节，随时可能会改</li></ul></li></ul></li></ul><h2 id="头文件" tabindex="-1"><a class="header-anchor" href="#头文件"><span>头文件</span></a></h2><h3 id="头文件声明" tabindex="-1"><a class="header-anchor" href="#头文件声明"><span>头文件声明</span></a></h3><p>有两种</p><ul><li>使用<code>&lt;&gt;</code>包裹，如<code>&lt;coo din.h&gt;</code><ul><li>编译器会在存储标准头文件的主机系统的文件系统中查找</li></ul></li><li>使用<code>&quot;&quot;</code>包裹，如<code>&quot;&lt;coordin.h&quot;</code><ul><li>编译器首先查找当前的工作目录或源代码目录（或编译器指定其他目录）<br> 如果没有找到头文件，则编译器再在标准位置查找</li><li>在包含自己的头文件时，应使用引号而不是尖括号</li></ul></li></ul><h3 id="头文件内容" tabindex="-1"><a class="header-anchor" href="#头文件内容"><span>头文件内容</span></a></h3><h4 id="头文件可以放的东西" tabindex="-1"><a class="header-anchor" href="#头文件可以放的东西"><span>头文件可以放的东西</span></a></h4><ul><li>可放 <ul><li>结构声明</li><li>函数模板声明</li><li>内联函数定义：原因：会被预处理掉</li><li>类声明中的函数定义：原因：就算不加<code>inline</code>也会被视作内联函数</li><li>const常量：原因详见内存管理一章的底层原理，其第一次使用时才分配内存</li><li>enum枚举：原因：未知</li><li>priveta中函数定义（不用加inline为内联函数）：原因：这种函数并不会在客户程序中定义，当多个文件引用一个头文件时当然也并不会起冲突</li></ul></li><li>不可放 <ul><li>普通函数定义</li><li>变量声明（定义）</li></ul></li></ul><h4 id="应该放的东西" tabindex="-1"><a class="header-anchor" href="#应该放的东西"><span>应该放的东西</span></a></h4><ul><li>类声明头文件 <ul><li>函数/类模板声明：不能放实现文件，其不能被独立编译</li><li>内联函数定义：不能放实现文件，其不能被独立编译</li></ul></li><li>类实现文件</li><li>客户代码文件</li></ul><h4 id="不可放的原因" tabindex="-1"><a class="header-anchor" href="#不可放的原因"><span>不可放的原因</span></a></h4><ul><li>头文件的引用<code>#include</code>使用的是预处理机制</li><li>在头文件中定义会导致多个文件定义同一样东西，违反C++的单一定义原则</li></ul><h3 id="类与头文件" tabindex="-1"><a class="header-anchor" href="#类与头文件"><span>类与头文件</span></a></h3><ul><li><p>常见问题：</p><ul><li><p>可以在实现代码中定义变量而不在头文件中声明吗？</p></li><li><p>可以，但这样定义出来的变量的作用域是局部的，即无法被其他类函数使用，只能使用函数传参（使用起来不方便，放了相当于有全局变量方便点）</p><p>一般临时变量可以这样做。即使是new出来的变量，指向他的指针也会在头文件中声明</p></li></ul></li></ul><h2 id="头文件-——-宏" tabindex="-1"><a class="header-anchor" href="#头文件-——-宏"><span>头文件 —— 宏</span></a></h2><h3 id="常用宏" tabindex="-1"><a class="header-anchor" href="#常用宏"><span>常用宏</span></a></h3><p>其他</p><ul><li>宏定义, <code>#define</code></li><li>文件包含, <code>#include</code></li><li>条件编译, <code>#if</code></li></ul><p>QT的宏</p><ul><li><p>Q_OBJECT，Qt元对象系统</p></li><li><p>QT_BEGIN_NAMESPACE，命名空间</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QT_BEGIN_NAMESPACE</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Ui</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MainWindow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QT_END_NAMESPACE</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>QT_FORWARD_DECLARE_CLASS，和头文件#include作用类似</p></li></ul><p>C++常用宏</p><ul><li><code>#undef XXX</code>为解除定义</li><li><code>#error XXXX </code></li></ul><h3 id="条件编译宏" tabindex="-1"><a class="header-anchor" href="#条件编译宏"><span>条件编译宏</span></a></h3><p>条件编译宏</p><ul><li><code>#ifdef XXX - #endif</code>，如果定义</li><li><code>#ifndef XXX - #endif</code>，如果没定义，if not defined的缩写。用途：避免重复包含头文件</li><li><code>#if !defined XXX - #endif</code>，如果没定义</li><li><code>#if defined XXX - #endif </code>，如果定义。用途：是根据你是否定义了XXX这个宏，而使用不同的代码</li><li><code>#elif</code></li><li><code>#else</code></li><li>区别 <ul><li>#ifdef只能判断单一的宏是否定义，而#if defined()可以组成复杂的判别条件</li><li>对于单一的宏AAA来说，#ifdef AAA和#if defined(AAA)是<strong>完全相同</strong>的</li><li>而要组成复杂的判别条件，用#if defined()就灵活方便了，比如：<code>#if defined(AAA) &amp;&amp; (BBB &gt;= 10)</code></li></ul></li></ul><hr><p>以<code>#ifndef</code>为例</p><ul><li><p>简概</p><ul><li>同一个文件中只能将同一个头文件包含一次</li><li>但对于嵌套包含头文件或者其他情况，可能会包含多次</li><li>标准C/C++的一种技术可以避免多次包含同一头文件，其基于预处理编译指令<code>#ifndef</code>（<em>if not defined</em>）</li></ul></li><li><p>使用</p><ul><li><p>举例：（写在头文件中，而不是引用头文件的调用函数中）</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> COORDIN_H_</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果没有定义</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> COORDIN_H_</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 那么就定义（预编译定义常量）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 否则跳到此处、编译器不读取中间的内容（已经定义的话）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* ...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * ...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * ... </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> COORDIN_H_</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 当定义两次时，这里因为前面已经定义了，所以跳过这一块</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> COORDIN_H_</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>原理</p><ul><li><p>编译器过程</p><ul><li><p>编译器首次遇到该文件时，名称<code>COORDIN_H_</code>没有定义<br> （根据include文件名来选择名称，并加上一些下划线，以创建一个其他地方不会被定义的名称）</p><p>在这种情况下，编译器将查看<code>#ifndef</code>和<code>#endif</code>之间的内容，并读取定义<code>COORDIN_H_</code>的一行</p></li><li><p>如果在同一个文件遇到其他包含coordin.h的代码，编译器将知道<code>COORDIN_H_</code>已经被定义了，从而跳到<code>#endif</code>后面的一行上</p></li></ul></li><li><p>原理总结</p><ul><li>这种方法不防止编译器将文件包含两次，只是让它忽略除第一次包含之外的所有内容<br> （大多数标准C和C++头文件使用这种防护方案，在同一个文件中定义同一个结构两次不会导致编译错误）</li></ul></li></ul></li></ul><h3 id="两种防止头文件重复包含的方式" tabindex="-1"><a class="header-anchor" href="#两种防止头文件重复包含的方式"><span>两种防止头文件重复包含的方式</span></a></h3><p>为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式</p><p><code>#ifndef</code> 方式</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MAINWINDOW_H</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MAINWINDOW_H</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // MAINWINDOW_H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>#pragma once</code> 方式</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#pragma</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> once</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>区别：在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别</p><ul><li><code>#ifndef</code><ul><li><code>#ifndef</code> 的方式受C/C++语言标准支持。它不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含</li><li>缺点：如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷</li></ul></li><li><code>#pragma once</code><ul><li>一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件</li><li>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件</li><li>好处：你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些</li><li>缺点：如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包含很容易被发现并修正</li><li>缺点2：这种方式不支持跨平台</li></ul></li></ul><h2 id="模块设计" tabindex="-1"><a class="header-anchor" href="#模块设计"><span>模块设计</span></a></h2><p>编译和链接</p><ul><li>C++孤立将组建单独编译，然后在链接成可执行的程序（C++编译器既编译程序，也管理链接器）</li><li>这种做法的优点：如果只修改了一个文件，只需要重新编译该文件再链接。而无需所有文件一起重新编译</li></ul><p>程序结构：可以分成三部分（原型、定义、调用，三者分离），<strong>这种组织方法模块设计与OOP设计一致</strong></p><ul><li>头文件：包含<strong>结构声明</strong>和使用这些结构的函数的<strong>原型</strong></li><li>源代码文件1：包含与结构有关的函数的<strong>定义</strong>代码</li><li>源代码文件2：包含<strong>调用</strong>与结构相关的函数的代码</li></ul><h2 id="名称空间" tabindex="-1"><a class="header-anchor" href="#名称空间"><span>名称空间</span></a></h2><h3 id="名称空间-1" tabindex="-1"><a class="header-anchor" href="#名称空间-1"><span>名称空间</span></a></h3><h4 id="简概-1" tabindex="-1"><a class="header-anchor" href="#简概-1"><span>简概</span></a></h4><ul><li>名称空间原理：通过定义一种新的声明区域（声明区域详见内存管理思想一章）来创建命名的名称空间</li><li>名称空间与文件的关系 <ul><li>文件中可有不同的名称空间</li><li>不同文件可以有相同的名称空间</li><li>即两者没有定性的包含关系</li></ul></li><li>叫法 <ul><li>未被装饰的名称称为<code>未限定的名称</code>（<em>unqualified name</em>），如<code>cout</code></li><li>包含名称空间名的名称称为<code>限定的名称</code>（<em>qualigied name</em>），如<code>std::cout</code></li></ul></li></ul><h4 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h4><ul><li><p>声明</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Jack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Jill</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* 与类结合使用 */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> VECTOR</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Vector</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 与类的使用</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* 在QT中的使用 */</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QT_BEGIN_NAMESPACE</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Ui</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MainWindow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QT_END_NAMESPACE</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用（三种方法）</p><ul><li><strong>作用域解析运算符</strong>：<code>名称空间名</code>+<code>作用域解析运算符::</code>+<code>里面的成员</code>，举例：<code>Jack::n;</code>、<code>std::cout &lt;&lt;</code></li><li><strong>using编译指令</strong>：<code>using namespace 名称空间名;</code>，举例：<code>usign namespace std;</code></li><li><strong>using声明方法</strong>：<code>using namespace</code></li></ul></li></ul><h4 id="其他特性" tabindex="-1"><a class="header-anchor" href="#其他特性"><span>其他特性</span></a></h4><ul><li><p>注意项</p><ul><li>导入名称是，首选作用域解析运算符和using声明方法</li><li>而对于using声明，首选使用将其作用域设置为局部而不是全局</li><li>不要在头文件中使用using编译指令，否则可能会掩盖了要让那些名称可用，而且包含头文件的顺序可能会影响程序行为</li></ul></li><li><p>名称空间可以嵌套：例如<code>namespace nna{namespace nnb{int n;}}</code>，<code>nna::nnb::n;</code></p></li><li><p>可以使用匿名名称空间：例如<code>namespace {int spn;}</code></p><ul><li>这种用法等价于后面跟着using指令一样</li><li>原理：其潜在作用域为：从声明点到声明区域结尾</li><li>使用场景：提供了<strong>链接性为内部的静态变量</strong>的代替品（可以批量定义静态变量），其他文件无法连接访问</li></ul></li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><ul><li>取代静态全局变量、以及外部全局变量的用法</li><li>如果开发了一个函数库或者类库，应该放在一个名称空间中</li><li>作为将旧代码转换为使用名称空间代码的权宜之计</li></ul><h2 id="单独编译" tabindex="-1"><a class="header-anchor" href="#单独编译"><span>单独编译</span></a></h2><h3 id="先单独编译-后链接" tabindex="-1"><a class="header-anchor" href="#先单独编译-后链接"><span>先单独编译，后链接</span></a></h3><ul><li>C++提倡这种做法，能节省编译的效率。但这会引发一些问题（多个库的链接）</li></ul><h3 id="多个库的链接" tabindex="-1"><a class="header-anchor" href="#多个库的链接"><span>多个库的链接</span></a></h3><p>多个库链接 x 名称修饰（可能存在的问题）</p><ul><li>名称修饰对于二进制模块链接的影响 <ul><li>C++标准运行每个<code>编译器设计人员</code>以他认为的何时方式实现名称修饰，两个编译器将为同一个函数生成不同的修饰名</li><li>所以它们各自编译的二进制模块可能无法正确链接</li></ul></li><li>解决方案 <ul><li>确保所有对象文件或库都是同一个编译器生成的</li><li>如果有源代码，则可以用自己的编译器重新编译源代码来消除链接错误</li></ul></li></ul><h1 id="特殊操作" tabindex="-1"><a class="header-anchor" href="#特殊操作"><span>特殊操作</span></a></h1><h2 id="跨工程-调用头文件" tabindex="-1"><a class="header-anchor" href="#跨工程-调用头文件"><span>“跨工程”调用头文件</span></a></h2><p>参考：<a href="https://blog.csdn.net/shupan001/article/details/6436133" target="_blank" rel="noopener noreferrer">【CSDN】error LNK2019: 无法解析的外部符号....该符号在函数 ...中被引用 </a></p><p>问题描述</p><blockquote><p>在Qt中实验时发现了一个问题<br> 两个项目：A.h、A.cpp、B.h、B.cpp，其中项目B要使用项目A中的类<br> _<br> B.h：#include A.h<br> 报错：error: LNK2019: 无法解析的外部符号......中引用了该符号<br> _<br> B.h：#include A.h、#include A.cpp<br> 报错<br> _<br> B.h：#include A.h<br> B.cpp：#include A.cpp<br> 正确运行<br> _<br> 然后我懵了......这是种什么操作？我都不知道怎么在搜索引擎描述这个问题了</p></blockquote><p>原理</p><blockquote><p>首先，#include是“预处理机制”机制对吧，除去条件编译等操作，大概相当于把被include的头文件拷贝了一份到当前头文件<br> 那么，#include cpp他也是同理的</p><p>如果是在同一个工程内，不需要include cpp这一步。是否可以理解为，如果是分别在两个工程内，两个工程已经被分别编译了，你B工程没办法知道A工程的源代码，所以include头文件无效</p><p>而include cpp的工程相当于是将A工程的源代码拷贝到B工程里面</p><p>然后看上去B工程使用了A工程里面的类，但事实上只是一份拷贝</p></blockquote><p>总结</p><blockquote><p>这种操作也就实验一下，耦合很高</p></blockquote>`,69)]))}const h=s(e,[["render",t],["__file","02. 模块系统.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/02.%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F.html","title":"02. 模块系统","lang":"zh-CN","frontmatter":{"description":"02. 模块系统 简概 概念、底层原理（C++） C++库函数 C++库函数存储在库文件中，编译程序时会自动在库文件搜索你使用的函数（但好像还是要写头文件？） 即库文件包括很多头文件咯。库文件是工具仓库，头文件（库）是工具箱，头文件函数是工具 理解 C++ 中的头文件和源文件的作用 模块系统的作用： 提供函数原型的作用：简单来讲，头文件包括了库的函数原...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/02.%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"02. 模块系统"}],["meta",{"property":"og:description","content":"02. 模块系统 简概 概念、底层原理（C++） C++库函数 C++库函数存储在库文件中，编译程序时会自动在库文件搜索你使用的函数（但好像还是要写头文件？） 即库文件包括很多头文件咯。库文件是工具仓库，头文件（库）是工具箱，头文件函数是工具 理解 C++ 中的头文件和源文件的作用 模块系统的作用： 提供函数原型的作用：简单来讲，头文件包括了库的函数原..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"02. 模块系统\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":11.13,"words":3338},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/02. 模块系统.md","excerpt":"\\n<h2>简概</h2>\\n<h3>概念、底层原理（C++）</h3>\\n<ul>\\n<li>\\n<p><strong>C++库函数</strong></p>\\n<ul>\\n<li>C++库函数存储在库文件中，编译程序时会自动在库文件搜索你使用的函数（但好像还是要写头文件？）</li>\\n<li>即库文件包括很多头文件咯。库文件是工具仓库，头文件（库）是工具箱，头文件函数是工具</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.runoob.com/w3cnote/cpp-header.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">理解 C++ 中的<strong>头文件</strong>和源文件的<strong>作用</strong></a></p>\\n<ul>\\n<li>\\n<p>模块系统的作用：</p>\\n</li>\\n<li>\\n<p>提供函数原型的作用：简单来讲，头文件包括了库的函数原型的声明</p>\\n</li>\\n<li>\\n<p><strong>为什么C/C++中有标准库头文件</strong></p>\\n<ul>\\n<li>\\n<p>这也是由于C/C++相较于其他一些语言的一个不同所导致的，C/C++使用函数前需要先声明函数原型</p>\\n<p>而头文件除了提供模块以外，另一个作用是提高声明函数原型</p>\\n</li>\\n<li>\\n<p>而像Python这种不需要写函数原型声明的语言，其直接使用解释器内嵌的内置函数，就不需要标准库的存在了</p>\\n<p>只有使用非内置函数、使用其他模块时，才需要声明</p>\\n</li>\\n<li>\\n<p>C/C++没有编译时自动加入标准库的操作，说是“标准库”，但其实不存在真正意义上的标准库</p>\\n<p>stdio/iostream里最重要的其实还是输入输出流，但并不必须。有的文件并不需要引入</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>C++中不使用头文件cmath，也能运行sqrt函数？</strong></p>\\n<ul>\\n<li>MSVC STL在实现iostream的数值输入/输出时用了<code>&lt;cmath&gt;</code>中的一些函数（比如<code>ldexp</code>），所以<code>&lt;iostream&gt;</code>间接包含了<code>&lt;cmath&gt;</code></li>\\n<li>不过这是实现细节，随时可能会改</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/02. 模块系统.md","value":{"title":"02. 模块系统","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/02. 模块系统.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{h as comp,c as data};
