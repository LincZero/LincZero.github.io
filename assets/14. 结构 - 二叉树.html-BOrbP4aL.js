import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as p,a as s,b as a,e as n}from"./app-CyJMR3JQ.js";const l={},o=s(`<h2 id="二叉树-bt-btree-binarytree" tabindex="-1"><a class="header-anchor" href="#二叉树-bt-btree-binarytree"><span>二叉树 (BT, BTree, BinaryTree)</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><h4 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h4><p>二叉树节点结构</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    V value<span class="token punctuation">;</span>
    Node left<span class="token punctuation">;</span>
    Node right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来讲在面试场上不会考你二叉树coding的难度，或者说很少，但应该要会。他是让你考具体的题目还是考算法居多啊</p><h4 id="打印" tabindex="-1"><a class="header-anchor" href="#打印"><span>打印</span></a></h4><p>如何直观的打印一颗二叉树。这个一般也会考和自己写，自己准备一个方便打印debug就行</p><h4 id="树的边界" tabindex="-1"><a class="header-anchor" href="#树的边界"><span>树的边界</span></a></h4><p>左边界和右边界，就是一个节点不断往左/右节点往下形成的一条路径。</p><p>后面讲非递归遍历的中序遍历时，会再提到这个概念</p><h3 id="遍历" tabindex="-1"><a class="header-anchor" href="#遍历"><span>遍历</span></a></h3><p>用递归和非递归两种方式实现二叉树的先序、中序、后序遍历</p><h4 id="深度遍历概念-递归序-先序-中序-后序" tabindex="-1"><a class="header-anchor" href="#深度遍历概念-递归序-先序-中序-后序"><span>深度遍历概念：递归序，先序/中序/后序</span></a></h4><p>例如：</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
1<span class="token arrow operator">--&gt;</span>2
2<span class="token arrow operator">--&gt;</span>4
    4<span class="token arrow operator">--&gt;</span>41
    4<span class="token arrow operator">--&gt;</span>42
2<span class="token arrow operator">--&gt;</span>5
	5<span class="token arrow operator">--&gt;</span>51
	5<span class="token arrow operator">--&gt;</span>52
1<span class="token arrow operator">--&gt;</span>3
3<span class="token arrow operator">--&gt;</span>6
3<span class="token arrow operator">--&gt;</span>7
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>递归序</strong>为：1 2 4 4 4 2 5 5 5 2 1 3 6 3 7 3 1 (我们可以发现每个节点都会经过三次)</p><p>根据递归序加工的不同，分为：</p><ul><li><strong>先序</strong>：对于所有子树，都是依次打印 头-&gt;左-&gt;右。递归序中，第一次到节点打印，第二、三次到这个节点不打印</li><li><strong>中序</strong>：对于所有子树，都是依次打印 左-&gt;头-&gt;右。递归序中，第二次到节点打印，第一、三次到这个节点不打印</li><li><strong>后序</strong>：对于所有子树，都是依次打印 左-&gt;右-&gt;头。递归序中，第三次到节点打印，第一、二次到这个节点不打印</li></ul><h4 id="深度优先遍历-递归遍历" tabindex="-1"><a class="header-anchor" href="#深度优先遍历-递归遍历"><span>深度优先遍历 - 递归遍历</span></a></h4><p>递归的先序/中序/后序的代码实现上非常简单，在不同的时机打印就行了</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">public</span> 递归函数 <span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// System.out.print(head.value+&quot; &quot;); // 先序打印</span>
    递归函数<span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// System.out.print(head.value+&quot; &quot;); // 中序打印</span>
    递归函数<span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// System.out.print(head.value+&quot; &quot;); // 后序打印</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="深度优先遍历-非递归遍历" tabindex="-1"><a class="header-anchor" href="#深度优先遍历-非递归遍历"><span>深度优先遍历 - 非递归遍历</span></a></h4><p>任何递归一定都可以改成非递归。（不让系统压栈，自己压）</p><p>有时面试会考这个，就是看你理不理解压栈这个过程</p><h5 id="前序-先序-pre-order-traversal" tabindex="-1"><a class="header-anchor" href="#前序-先序-pre-order-traversal"><span>前序/先序 (Pre-order Traversal)</span></a></h5><p>准备一个栈，放入头节点，然后进行以下流程：</p><ol><li>弹出一个节点Current</li><li>打印/处理Current</li><li>以此分别压入右节点和左节点 (如果有) (先压右再压左是为了先左出栈，先处理左)</li><li>循环处理</li></ol><h5 id="后序" tabindex="-1"><a class="header-anchor" href="#后序"><span>后序</span></a></h5><p>准备两个栈（主栈和收集栈），主栈放入头节点，然后进行以下流程：</p><ol><li>主栈弹出一个节点Current</li><li>节点放入收集栈</li><li>以此分别压入右节点和左节点</li><li>循环处理</li><li>当全部完成后，收集栈的出栈顺序就是中序遍历处理的顺序（收集栈的入栈顺序是头-&gt;右-&gt;左，出栈顺序自然是左-&gt;右-&gt;头）</li></ol><h5 id="中序" tabindex="-1"><a class="header-anchor" href="#中序"><span>中序</span></a></h5><p>类似先序打印。左-&gt;右-&gt;头，思路：子树中整个左树进栈（整个左边界进栈），出栈时对弹出节点的右树进行相同的处理</p><p>例如在下面这个图中：</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
1<span class="token arrow operator">--&gt;</span>2
2<span class="token arrow operator">--&gt;</span>4
2<span class="token arrow operator">--&gt;</span>5
5<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">L</span><span class="token arrow operator">--&gt;</span></span>6
6<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">L</span><span class="token arrow operator">--&gt;</span></span>7
1<span class="token arrow operator">--&gt;</span>3
3<span class="token arrow operator">--&gt;</span>8
8<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">R</span><span class="token arrow operator">--&gt;</span></span>10
10<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">L</span><span class="token arrow operator">--&gt;</span></span>11
3<span class="token arrow operator">--&gt;</span>9
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先进124，然后4出栈打印2，看2有右节点5，就压入右节点5和他的整个左树。循环</p><h4 id="广度优先遍历" tabindex="-1"><a class="header-anchor" href="#广度优先遍历"><span>广度优先遍历</span></a></h4><p>如何完成二叉树的宽度优先遍历 (常见题目：求一棵二叉树的宽度)</p><p>用队列（队列先进先出，这次不用栈了。深度用栈，广度用队列）</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
1<span class="token arrow operator">--&gt;</span>2
2<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">R</span><span class="token arrow operator">--&gt;</span></span>4
4<span class="token arrow operator">--&gt;</span>6
4<span class="token arrow operator">--&gt;</span>7
1<span class="token arrow operator">--&gt;</span>3
3<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">L</span><span class="token arrow operator">--&gt;</span></span>5
5<span class="token arrow operator">--&gt;</span>8
5<span class="token arrow operator">--&gt;</span>9
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法：放入头节点然后执行：</p><ol><li>头弹出就打印，并且以此将左节点和右节点入队列</li></ol><p>最后打印就是：头-&gt;左-&gt;右，先序遍历。简单理解：[1]-&gt;[32|1]-&gt;[32]-&gt;[54|32]-&gt;[54]-&gt;[9876|54]-&gt;[9876] (右头左尾) （注意：这里简化了一些延长了出队列的时间，实际内存不是这样）</p><p>实现细节：</p><p>先序/中序/后序的切换比较简单。并且这里用队列而非栈，也就是不需要手动递归，只需要 <code>while(!queue.isEmpty())</code> 就行，当作普通循环，较好理解</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Java的队列</span>
queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// System.out.println(cur.value): // 先序</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// System.out.println(cur.value): // 中序</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// System.out.println(cur.value): // 后序</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="题-求一棵二叉树的宽度" tabindex="-1"><a class="header-anchor" href="#题-求一棵二叉树的宽度"><span>题：求一棵二叉树的宽度</span></a></h5><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
1<span class="token arrow operator">--&gt;</span>2
2<span class="token arrow operator">--&gt;</span>4
2<span class="token arrow operator">--&gt;</span>5
5<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">L</span><span class="token arrow operator">--&gt;</span></span>7
1<span class="token arrow operator">--&gt;</span>3
3<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">L</span><span class="token arrow operator">--&gt;</span></span>6
6<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">R</span><span class="token arrow operator">--&gt;</span></span>8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如这里的最大宽度是3，在第三层出现</p><p>答案：</p><p>要知道最大宽度，还需要知道各个节点分别存在第几层，需要统计每一层的节点数是几。</p><p>那么我们可以用 <code>HashMap&lt;Node, Interget&gt; levelMap = new HashMap&lt;&gt;()</code> 的哈希表，来记录每个节点在第几层。</p><p>遍历打印时去看是第几层（广度深度都有解法），然后分别累加就行</p><p>答案：（无hash表方案）</p><p>这个说是难很多，但我感觉可以用我前面那个简化版的流程是非常好理解的：[1]-&gt;[32|1]-&gt;[32]-&gt;[54|32]-&gt;[54]-&gt;[9876|54]-&gt;[9876] (右头左尾)</p><p>只要几个变量：</p><ul><li>nodeCurEnd 当前层的最后一个节点</li><li>nodeNextEnd 下一层的最后一个节点</li><li>curLevel 当前层的最大宽度</li><li>maxLevel 最大宽度</li></ul><p>LeetCode102、LeetCode104，弹幕说那里的解法简单些</p><h3 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索"><span>搜索</span></a></h3><h4 id="广搜" tabindex="-1"><a class="header-anchor" href="#广搜"><span>广搜</span></a></h4><h3 id="题-二叉树常见题" tabindex="-1"><a class="header-anchor" href="#题-二叉树常见题"><span>题 (二叉树常见题)</span></a></h3><p>下面几个概念可以缝合的，例如：平衡二叉查找树 (Balanced Binary Search Tree)</p><h4 id="判断-搜索二叉树-bst-binary-search-tree" tabindex="-1"><a class="header-anchor" href="#判断-搜索二叉树-bst-binary-search-tree"><span>判断 搜索二叉树 (BST, Binary Search Tree)</span></a></h4><p>也叫二叉查找树 (Binary Search Tree)，更符合英文翻译</p><p>搜索二叉树特点：左树小于右树、且没有重复值</p><p>方法：中序遍历（深度遍历，是否递归都行），一定是升序输出</p><h4 id="判断-完全二叉树-fbt-cbt" tabindex="-1"><a class="header-anchor" href="#判断-完全二叉树-fbt-cbt"><span>判断 完全二叉树 (FBT/CBT)</span></a></h4><p>完全二叉树特点：按顺序从左到右铺（堆就是一棵完全二叉树，不一定是满二叉树）</p><p>方法：广度遍历，遍历的过程中。刚开始时的节点，均有左右节点</p><ol><li><p>如果发现一个节点有右孩子但没左孩子，返回false</p></li><li><p>如果遇到第一个节点有左孩子但无右孩子，那么后面遇到的所有节点都应该是叶子节点（均无左右孩子），否则返回false</p><p>（例如在下图中，节点6就是往后遍历的所有节点都是叶子节点）</p></li></ol><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
1<span class="token arrow operator">--&gt;</span>2
2<span class="token arrow operator">--&gt;</span>4
    4<span class="token arrow operator">--&gt;</span>41
    4<span class="token arrow operator">--&gt;</span>42
2<span class="token arrow operator">--&gt;</span>5
	5<span class="token arrow operator">--&gt;</span>51
	5<span class="token arrow operator">--&gt;</span>52
1<span class="token arrow operator">--&gt;</span>3
3<span class="token arrow operator">--&gt;</span>6
6<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">L</span><span class="token arrow operator">--&gt;</span></span>61
3<span class="token arrow operator">--&gt;</span>7
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="判断-满二叉树" tabindex="-1"><a class="header-anchor" href="#判断-满二叉树"><span>判断 满二叉树</span></a></h4><p>满二叉树特点：（满二叉树是特殊的完全二叉树）</p><p>方法：在判断完全二叉树的基础上微改一下就行。广度遍历，遍历的过程中。刚开始时的节点，均有左右节点</p><ol><li>如果发现一个节点只有一个孩子，返回false</li><li>如果遇到第一个节点均无左右孩子，那么后面遇到的所有节点都应该是叶子节点（均无左右孩子），否则返回false</li></ol><p>另一个比较麻烦但好理解的方法</p>`,76),r=a("ol",null,[a("li",null,[n("分别统计最大深度L和节点个数N，那么满足公式 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"N"),a("mo",null,"="),a("msup",null,[a("mn",null,"2"),a("mi",null,"L")]),a("mo",null,"−"),a("mn",null,"1")]),a("annotation",{encoding:"application/x-tex"},"N=2^L-1")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.9247em","vertical-align":"-0.0833em"}}),a("span",{class:"mord"},[a("span",{class:"mord"},"2"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.8413em"}},[a("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mathnormal mtight"},"L")])])])])])])]),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"−"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1")])])]),n(" (等倍数列求和)")])],-1),i=s(`<h4 id="判断-平衡二叉树-二叉树套路" tabindex="-1"><a class="header-anchor" href="#判断-平衡二叉树-二叉树套路"><span>判断 平衡二叉树 (二叉树套路)</span></a></h4><p>平衡二叉树特点：对于任何子树，左树高度与右树高度不相差超过一</p><p>二叉树做题套路：基于我可以向我左数要某些信息，右数要某些信息的情况下，我怎么罗列这个可能性。</p><p>例如在平衡二叉树的题目中，如果：左树是平衡二叉树、右树是平衡二叉树，且两者高度差不超过一，则通过。</p><p>那么就可以想到递归，每个递归返回两个信息：是否平衡、高度多少</p><h4 id="寻找-公共祖先节点-二叉树套路" tabindex="-1"><a class="header-anchor" href="#寻找-公共祖先节点-二叉树套路"><span>寻找 公共祖先节点 (二叉树套路)</span></a></h4><p>题：给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点</p><p>例如下图中，D和F的最低公共祖先是B</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
A<span class="token arrow operator">--&gt;</span>B
B<span class="token arrow operator">--&gt;</span>D
B<span class="token arrow operator">--&gt;</span>E
E<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">R</span><span class="token arrow operator">--&gt;</span></span>F
A<span class="token arrow operator">--&gt;</span>C
C<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">R</span><span class="token arrow operator">--&gt;</span></span>K
K<span class="token arrow operator">--&gt;</span>G
K<span class="token arrow operator">--&gt;</span>I
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解题：</p><ul><li><p>找类似题的思路 —— 链表。我开始想到的是链表找相交节点的那个题目，或者有点有向无环图的感觉。链表找相交节点麻烦的做法是逆序，方便点就是快慢指针判断末尾节点，同时加有环判断。但这里有些区别，因为是头节点相同而不是尾节点相同，那么理论上可以逆序然后再求链表相交节点，但很麻烦。</p></li><li><p>遍历方式思路 —— 看能不能从递归序中提取出来。</p></li><li><p>空间 O(n) 哈希表解法思路。D和F节点都存储自己的路径（相当于用哈希表模拟了一条虚拟的倒序链表），再对比</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> fathreMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存储每个节点的父节点</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存储节点一的整条路径，然后再去看另一条节点的路径</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>解题套路解法尝试递归</p><ul><li>往子树需要要的信息：o1和o2在不在你那？然后就有了下面的 O(1) 解法（这个解图思路确实好用）</li><li>另外需要注意一下边界问题 <ul><li>情况一：O1是O2的LCA或O2是O1的LCA</li><li>情况二：O1和O2不彼此为LCA</li></ul></li><li>答案：</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">lowestAncestor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span> <span class="token class-name">Node</span> o1<span class="token punctuation">,</span> <span class="token class-name">Node</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 情况一的到达条件</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head <span class="token operator">==</span> o1 <span class="token operator">||</span> head <span class="token operator">==</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 情况二的到达条件</span>
	<span class="token class-name">Node</span> left <span class="token operator">=</span> <span class="token function">lowestAncestor</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">,</span> o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Node</span> right <span class="token operator">=</span> <span class="token function">lowestAncestor</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">,</span> o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 递归条件，继续递归</span>
	<span class="token keyword">return</span> left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> left <span class="token operator">:</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="寻找-后继节点-简单" tabindex="-1"><a class="header-anchor" href="#寻找-后继节点-简单"><span>寻找 后继节点 (简单)</span></a></h4><p>在二叉树中找到一个节点的后继节点</p><p>现在有一种新的二叉树节点类型如下</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token operator">:</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> parent<span class="token punctuation">;</span>	<span class="token comment">// 该结构比普通二叉树节点结构多了一个指向父节点的parent指针</span>
    					<span class="token comment">// 假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    value <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的<strong>中序遍历的序列中， node的下一个节点叫作node的后继节点</strong>。</p><p>答案：</p><ul><li>最简单的肯定是中序遍历后，将输出保存起来。缺点是空间和时间复杂度O(n)，代价大</li><li>但这里我们有父指针这个新特征，也很简单。思考情况： <ul><li>情况一：该节点有右孩子，则是右孩子的最左节点</li><li>情况二：该节点无右孩子，则找一直往上找自己不是右节点的父节点X</li><li>情况三：没有后继节点，情况二最后找到根节点也不符合</li><li>（最左节点：再不断往下找左节点，直到没有左节点则输出）</li><li>空间复杂度O(1)，时间复杂度为两个节点的最短路径O(k)</li></ul></li></ul><h4 id="二叉树的序列化和反序列化" tabindex="-1"><a class="header-anchor" href="#二叉树的序列化和反序列化"><span>二叉树的序列化和反序列化</span></a></h4><p>（LeetCode 297）</p><p>就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树</p><p>答案：</p><ul><li>序列化 <ul><li>不同于遍历打印的一点是，还要求是一一对应关系。但其实大同小异，只要把”空“也用特殊字符打印出来，其实就可以了</li><li>用先中后序序列化都是同理的，以先序为例：例如输出结果为：[1,#,2,4,#,#,#]</li></ul></li><li>反序列化 <ul><li>也简单，这里是先序遍历所以先建头节点，再建左/右节点。</li><li>先加载头节点，遇到空的就往左/右节点插入空，否则插入对应节点并进入该节点中继续插值。 左右节点都插满后返回上节点，继续插</li></ul></li><li>二叉树这个很简单清晰，也不需要序列化得像标签语言一样的那种形式，而是更扁平的存储方式。但如果B+树就不能用这种方式序列化了</li></ul><h4 id="判断-一颗二叉树是不是另一棵二叉树的子树" tabindex="-1"><a class="header-anchor" href="#判断-一颗二叉树是不是另一棵二叉树的子树"><span>判断 一颗二叉树是不是另一棵二叉树的子树</span></a></h4><p>略</p><h4 id="折纸问题-简单" tabindex="-1"><a class="header-anchor" href="#折纸问题-简单"><span>折纸问题 (简单)</span></a></h4><p>题：(一个微软的题，也不难)</p><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。</p><p>如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p><p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。</p><p>例如：N=1时，打印: down，N=2时，打印: down down up</p><p>解题：</p><ul><li><p>先找规律然后总结规律，数学方式打印。实际解决是可行的，不过如果禁止用数学思维而强制用计算机模拟</p></li><li><p>应该是能用树表示，一棵满二叉树来的，每次对折就深度加一（规定左节点是上面的，右节点是下面的）</p><ul><li><p>特征：每个节点的凹凸状态不会变，每次对折增加左右节点，这新增的两个节点必定左凹右突</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
1凹<span class="token arrow operator">--&gt;</span>2凹<span class="token arrow operator">--&gt;</span>3凹
2凹<span class="token arrow operator">--&gt;</span>3凸
1凹<span class="token arrow operator">--&gt;</span>2凸<span class="token arrow operator">--&gt;</span>3凹_
2凸<span class="token arrow operator">--&gt;</span>3凸_
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>最后构造完后，中序遍历输出就行了</p></li></ul></li></ul><h3 id="解题思维总结-递归所需信息" tabindex="-1"><a class="header-anchor" href="#解题思维总结-递归所需信息"><span><strong>解题思维总结</strong> (递归所需信息)</span></a></h3><p>二叉树做题套路：基于我可以向我左数要某些信息，右数要某些信息的情况下，我怎么罗列这个可能性。</p><ul><li><p>例如在平衡二叉树的题目中，如果：左树是平衡二叉树、右树是平衡二叉树，且两者高度差不超过一，则通过。</p><p>以此写递归：每个递归返回两个信息：是否平衡、高度多少</p></li><li><p>例如在搜索二叉树题目中，如果：左树是搜索树、右树是搜索树、且左Max&lt;头节点&lt;右min，则通过。</p><p>以此写递归：每个递归返回两个信息：是否搜索二叉树、最大值与最小值多少</p></li></ul><p>这个递归套路非常之好用，可以解决你们面试中一切<strong>树形DP</strong> (树上动态规划) 的问题，树形DP是面试中最难的问题</p>`,37),c=[o,r,i];function d(u,k){return t(),p("div",null,c)}const h=e(l,[["render",d],["__file","14. 结构 - 二叉树.html.vue"]]),g=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Program_Algorithm/%E9%80%9A%E7%94%A8%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B%20-%20%E5%B7%A6%E7%A8%8B%E4%BA%91/01.%20%E5%9F%BA%E7%A1%80%E7%8F%AD/14.%20%E7%BB%93%E6%9E%84%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91.html","title":"","lang":"zh-CN","frontmatter":{"description":"二叉树 (BT, BTree, BinaryTree) 概念 结构 二叉树节点结构 一般来讲在面试场上不会考你二叉树coding的难度，或者说很少，但应该要会。他是让你考具体的题目还是考算法居多啊 打印 如何直观的打印一颗二叉树。这个一般也会考和自己写，自己准备一个方便打印debug就行 树的边界 左边界和右边界，就是一个节点不断往左/右节点往下形成的...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Program_Algorithm/%E9%80%9A%E7%94%A8%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B%20-%20%E5%B7%A6%E7%A8%8B%E4%BA%91/01.%20%E5%9F%BA%E7%A1%80%E7%8F%AD/14.%20%E7%BB%93%E6%9E%84%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:description","content":"二叉树 (BT, BTree, BinaryTree) 概念 结构 二叉树节点结构 一般来讲在面试场上不会考你二叉树coding的难度，或者说很少，但应该要会。他是让你考具体的题目还是考算法居多啊 打印 如何直观的打印一颗二叉树。这个一般也会考和自己写，自己准备一个方便打印debug就行 树的边界 左边界和右边界，就是一个节点不断往左/右节点往下形成的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":2,"title":"二叉树 (BT, BTree, BinaryTree)","slug":"二叉树-bt-btree-binarytree","link":"#二叉树-bt-btree-binarytree","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[{"level":4,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":4,"title":"打印","slug":"打印","link":"#打印","children":[]},{"level":4,"title":"树的边界","slug":"树的边界","link":"#树的边界","children":[]}]},{"level":3,"title":"遍历","slug":"遍历","link":"#遍历","children":[{"level":4,"title":"深度遍历概念：递归序，先序/中序/后序","slug":"深度遍历概念-递归序-先序-中序-后序","link":"#深度遍历概念-递归序-先序-中序-后序","children":[]},{"level":4,"title":"深度优先遍历 - 递归遍历","slug":"深度优先遍历-递归遍历","link":"#深度优先遍历-递归遍历","children":[]},{"level":4,"title":"深度优先遍历 - 非递归遍历","slug":"深度优先遍历-非递归遍历","link":"#深度优先遍历-非递归遍历","children":[{"level":5,"title":"前序/先序 (Pre-order Traversal)","slug":"前序-先序-pre-order-traversal","link":"#前序-先序-pre-order-traversal","children":[]},{"level":5,"title":"后序","slug":"后序","link":"#后序","children":[]},{"level":5,"title":"中序","slug":"中序","link":"#中序","children":[]}]},{"level":4,"title":"广度优先遍历","slug":"广度优先遍历","link":"#广度优先遍历","children":[{"level":5,"title":"题：求一棵二叉树的宽度","slug":"题-求一棵二叉树的宽度","link":"#题-求一棵二叉树的宽度","children":[]}]}]},{"level":3,"title":"搜索","slug":"搜索","link":"#搜索","children":[{"level":4,"title":"广搜","slug":"广搜","link":"#广搜","children":[]}]},{"level":3,"title":"题 (二叉树常见题)","slug":"题-二叉树常见题","link":"#题-二叉树常见题","children":[{"level":4,"title":"判断 搜索二叉树 (BST, Binary Search Tree)","slug":"判断-搜索二叉树-bst-binary-search-tree","link":"#判断-搜索二叉树-bst-binary-search-tree","children":[]},{"level":4,"title":"判断 完全二叉树 (FBT/CBT)","slug":"判断-完全二叉树-fbt-cbt","link":"#判断-完全二叉树-fbt-cbt","children":[]},{"level":4,"title":"判断 满二叉树","slug":"判断-满二叉树","link":"#判断-满二叉树","children":[]},{"level":4,"title":"判断 平衡二叉树 (二叉树套路)","slug":"判断-平衡二叉树-二叉树套路","link":"#判断-平衡二叉树-二叉树套路","children":[]},{"level":4,"title":"寻找 公共祖先节点 (二叉树套路)","slug":"寻找-公共祖先节点-二叉树套路","link":"#寻找-公共祖先节点-二叉树套路","children":[]},{"level":4,"title":"寻找 后继节点 (简单)","slug":"寻找-后继节点-简单","link":"#寻找-后继节点-简单","children":[]},{"level":4,"title":"二叉树的序列化和反序列化","slug":"二叉树的序列化和反序列化","link":"#二叉树的序列化和反序列化","children":[]},{"level":4,"title":"判断 一颗二叉树是不是另一棵二叉树的子树","slug":"判断-一颗二叉树是不是另一棵二叉树的子树","link":"#判断-一颗二叉树是不是另一棵二叉树的子树","children":[]},{"level":4,"title":"折纸问题 (简单)","slug":"折纸问题-简单","link":"#折纸问题-简单","children":[]}]},{"level":3,"title":"解题思维总结 (递归所需信息)","slug":"解题思维总结-递归所需信息","link":"#解题思维总结-递归所需信息","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":12.39,"words":3718},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Program_Algorithm/通用算法/算法教程 - 左程云/01. 基础班/14. 结构 - 二叉树.md","autoDesc":true}');export{h as comp,g as data};
