import{_ as l,c as t,e as n,o as i}from"./app-BDGujT_T.js";const o={};function c(p,e){return i(),t("div",null,e[0]||(e[0]=[n('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="对象树和拥有权" tabindex="-1"><a class="header-anchor" href="#对象树和拥有权"><span>对象树和拥有权</span></a></h1><h2 id="对象模型-对象树" tabindex="-1"><a class="header-anchor" href="#对象模型-对象树"><span>对象模型（对象树）</span></a></h2><p>parent-child机制</p><ul><li><p>作用</p><ul><li>介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制</li><li>这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁</li></ul></li><li><p>简概</p><ul><li>Qt中创建对象时会提供一个Parent对象指针</li><li>注意，对象树不等于继承树</li></ul></li><li><p>原理</p><ul><li><p>当创建一个<code>QObject</code>对象时，其构造函数接受一个<code>QObject</code>指针作为参数，这个参数是<code>parent</code>，也就是<code>父对象指针</code>（不是父类）</p><ul><li><p>可以通过构造函数传入<code>父对象指针</code>，也可以后期通过<code>setParent()</code>函数修改<code>父对象指针</code>，一般为this</p></li><li><p>这个QObject对象会自动添加到<strong>父对象的<code>children()</code>列表</strong></p></li></ul></li><li><p>当<code>父对象</code>析构时，这个列表中的所有对象也会被析构</p></li><li><p>这种机制在GUI程序设计中相当有用</p></li><li><p>即：<mark>不需要delete QObject对象及其后代类</mark></p></li></ul></li><li><p>补充</p><ul><li>这里的设计可能有点反直觉：父对象指针为参，但目的是要调用*parent里面的addChildren()??方法来修改的是父对象中的children()列表</li><li>之所以这样设计 <ul><li>一是方便于为组件指定的父对象（如控件所属哪个窗口）</li><li>二是以便与在构造QObject对象时完成所有操作（而不是把QObject对象传入到包含它的类的方法参数里）</li><li>三是将children放在父对象中，当销毁父对象的时候不需要遍历所有对象，就能直接找到要销毁的子对象</li></ul></li></ul></li></ul>',6)]))}const d=l(o,[["render",c],["__file","03. 对象树和拥有权.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/03.%20%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%8B%A5%E6%9C%89%E6%9D%83.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 对象树和拥有权 对象模型（对象树） parent-child机制 作用 介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制 这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁 简概 Qt中创建对象时会提供一个Parent对象指针 注意，对象树不等于继承树 原理 当创建一个QObject对象时...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/03.%20%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%8B%A5%E6%9C%89%E6%9D%83.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 对象树和拥有权 对象模型（对象树） parent-child机制 作用 介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制 这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁 简概 Qt中创建对象时会提供一个Parent对象指针 注意，对象树不等于继承树 原理 当创建一个QObject对象时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"对象树和拥有权","slug":"对象树和拥有权","link":"#对象树和拥有权","children":[{"level":2,"title":"对象模型（对象树）","slug":"对象模型-对象树","link":"#对象模型-对象树","children":[]}]}],"git":{},"readingTime":{"minutes":1.42,"words":425},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/03. 对象树和拥有权.md","excerpt":"\\n<h1>目录</h1>\\n<h1>对象树和拥有权</h1>\\n<h2>对象模型（对象树）</h2>\\n<p>parent-child机制</p>\\n<ul>\\n<li>\\n<p>作用</p>\\n<ul>\\n<li>介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制</li>\\n<li>这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁</li>\\n</ul>\\n</li>\\n<li>\\n<p>简概</p>\\n<ul>\\n<li>Qt中创建对象时会提供一个Parent对象指针</li>\\n<li>注意，对象树不等于继承树</li>\\n</ul>\\n</li>\\n<li>\\n<p>原理</p>\\n<ul>\\n<li>\\n<p>当创建一个<code>QObject</code>对象时，其构造函数接受一个<code>QObject</code>指针作为参数，这个参数是<code>parent</code>，也就是<code>父对象指针</code>（不是父类）</p>\\n<ul>\\n<li>\\n<p>可以通过构造函数传入<code>父对象指针</code>，也可以后期通过<code>setParent()</code>函数修改<code>父对象指针</code>，一般为this</p>\\n</li>\\n<li>\\n<p>这个QObject对象会自动添加到<strong>父对象的<code>children()</code>列表</strong></p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>当<code>父对象</code>析构时，这个列表中的所有对象也会被析构</p>\\n</li>\\n<li>\\n<p>这种机制在GUI程序设计中相当有用</p>\\n</li>\\n<li>\\n<p>即：<mark>不需要delete QObject对象及其后代类</mark></p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>补充</p>\\n<ul>\\n<li>这里的设计可能有点反直觉：父对象指针为参，但目的是要调用*parent里面的addChildren()??方法来修改的是父对象中的children()列表</li>\\n<li>之所以这样设计\\n<ul>\\n<li>一是方便于为组件指定的父对象（如控件所属哪个窗口）</li>\\n<li>二是以便与在构造QObject对象时完成所有操作（而不是把QObject对象传入到包含它的类的方法参数里）</li>\\n<li>三是将children放在父对象中，当销毁父对象的时候不需要遍历所有对象，就能直接找到要销毁的子对象</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/03. 对象树和拥有权.md","value":{"title":"03. 对象树和拥有权","path":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/03. 对象树和拥有权.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{d as comp,r as data};
