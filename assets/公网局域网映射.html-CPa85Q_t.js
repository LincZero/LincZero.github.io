import{_ as a,c as s,b as e,o as t}from"./app-CxAoBuKS.js";const p={};function i(l,n){return t(),s("div",null,n[0]||(n[0]=[e(`<h1 id="公网局域网映射" tabindex="-1"><a class="header-anchor" href="#公网局域网映射"><span>公网局域网映射</span></a></h1><p>见 &quot;网络工具/转发工具&quot;</p><h2 id="gpt" tabindex="-1"><a class="header-anchor" href="#gpt"><span>GPT</span></a></h2><h3 id="nginx方案" tabindex="-1"><a class="header-anchor" href="#nginx方案"><span>Nginx方案</span></a></h3><blockquote><p>我有一台公网Debian设备(8.134.151.111)和局域网Ubuntu设备(192.168.31.164)，两台机器在不同的环境，我想将公网的8081端口映射到局域网的8081端口</p></blockquote><p>实现这个目标，你需要在公网Debian设备上设置一个反向代理，这样它就可以将来自8081端口的流量转发到局域网Ubuntu设备的8081端口。你可以使用Nginx或者Apache等工具来实现这个功能。这里我提供一个使用Nginx的示例：</p><p>首先，在公网Debian设备上安装Nginx：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，创建一个新的Nginx配置文件，例如<code>/etc/nginx/conf.d/reverse-proxy.conf</code>，并添加以下内容：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>server <span class="token punctuation">{</span>
    listen <span class="token number">8081</span><span class="token punctuation">;</span>
    location / <span class="token punctuation">{</span>
        proxy_pass http://192.168.31.164:8081<span class="token punctuation">;</span>
        proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>
        proxy_set_header X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，重启Nginx：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">service</span> nginx restart
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，公网的8081端口就被映射到局域网的8081端口了。</p><p>但是，请注意，你需要确保公网Debian设备可以访问到局域网Ubuntu设备。如果两台设备在不同的物理网络中，你可能需要设置VPN或者其他的网络转发机制。</p><h3 id="ssh隧道方案-仅tcp" tabindex="-1"><a class="header-anchor" href="#ssh隧道方案-仅tcp"><span>ssh隧道方案 (仅TCP)</span></a></h3><blockquote><p>公网访问不了局域网设备，局域网能访问公网</p></blockquote><p>如果局域网设备可以访问公网设备，但公网设备不能访问局域网设备，那么你可以考虑使用SSH隧道技术来解决这个问题。SSH隧道可以让你在局域网设备上建立一个到公网设备的连接，然后公网设备可以使用这个连接来访问局域网设备。</p><h4 id="局域网操作" tabindex="-1"><a class="header-anchor" href="#局域网操作"><span>局域网操作</span></a></h4><p>下面是一个步骤，你可以在局域网设备上运行这些命令，以在公网设备上的8081端口和局域网设备上的8081端口之间创建一个SSH隧道：</p><ol><li><p>在局域网设备上安装<code>ssh</code>和<code>autossh</code>（如果尚未安装的话）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">ssh</span> autossh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>创建SSH密钥对（如果尚未创建的话）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ssh-keygen

<span class="token comment"># 例如</span>
$ ssh-keygen
Generating public/private rsa key pair.
Enter <span class="token function">file</span> <span class="token keyword">in</span> <span class="token function">which</span> to save the key <span class="token punctuation">(</span>/root/.ssh/id_rsa<span class="token punctuation">)</span>: id_rsa
Enter passphrase <span class="token punctuation">(</span>empty <span class="token keyword">for</span> no passphrase<span class="token punctuation">)</span>: qwe123
Enter same passphrase again: qwe123
Your identification has been saved <span class="token keyword">in</span> id_rsa
Your public key has been saved <span class="token keyword">in</span> id_rsa.pub
The key fingerprint is:
SHA256:uS65+kL6mxnJJFCnF4d2/kVHeTskXOw1yoJFd2PJrBk root@msy
The key&#39;s randomart image is:
+---<span class="token punctuation">[</span>RSA <span class="token number">3072</span><span class="token punctuation">]</span>----+
<span class="token operator">|</span>  <span class="token builtin class-name">.</span> o<span class="token punctuation">..</span>   .+.<span class="token operator">=</span>++.<span class="token operator">|</span>
<span class="token operator">|</span> <span class="token builtin class-name">.</span> ooo.   <span class="token punctuation">..</span>*E*<span class="token operator">=</span>o<span class="token operator">|</span>
<span class="token operator">|</span><span class="token builtin class-name">.</span> <span class="token punctuation">..</span>.o   .o<span class="token punctuation">..</span><span class="token operator">==</span>o.<span class="token operator">|</span>
<span class="token operator">|</span> <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span>  <span class="token builtin class-name">.</span>  o<span class="token punctuation">..</span> <span class="token operator">=</span>+  <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span>  .S.  <span class="token builtin class-name">.</span>  <span class="token builtin class-name">.</span> <span class="token operator">|</span>
<span class="token operator">|</span>   +<span class="token punctuation">..</span>  <span class="token punctuation">..</span>       <span class="token operator">|</span>
<span class="token operator">|</span>   o+  <span class="token punctuation">..</span>        <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token builtin class-name">.</span> .+o.         <span class="token operator">|</span>
<span class="token operator">|</span>   .*<span class="token operator">=</span>oo.        <span class="token operator">|</span>
+----<span class="token punctuation">[</span>SHA256<span class="token punctuation">]</span>-----+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>将局域网设备的公钥添加到公网设备的<code>~/.ssh/authorized_keys</code>文件中。你可以通过<code>ssh-copy-id</code>命令来完成这个步骤：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ssh-copy-id <span class="token operator">&lt;</span>公网设备用户名<span class="token operator">&gt;</span>@8.134.151.111

<span class="token comment"># 例如</span>
$ ssh-copy-id root@8.134.151.215
/usr/bin/ssh-copy-id: INFO: Source of key<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to be installed: <span class="token string">&quot;/root/.ssh/id_rsa.pub&quot;</span>
The authenticity of <span class="token function">host</span> <span class="token string">&#39;8.134.151.215 (8.134.151.215)&#39;</span> can<span class="token string">&#39;t be established.
ED25519 key fingerprint is SHA256:cnincYMzCu8zoJ+26nAZBdayDT9QS8Mq5Sp3Fmn2zoM.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@8.134.151.215&#39;</span>s password:

Number of key<span class="token punctuation">(</span>s<span class="token punctuation">)</span> added: <span class="token number">1</span>

Now try logging into the machine, with:   <span class="token string">&quot;ssh &#39;root@8.134.151.215&#39;&quot;</span>
and check to <span class="token function">make</span> sure that only the key<span class="token punctuation">(</span>s<span class="token punctuation">)</span> you wanted were added.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用<code>autossh</code>创建一个SSH隧道：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>autossh <span class="token parameter variable">-M</span> <span class="token number">0</span> <span class="token parameter variable">-o</span> <span class="token string">&quot;ServerAliveInterval 30&quot;</span> <span class="token parameter variable">-o</span> <span class="token string">&quot;ServerAliveCountMax 3&quot;</span> <span class="token parameter variable">-R</span> <span class="token number">8081</span>:localhost:8081 <span class="token operator">&lt;</span>公网设备用户名<span class="token operator">&gt;</span>@8.134.151.111

<span class="token comment"># 例如：</span>
$ autossh <span class="token parameter variable">-M</span> <span class="token number">0</span> <span class="token parameter variable">-o</span> <span class="token string">&quot;ServerAliveInterval 30&quot;</span> <span class="token parameter variable">-o</span> <span class="token string">&quot;ServerAliveCountMax 3&quot;</span> <span class="token parameter variable">-R</span> <span class="token number">8081</span>:localhost:8081 root@8.134.151.215
Enter passphrase <span class="token keyword">for</span> key <span class="token string">&#39;/root/.ssh/id_rsa&#39;</span><span class="token builtin class-name">:</span> qwe123
Linux iZ7xv8wxsqxfla1txzmm8lZ <span class="token number">5.10</span>.0-21-amd64 <span class="token comment">#1 SMP Debian 5.10.162-1 (2023-01-21) x86_64</span>
Welcome to Alibaba Cloud Elastic Compute Service <span class="token operator">!</span>
Last login: Fri Nov  <span class="token number">3</span> <span class="token number">10</span>:58:22 <span class="token number">2023</span> from <span class="token number">27.45</span>.72.99
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>这样，公网设备上的8081端口就被映射到了局域网设备的8081端口。</p><h4 id="公网操作" tabindex="-1"><a class="header-anchor" href="#公网操作"><span>公网操作</span></a></h4><p>注意，你可能需要在公网设备上修改SSH配置以允许远程端口转发。这可以通过编辑<code>/etc/ssh/sshd_config</code>文件并添加或修改以下行来完成：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>GatewayPorts <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后重启SSH服务：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">ssh</span> restart
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个设置将允许从公网设备的任何地址连接到转发的端口。如果你只想从公网设备本身连接到转发的端口，你可以将<code>GatewayPorts</code>设置为<code>localhost</code>。</p><h4 id="验证" tabindex="-1"><a class="header-anchor" href="#验证"><span>验证</span></a></h4><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">curl</span> http://localhost:8081
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="windows版" tabindex="-1"><a class="header-anchor" href="#windows版"><span>Windows版</span></a></h4><p>与上面差不多，保证好公网配置好和局域网安装好ssh后，powershell：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">ssh</span> <span class="token parameter variable">-R</span> <span class="token number">8080</span>:localhost:8080 root@8.134.151.215
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果你想让这个SSH隧道在后台运行，你可以添加<code>-f -N</code>参数：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">ssh</span> <span class="token parameter variable">-f</span> <span class="token parameter variable">-N</span> <span class="token parameter variable">-R</span> <span class="token number">52955</span>:localhost:52955 <span class="token operator">&lt;</span>公网设备用户名<span class="token operator">&gt;</span>@8.134.151.111
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="iptable方案-可udp" tabindex="-1"><a class="header-anchor" href="#iptable方案-可udp"><span>iptable方案 (可UDP)</span></a></h3><p>在这种情况下，你可以在Linux A上使用iptables进行端口转发。这需要在Linux A上运行的网络防火墙配置中进行一些修改。</p><p>以下是一种可能的iptables规则配置方式：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 允许转发</span>
<span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">&gt;</span> /proc/sys/net/ipv4/ip_forward

<span class="token comment"># 设置NAT规则</span>
iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> PREROUTING <span class="token parameter variable">-p</span> udp <span class="token parameter variable">--dport</span> <span class="token number">7000</span> <span class="token parameter variable">-j</span> DNAT --to-destination <span class="token punctuation">[</span>LinuxB的内网IP地址<span class="token punctuation">]</span>:7000
iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> POSTROUTING <span class="token parameter variable">-p</span> udp <span class="token parameter variable">-d</span> <span class="token punctuation">[</span>LinuxB的内网IP地址<span class="token punctuation">]</span> <span class="token parameter variable">--dport</span> <span class="token number">7000</span> <span class="token parameter variable">-j</span> SNAT --to-source <span class="token punctuation">[</span>LinuxA的公网IP地址<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的规则意味着：</p><ol><li>当一个UDP包到达Linux A的7000端口时，PREROUTING规则会将它的目标地址更改为Linux B的内网IP地址，端口保持为7000。</li><li>当Linux B向Linux A响应UDP包时，POSTROUTING规则会将源地址更改为Linux A的公网IP地址，这样对于外部的客户端来说，就像是与Linux A进行通信一样。</li></ol><p>注意这里的IP地址需要替换为你实际的IP地址。同时，确保Linux A的防火墙允许7000端口的UDP流量。</p><p>这种方式<strong>需要Linux A具有路由到Linux B的能力</strong>，也就是说，Linux A需要知道如何将包发送到Linux B。如果Linux A和Linux B在同一个子网内，或者Linux A知道去往Linux B的路由，那么这通常不是问题。</p><p>此外，这种设置可能需要root权限才能进行。如果你没有root权限，你可能需要联系你的系统管理员。</p><p>最后，这些更改可能在重启后失效。如果你希望它们在重启后仍然有效，你可能需要将这些命令添加到启动脚本中，或者使用iptables持久化工具，如<code>iptables-persistent</code>。</p><p>这是一个基础的解决方案，实际的网络环境可能会更复杂，需要更多的配置。例如，如果你的网络中有其他的防火墙或路由设备，你可能需要在这些设备上进行额外的配置。</p><h3 id="openvpn-可udp" tabindex="-1"><a class="header-anchor" href="#openvpn-可udp"><span>openVPN (可UDP)</span></a></h3><p>对不起，我之前没有完全理解你的问题。你的情况是Linux A无法直接访问Linux B，但Linux B可以访问Linux A，并且你希望进行UDP流量的转发。这确实比我之前描述的更复杂一些。</p><p>你可以考虑使用SSH隧道的UDP版本，也就是VPN。如果你有权限在Linux B上运行服务，那么你可以在那里设置一个VPN服务器，然后在Linux A上连接到这个VPN。这样，Linux A就可以访问Linux B了，然后你就可以使用我之前描述的iptables规则进行端口转发。</p><p>OpenVPN是一种常见的VPN解决方案，它支持UDP流量。以下是一个简单的OpenVPN配置示例：</p><p>在Linux B（VPN服务器）上：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openvpn <span class="token parameter variable">--remote</span> <span class="token punctuation">[</span>LinuxA的公网IP地址<span class="token punctuation">]</span> <span class="token parameter variable">--dev</span> tun <span class="token parameter variable">--ifconfig</span> <span class="token number">10.8</span>.0.1 <span class="token number">10.8</span>.0.2 <span class="token parameter variable">--cipher</span> none <span class="token parameter variable">--auth</span> none <span class="token parameter variable">--proto</span> udp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在Linux A（VPN客户端）上：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openvpn <span class="token parameter variable">--remote</span> <span class="token punctuation">[</span>LinuxB的公网IP地址<span class="token punctuation">]</span> <span class="token parameter variable">--dev</span> tun <span class="token parameter variable">--ifconfig</span> <span class="token number">10.8</span>.0.2 <span class="token number">10.8</span>.0.1 <span class="token parameter variable">--cipher</span> none <span class="token parameter variable">--auth</span> none <span class="token parameter variable">--proto</span> udp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后在Linux A上设置iptables规则进行端口转发：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> PREROUTING <span class="token parameter variable">-p</span> udp <span class="token parameter variable">--dport</span> <span class="token number">7000</span> <span class="token parameter variable">-j</span> DNAT --to-destination <span class="token number">10.8</span>.0.1:7000
iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> POSTROUTING <span class="token parameter variable">-p</span> udp <span class="token parameter variable">-d</span> <span class="token number">10.8</span>.0.1 <span class="token parameter variable">--dport</span> <span class="token number">7000</span> <span class="token parameter variable">-j</span> SNAT --to-source <span class="token punctuation">[</span>LinuxA的公网IP地址<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这只是一个基本的示例，实际的配置可能会更复杂。例如，你可能需要考虑安全性问题，例如使用加密和身份验证而不是<code>--cipher none --auth none</code>。你也可能需要根据你的网络环境调整<code>--ifconfig</code>参数。</p><p>请注意，这种方法需要Linux B可以访问Linux A，而且需要在两台机器上都安装OpenVPN。如果你不能在Linux B上运行服务，那么这种方法可能无法工作。</p>`,57)]))}const r=a(p,[["render",i],["__file","公网局域网映射.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E5%A4%9A%E6%9C%BA%E7%BB%84%E7%BD%91/%E5%85%AC%E7%BD%91%E5%B1%80%E5%9F%9F%E7%BD%91%E6%98%A0%E5%B0%84.html","title":"公网局域网映射","lang":"zh-CN","frontmatter":{"Permission":"yunzheng","description":"公网局域网映射 见 \\"网络工具/转发工具\\" GPT Nginx方案 我有一台公网Debian设备(8.134.151.111)和局域网Ubuntu设备(192.168.31.164)，两台机器在不同的环境，我想将公网的8081端口映射到局域网的8081端口 实现这个目标，你需要在公网Debian设备上设置一个反向代理，这样它就可以将来自8081端口的流...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E5%A4%9A%E6%9C%BA%E7%BB%84%E7%BD%91/%E5%85%AC%E7%BD%91%E5%B1%80%E5%9F%9F%E7%BD%91%E6%98%A0%E5%B0%84.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"公网局域网映射"}],["meta",{"property":"og:description","content":"公网局域网映射 见 \\"网络工具/转发工具\\" GPT Nginx方案 我有一台公网Debian设备(8.134.151.111)和局域网Ubuntu设备(192.168.31.164)，两台机器在不同的环境，我想将公网的8081端口映射到局域网的8081端口 实现这个目标，你需要在公网Debian设备上设置一个反向代理，这样它就可以将来自8081端口的流..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"公网局域网映射\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"公网局域网映射","slug":"公网局域网映射","link":"#公网局域网映射","children":[{"level":2,"title":"GPT","slug":"gpt","link":"#gpt","children":[{"level":3,"title":"Nginx方案","slug":"nginx方案","link":"#nginx方案","children":[]},{"level":3,"title":"ssh隧道方案 (仅TCP)","slug":"ssh隧道方案-仅tcp","link":"#ssh隧道方案-仅tcp","children":[{"level":4,"title":"局域网操作","slug":"局域网操作","link":"#局域网操作","children":[]},{"level":4,"title":"公网操作","slug":"公网操作","link":"#公网操作","children":[]},{"level":4,"title":"验证","slug":"验证","link":"#验证","children":[]},{"level":4,"title":"Windows版","slug":"windows版","link":"#windows版","children":[]}]},{"level":3,"title":"iptable方案 (可UDP)","slug":"iptable方案-可udp","link":"#iptable方案-可udp","children":[]},{"level":3,"title":"openVPN (可UDP)","slug":"openvpn-可udp","link":"#openvpn-可udp","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.97,"words":2092},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/多机组网/公网局域网映射.md","excerpt":"\\n<p>见 \\"网络工具/转发工具\\"</p>\\n<h2>GPT</h2>\\n<h3>Nginx方案</h3>\\n<blockquote>\\n<p>我有一台公网Debian设备(8.134.151.111)和局域网Ubuntu设备(192.168.31.164)，两台机器在不同的环境，我想将公网的8081端口映射到局域网的8081端口</p>\\n</blockquote>\\n<p>实现这个目标，你需要在公网Debian设备上设置一个反向代理，这样它就可以将来自8081端口的流量转发到局域网Ubuntu设备的8081端口。你可以使用Nginx或者Apache等工具来实现这个功能。这里我提供一个使用Nginx的示例：</p>","autoDesc":true}');export{r as comp,c as data};
