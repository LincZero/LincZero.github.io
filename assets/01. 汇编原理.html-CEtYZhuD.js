import{_ as d,e,g as a,o as n}from"./app-DeGPQmv-.js";const r={};function s(i,t){return n(),e("div",null,t[0]||(t[0]=[a(`<h1 id="computersystems" tabindex="-1"><a class="header-anchor" href="#computersystems"><span>ComputerSystems</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="汇编原理" tabindex="-1"><a class="header-anchor" href="#汇编原理"><span>汇编原理</span></a></h1><h2 id="汇编原理-1" tabindex="-1"><a class="header-anchor" href="#汇编原理-1"><span>汇编原理</span></a></h2><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例</span></a></h3><h4 id="制定一些简单指令" tabindex="-1"><a class="header-anchor" href="#制定一些简单指令"><span>制定一些简单指令</span></a></h4><table><thead><tr><th>指令</th><th>代码</th><th>功能</th></tr></thead><tbody><tr><td>LOAD_A</td><td>0000</td><td>将指定内存地址数据加载至寄存器A</td></tr><tr><td>LOAD_B</td><td>0001</td><td>将指定内存地址数据加载至寄存器B</td></tr><tr><td>ADD</td><td>0100</td><td>将指定两个寄存器数据相加</td></tr><tr><td>STORE_A</td><td>1000</td><td>将寄存器数据存储至制定内存地址</td></tr></tbody></table><h4 id="汇编代码" tabindex="-1"><a class="header-anchor" href="#汇编代码"><span>汇编代码</span></a></h4><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LOAD_A 7	0000 0111</span></span>
<span class="line"><span>LOAD_B 8	0001 1000</span></span>
<span class="line"><span>ADD A B 	0100 0001</span></span>
<span class="line"><span>STORE_A 15	1000 1111</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="内存状态" tabindex="-1"><a class="header-anchor" href="#内存状态"><span>内存状态</span></a></h4><p>冯诺依曼架构计算机（存储程序计算机），指令和数据都放在内存中</p><table><thead><tr><th>地址</th><th>内容</th><th>二进制地址</th></tr></thead><tbody><tr><td>0</td><td>LOAD_A 7</td><td>0000</td></tr><tr><td>1</td><td>LOAD_B 8</td><td>0001</td></tr><tr><td>2</td><td>ADD A B</td><td>0010</td></tr><tr><td>3</td><td>STORE_A F</td><td>0011</td></tr><tr><td>4</td><td></td><td></td></tr><tr><td>5</td><td></td><td></td></tr><tr><td>6</td><td></td><td></td></tr><tr><td>7</td><td>8</td><td>0111</td></tr><tr><td>8</td><td>6</td><td>1000</td></tr><tr><td>……</td><td></td><td></td></tr><tr><td>F</td><td>(14)</td><td>1111</td></tr></tbody></table><h4 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤"><span>步骤</span></a></h4><p><code>指令流水线</code>整体步骤：取指 -&gt; 解码 -&gt; 执行（循环）。有的CPU的流水线可能不止三级</p><p>分步步骤（补充：每一行指令完成后IC自动+1，下表中不再赘述这点）</p><table><thead><tr><th>IC</th><th>取指令</th><th>解码</th><th>执行</th></tr></thead><tbody><tr><td>0，CPU初始化完成后置为0</td><td>控制单元到内存地址为0的位置取指令</td><td>0000 0111</td><td>执行加载指令，地址中的内容 (8) 到寄存器A</td></tr><tr><td>1</td><td>LOAD_B 8</td><td>0001 1000</td><td>执行加载指令，地址中的内容 (6) 到寄存器B</td></tr><tr><td>2</td><td>ADD A B</td><td>0100 0001</td><td>6和8送往ALU的两端，产生结果14后存回寄存器A</td></tr><tr><td>3</td><td>STORE_A F</td><td>1000 1111</td><td>执行存储指令，将寄存器A的内容存向指定地址</td></tr></tbody></table><h3 id="指令集架构" tabindex="-1"><a class="header-anchor" href="#指令集架构"><span>指令集架构</span></a></h3><ul><li><p>历史扩展</p><ul><li><p>x86</p><p>指令集架构起初都是CPU的制造厂商制定的，经典的是Intel提出的x86<br> Intel制定指令集、设计CPU电路、制造CPU均能自己</p></li><li><p>公版ARM</p><p>后来英国ARM公司推出ARM指令集架构<br> 但是ARM不制造CPU，授权产商可以根据他们提供的电路执行制造CPU。</p><ul><li><p>定制ARM</p><p>有能力生产CPU的产商：化为、低通、挨炮、三桑等公司<br> 他们会根据自己的需求，改进公版的设计，集成更多模块（如5G基带、图像处理模块等），产出：麒麟、骁龙、A系列、猎户座等产品</p></li><li><p>SoC</p><p>这些集成度很高的产品，称为SoC，超出了传统CPU的定义<br> 像台积电这种产商专注于这些产品的代工<br> Intel、AMD等产生也在x86架构中集成GPU或IO模块，向着SoC的方向发展。CPU和SoC的界限逐渐变得模糊</p></li></ul></li><li><p>RISC-V开源指令集<br> 前面的都是要钱的，这个可以使用该指令集自行设计电路，不需要钱<br> 但如果使用RISC-V官方给出的具体电路设计，这个是要钱的</p></li></ul></li></ul><h3 id="历史原理" tabindex="-1"><a class="header-anchor" href="#历史原理"><span>历史原理</span></a></h3><p>bug计算机缺陷、patch补丁 的由来</p><ul><li>逻辑电路：开关机</li><li>机器语言：高低电压 + 打孔纸带</li><li>汇编语言：用单词来代替一串01序列</li><li>高级语言</li></ul>`,21)]))}const l=d(r,[["render",s],["__file","01. 汇编原理.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/01.%20%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/01.%20%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.html","title":"ComputerSystems","lang":"zh-CN","frontmatter":{"description":"ComputerSystems 目录 汇编原理 汇编原理 举例 制定一些简单指令 汇编代码 内存状态 冯诺依曼架构计算机（存储程序计算机），指令和数据都放在内存中 步骤 指令流水线整体步骤：取指 -> 解码 -> 执行（循环）。有的CPU的流水线可能不止三级 分步步骤（补充：每一行指令完成后IC自动+1，下表中不再赘述这点） 指令集架构 历史扩展 x8...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/01.%20%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/01.%20%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"ComputerSystems"}],["meta",{"property":"og:description","content":"ComputerSystems 目录 汇编原理 汇编原理 举例 制定一些简单指令 汇编代码 内存状态 冯诺依曼架构计算机（存储程序计算机），指令和数据都放在内存中 步骤 指令流水线整体步骤：取指 -> 解码 -> 执行（循环）。有的CPU的流水线可能不止三级 分步步骤（补充：每一行指令完成后IC自动+1，下表中不再赘述这点） 指令集架构 历史扩展 x8..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ComputerSystems\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":2.46,"words":739},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/01. 汇编基础/01. 汇编原理.md","excerpt":"\\n<h1>目录</h1>\\n<h1>汇编原理</h1>\\n<h2>汇编原理</h2>\\n<h3>举例</h3>\\n<h4>制定一些简单指令</h4>\\n<table>\\n<thead>\\n<tr>\\n<th>指令</th>\\n<th>代码</th>\\n<th>功能</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>LOAD_A</td>\\n<td>0000</td>\\n<td>将指定内存地址数据加载至寄存器A</td>\\n</tr>\\n<tr>\\n<td>LOAD_B</td>\\n<td>0001</td>\\n<td>将指定内存地址数据加载至寄存器B</td>\\n</tr>\\n<tr>\\n<td>ADD</td>\\n<td>0100</td>\\n<td>将指定两个寄存器数据相加</td>\\n</tr>\\n<tr>\\n<td>STORE_A</td>\\n<td>1000</td>\\n<td>将寄存器数据存储至制定内存地址</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/01. 汇编基础/01. 汇编原理.md","value":{"title":"01. 汇编原理","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/01. 汇编基础/01. 汇编原理.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{l as comp,p as data};
