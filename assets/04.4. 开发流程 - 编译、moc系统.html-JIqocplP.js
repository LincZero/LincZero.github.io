import{_ as s,c as r,b as a,a as i,e as l,d as t,o as d,r as c}from"./app-D3Mctuuh.js";const o={},m={href:"https://blog.csdn.net/caoshangpa/article/details/80135971",target:"_blank",rel:"noopener noreferrer"},p={href:"https://blog.51cto.com/devbean/355100",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.cnblogs.com/wzxNote/p/8341006.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.cnblogs.com/xiangism/p/4621108.html",target:"_blank",rel:"noopener noreferrer"},h={href:"http://developer.qt.nokia.com/quarterly/view/using_cmake_to_build_qt_projects",target:"_blank",rel:"noopener noreferrer"};function b(g,e){const n=c("ExternalLinkIcon");return d(),r("div",null,[e[15]||(e[15]=a('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="项目流程-编译、moc系统-三种方法" tabindex="-1"><a class="header-anchor" href="#项目流程-编译、moc系统-三种方法"><span>项目流程 - 编译、moc系统（三种方法）</span></a></h1><p>编译Qt应用程序：有三种方法编译应用程序</p><h2 id="基础知识-qt与c" tabindex="-1"><a class="header-anchor" href="#基础知识-qt与c"><span>基础知识：Qt与C++</span></a></h2><p>参考：</p>',6)),i("ul",null,[i("li",null,[i("a",m,[e[0]||(e[0]=l("【CSDN】Qt核心剖析: moc")),t(n)]),e[2]||(e[2]=l("（")),i("a",p,[e[1]||(e[1]=l("【51CTO】Qt核心剖析: moc")),t(n)]),e[3]||(e[3]=l("）"))]),i("li",null,[i("a",u,[e[4]||(e[4]=l("【博客园】qt中moc的作用")),t(n)])])]),e[16]||(e[16]=i("p",null,[l("Qt 不是使用的“标准的” C++ 语言，而是对其进行了一定程度的“扩展”。这里我们从Qt新增加的关键字就可以看出来："),i("code",null,"signals、slots 或者 emit"),l("。")],-1)),e[17]||(e[17]=i("p",null,"所以有人会觉得 Qt 的程序编译速度慢，这主要是因为在 Qt 将源代码交给标准 C++ 编译器，如 gcc 之前，需要事先将这些扩展的语法去除掉。",-1)),e[18]||(e[18]=i("p",null,"完成这一操作的就是 moc。",-1)),e[19]||(e[19]=i("p",null,"moc具体操作见后",-1)),e[20]||(e[20]=i("h2",{id:"moc、uic、rcc-编译工具",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#moc、uic、rcc-编译工具"},[i("span",null,"moc、uic、rcc 编译工具")])],-1)),i("p",null,[e[6]||(e[6]=l("参考：")),i("a",v,[e[5]||(e[5]=l("【博客园】qt的moc,uic,rcc命令的使用")),t(n)])]),e[21]||(e[21]=a(`<p>关于名称：</p><ul><li>moc：Meta-Object Compiler，也就是“元对象编译器”</li><li>uic：ui Compiler</li><li>rcc：qrc Compiler</li></ul><h3 id="moc" tabindex="-1"><a class="header-anchor" href="#moc"><span>moc</span></a></h3><h4 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h4><p>moc 全称是 Meta-Object Compiler，也就是“元对象编译器”</p><p>Qt 程序在交由标准编译器编译之前，先要使用 moc 分析 C++ 源文件。如果它发现在一个头文件中包含了<code>宏 Q_OBJECT</code>，则会生成另外一个 C++ 源文件。这个源文件中包含了 Q_OBJECT 宏的实现代码。这个新的文件名字将会是原文件名前面加上 moc_ 构成。</p><p>这个新的文件同样将进入编译系统，最终被链接到二进制代码中去。因此我们可以知道，这个新的文件不是“替换”掉旧的文件，而是与原文件一起参与编译。另外，我们还可以看出一点，</p><p><strong>moc 的执行是在预处理器之前。因为预处理器执行之后，Q_OBJECT 宏就不存在了</strong></p><p>Qt 将源代码交给标准 C++ 编译器，如 gcc 之前，需要事先将这些扩展的语法去除掉。完成这一操作的就是 moc</p><h4 id="使用命令" tabindex="-1"><a class="header-anchor" href="#使用命令"><span>使用命令</span></a></h4><p>从qt继承而来的类只要用了关键字 Q_OBJECT，都必须生成其对应的moc文件（不带Q_OBJENT的源文件） 命令行命令如下</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>moc.exe myclass.h <span class="token parameter variable">-o</span> mac_myclass.cpp
<span class="token comment"># 或</span>
moc yourfilename.h <span class="token parameter variable">-o</span> moc_youfilename.cpp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中myclass.h中有类有Q_OBJECT属性。在vs项目中只需要添加mac_myclass.cpp文件即可</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><ol><li>moc 就是“元对象编译器”；</li><li>Qt程序在交给标准编译器预编译之前要使用 moc 分析 C++ 源文件；</li><li>如果有宏 Q_OBJECT，则生成一个包含Q_OBJECT 宏的实现代码的C++源文件；</li><li>新生成的源文件参与到标准编译器的编译中；</li><li>编译过程中如果找不到对应的moc文件就会出现链接错误，此时要添加上对应的moc文件；</li></ol><h4 id="相关报错" tabindex="-1"><a class="header-anchor" href="#相关报错"><span>相关报错</span></a></h4><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>error PRJ0019: A tool returned an error code from <span class="token string">&quot;Moc&#39;ing treenodepreferencepage.h...&quot;</span> imediago
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>主要是.h文件的属性配置有问题，详细解决方案参见下面链接</li></ul><p>https://jingyan.baidu.com/article/3065b3b68518adbecef8a477.html</p><p>有时候简单的修改这个属性还不能起到想要的效果，具体原因以及应对方法等到下周一分解</p><ul><li>有可能是定义的类没有继承QObject这样的Qt类导致的</li></ul><h4 id="生成代码原理解析" tabindex="-1"><a class="header-anchor" href="#生成代码原理解析"><span>生成代码原理解析</span></a></h4><p>moc_core.cpp（原代码51行，moc文件去注释后85行）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;memory&gt;
#include &quot;../../../SuperManager/Core/core.h&quot;		// 关键，包含原文件的头文件
#include &lt;QtCore/qbytearray.h&gt;
#include &lt;QtCore/qmetatype.h&gt;
#if !defined(Q_MOC_OUTPUT_REVISION)
//#error &quot;The header file &#39;core.h&#39; doesn&#39;t include &lt;QObject&gt;.&quot;	// 报错时，不运行
//#elif Q_MOC_OUTPUT_REVISION != 68
//#error &quot;This file was generated using the moc from 6.0.3. It&quot;
//#error &quot;cannot be used with the include files from this version of Qt.&quot;
//#error &quot;(The moc has changed too much.)&quot;
#endif

QT_BEGIN_MOC_NAMESPACE								// 话说moc文件依旧存在挺多的QT宏
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_Core_t {
    const uint offsetsAndSize[2];
    char stringdata0[5];
};
#define QT_MOC_LITERAL(ofs, len) \\
    uint(offsetof(qt_meta_stringdata_Core_t, stringdata0) + ofs), len 
static const qt_meta_stringdata_Core_t qt_meta_stringdata_Core = {
    {
QT_MOC_LITERAL(0, 4) // &quot;Core&quot;

    },
    &quot;Core&quot;
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_Core[] = {

 // content:
       9,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void Core::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)	// 【元call】（静态）
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject Core::staticMetaObject = { {											// 【元对象系统】（静态）
    QMetaObject::SuperData::link&lt;QMainWindow::staticMetaObject&gt;(),
    qt_meta_stringdata_Core.offsetsAndSize,
    qt_meta_data_Core,
    qt_static_metacall,
    nullptr,
    nullptr,
    nullptr
} };


const QMetaObject *Core::metaObject() const												// 【元对象系统】
{
    return QObject::d_ptr-&gt;metaObject ? QObject::d_ptr-&gt;dynamicMetaObject() : &amp;staticMetaObject;
}

void *Core::qt_metacast(const char *_clname)											// 【元cast】
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_Core.stringdata0))
        return static_cast&lt;void*&gt;(this);
    return QMainWindow::qt_metacast(_clname);
}

int Core::qt_metacall(QMetaObject::Call _c, int _id, void **_a)							// 【元call】
{
    _id = QMainWindow::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是五个函数</p><ul><li><code>void A::qt_static_metacall</code></li><li><code>const QMetaObject A::staticMetaObject</code></li><li><code>const QMetaObject *A::metaObject() const</code></li><li><code>void *A::qt_metacast</code></li><li><code>int A::qt_metacall</code></li></ul><h3 id="ui" tabindex="-1"><a class="header-anchor" href="#ui"><span>UI</span></a></h3><p>虽然不使用designer来设计界面，但在编译一个demo项目时都会用*.ui文件，这时得先将其用uic.exe进行转化</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>uic.exe app.ui <span class="token parameter variable">-o</span> ui_app.h
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中app.ui是用designer设计好的界面文件， ui_app.h是生成的头文件。然后在c++项目中#include &quot;ui_app.h&quot;即可。</p><h4 id="生成代码原理解析-1" tabindex="-1"><a class="header-anchor" href="#生成代码原理解析-1"><span>生成代码原理解析</span></a></h4><p>略，其实和正常写cpp没什么区别</p><h3 id="资源" tabindex="-1"><a class="header-anchor" href="#资源"><span>资源</span></a></h3><p>qt定义了一套它自己的资源使用方式，其资源定义文件形如*.qrc</p><p>ras.qrc文件其实就是一个xml文件，其中就包含了ras文件夹中的一些png文件。</p><p>用如下的命令可以将ras.qrc文件转化成cpp代码:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>rcc.exe -no-compress ras.qrc <span class="token parameter variable">-o</span> ras.cpp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样在vs项目中添加ras.cpp文件后，就可以用如下的路径来使用资源</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QIcon icon_app(&quot;:/ras/app.png&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="生成代码原理解析-2" tabindex="-1"><a class="header-anchor" href="#生成代码原理解析-2"><span>生成代码原理解析</span></a></h4><p>大致地看一下ras.cpp的代码，可以发现qt应该是将图像的像素点转化成c++字节数组进行存储</p><p>里面有几个主要的数组</p><ul><li>第一个是data数组 <ul><li>存放的是资源列表文件真实的16进制</li></ul></li><li>第二个是url数组 <ul><li>存放的是资源列表的url</li></ul></li></ul><h3 id="qml" tabindex="-1"><a class="header-anchor" href="#qml"><span>QML</span></a></h3><h4 id="生成代码原理解析-3" tabindex="-1"><a class="header-anchor" href="#生成代码原理解析-3"><span>生成代码原理解析</span></a></h4><p>主要注意项是id绑定和调用指定id的参数</p><p>原理上是会生成类似信号和槽的代码</p><h3 id="代码批量转化" tabindex="-1"><a class="header-anchor" href="#代码批量转化"><span>代码批量转化</span></a></h3><p>上面说的这些命令，如果只是一个小项目，还可以去手动输入一个个命令，如果是一个大项目，那如果手动的话就简单是恶梦了</p><p>可以用IDE等其他工具实现自动转换</p><h2 id="make-编译工具" tabindex="-1"><a class="header-anchor" href="#make-编译工具"><span>make 编译工具</span></a></h2><h3 id="qmake-qt提供" tabindex="-1"><a class="header-anchor" href="#qmake-qt提供"><span>qmake（Qt提供）</span></a></h3><ul><li><p>qmake工作原理</p><ul><li><p>使用与平台无关的<code>.pro文件</code>生成与平台相关的<code>makefile</code></p></li><li><p>该工具包含了调用Qt内置代码生成工具（moc、uic、rcc）的必要逻辑规则</p></li><li><p>qmake工具是与Qt一起提供的，它用来编译Qt本身</p></li></ul></li><li><p>使用</p><ul><li>qmake的在线帮助文档：http://doc.qt.io/qt-5/qmake-manual.html</li></ul></li><li><p>qmake指令</p><ul><li><p>主要目的是生成makefile，也可以用来生成.pro文件</p></li><li><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>qmake hello.pro 					<span class="token comment"># 生成工程文件hello.pro的makefile</span>
qmake <span class="token parameter variable">-tp</span> vc hello.pro				<span class="token comment"># 生成一个Microsoft Visual Studio工程文件（.dsp或.vproj）</span>
qmake <span class="token parameter variable">-project</span>						<span class="token comment"># 生成.pro文件（原理：搜索当前目录下已知扩展名的文件，生成一个列举这些文件的.pro文件）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>-spec命令行参数</p><ul><li><p>可以用来指定平台/编译器的组合</p></li><li><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>qmake <span class="token parameter variable">-spec</span> macx-xcode hello.pro	<span class="token comment"># Mac OS X系统上创建一个Xcode工程文件</span>
qmake <span class="token parameter variable">-spec</span> macx-g++ hello.pro		<span class="token comment"># Mac OS X系统上创建makefile</span>
qmake <span class="token parameter variable">-spec</span> linux-icc-64 hello.pro	<span class="token comment"># linux上以64位模式调用Intel C++编译器(ICC)生成makefile</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="cmake-第三方编译工具" tabindex="-1"><a class="header-anchor" href="#cmake-第三方编译工具"><span>cmake（第三方编译工具）</span></a></h3>`,54)),i("ul",null,[e[12]||(e[12]=i("li",null,"cmake获取：http://www.cmake.org",-1)),e[13]||(e[13]=i("li",null,[l("选用比较 "),i("ul",null,[i("li",null,"qmake 是为 Qt 量身打造的，使用起来非常方便"),i("li",null,"cmake 使用上不如qmake简单直接，但复杂换来的是强大的功能")])],-1)),i("li",null,[e[11]||(e[11]=l("如何选择？ ")),i("ul",null,[i("li",null,[i("a",h,[e[7]||(e[7]=l("Using CMake to Build Qt Projects")),t(n)]),e[8]||(e[8]=l(" 一文中说："))]),e[9]||(e[9]=i("li",null,"对简单的Qt工程，采用 qmake",-1)),e[10]||(e[10]=i("li",null,"对复杂度超过 qmake 处理能力的，采用 cmake",-1))])]),e[14]||(e[14]=i("li",null,[l("项目区别 "),i("ul",null,[i("li",null,"需要创建一个CMakeLists.txt文件，该文件很像是一个qmake.pro文件")])],-1))]),e[22]||(e[22]=a('<p>略</p><h3 id="选择" tabindex="-1"><a class="header-anchor" href="#选择"><span>选择</span></a></h3><p>两者都是构建系统，但它们根本不太相似。如果你的项目使用Qt，那么最好使用qmake。CMake更通用，也是功能更强大的构建系统，并且适用于任何类型的项目</p><h3 id="makefile与cmakelists文件" tabindex="-1"><a class="header-anchor" href="#makefile与cmakelists文件"><span>Makefile与CMakeLists文件</span></a></h3><p>参考学习：</p><ul><li>modern cmake教程</li><li>https://github.com/RaymondZuo301/ModernCMake-Chinese</li></ul><h2 id="集成开发环境-ide-与构建套件-kit" tabindex="-1"><a class="header-anchor" href="#集成开发环境-ide-与构建套件-kit"><span>集成开发环境（IDE）与构建套件（kit）</span></a></h2><h3 id="ide" tabindex="-1"><a class="header-anchor" href="#ide"><span>IDE</span></a></h3><p>略</p><h3 id="kit" tabindex="-1"><a class="header-anchor" href="#kit"><span>Kit</span></a></h3><p>构建套件包含一系列的构建工具，如moc、uic、rcc、gcc/g++等编译命令</p><p>菜单工具 &gt; 选项 &gt; Kits，可查看构建套件</p><p>例如</p><ul><li>Qt 5.15.2 MinGW 32-bit Qt 5.15.2 MinGW 64-bit</li><li>Qt 5.15.2 MSVC2015 64bit Qt 5.15.2 MSVC2019 32bit Qt 5.15.2 MSVC2019 64bit</li><li>Qt 6.0.3 MinGW 64-bit</li><li>Qt 6.0.3 MSVC2019 64bit</li></ul><h2 id="编译生成文件" tabindex="-1"><a class="header-anchor" href="#编译生成文件"><span>编译生成文件</span></a></h2><table><thead><tr><th>工程文件</th><th>相关编译工具</th><th>生成文件</th></tr></thead><tbody><tr><td>main.cpp</td><td>标准编译器gcc</td><td>main.obj</td></tr><tr><td>mainwindow.h<br>mainwindow.h</td><td>标准编译器gcc<br>moc工具<br>moc工具</td><td>mainwindow.obj<br>moc_mainwindow.cpp<br>moc_mainwindow.obj</td></tr><tr><td>mainwindow.ui</td><td>uic工具</td><td>ui_mainwindow.h</td></tr><tr><td>test.qrc</td><td>rcc工具<br>标准编译器gcc</td><td>qrc_test.cpp<br>qrc_test.obj</td></tr><tr><td>无</td><td></td><td>moc_predefs<br>.ilk、.pdb、.vs.pdb</td></tr><tr><td>无</td><td></td><td>Makefile</td></tr></tbody></table><p>编译工具处理顺序</p><ul><li>源代码(.h.cpp) &gt; moc(moc_.cpp) &gt; 预处理器(.i) &gt; gcc编译(.s) &gt; gcc汇编(.o.obj) &gt; gcc链接(.exe)</li></ul><p>非编译过程生成文件，而是最终文件的有</p><ul><li>.exe、.dll</li></ul>',20))])}const _=s(o,[["render",b],["__file","04.4. 开发流程 - 编译、moc系统.html.vue"]]),f=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/02.%20%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/04.4.%20%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%20-%20%E7%BC%96%E8%AF%91%E3%80%81moc%E7%B3%BB%E7%BB%9F.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 项目流程 - 编译、moc系统（三种方法） 编译Qt应用程序：有三种方法编译应用程序 基础知识：Qt与C++ 参考： 【CSDN】Qt核心剖析: moc（【51CTO】Qt核心剖析: moc） 【博客园】qt中moc的作用 Qt 不是使用的“标准的” C++ 语言，而是对其进行了一定程度的“扩展”。这里我们从Qt新增加的关键字就可以看出来：...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/02.%20%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/04.4.%20%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%20-%20%E7%BC%96%E8%AF%91%E3%80%81moc%E7%B3%BB%E7%BB%9F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 项目流程 - 编译、moc系统（三种方法） 编译Qt应用程序：有三种方法编译应用程序 基础知识：Qt与C++ 参考： 【CSDN】Qt核心剖析: moc（【51CTO】Qt核心剖析: moc） 【博客园】qt中moc的作用 Qt 不是使用的“标准的” C++ 语言，而是对其进行了一定程度的“扩展”。这里我们从Qt新增加的关键字就可以看出来：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"项目流程 - 编译、moc系统（三种方法）","slug":"项目流程-编译、moc系统-三种方法","link":"#项目流程-编译、moc系统-三种方法","children":[{"level":2,"title":"基础知识：Qt与C++","slug":"基础知识-qt与c","link":"#基础知识-qt与c","children":[]},{"level":2,"title":"moc、uic、rcc 编译工具","slug":"moc、uic、rcc-编译工具","link":"#moc、uic、rcc-编译工具","children":[{"level":3,"title":"moc","slug":"moc","link":"#moc","children":[{"level":4,"title":"简概","slug":"简概","link":"#简概","children":[]},{"level":4,"title":"使用命令","slug":"使用命令","link":"#使用命令","children":[]},{"level":4,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":4,"title":"相关报错","slug":"相关报错","link":"#相关报错","children":[]},{"level":4,"title":"生成代码原理解析","slug":"生成代码原理解析","link":"#生成代码原理解析","children":[]}]},{"level":3,"title":"UI","slug":"ui","link":"#ui","children":[{"level":4,"title":"生成代码原理解析","slug":"生成代码原理解析-1","link":"#生成代码原理解析-1","children":[]}]},{"level":3,"title":"资源","slug":"资源","link":"#资源","children":[{"level":4,"title":"生成代码原理解析","slug":"生成代码原理解析-2","link":"#生成代码原理解析-2","children":[]}]},{"level":3,"title":"QML","slug":"qml","link":"#qml","children":[{"level":4,"title":"生成代码原理解析","slug":"生成代码原理解析-3","link":"#生成代码原理解析-3","children":[]}]},{"level":3,"title":"代码批量转化","slug":"代码批量转化","link":"#代码批量转化","children":[]}]},{"level":2,"title":"make 编译工具","slug":"make-编译工具","link":"#make-编译工具","children":[{"level":3,"title":"qmake（Qt提供）","slug":"qmake-qt提供","link":"#qmake-qt提供","children":[]},{"level":3,"title":"cmake（第三方编译工具）","slug":"cmake-第三方编译工具","link":"#cmake-第三方编译工具","children":[]},{"level":3,"title":"选择","slug":"选择","link":"#选择","children":[]},{"level":3,"title":"Makefile与CMakeLists文件","slug":"makefile与cmakelists文件","link":"#makefile与cmakelists文件","children":[]}]},{"level":2,"title":"集成开发环境（IDE）与构建套件（kit）","slug":"集成开发环境-ide-与构建套件-kit","link":"#集成开发环境-ide-与构建套件-kit","children":[{"level":3,"title":"IDE","slug":"ide","link":"#ide","children":[]},{"level":3,"title":"Kit","slug":"kit","link":"#kit","children":[]}]},{"level":2,"title":"编译生成文件","slug":"编译生成文件","link":"#编译生成文件","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.5,"words":2250},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/02. 开发流程/04.4. 开发流程 - 编译、moc系统.md","excerpt":"\\n<h1>目录</h1>\\n<h1>项目流程 - 编译、moc系统（三种方法）</h1>\\n<p>编译Qt应用程序：有三种方法编译应用程序</p>\\n<h2>基础知识：Qt与C++</h2>\\n<p>参考：</p>\\n<ul>\\n<li><a href=\\"https://blog.csdn.net/caoshangpa/article/details/80135971\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【CSDN】Qt核心剖析: moc</a>（<a href=\\"https://blog.51cto.com/devbean/355100\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【51CTO】Qt核心剖析: moc</a>）</li>\\n<li><a href=\\"https://www.cnblogs.com/wzxNote/p/8341006.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【博客园】qt中moc的作用</a></li>\\n</ul>","autoDesc":true}');export{_ as comp,f as data};
