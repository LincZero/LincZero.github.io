import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as e,e as t}from"./app-CoO7IlkE.js";const n="/assets/I_O软件分层-Cv_d35w5.png",o="/assets/384029-20160413234742113-712280053-Dy7FR0wx.png",r="/assets/2f4550ee9e8461a237c1adc5bd6a0775-XnKYSJJp.png",s={},a=t('<h1 id="存储系统io软件分层" tabindex="-1"><a class="header-anchor" href="#存储系统io软件分层"><span>存储系统IO软件分层</span></a></h1><h2 id="提前总结" tabindex="-1"><a class="header-anchor" href="#提前总结"><span>提前总结</span></a></h2><h3 id="io软件三个分层" tabindex="-1"><a class="header-anchor" href="#io软件三个分层"><span>IO软件三个分层</span></a></h3><p>前面说到了不少东西，设备、设备控制器、驱动程序、通用块层，现在再结合文件系统原理，我们来看看 Linux 存储系统的 I/O 软件分层。</p><p>可以把 Linux 存储系统的 I/O 由上到下可以分为三个层次：</p><ul><li><p>内核</p><ul><li><p>(1) <strong>文件系统层</strong></p><ul><li>作用：包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。</li></ul></li><li><p>(2) <strong>通用块层</strong></p><ul><li>作用：包括块设备的 I/O 队列和 I/O 调度器，它会对文件系统的 I/O 请求进行排队，再通过 I/O 调度器，选择一个 I/O 发给下一层的设备层。</li></ul></li></ul></li><li><p>物理硬件</p><ul><li>(3) <strong>设备层</strong><ul><li>作用：包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I/O 操作。</li></ul></li></ul></li></ul><p>他们整个的层次关系如下 (下一节的架构图)</p><h3 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图"><span>架构图</span></a></h3><h4 id="存储系统-线性分层" tabindex="-1"><a class="header-anchor" href="#存储系统-线性分层"><span>存储系统 - 线性分层</span></a></h4><figure><img src="'+n+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>用户空间 <ul><li><strong>用户程序</strong></li></ul></li><li>内核空间 <ul><li><strong>文件系统接口</strong></li><li><strong>虚拟文件系统 (VFS)</strong><ul><li>作用：<em>减少差异</em> (不同文件系统)</li></ul></li><li><strong>文件系统 (FS)</strong><ul><li>例如：ext4、nfs</li></ul></li><li><strong>页缓存</strong><ul><li>作用：“非直接I/O” 时的操作系统缓存</li></ul></li><li><strong>通用块层</strong><ul><li>作用：<em>减少差异</em> (不同块设备)、统一管理块设备</li></ul></li><li><strong>IO调度层</strong> (块设备的) <ul><li>作用：IO调度</li></ul></li><li><strong>驱动程序</strong> (块设备的) <ul><li>作用：<em>减少差异</em> (不同设备控制器)</li></ul></li></ul></li><li>物理硬件 <ul><li><strong>中断控制器</strong> (块设备的)</li><li><strong>设备控制器</strong> (块设备的) <ul><li>作用：<em>减少差异</em> (不同设备)</li></ul></li><li><strong>磁盘设备</strong></li></ul></li></ul><p>（在这个文件系统分层里面，我们前面和这章也依次学习过了：VFS FS 页缓存、设备 设备控制器 中断控制器、驱动程序 IO调度 通用块层。 然后把他们串连起来理解，融会贯通一下）</p><h4 id="存储系统-网络系统-字符系统-linux内核系统调用接口" tabindex="-1"><a class="header-anchor" href="#存储系统-网络系统-字符系统-linux内核系统调用接口"><span>存储系统 / 网络系统 / 字符系统 - Linux内核系统调用接口</span></a></h4><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>一些翻译：</p><ul><li>IO子系统 <ul><li>(字符相关, 灰) <ul><li>终端</li><li>line discipline (不会翻译)</li><li><strong>字符设备驱动程序</strong></li></ul></li><li>(网络相关, 绿) <ul><li>套接字</li><li>网络过滤器 / Nftables (后面词那个没搜到翻译)</li><li>网络协议栈</li><li>Linux内核包调度器</li><li><strong>网络设备驱动程序</strong></li></ul></li><li>(文件存储相关, 青) <ul><li><strong>文件系统</strong></li><li><strong>通用块层</strong></li><li><strong>Linux内核IO调度器</strong></li><li><strong>块设备驱动程序</strong></li></ul></li></ul></li><li>内存管理子系统 <ul><li>虚拟内存</li><li>分页页替换 ？？？</li><li>页缓存</li></ul></li><li>程序管理子系统 <ul><li>信号处理</li><li>程序/进程创建与终止</li><li>Linux内核程序调度器</li></ul></li><li>（IRQs 中断请求，Dispatcher 调度器）</li></ul><h4 id="存储系统-堆栈图" tabindex="-1"><a class="header-anchor" href="#存储系统-堆栈图"><span>存储系统 - 堆栈图</span></a></h4><figure><img src="'+r+'" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>一些翻译：</p><ul><li>应用程序</li><li>LIO</li><li>虚拟文件系统 VFS <ul><li>基于块文件系统：ext2、ext3、ext4、xfs、btrfs、ifs、iso9660、gfs、ocfs、……</li><li>网络文件系统：NFS、coda、smbfs、ceph、……</li><li>假文件系统？：proc、sysfs、pipefs、futexfs、usbfs、……</li><li>特别目的文件系统？：tmpfs、ramfs、devtmpfs</li></ul></li><li>页缓存</li><li>通用块层 <ul><li>IO调度器：nooq、cfq、deadline</li><li>blkmq</li></ul></li><li>SCSI 中间层</li><li>SCSI 低层次驱动</li><li>物理驱动 <ul><li>HDD、SDD、DVD驱动</li><li>LSI Raid、LSI Raid、Adaptec Raid</li><li>Qlongic HBA、Emulex HBA、LSI 12Gbs SAS HBA</li><li>para-virtualized SCSI、VMware&#39;s para-virtualized SCSI</li><li>virtio_pci、Micron PCIe Card、nvme device、stec device</li></ul></li></ul><h2 id="设备的读写和操作" tabindex="-1"><a class="header-anchor" href="#设备的读写和操作"><span>设备的读写和操作</span></a></h2><ul><li><p>读写操作</p><ul><li><p>相关函数：<code>read</code>、<code>write</code></p></li><li><p>同读写文件。Linux一切皆文件，包括设备</p><p>有了文件系统接口之后，不但可以通过文件系统的命令行操作设备，也可以通过应用程序，调用 read、write 函数。 就像读写文件一样操作设备，所以说设备在 Linux 下，也只是一个特殊的文件。</p></li></ul></li><li><p>非读写操作</p><ul><li><p>相关函数：<code>ioctl</code></p></li><li><p>除了读写操作，还需要有检查特定于设备的功能和属性。使用 ioctl 接口，它表示输入输出控制接口，是用于配置和修改特定设备属性的通用接口。</p></li></ul></li></ul><h2 id="提高效率的机制" tabindex="-1"><a class="header-anchor" href="#提高效率的机制"><span>提高效率的机制</span></a></h2><p>另外，存储系统的 I/O 是整个系统<strong>最慢</strong>的一个环节，所以 Linux 提供了不少<strong>缓存机制</strong>来提高 I/O 的效率。</p><ul><li>为了提高文件访问的效率：会使用 <strong>页缓存、索引节点缓存、目录项缓存</strong> 等多种缓存机制，目的是为了减少对块设备的直接调用。</li><li>为了提高块设备的访问效率：会使用 <strong>缓冲区</strong>，来缓存块设备的数据。</li></ul>',25),u=[a];function p(E,c){return i(),e("div",null,u)}const B=l(s,[["render",p],["__file","05. 存储系统IO软件分层.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/08.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/05.%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FIO%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.html","title":"存储系统IO软件分层","lang":"zh-CN","frontmatter":{"description":"存储系统IO软件分层 提前总结 IO软件三个分层 前面说到了不少东西，设备、设备控制器、驱动程序、通用块层，现在再结合文件系统原理，我们来看看 Linux 存储系统的 I/O 软件分层。 可以把 Linux 存储系统的 I/O 由上到下可以分为三个层次： 内核 (1) 文件系统层 作用：包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/08.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/05.%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FIO%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"存储系统IO软件分层"}],["meta",{"property":"og:description","content":"存储系统IO软件分层 提前总结 IO软件三个分层 前面说到了不少东西，设备、设备控制器、驱动程序、通用块层，现在再结合文件系统原理，我们来看看 Linux 存储系统的 I/O 软件分层。 可以把 Linux 存储系统的 I/O 由上到下可以分为三个层次： 内核 (1) 文件系统层 作用：包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"存储系统IO软件分层\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"存储系统IO软件分层","slug":"存储系统io软件分层","link":"#存储系统io软件分层","children":[{"level":2,"title":"提前总结","slug":"提前总结","link":"#提前总结","children":[{"level":3,"title":"IO软件三个分层","slug":"io软件三个分层","link":"#io软件三个分层","children":[]},{"level":3,"title":"架构图","slug":"架构图","link":"#架构图","children":[{"level":4,"title":"存储系统 - 线性分层","slug":"存储系统-线性分层","link":"#存储系统-线性分层","children":[]},{"level":4,"title":"存储系统 / 网络系统 / 字符系统 - Linux内核系统调用接口","slug":"存储系统-网络系统-字符系统-linux内核系统调用接口","link":"#存储系统-网络系统-字符系统-linux内核系统调用接口","children":[]},{"level":4,"title":"存储系统 - 堆栈图","slug":"存储系统-堆栈图","link":"#存储系统-堆栈图","children":[]}]}]},{"level":2,"title":"设备的读写和操作","slug":"设备的读写和操作","link":"#设备的读写和操作","children":[]},{"level":2,"title":"提高效率的机制","slug":"提高效率的机制","link":"#提高效率的机制","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.91,"words":1174},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/08. 设备管理/05. 存储系统IO软件分层.md","autoDesc":true}');export{B as comp,h as data};
