import{_ as s,c as a,e as l,o as e}from"./app-DEUP2Tjk.js";const n={};function h(t,i){return e(),a("div",null,i[0]||(i[0]=[l(`<h1 id="《linux内核观测技术bpf》" tabindex="-1"><a class="header-anchor" href="#《linux内核观测技术bpf》"><span>《Linux内核观测技术BPF》</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="运行bpf程序" tabindex="-1"><a class="header-anchor" href="#运行bpf程序"><span>运行BPF程序</span></a></h1><h2 id="llvm-编译器" tabindex="-1"><a class="header-anchor" href="#llvm-编译器"><span>LLVM 编译器</span></a></h2><h3 id="llvm编译器" tabindex="-1"><a class="header-anchor" href="#llvm编译器"><span>LLVM编译器</span></a></h3><blockquote><p>最常见方住是使用 C 语言子集编写 BPF 程序，之后使用 LLVM 编译器进行编译。 <strong>LLVM 编译器</strong> 是一种通用编译器，可以编译成不同类型的<strong>字节码</strong> 。</p></blockquote><h3 id="字节码" tabindex="-1"><a class="header-anchor" href="#字节码"><span>字节码</span></a></h3><blockquote><p>针对 BPF 程序， LLVM 能够编译出加载到内核中执行的汇编代码。本书不会过多地介绍 BPF 汇编。经过慎重考虑，我们决定本书主要介绍在具体情景下如何使用 BDF，关于 BPF 汇编，你可以在网上轻松地找到-些参考或者通过 BPF 手册得到帮助。不过，之后的章节会有 BPF 汇编代码的简短示例，你会发现在某些情景下使用汇编比 C 语言更合适，例如，使用 Seccomp 过滤器控制内核的系统调用。我们将在第 8 章中详细讨论 Seccompo。</p></blockquote><h3 id="加载字节码" tabindex="-1"><a class="header-anchor" href="#加载字节码"><span>加载字节码</span></a></h3><blockquote><p>BPF 程序编译后，内核通过 bpf 系统调用将程序字节码加载到 BPF 虚拟机中 。 除加载程序外， bpf 系统调用还可用于其他操作，我们将在后续章节中看到更多的示例。内核还提供了一些工具 (帮助函数) 协助加载 BPF 程序。</p></blockquote><h3 id="许可证-gpl" tabindex="-1"><a class="header-anchor" href="#许可证-gpl"><span>许可证（GPL）</span></a></h3><blockquote><p>在下面示例的最后，我们还需要指定程序许可证。因为 Linux 内核采用 GPL 许可证，所以它只能加载 GPL 许可证的程序。如果将程序设置为其他许可证，内核将拒绝加载该程序。</p><p>我们使用函数 bpf_trace_printk 在内核跟踪日志中打印消息，你可以在文件 /syslkernel/debug/tracing/traceyipe 中查看。</p></blockquote><h2 id="第一个代码" tabindex="-1"><a class="header-anchor" href="#第一个代码"><span>第一个代码</span></a></h2><h3 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span>代码</span></a></h3><p>在第一个代码示例中，我们将使用这些帮助函数来实现 BPF 的&quot; Hello World&quot;：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;linux/bpf.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SEC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">NAME</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__attribute__</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">section</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(NAME) </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> used</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SEC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 使用SEC属性告知BPF虚拟机何时运行此程序。当检测到 execve 系统调用跟踪点被执行时，BPF 程序将运行，我们会看到消息输出 “Hello，BPF World!”。 </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bpf_prog</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">ctx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> msg</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Hello, BPF World!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    bpf_trace_printk</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(msg, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(msg));</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> _license</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SEC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;license&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;GPL&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码来检查内核的执行。我们将在第 4 章中详细讨论跟踪点。</p><h3 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h3><p>我们可以使用 clang 将第 一 个程序编译成内核可加载的 ELF (Executable and Linkable Format) 格式的二进制文件。我们将第一个 BPF 程序保存为 bpf_program.c ，使用下面的命令进行编译:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clang</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -O2</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -target</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bpf</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bpf_program.c</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bpf_program.o</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="运行" tabindex="-1"><a class="header-anchor" href="#运行"><span>运行</span></a></h3><p>现在，我们已经编译了第一个 BPF 程序，我们需要将它加载到内核中运行 。如前所述，我们使用内核提供的特定帮助函数，该帮助函数会对编译和加载程序按模板抽象进行处理。这个帮助函数叫<code> load_bp_file</code> ，它将获取一 个二进制文件将它加载到内核中。 如下所示:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;stdio.h &gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;uapi/linux/bpf.h &gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;bpf_load.h&quot;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> argc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> **</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">argv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">load_bpf_file</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello_world_kern.o&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // load_bpf_file 帮助函数</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;The kernel didn&#39;t load the BPF program</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    read_trace_pipe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以使用脚本编译和链接该程序生成 ELF 二进制文件 。 这里，我们不需要指定编译后的目标文件，因为该程序不会加载到 BPF 虚拟机中。编译程序需要一些依赖库，编写如下脚本会更容易将外部依赖库放在一起:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">TOOLS</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">tools</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">INCLUDE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">libbpf</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">include</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">HEADERS</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">libbpf</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">src</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clang </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">o loader </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">l elf </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">I\${INCLUDE} </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">I\${HEADERS} </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">I\${TOOLS} </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    \${TOOLS}</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">bpf_load.c </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    loader.c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你要运行该程序，可以使用 sudo 执行此二进制文件 sudo ./loader。</p><p>sudo 是一个 Linux 命令，为你提供计算机的 root 特权。如果你不使用 sudo 运行该程序，将会返回错误消息，因为对于大多数 BPF 程序而言，只能由root 特权用户加载到内核中。</p><p>运行该程序，即使计算机不进行任何操作，几秒钟后你也将会看到 &quot;Hello ，BPF World !&quot;。这是因为计算机是一个井行的系统，其他程序在后台执行，可能正在执行其他程序。</p><p>程序停止后，消息将不在终端上显示。 一旦程序终止，加载的 BPF 程序将从BPF 虚拟机中卸载。在后续的章节中，我们将讨论如何使 B PF 程序持久化，BPF 程序甚至可以在加载器终止后继续运行，但现在，我们不想引人太多概念。请牢记这一重要概念，因为在许多情况下，你将在后台运行 BPF 程序，从系统中收集数据，不管其他进程是否正在运行。</p><h2 id="bpf程序类型" tabindex="-1"><a class="header-anchor" href="#bpf程序类型"><span>BPF程序类型</span></a></h2><p>虽然 BPF 程序没有明确的分类，但本节根据其主要目的，可以将 BPF 程序分为两类：</p><ol><li>跟踪 <ul><li>你能编写程序来更好地了解系统正在发生什么。这类程序提供了系统行为及系统硬件的直接信息。 例如： <ul><li>访问特定程序的内存区域，从运行进程中提取执行跟踪信息</li><li>直接访问为每个特定进程分配的资源，包括文件描述符、 CPU 和内存</li></ul></li></ul></li><li>网络 <ul><li>这类程序可以检测和控制系统的网络流量。可以对网络接口的数据包进行过滤，甚至可以完全拒绝数据包。我们可以使用不同的程序类型，将程序附加到内核网络处理的不同阶段上，这样做各有利弊。 例如： <ul><li>将 BPF 程序附加到网络驱动程序接收数据包的网络事件上，此时，由于内核没有提供足够的信息，程序也只能访问较少的数据包信息。另 一方面，你可以将 BPF 程序附加到数据包传递给用户空间的网络事件。在这种情况下，你可以获得更多的数据包信息，这将有助于你做出更明智的决策，但是完整地处理这些数据包信息需要付出更高的代价。</li></ul></li></ul></li></ol><h3 id="套接字过滤器程序" tabindex="-1"><a class="header-anchor" href="#套接字过滤器程序"><span>套接字过滤器程序</span></a></h3><p>（我们将在第 6 章中详细介绍套接宇过滤程序和其他网络程序）</p><p><code>BPF PROG TYPE SOCKET FILTER</code> 类型是添加到 Linux 内核的第一个程序类型。套接字过滤器程序会附加到原始套接字上，用于访问所有套接字处理的数据包。套接宇过滤器程序只能用于对套接字的观测，不允许修改数据包内容或更改其目的地。 BPF 程序会接收与网络协议桔信息相关的元数据，例如，发送数据包的协议类型。</p><h3 id="kprobe-程序" tabindex="-1"><a class="header-anchor" href="#kprobe-程序"><span>kprobe 程序</span></a></h3><p>kprobe 是动态附加到内核调用点的函数，我们将在第 4 章介绍跟踪时对kprobe 进行详细介绍。 BPF kprobe 程序类型允许使用 BPF 程序作为 kprobe的处理程序。程序类型被定义为 BPF_PROG_TYPE_KPROBE o BPF 虚拟机确保 kprobe 程序总是可以安全运行 ， 这是传统 kprobe 模块的优势。但需要注意，在内核中 kprobe 被认为是不稳定的入口点，因此你需要确定 kprobe BPF 程序是否与正在使用的特定内核版本兼容。</p><p>编写附加到 kprobe 模块上的 BPF 程序，我们需要确定 BPF 程序是在函数调用的第一条指令执行还是函数调用完成时执行。我们需要在 BPF 程序的 SEC头部声明行为。例如，如果你想在内核 exec 系统调用前检查参数，则需要在系统调用开始时附加 BPF 程序。</p><p>这里，你需要在 BPF 程序设置 SEC 头部: <code>SEC(&quot;kprobe/sys_exec&quot;) </code>。 如果你想检查 exec 系统调用的返回值，需要在 BPF 程序设置 SEC 头部 <code>SEC(&quot;kretprobe/sys_exec&quot;) </code></p><h3 id="跟踪点程序" tabindex="-1"><a class="header-anchor" href="#跟踪点程序"><span>跟踪点程序</span></a></h3><h3 id="xdp-程序" tabindex="-1"><a class="header-anchor" href="#xdp-程序"><span>XDP 程序</span></a></h3><h3 id="perf-事件程序" tabindex="-1"><a class="header-anchor" href="#perf-事件程序"><span>Perf 事件程序</span></a></h3><h3 id="cgroup-套接字程序" tabindex="-1"><a class="header-anchor" href="#cgroup-套接字程序"><span>cgroup 套接字程序</span></a></h3><h3 id="cgroup-打开套接字程序" tabindex="-1"><a class="header-anchor" href="#cgroup-打开套接字程序"><span>cgroup 打开套接字程序</span></a></h3><h3 id="套接字选项程序" tabindex="-1"><a class="header-anchor" href="#套接字选项程序"><span>套接字选项程序</span></a></h3><h3 id="套接字映射程序" tabindex="-1"><a class="header-anchor" href="#套接字映射程序"><span>套接字映射程序</span></a></h3><h3 id="cgroup-设备程序" tabindex="-1"><a class="header-anchor" href="#cgroup-设备程序"><span>cgroup 设备程序</span></a></h3><h3 id="套接字消息传递程序" tabindex="-1"><a class="header-anchor" href="#套接字消息传递程序"><span>套接字消息传递程序</span></a></h3><h3 id="原始跟踪点程序" tabindex="-1"><a class="header-anchor" href="#原始跟踪点程序"><span>原始跟踪点程序</span></a></h3><h3 id="cgroup-套接字地址程序" tabindex="-1"><a class="header-anchor" href="#cgroup-套接字地址程序"><span>cgroup 套接字地址程序</span></a></h3><h3 id="套接字重用端口程序" tabindex="-1"><a class="header-anchor" href="#套接字重用端口程序"><span>套接字重用端口程序</span></a></h3><h3 id="流量解析程序" tabindex="-1"><a class="header-anchor" href="#流量解析程序"><span>流量解析程序</span></a></h3><h3 id="其他-bpf-程序" tabindex="-1"><a class="header-anchor" href="#其他-bpf-程序"><span>其他 BPF 程序</span></a></h3><h2 id="bpf-验证器" tabindex="-1"><a class="header-anchor" href="#bpf-验证器"><span>BPF 验证器</span></a></h2><h2 id="bpf-类型格式" tabindex="-1"><a class="header-anchor" href="#bpf-类型格式"><span>BPF 类型格式</span></a></h2><h2 id="尾部调用" tabindex="-1"><a class="header-anchor" href="#尾部调用"><span>尾部调用</span></a></h2>`,56)]))}const k=s(n,[["render",h],["__file","02. 运行BPF程序.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/02.%20%E8%BF%90%E8%A1%8CBPF%E7%A8%8B%E5%BA%8F.html","title":"《Linux内核观测技术BPF》","lang":"zh-CN","frontmatter":{"description":"《Linux内核观测技术BPF》 目录 运行BPF程序 LLVM 编译器 LLVM编译器 最常见方住是使用 C 语言子集编写 BPF 程序，之后使用 LLVM 编译器进行编译。 LLVM 编译器 是一种通用编译器，可以编译成不同类型的字节码 。 字节码 针对 BPF 程序， LLVM 能够编译出加载到内核中执行的汇编代码。本书不会过多地介绍 BPF 汇...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/02.%20%E8%BF%90%E8%A1%8CBPF%E7%A8%8B%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《Linux内核观测技术BPF》"}],["meta",{"property":"og:description","content":"《Linux内核观测技术BPF》 目录 运行BPF程序 LLVM 编译器 LLVM编译器 最常见方住是使用 C 语言子集编写 BPF 程序，之后使用 LLVM 编译器进行编译。 LLVM 编译器 是一种通用编译器，可以编译成不同类型的字节码 。 字节码 针对 BPF 程序， LLVM 能够编译出加载到内核中执行的汇编代码。本书不会过多地介绍 BPF 汇..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《Linux内核观测技术BPF》\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《Linux内核观测技术BPF》","slug":"《linux内核观测技术bpf》","link":"#《linux内核观测技术bpf》","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"运行BPF程序","slug":"运行bpf程序","link":"#运行bpf程序","children":[{"level":2,"title":"LLVM 编译器","slug":"llvm-编译器","link":"#llvm-编译器","children":[{"level":3,"title":"LLVM编译器","slug":"llvm编译器","link":"#llvm编译器","children":[]},{"level":3,"title":"字节码","slug":"字节码","link":"#字节码","children":[]},{"level":3,"title":"加载字节码","slug":"加载字节码","link":"#加载字节码","children":[]},{"level":3,"title":"许可证（GPL）","slug":"许可证-gpl","link":"#许可证-gpl","children":[]}]},{"level":2,"title":"第一个代码","slug":"第一个代码","link":"#第一个代码","children":[{"level":3,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":3,"title":"编译","slug":"编译","link":"#编译","children":[]},{"level":3,"title":"运行","slug":"运行","link":"#运行","children":[]}]},{"level":2,"title":"BPF程序类型","slug":"bpf程序类型","link":"#bpf程序类型","children":[{"level":3,"title":"套接字过滤器程序","slug":"套接字过滤器程序","link":"#套接字过滤器程序","children":[]},{"level":3,"title":"kprobe 程序","slug":"kprobe-程序","link":"#kprobe-程序","children":[]},{"level":3,"title":"跟踪点程序","slug":"跟踪点程序","link":"#跟踪点程序","children":[]},{"level":3,"title":"XDP 程序","slug":"xdp-程序","link":"#xdp-程序","children":[]},{"level":3,"title":"Perf 事件程序","slug":"perf-事件程序","link":"#perf-事件程序","children":[]},{"level":3,"title":"cgroup 套接字程序","slug":"cgroup-套接字程序","link":"#cgroup-套接字程序","children":[]},{"level":3,"title":"cgroup 打开套接字程序","slug":"cgroup-打开套接字程序","link":"#cgroup-打开套接字程序","children":[]},{"level":3,"title":"套接字选项程序","slug":"套接字选项程序","link":"#套接字选项程序","children":[]},{"level":3,"title":"套接字映射程序","slug":"套接字映射程序","link":"#套接字映射程序","children":[]},{"level":3,"title":"cgroup 设备程序","slug":"cgroup-设备程序","link":"#cgroup-设备程序","children":[]},{"level":3,"title":"套接字消息传递程序","slug":"套接字消息传递程序","link":"#套接字消息传递程序","children":[]},{"level":3,"title":"原始跟踪点程序","slug":"原始跟踪点程序","link":"#原始跟踪点程序","children":[]},{"level":3,"title":"cgroup 套接字地址程序","slug":"cgroup-套接字地址程序","link":"#cgroup-套接字地址程序","children":[]},{"level":3,"title":"套接字重用端口程序","slug":"套接字重用端口程序","link":"#套接字重用端口程序","children":[]},{"level":3,"title":"流量解析程序","slug":"流量解析程序","link":"#流量解析程序","children":[]},{"level":3,"title":"其他 BPF 程序","slug":"其他-bpf-程序","link":"#其他-bpf-程序","children":[]}]},{"level":2,"title":"BPF 验证器","slug":"bpf-验证器","link":"#bpf-验证器","children":[]},{"level":2,"title":"BPF 类型格式","slug":"bpf-类型格式","link":"#bpf-类型格式","children":[]},{"level":2,"title":"尾部调用","slug":"尾部调用","link":"#尾部调用","children":[]}]}],"git":{},"readingTime":{"minutes":7.06,"words":2119},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/02. 运行BPF程序.md","excerpt":"\\n<h1>目录</h1>\\n<h1>运行BPF程序</h1>\\n<h2>LLVM 编译器</h2>\\n<h3>LLVM编译器</h3>\\n<blockquote>\\n<p>最常见方住是使用 C 语言子集编写 BPF 程序，之后使用 LLVM 编译器进行编译。\\n<strong>LLVM 编译器</strong> 是一种通用编译器，可以编译成不同类型的<strong>字节码</strong> 。</p>\\n</blockquote>\\n<h3>字节码</h3>\\n<blockquote>\\n<p>针对 BPF  程序， LLVM 能够编译出加载到内核中执行的汇编代码。本书不会过多地介绍 BPF 汇编。经过慎重考虑，我们决定本书主要介绍在具体情景下如何使用 BDF，关于 BPF 汇编，你可以在网上轻松地找到-些参考或者通过 BPF 手册得到帮助。不过，之后的章节会有 BPF 汇编代码的简短示例，你会发现在某些情景下使用汇编比 C 语言更合适，例如，使用 Seccomp 过滤器控制内核的系统调用。我们将在第 8 章中详细讨论 Seccompo。</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/02. 运行BPF程序.md","value":{"title":"02. 运行BPF程序","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/02. 运行BPF程序.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{k as comp,r as data};
