import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as i,a as t}from"./app-CsHIiQ5U.js";const a={},c=t('<h1 id="类模板" tabindex="-1"><a class="header-anchor" href="#类模板"><span>类模板</span></a></h1><h2 id="类模板-1" tabindex="-1"><a class="header-anchor" href="#类模板-1"><span>类模板</span></a></h2><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><h4 id="使用-1" tabindex="-1"><a class="header-anchor" href="#使用-1"><span>使用</span></a></h4><ul><li>简概 <ul><li>C++最初不支持模板，但模板被引入后一直在改进，因此有的编译器可能不支持所有特性</li><li>模板提供<code>参数化类型</code>（<em>parameterized type</em>）</li></ul></li><li>使用场景 <ul><li>可以用于设计容器类（<em>container calss</em>）（如Stack、Queue等）</li></ul></li><li>使用 <ul><li>和模板函数差不多，但稍复杂些</li><li>一方面，在class声明前加<code>template &lt;typename T&gt;</code></li><li>另一方面，所有的成员函数前加<code>template &lt;typename T&gt;</code>，并把作用域解析符前的<code>类名</code>换成<code>类名&lt;T&gt;</code></li></ul></li><li>原理 <ul><li>和模板函数差不多</li><li>当定义类实例时，会根据<code>类名&lt;T&gt;</code>模板来生成不同的类声明和和类方法</li><li>因为是模板，所以可以不用（不会产生定义）也不能（模板不能单独编译）分离头文件和实现，实现要写在头文件中</li></ul></li><li>类模板的函数模板区别 <ul><li>与函数模板不同，必须显式提供所需的类型而不能由参数类型来确定要生成那种函数</li></ul></li></ul><h4 id="类型参数补充" tabindex="-1"><a class="header-anchor" href="#类型参数补充"><span>类型参数补充</span></a></h4><ul><li>类型参数 <ul><li><code>template &lt;typename T&gt;</code>中的<code>T</code>是一个<code>类型参数</code>（<em>type parameter</em>）</li><li>这这意味着它类似于变量，<code>T</code>为<strong>可以修改名字</strong>的变量名，而赋值给它的是<code>类型</code></li></ul></li><li>非类型（<em>non-type</em>）参数或表达式（<em>expression</em>）参数 <ul><li><code>template &lt;int n&gt;</code>中的<code>n</code>是一个<code>非类型参数</code>（<em>non-type parameter</em>）或<code>表达式参数</code>（<em>expression parameter</em>）</li><li>比如<code>template &lt;class T, int n&gt;</code>可以替换为</li></ul></li><li>类模板传参和构造函数传参区别（以创建数组为例） <ul><li><code>vector</code>类型使用的是构造函数方法 <ul><li>优点：通过new和delete管理堆内存，更方便</li></ul></li><li><code>array</code>类型使用的是类模板传参方法 <ul><li>优点：为自动变量维护内存栈，速度更快</li><li>缺点：会为不同长度的数组生成多个模板定义。如<code>Array&lt;int, 2&gt;;</code>、<code>Array&lt;int, 3&gt;;</code>会生成两个定义</li></ul></li></ul></li></ul><h4 id="功能多样性-功能扩展" tabindex="-1"><a class="header-anchor" href="#功能多样性-功能扩展"><span>功能多样性 / 功能扩展</span></a></h4><p>模板功能性多，可用作基类、组件类、还可用作其他模板的类型参数</p><ul><li>可以递归使用模板 <ul><li>如<code>Array&lt;Array&lt;int,5&gt;,10&gt; twodee;</code>，这相当于二维数组<code>int twodee[10][5];</code></li></ul></li><li>可以使用多个类型参数 <ul><li>如<code>template &lt;class T1, class T2&gt;</code></li></ul></li><li>默认类型模板参数 <ul><li>如<code>template &lt;class T1, class T2=int&gt; class A {...}</code></li></ul></li></ul><h3 id="具体化、实例化" tabindex="-1"><a class="header-anchor" href="#具体化、实例化"><span>具体化、实例化</span></a></h3><p><code>具体化</code>（<em>specialization</em>）和<code>实例化</code>（<em>instantiation</em>）</p><p>写法和函数模板的不太同，主要原因可能是因为：</p><ul><li>函数模板在圆括号的参数中写类型参数，而且会自动判别类型</li><li>类模板的原括号保留用作构造函数，使用尖括号，而且是显式写出类型</li></ul><h4 id="隐式实例化-implicit-instantiation" tabindex="-1"><a class="header-anchor" href="#隐式实例化-implicit-instantiation"><span>隐式实例化（<em>implicit instantiation</em>）</span></a></h4><ul><li>写法 <ul><li>举例：假如定义了<code>template &lt;class T&gt; class A {...}</code>，则当声明对象<code>A&lt;int&gt; a;</code>时进行<code>隐式实例化</code></li></ul></li></ul><h4 id="显式实例化-explicit-instantiation" tabindex="-1"><a class="header-anchor" href="#显式实例化-explicit-instantiation"><span>显式实例化（<em>explicit instantiation</em>）</span></a></h4><ul><li>写法 <ul><li>举例：假如定义了<code>template &lt;class T&gt; class A {...}</code>，则可以<code>template class A&lt;int&gt;;</code>进行<code>显式实例化</code></li></ul></li></ul><h4 id="显式具体化-explicit-specialization" tabindex="-1"><a class="header-anchor" href="#显式具体化-explicit-specialization"><span>显式具体化（<em>explicit specialization</em>）</span></a></h4><ul><li><p>简概</p><ul><li>是特定类型（用于替换模板中的泛型）的定义</li></ul></li><li><p>使用场景</p><ul><li>需要为特殊类型实例化时，对模板进行修改，使其行为不同</li></ul></li><li><p>写法</p><ul><li><p>通用：<code>template &lt;&gt; class ClassName &lt;specialized-type-name&gt; {...};</code></p><p>或：<code>calss ClassName&lt;specialized-type-name&gt; {...};</code>（早期的写法）</p></li><li><p>举例：<code>template &lt;&gt; class A &lt;int&gt; {...};</code></p></li></ul></li></ul><h4 id="部分具体化-partial-specialization" tabindex="-1"><a class="header-anchor" href="#部分具体化-partial-specialization"><span>部分具体化（<em>partial specialization</em>）</span></a></h4><ul><li>简概 <ul><li>即限制模板的通用性</li></ul></li><li>写法 <ul><li>举例：<code>template &lt;class T1&gt; class A &lt;T1, int&gt; {...};</code>，该语句将<code>T2</code>具体化为int，但<code>T1</code>保持不变</li></ul></li></ul><h3 id="功能扩展" tabindex="-1"><a class="header-anchor" href="#功能扩展"><span>功能扩展</span></a></h3><h4 id="嵌套-x-模板" tabindex="-1"><a class="header-anchor" href="#嵌套-x-模板"><span>嵌套 x 模板</span></a></h4>',24),n=[c];function o(s,d){return l(),i("div",null,n)}const h=e(a,[["render",o],["__file","04. 模板类.html.vue"]]),u=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/05.%20%E5%B0%81%E8%A3%85/04.%20%E6%A8%A1%E6%9D%BF%E7%B1%BB.html","title":"类模板","lang":"zh-CN","frontmatter":{"description":"类模板 类模板 使用 使用 简概 C++最初不支持模板，但模板被引入后一直在改进，因此有的编译器可能不支持所有特性 模板提供参数化类型（parameterized type） 使用场景 可以用于设计容器类（container calss）（如Stack、Queue等） 使用 和模板函数差不多，但稍复杂些 一方面，在class声明前加template <...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/05.%20%E5%B0%81%E8%A3%85/04.%20%E6%A8%A1%E6%9D%BF%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"类模板"}],["meta",{"property":"og:description","content":"类模板 类模板 使用 使用 简概 C++最初不支持模板，但模板被引入后一直在改进，因此有的编译器可能不支持所有特性 模板提供参数化类型（parameterized type） 使用场景 可以用于设计容器类（container calss）（如Stack、Queue等） 使用 和模板函数差不多，但稍复杂些 一方面，在class声明前加template <..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类模板\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"类模板","slug":"类模板","link":"#类模板","children":[{"level":2,"title":"类模板","slug":"类模板-1","link":"#类模板-1","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[{"level":4,"title":"使用","slug":"使用-1","link":"#使用-1","children":[]},{"level":4,"title":"类型参数补充","slug":"类型参数补充","link":"#类型参数补充","children":[]},{"level":4,"title":"功能多样性 / 功能扩展","slug":"功能多样性-功能扩展","link":"#功能多样性-功能扩展","children":[]}]},{"level":3,"title":"具体化、实例化","slug":"具体化、实例化","link":"#具体化、实例化","children":[{"level":4,"title":"隐式实例化（implicit instantiation）","slug":"隐式实例化-implicit-instantiation","link":"#隐式实例化-implicit-instantiation","children":[]},{"level":4,"title":"显式实例化（explicit instantiation）","slug":"显式实例化-explicit-instantiation","link":"#显式实例化-explicit-instantiation","children":[]},{"level":4,"title":"显式具体化（explicit specialization）","slug":"显式具体化-explicit-specialization","link":"#显式具体化-explicit-specialization","children":[]},{"level":4,"title":"部分具体化（partial specialization）","slug":"部分具体化-partial-specialization","link":"#部分具体化-partial-specialization","children":[]}]},{"level":3,"title":"功能扩展","slug":"功能扩展","link":"#功能扩展","children":[{"level":4,"title":"嵌套 x 模板","slug":"嵌套-x-模板","link":"#嵌套-x-模板","children":[]}]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.97,"words":891},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/05. 封装/04. 模板类.md","autoDesc":true}');export{h as comp,u as data};
