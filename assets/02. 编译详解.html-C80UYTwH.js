import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as d,a}from"./app-5ajJQ-aM.js";const o={},n=a(`<h1 id="编译详解" tabindex="-1"><a class="header-anchor" href="#编译详解"><span>编译详解</span></a></h1><h2 id="编译原理" tabindex="-1"><a class="header-anchor" href="#编译原理"><span>编译原理</span></a></h2><h3 id="源文件创建-文件扩展名-与c不同" tabindex="-1"><a class="header-anchor" href="#源文件创建-文件扩展名-与c不同"><span>源文件创建 - 文件扩展名（与C不同）</span></a></h3><p>源代码文件扩展名</p><table><thead><tr><th style="text-align:right;">C++实现</th><th>源代码文件的扩展名</th></tr></thead><tbody><tr><td style="text-align:right;">UNIX</td><td>C、cc、cxx、c</td></tr><tr><td style="text-align:right;">GUN C++</td><td>C、cc、cxx、cpp、c++</td></tr><tr><td style="text-align:right;">Digital Mars</td><td>cpp、cxx</td></tr><tr><td style="text-align:right;">Borland C++</td><td>cpp</td></tr><tr><td style="text-align:right;">Watcom</td><td>cpp</td></tr><tr><td style="text-align:right;">Microsoft Visual C++</td><td>cpp、cxx、cc</td></tr><tr><td style="text-align:right;">Freestyle CodeWarrior</td><td>cp、cpp、cc、cxx、c++</td></tr></tbody></table><h3 id="编译和连接原理" tabindex="-1"><a class="header-anchor" href="#编译和连接原理"><span>编译和连接原理</span></a></h3><ul><li>C语言编程步骤</li></ul><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
A<span class="token text string">[源程序-文本-hello.c]</span><span class="token arrow operator">--</span>预处理器-cpp<span class="token arrow operator">--&gt;</span>
B<span class="token text string">[修改了的源程序-文本-hello.i]</span><span class="token arrow operator">--</span>编译器-ccl<span class="token arrow operator">--&gt;</span>
C<span class="token text string">[汇编程序-文本-hello.s]</span><span class="token arrow operator">--</span>汇编器-as<span class="token arrow operator">--&gt;</span>
D<span class="token text string">[可重定位目标程序-二进制-hello.o]</span><span class="token arrow operator">--</span>链接器-ld<span class="token arrow operator">--&gt;</span>
E<span class="token text string">[可执行目标程序-二进制-hello]</span>

F<span class="token text string">[C编译器提供的标准C库中的函数对应文件-二进制-print.o]</span><span class="token arrow operator">--</span>链接器-ld<span class="token arrow operator">--&gt;</span>E
G<span class="token text string">[系统头文件-文本-stdio.h]</span><span class="token arrow operator">--</span>预处理器-cpp<span class="token arrow operator">--&gt;</span>B
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>C++编程步骤（简化版）</li></ul><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> LR
源代码<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">编译器</span><span class="token arrow operator">--&gt;</span></span>B<span class="token text string">[目标代码-hello.o]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">链接程序</span><span class="token arrow operator">--&gt;</span></span>D<span class="token text string">[可执行代码 - a.out]</span>
启动代码<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">链接程序</span><span class="token arrow operator">--&gt;</span></span>D
库代码<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">链接程序</span><span class="token arrow operator">--&gt;</span></span>D
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="编译和连接方式" tabindex="-1"><a class="header-anchor" href="#编译和连接方式"><span>编译和连接方式</span></a></h2><p>最初C++使用编译器程序到C，而不是开发直接的C++到目标代码的编译器</p><p>前者叫作cfront。后者为C++编译器，加速了编译过程</p><h3 id="各平台下的编译" tabindex="-1"><a class="header-anchor" href="#各平台下的编译"><span>各平台下的编译</span></a></h3><table><thead><tr><th>平台</th><th>方法</th><th>补充</th></tr></thead><tbody><tr><td>UNIX</td><td>自带编译器CC，<code>CC spiffy.C</code>，生成<code>a.out</code></td><td></td></tr><tr><td>Linux</td><td>自带编译器g++，<code>g++ spiffy.cxx</code>，生成<code>a.out</code></td><td></td></tr><tr><td>Windows</td><td>下载命令行编译器，也是用g++编译器，生成<code>a.out</code></td><td>如<code>Cygwin</code>、<code>MinGW</code>（相当于弄了个Linux环境，均在命令提示符模式下运行）</td></tr><tr><td>Windows</td><td>下载IDE编译器，生成<code>.exe</code></td><td>如<code>VC++</code>、<code>VS</code>（一般进行项目的创建而非仅仅编译单个文件）</td></tr><tr><td>Macintosh</td><td>开发框架Xcode，Apple官网安装</td><td>Xcode提功力支持多种语言的IDE和两个命令行解释器（g++和clang）<br>还可通过Termianl进入UNIX模式</td></tr></tbody></table><p>补充</p><ul><li><strong>生成可执行代码的过程</strong>：先生成目标代码文件<code>spiffy.o</code>，再自动生成可执行文件<code>a.out</code>，并删除目标代码</li><li><strong>可执行对象的名字</strong>：UNIX和Linux均默认为<code>a.out</code>，再次编译会自动覆盖</li><li><strong>g++补充</strong>：有些版本可能要求连接C++库<code>g++ spiffy.cxx -lg++</code>，编译多个文件<code>g++ my.cxx precious.cxx</code></li></ul><h3 id="补充-说下编译器gcc和g-与c不同" tabindex="-1"><a class="header-anchor" href="#补充-说下编译器gcc和g-与c不同"><span>补充：说下编译器gcc和g++（与C不同）</span></a></h3><p>gcc和g++都可以编译C/C++，但教程上一般是gcc对C，gcc汇编，g++对C++，具体的这里不再深入</p><p>两者的用法几乎完全一致</p><table><thead><tr><th>linux指令（<code>gcc</code>与<code>objdump</code>）</th><th>操作</th><th>生成文件</th><th>文件补充</th></tr></thead><tbody><tr><td><code>gcc main.c</code></td><td>编译+汇编+链接?</td><td>二进制文件<code>a.out</code></td><td><code>sudo ./a.out</code>可运行该文件</td></tr><tr><td><code>gcc -Og -S main.c</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>可以文本方式打开阅读汇编代码</td></tr><tr><td><code>gcc -Og -S -masm=intel main.c</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>还可以生成Intel格式的代码（没区别？）</td></tr><tr><td><code>gcc -Og -c main.c</code></td><td>编译+汇编</td><td>二进制文件<code>main.o</code></td><td><code>sudo ./main.o</code>可运行该文件</td></tr><tr><td><code>gcc -Og -o prog main.c hello.c</code></td><td>编译+汇编+链接</td><td>二进制文件<code>prog</code></td><td><code>sudo ./prog</code>可运行该文件</td></tr><tr><td>——————</td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td><code>g++ main.cpp</code></td><td>编译+汇编+链接?</td><td>二进制文件<code>a.out</code></td><td><code>sudo ./a.out</code>可运行该文件</td></tr><tr><td><code>g++ -S main.cpp</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>可以文本方式打开阅读汇编代码</td></tr><tr><td><code>g++ -c main.cpp</code></td><td>编译+汇编</td><td>二进制文件<code>main.o</code></td><td><code>sudo ./main.o</code>可运行该文件</td></tr><tr><td><code>g++ -o [world] main.cpp</code></td><td>编译+汇编+链接</td><td>二进制文件<code>main</code> (或<code>world</code>)</td><td><code>sudo ./prog</code>可运行该文件</td></tr><tr><td>——————</td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td><code>objdump -d mstore.o</code></td><td>反汇编二进制代码</td><td>不生成，在终端显示结果</td><td></td></tr><tr><td><code>objdump -d prog</code></td><td>反汇编二进制代码</td><td>不生成，在终端显示结果</td><td></td></tr></tbody></table><p><strong>表格补充：如进行链接，则必须要有一个main函数</strong></p>`,22),r=[n];function s(c,l){return e(),d("div",null,r)}const g=t(o,[["render",s],["__file","02. 编译详解.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.%20%E7%BC%96%E8%AF%91%E8%AF%A6%E8%A7%A3.html","title":"编译详解","lang":"zh-CN","frontmatter":{"description":"编译详解 编译原理 源文件创建 - 文件扩展名（与C不同） 源代码文件扩展名 编译和连接原理 C语言编程步骤 C++编程步骤（简化版） 编译和连接方式 最初C++使用编译器程序到C，而不是开发直接的C++到目标代码的编译器 前者叫作cfront。后者为C++编译器，加速了编译过程 各平台下的编译 补充 生成可执行代码的过程：先生成目标代码文件spiff...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.%20%E7%BC%96%E8%AF%91%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"编译详解"}],["meta",{"property":"og:description","content":"编译详解 编译原理 源文件创建 - 文件扩展名（与C不同） 源代码文件扩展名 编译和连接原理 C语言编程步骤 C++编程步骤（简化版） 编译和连接方式 最初C++使用编译器程序到C，而不是开发直接的C++到目标代码的编译器 前者叫作cfront。后者为C++编译器，加速了编译过程 各平台下的编译 补充 生成可执行代码的过程：先生成目标代码文件spiff..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编译详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"编译详解","slug":"编译详解","link":"#编译详解","children":[{"level":2,"title":"编译原理","slug":"编译原理","link":"#编译原理","children":[{"level":3,"title":"源文件创建 - 文件扩展名（与C不同）","slug":"源文件创建-文件扩展名-与c不同","link":"#源文件创建-文件扩展名-与c不同","children":[]},{"level":3,"title":"编译和连接原理","slug":"编译和连接原理","link":"#编译和连接原理","children":[]}]},{"level":2,"title":"编译和连接方式","slug":"编译和连接方式","link":"#编译和连接方式","children":[{"level":3,"title":"各平台下的编译","slug":"各平台下的编译","link":"#各平台下的编译","children":[]},{"level":3,"title":"补充：说下编译器gcc和g++（与C不同）","slug":"补充-说下编译器gcc和g-与c不同","link":"#补充-说下编译器gcc和g-与c不同","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.06,"words":917},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/01. 编程语言/02. 编译详解.md","autoDesc":true}');export{g as comp,h as data};
