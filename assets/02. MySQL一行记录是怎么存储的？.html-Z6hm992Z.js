import{_ as e,c as p,e as t,a as s,g as l,f as a,o as r}from"./app-DEUP2Tjk.js";const o="/assets/database-DBPy_748.png",h="/assets/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio-I3FxFhoQ.png",c="/assets/COMPACT.drawio-CnbFZoly.png",n="/assets/t_test-O7bxQItE.png",d="/assets/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81-BFivpcXS.png",m="/assets/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A82-BOcdZXy3.png",g="/assets/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A83-CGD2Rjbi.png",k="/assets/null%E5%80%BC%E5%88%97%E8%A1%A81-Dz_RsuGE.png",u="/assets/null%E5%80%BC%E5%88%97%E8%A1%A82-DnBaGqHt.png",v="/assets/null%E5%80%BC%E5%88%97%E8%A1%A83-BXk2OpNJ.png",y="/assets/null%E5%80%BC%E5%88%97%E8%A1%A84-C7355IaM.png",A="/assets/null%E5%80%BC%E5%88%97%E8%A1%A85-HxyKRIUV.png",B="/assets/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE-CpRoQCfn.png",L="/assets/error-BPXuHRQQ.png",b="/assets/65533-CRd0qsUv.png",_="/assets/65532-CJu99Bow.png",f="/assets/%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5-Do1CxF-F.png",E="/assets/%E8%A1%8C%E6%BA%A2%E5%87%BA-D4zdavpz.png",w="/assets/%E8%A1%8C%E6%BA%A2%E5%87%BA2-CuQVa5Fi.png",x={};function C(D,i){return r(),p("div",null,i[0]||(i[0]=[t(`<h1 id="mysql一行记录是怎么存储的" tabindex="-1"><a class="header-anchor" href="#mysql一行记录是怎么存储的"><span>MySQL一行记录是怎么存储的？</span></a></h1><p>如果你知道 MySQL 一行记录的存储结构，那么这个问题对你没什么难度。</p><p>如果你不知道也没关系，这次我跟大家聊聊 <strong>MySQL 一行记录是怎么存储的？</strong></p><p>知道了这个之后，除了能应解锁前面这道面试题，你还会解锁这些面试题：</p><ul><li>MySQL 的 NULL 值会占用空间吗？</li><li>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</li><li>varchar(n) 中 n 最大取值为多少？</li><li>行溢出后，MySQL 是怎么处理的？</li></ul><p>这些问题看似毫不相干，其实都是在围绕「 MySQL 一行记录的存储结构」这一个知识点，所以攻破了这个知识点后，这些问题就引刃而解了。</p><p>好了，话不多说，发车！</p><h2 id="mysql-的数据存储" tabindex="-1"><a class="header-anchor" href="#mysql-的数据存储"><span>MySQL 的数据存储</span></a></h2><h3 id="创建一个数据库" tabindex="-1"><a class="header-anchor" href="#创建一个数据库"><span>创建一个数据库</span></a></h3><p>比如，我这里有一个名为 <em>my_test 数据库</em>，该 database 里有一张名为 <em>t_order 数据库表</em>。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysql</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHOW VARIABLES </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIKE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;datadir&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">+</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">---------------+-----------------+</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">| Variable_name | </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">           |</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">+</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">---------------+-----------------+</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">| datadir       | /var/lib/mysql/ |</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">+</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">---------------+-----------------+</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> row</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+o+`" alt="img" loading="lazy"></p><p>此时，理应生成一个用于存储的数据库文件。</p><p>大家都知道 MySQL 的数据都是保存在磁盘的，那具体是保存在哪个文件呢？</p><h3 id="数据库文件的位置" tabindex="-1"><a class="header-anchor" href="#数据库文件的位置"><span>数据库文件的位置</span></a></h3><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>这里以 InnoDB 存储引擎为基准展开讨论</p><p>MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。</p><p>InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎。所以，本文主要以 InnoDB 存储引擎展开讨论。</p></div></div><p>我们创建数据库后，会创建一个目录 <code>/var/lib/mysql/数据库名</code>，然后保存表结构和表数据的文件都会存放在这个目录里</p><p>然后，我们进入这个目录，看看里面有什么文件？</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ls</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/lib/mysql/my_test</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		# 可以看到该路径下有三个文件：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">db.opt</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">t_order.frm</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">t_order.ibd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,19),s("div",{class:"ab-note drop-shadow"},[s("table",{class:"ab-table ab-list-table ab-table-folder"},[s("tbody",null,[s("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"opt",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 0
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[s("td",{rowspan:"1"},[s("div",{class:"ab-list-table-svg"},[s("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 384 512"},[l("!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc."),s("path",{d:"M320 464c8.8 0 16-7.2 16-16l0-288-80 0c-17.7 0-32-14.3-32-32l0-80L64 48c-8.8 0-16 7.2-16 16l0 384c0 8.8 7.2 16 16 16l256 0zM0 64C0 28.7 28.7 0 64 0L229.5 0c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3L384 448c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64z"})])]),s("div",{class:"ab-list-table-witharrow markdown-rendered"},[s("div",null,[s("p",null,"db.opt")])])]),s("td",{rowspan:"1"},[s("div",{class:"ab-list-table-witharrow markdown-rendered"},[s("div",null,[s("p",null,[a("用来存储当前数据库的"),s("em",null,"默认字符集和字符校验规则")])])])])]),s("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"frm",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 1
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[s("td",{rowspan:"1"},[s("div",{class:"ab-list-table-svg"},[s("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 384 512"},[l("!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc."),s("path",{d:"M320 464c8.8 0 16-7.2 16-16l0-288-80 0c-17.7 0-32-14.3-32-32l0-80L64 48c-8.8 0-16 7.2-16 16l0 384c0 8.8 7.2 16 16 16l256 0zM0 64C0 28.7 28.7 0 64 0L229.5 0c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3L384 448c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64z"})])]),s("div",{class:"ab-list-table-witharrow markdown-rendered"},[s("div",null,[s("p",null,"t_order.frm")])])]),s("td",{rowspan:"1"},[s("div",{class:"ab-list-table-witharrow markdown-rendered"},[s("div",null,[s("p",null,[a("保存 (t_order) 表的元数据信息的，主要包含"),s("em",null,"表结构"),a("定义 在 MySQL 中建立一张表都会生成一个.frm 文件")])])])])]),s("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"ibd",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 2
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[s("td",{rowspan:"1"},[s("div",{class:"ab-list-table-svg"},[s("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 384 512"},[l("!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc."),s("path",{d:"M320 464c8.8 0 16-7.2 16-16l0-288-80 0c-17.7 0-32-14.3-32-32l0-80L64 48c-8.8 0-16 7.2-16 16l0 384c0 8.8 7.2 16 16 16l256 0zM0 64C0 28.7 28.7 0 64 0L229.5 0c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3L384 448c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64z"})])]),s("div",{class:"ab-list-table-witharrow markdown-rendered"},[s("div",null,[s("p",null,"t_order.ibd")])])]),s("td",{rowspan:"1"},[s("div",{class:"ab-list-table-witharrow markdown-rendered"},[s("div",null,[s("p",null,[a("保存t_order 的"),s("em",null,"表数据"),a(" 表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd），这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间 从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后，MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。")])])])])])]),s("button",{class:"ab-table-fold",is_fold:"false"},"全部折叠/展开")])],-1),t('<p>好了，现在我们知道了一张数据库表的数据是保存在 <code>表名字.ibd</code> 的文件里的，这个文件也称为<em>独占表空间文件</em>。</p><h3 id="数据库文件的结构" tabindex="-1"><a class="header-anchor" href="#数据库文件的结构"><span>数据库文件的结构</span></a></h3><p>表空间文件的结构是怎么样的？</p><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p><p><img src="'+h+'" alt="img" loading="lazy"></p><p>下面我们从下往上一个个看看。</p><h4 id="行-row" tabindex="-1"><a class="header-anchor" href="#行-row"><span>行（row）</span></a></h4><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><p>后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。</p><h4 id="页-page" tabindex="-1"><a class="header-anchor" href="#页-page"><span>页（page）</span></a></h4><ul><li><p>读写的最小单位</p><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，<strong>效率会非常低</strong>。</p><p>因此，<strong>InnoDB 的数据是按「页」为最小单位来读写的</strong>（也即是内存管理的最小单位、内存和磁盘进行数据交换的最小单位）（<strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间）</p><p>即当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p></li><li><p>页的类型。常见的有：</p><ul><li>数据页 <ul><li>其中，数据表中的行记录是用**「数据页」**来管理的，数据页的结构这里我就不讲细说了，之前文章有说过，感兴趣的可以去看这篇文章：<a href="https://xiaolincoding.com/mysql/index/page.html" target="_blank" rel="noopener noreferrer">换一个角度看 B+ 树</a>。总之知道表中的记录存储在「数据页」里面就行。</li></ul></li><li>undo 日志页</li><li>溢出页</li><li>等等</li></ul></li></ul><h4 id="区-extent" tabindex="-1"><a class="header-anchor" href="#区-extent"><span>区（extent）</span></a></h4><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。区的作用是使：B+ 树的相邻页的物理位置也相邻</p><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>区让B+ 树相邻页的物理位置也相邻</p><ul><li><p>为什么要这样做：</p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p></li><li><p>那具体怎么解决呢？</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。</strong></p><p><strong>每个区的大小为 1MB，连续的 64 个 (16KB的) 页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</strong></p></li></ul></div></div><h4 id="段-segment" tabindex="-1"><a class="header-anchor" href="#段-segment"><span>段（segment）</span></a></h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为三种：</p><ul><li><strong>索引段</strong>： 存放 B + 树的非叶子节点的区的集合；</li><li><strong>数据段</strong>： 存放 B + 树的叶子节点的区的集合；</li><li><strong>回滚段</strong>： 存放的是回滚数据的区的集合，之前讲<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html" target="_blank" rel="noopener noreferrer">事务隔离</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><h2 id="innodb-行格式有哪些" tabindex="-1"><a class="header-anchor" href="#innodb-行格式有哪些"><span>InnoDB 行格式有哪些</span></a></h2><p>好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。</p><p>之所以要绕一大圈才讲行记录的格式，主要是想让大家知道行记录是存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。</p><h3 id="_4种行格式" tabindex="-1"><a class="header-anchor" href="#_4种行格式"><span>4种行格式</span></a></h3><p>行格式（row_format），就是一条记录的存储结构。</p><p>InnoDB 提供了 4 种行格式，分别是：</p><ul><li><p><strong>Redundant</strong>，</p><p>缺点：它是一种<em>不紧凑</em>的行格式</p><p>版本：是很古老的行格式了， <em>MySQL 5.0</em> 版本之前用的行格式，现在基本没人用了。</p></li><li><p><strong>Compact</strong>，</p><p>优点：Compact 是一种<em>紧凑</em>的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录。</p><p>版本：MySQL 5.0 之后引入了 Compact 行记录存储方式，从 <em>MySQL 5.1</em> 版本之后，行格式默认设置成 Compact。</p></li><li><p><strong>Dynamic</strong>，</p><p>优点：Dynamic 和 Compressed 两个都是<em>紧凑</em>的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。</p><p>版本：从 <em>MySQL 5.7</em> 版本之后，默认使用 Dynamic 行格式。</p></li><li><p><strong>Compressed</strong>，</p></li></ul><h3 id="compact-行格式" tabindex="-1"><a class="header-anchor" href="#compact-行格式"><span>COMPACT 行格式</span></a></h3><p>下面重点介绍 Compact 行格式。Redundant 现在基本没人用就不讲了，而 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像，先弄懂 Compact 行格式，之后再去了解其他行格式，很快也能看懂。</p><p>先跟 Compact 行格式混个脸熟，它长这样：</p><p><img src="'+c+'" alt="img" loading="lazy"></p><p>一条完整的记录组成：</p><ul><li>记录的额外信息 <ul><li>变长字段长度列表 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><mn>1</mn><mo>∼</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\sum(1\\sim2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> Byte，可无)</li><li>NULL 值列表 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">(</mo><mtext>向上取整</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L/8(向上取整)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span><span class="mopen">(</span><span class="mord cjk_fallback">向上取整</span><span class="mclose">)</span></span></span></span> Byte，可无)</li><li>记录头信息 <ul><li>delete_mask</li><li>next_record</li><li>record_type</li></ul></li></ul></li><li>记录的真实数据 <ul><li>row_id (6Byte，可无，隐藏主键)</li><li>trx_id (6Byte)，事务id</li><li>roll_pointer (7Byte)</li><li>[...列值] (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\sum(L_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> Byte)</li></ul></li></ul><h4 id="记录的额外信息" tabindex="-1"><a class="header-anchor" href="#记录的额外信息"><span>记录的额外信息</span></a></h4><h5 id="变长字段长度列表" tabindex="-1"><a class="header-anchor" href="#变长字段长度列表"><span>变长字段长度列表</span></a></h5><blockquote><h6 id="数据准备" tabindex="-1"><a class="header-anchor" href="#数据准备"><span>数据准备</span></a></h6></blockquote><p><code>varchar(n)</code> 和 <code>char(n)</code> 的区别是什么，相信大家都非常清楚。char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p><p>为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> `</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">t_user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">` (</span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  `id`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">NOT NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,												# 定长</span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  `name`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,										# 变长字段</span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  `phone`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,										# 变长字段</span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  `age`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,											# 定长</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">`id`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">USING</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> BTREE</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) ENGINE </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> InnoDB </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> CHARACTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> SET</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ascii ROW_FORMAT </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> COMPACT; 	# 行格式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在 t_user 表里有这三条记录：</p><p><img src="'+n+'" alt="img" loading="lazy"></p><blockquote><h6 id="数据分析" tabindex="-1"><a class="header-anchor" href="#数据分析"><span>数据分析</span></a></h6></blockquote><p>接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。</p><p><strong>来看第一条记录</strong>：</p><ul><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li><li>age 列和 id 列不是变长字段，所以这里不用管。</li></ul><p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。</p><p><img src="'+d+'" alt="img" loading="lazy"></p><p><strong>来看第二条记录</strong>：同样的道理，我们也可以得出「变长字段长度列表」里的内容是「 04 02」，如下图：</p><p><img src="'+m+'" alt="img" loading="lazy"></p><p><strong>来看第三条记录</strong>：phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p><p><img src="'+g+'" alt="img" loading="lazy"></p><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>为什么「变长字段长度列表」和「 NULL 值列表」的信息要按照逆序存放？</p><p>特点</p><ul><li>这个设计主要是因为「记录头信息」中指向下一个记录的指针，而这个指针是记录的「记录头信息」和「真实数据」<em>之间的位置</em></li></ul><p>好处：</p><ol><li>向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>同时，逆序存放可以使得位置<strong>靠前</strong>的记录的真实数据和数据对应的字段长度信息可以同时<strong>在一个 CPU Cache Line 中</strong>，提高 CPU Cache 命中率</li></ol><p>如果你不知道什么是 CPU Cache，可以看<a href="https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html" target="_blank" rel="noopener noreferrer">这篇文章</a>，这属于计算机组成的知识。</p></div></div><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>每个数据库表的行格式都有「变长字段字节数列表」吗？</p><p>其实「变长字段字节数列表」不是必须的，只出现在数据表有变长字段的时候。</p><p><strong>原因</strong>：没必要，不如去掉以节省空间。</p></div></div><h5 id="null-值列表" tabindex="-1"><a class="header-anchor" href="#null-值列表"><span>NULL 值列表</span></a></h5><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制<em>位（bit）</em>，二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p><p>还是以 t_user 表的这三条记录作为例子：</p><p><img src="'+n+'" alt="img" loading="lazy"></p><p>接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。</p><p><strong>来看第一条记录</strong>：第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：</p><p><img src="'+k+'" alt="img" loading="lazy"></p><p>但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：</p><p><img src="'+u+'" alt="img" loading="lazy"></p><p>所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。</p><p><strong>来看第二条记录</strong>：第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。</p><p><img src="'+v+'" alt="img" loading="lazy"></p><p><strong>来看第三条记录</strong>：第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p><p><img src="'+y+'" alt="img" loading="lazy"></p><p>我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p><p><img src="'+A+'" alt="img" loading="lazy"></p><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>每个数据库表的行格式都有「NULL 值列表」吗？</p><p>NULL 值列表也不是必须的。当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p></div></div><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？</p><p>不是固定 1 字节。当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p></div></div><h5 id="记录头信息" tabindex="-1"><a class="header-anchor" href="#记录头信息"><span>记录头信息</span></a></h5><p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p><ul><li><p>delete_mask：</p><p>标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</p></li><li><p>next_record：</p><p>下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p></li><li><p>record_type：</p><p>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</p></li></ul><h4 id="记录的真实数据" tabindex="-1"><a class="header-anchor" href="#记录的真实数据"><span>记录的真实数据</span></a></h4><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。</p><p><img src="'+B+'" alt="img" loading="lazy"></p><ul><li><p>row_id (6Byte，可无，隐藏主键)</p><p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p></li><li><p>trx_id (6Byte)，事务id</p><p>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p></li><li><p>roll_pointer (7Byte)</p><p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p></li><li><p>[...列值]</p><p>略</p></li></ul><blockquote><p>如果你熟悉 MVCC 机制，你应该就清楚 trx_id 和 roll_pointer 的作用了。 如果你还不知道 MVCC 机制，可以看完<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html" target="_blank" rel="noopener noreferrer">这篇文章</a>，<strong>一定要掌握</strong>，面试也很经常问 MVCC 是怎么实现的。</p></blockquote><h2 id="一行的最大字节" tabindex="-1"><a class="header-anchor" href="#一行的最大字节"><span>一行的最大字节</span></a></h2><h3 id="一行的最大字节-1" tabindex="-1"><a class="header-anchor" href="#一行的最大字节-1"><span>一行的最大字节</span></a></h3><p>也就是说，<strong>除了</strong> TEXT、BLOBs 大对象类型的列，<strong>一行记录限制最大为 65535 字节</strong>（注意是一行的总长度，不是一列，而是多列的和）</p><h3 id="varchar-n-中-n-最大取值为多少" tabindex="-1"><a class="header-anchor" href="#varchar-n-中-n-最大取值为多少"><span>varchar(n) 中 n 最大取值为多少？</span></a></h3><p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p><p>varchar(n) 字段类型的 n 代表的是最多存储的<em>字符数量，并不是字节大小</em>哦。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节。（比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据）</p><h4 id="单字段的情况-一个字符占用一个字节" tabindex="-1"><a class="header-anchor" href="#单字段的情况-一个字符占用一个字节"><span>单字段的情况 (一个字符占用一个字节)</span></a></h4><p>前面我们知道了，一行记录最大只能存储 65535 字节的数据。</p><p>那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？</p><h5 id="原因、计算分析" tabindex="-1"><a class="header-anchor" href="#原因、计算分析"><span>原因、计算分析</span></a></h5><p>顺便复习一下之前的行记录组成：</p><ul><li>记录的额外信息 <ul><li>变长字段长度列表 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><mn>1</mn><mo>∼</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\sum(1\\sim2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> Byte，可无)</li><li>NULL 值列表 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">(</mo><mtext>向上取整</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L/8(向上取整)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span><span class="mopen">(</span><span class="mord cjk_fallback">向上取整</span><span class="mclose">)</span></span></span></span> Byte，可无)</li><li>记录头信息 <ul><li>delete_mask</li><li>next_record</li><li>record_type</li></ul></li></ul></li><li>记录的真实数据 <ul><li>row_id (6Byte，可无，隐藏主键)</li><li>trx_id (6Byte)，事务id</li><li>roll_pointer (7Byte)</li><li>[...列值] (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\sum(L_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> Byte)</li></ul></li></ul><p>在这个案例中，我们存储字段类型为 varchar(n) 的数据时，其实涉及了三个部分来存储：</p><ul><li><p><em>NULL 标识 (1Byte)</em></p><ul><li>一般规则：如果不允许为NULL，这部分不需要。否则则应该按位存储，向上取整到字节。</li><li>本次案例：前面我创建表的时候，字段是允许为 NULL 的，所以<strong>会用 1 字节来表示「NULL 值列表」</strong>。</li></ul></li><li><p><em>真实数据占用的字节数 (2Byte)</em></p><ul><li><p>一般规则：具体情况分为：</p><ul><li>条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；</li><li>条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；</li></ul></li><li><p>本次案例：</p><ul><li>我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。</li><li>因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，<strong>也就是 2 字节</strong>。</li></ul></li></ul></li><li><p><em>真实数据 (65533Byte)</em></p><ul><li><p>一般规则：就是你这部分占了多少。在单字段的情况下，n就表示n个字节。在多字段的情况下，具体分析</p></li><li><p>本次案例：全部加起来最大值值是65535，前面两项已经被定下来了。因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。</p><p>所以，<strong>在本次案例中</strong>（数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下）</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mtext>中</mtext><mi>n</mi><mtext>最大值</mtext><mo>=</mo><mtext>一行限制</mtext><mo stretchy="false">(</mo><mn>65535</mn><mo stretchy="false">)</mo><mo>−</mo><mtext>变长字段长度</mtext><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mi>N</mi><mi>U</mi><mi>L</mi><mi>L</mi><mtext>值列表</mtext><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>65532</mn></mrow><annotation encoding="application/x-tex">varchar(n) 中 n 最大值 = 一行限制(65535) - 变长字段长度(2) - NULL值列表(1) = 65532 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rc</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord cjk_fallback">中</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">最大值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">一行限制</span><span class="mopen">(</span><span class="mord">65535</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">变长字段长度</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">ULL</span><span class="mord cjk_fallback">值列表</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65532</span></span></span></span></span></p><p>而后面的实验结果也能够说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。</p></li></ul></li></ul><h5 id="实验" tabindex="-1"><a class="header-anchor" href="#实验"><span>实验</span></a></h5><p>可以做实验验证一下：</p><blockquote><p>65535</p></blockquote><p>我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ( </span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">`name`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">65535</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">NULL</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) ENGINE </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> InnoDB </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> CHARACTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> SET</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ascii ROW_FORMAT </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> COMPACT;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看能不能成功创建一张表：</p><p><img src="'+L+'" alt="img" loading="lazy"></p><p>可以看到，创建失败了。</p><p>从报错信息就可以知道<strong>一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead</strong>。</p><p>问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说<strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong>。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。</p><blockquote><p>65533</p></blockquote><p>我们先来测试看看 varchar(65533) 是否可行？</p><p><img src="'+b+'" alt="img" loading="lazy"></p><blockquote><p>65532</p></blockquote><p>可以看到，还是不行，接下来看看 varchar(65532) 是否可行？</p><p><img src="'+_+'" alt="img" loading="lazy"></p><p>可以看到，创建成功了。</p><h4 id="多字段的情况-一个字符占用多个字节" tabindex="-1"><a class="header-anchor" href="#多字段的情况-一个字符占用多个字节"><span>多字段的情况 (一个字符占用多个字节)</span></a></h4><p>当然，在这之前的例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。</p><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535</strong>。</p><p>这里举个多字段的情况的例子（感谢@Emoji同学提供的例子）</p><p><img src="'+f+'" alt="img" loading="lazy"></p><h3 id="行溢出后-mysql-是怎么处理的" tabindex="-1"><a class="header-anchor" href="#行溢出后-mysql-是怎么处理的"><span>行溢出后，MySQL 是怎么处理的？</span></a></h3><h4 id="行溢出现象" tabindex="-1"><a class="header-anchor" href="#行溢出现象"><span>行溢出现象</span></a></h4><p>MySQL 中磁盘和内存交互的基本单位是页。但有时一个页可能存不了一条记录，如：</p><ul><li>一个页的大小：一般是 <code>16KB</code>，也就是 <code>16384字节</code></li><li>一个 varchar(n) 类型的列：最多可以存储 <code>65532字节</code></li><li>一些大对象：如 TEXT、BLOB 可能存储更多的数据</li></ul><p>这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><h4 id="解决方案-「数据页」与「溢出页」" tabindex="-1"><a class="header-anchor" href="#解决方案-「数据页」与「溢出页」"><span>解决方案 (「数据页」与「溢出页」)</span></a></h4><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><ul><li>在一般情况下，InnoDB 的数据都是存放在 **「数据页」**中。</li><li>但是当发生行溢出时，溢出的数据会存放到**「溢出页」**中。</li></ul><blockquote><h5 id="对于-compact-行格式" tabindex="-1"><a class="header-anchor" href="#对于-compact-行格式"><span>对于 Compact 行格式</span></a></h5></blockquote><p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，<strong>然后真实数据处用 20 字节存储指向溢出页的地址</strong>，从而可以找到剩余数据所在的页。大致如下图所示。</p><p><img src="'+E+'" alt="img" loading="lazy"></p><blockquote><h5 id="对于-compressed-和-dynamic-行格式" tabindex="-1"><a class="header-anchor" href="#对于-compressed-和-dynamic-行格式"><span>对于 Compressed 和 Dynamic 行格式</span></a></h5></blockquote><p>这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这两种格式采用完全的行溢出方式，记录的真实数据处<strong>不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页</strong>。而实际的数据都存储在溢出页中，看起来就像下面这样：</p><p><img src="'+w+'" alt="img" loading="lazy"></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>MySQL 的 NULL 值是怎么存放的？</p><p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p><ul><li>NULL值列表会占用 1 字节空间。（可NULL列除以8并向上取整）</li><li>当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</li></ul></div></div><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p><p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p></div></div><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>varchar(n) 中 n 最大取值为多少？</p><p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p><p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。</p><p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535。</p></div></div><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p></p><p>行溢出后，MySQL 是怎么处理的？</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p></div></div><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li>《MySQL 是怎样运行的》</li><li>《MySQL技术内幕 InnoDB存储引擎》</li></ul>',138)]))}const M=e(x,[["render",C],["__file","02. MySQL一行记录是怎么存储的？.html.vue"]]),N=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/03.%20%E5%9B%BE%E8%A7%A3MySQL/01.%20%E5%9F%BA%E7%A1%80/02.%20MySQL%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F.html","title":"MySQL一行记录是怎么存储的？","lang":"zh-CN","frontmatter":{"description":"MySQL一行记录是怎么存储的？ 如果你知道 MySQL 一行记录的存储结构，那么这个问题对你没什么难度。 如果你不知道也没关系，这次我跟大家聊聊 MySQL 一行记录是怎么存储的？ 知道了这个之后，除了能应解锁前面这道面试题，你还会解锁这些面试题： MySQL 的 NULL 值会占用空间吗？ MySQL 怎么知道 varchar(n) 实际占用数据的...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/03.%20%E5%9B%BE%E8%A7%A3MySQL/01.%20%E5%9F%BA%E7%A1%80/02.%20MySQL%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"MySQL一行记录是怎么存储的？"}],["meta",{"property":"og:description","content":"MySQL一行记录是怎么存储的？ 如果你知道 MySQL 一行记录的存储结构，那么这个问题对你没什么难度。 如果你不知道也没关系，这次我跟大家聊聊 MySQL 一行记录是怎么存储的？ 知道了这个之后，除了能应解锁前面这道面试题，你还会解锁这些面试题： MySQL 的 NULL 值会占用空间吗？ MySQL 怎么知道 varchar(n) 实际占用数据的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL一行记录是怎么存储的？\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"MySQL一行记录是怎么存储的？","slug":"mysql一行记录是怎么存储的","link":"#mysql一行记录是怎么存储的","children":[{"level":2,"title":"MySQL 的数据存储","slug":"mysql-的数据存储","link":"#mysql-的数据存储","children":[{"level":3,"title":"创建一个数据库","slug":"创建一个数据库","link":"#创建一个数据库","children":[]},{"level":3,"title":"数据库文件的位置","slug":"数据库文件的位置","link":"#数据库文件的位置","children":[]},{"level":3,"title":"数据库文件的结构","slug":"数据库文件的结构","link":"#数据库文件的结构","children":[{"level":4,"title":"行（row）","slug":"行-row","link":"#行-row","children":[]},{"level":4,"title":"页（page）","slug":"页-page","link":"#页-page","children":[]},{"level":4,"title":"区（extent）","slug":"区-extent","link":"#区-extent","children":[]},{"level":4,"title":"段（segment）","slug":"段-segment","link":"#段-segment","children":[]}]}]},{"level":2,"title":"InnoDB 行格式有哪些","slug":"innodb-行格式有哪些","link":"#innodb-行格式有哪些","children":[{"level":3,"title":"4种行格式","slug":"_4种行格式","link":"#_4种行格式","children":[]},{"level":3,"title":"COMPACT 行格式","slug":"compact-行格式","link":"#compact-行格式","children":[{"level":4,"title":"记录的额外信息","slug":"记录的额外信息","link":"#记录的额外信息","children":[{"level":5,"title":"变长字段长度列表","slug":"变长字段长度列表","link":"#变长字段长度列表","children":[]},{"level":5,"title":"NULL 值列表","slug":"null-值列表","link":"#null-值列表","children":[]},{"level":5,"title":"记录头信息","slug":"记录头信息","link":"#记录头信息","children":[]}]},{"level":4,"title":"记录的真实数据","slug":"记录的真实数据","link":"#记录的真实数据","children":[]}]}]},{"level":2,"title":"一行的最大字节","slug":"一行的最大字节","link":"#一行的最大字节","children":[{"level":3,"title":"一行的最大字节","slug":"一行的最大字节-1","link":"#一行的最大字节-1","children":[]},{"level":3,"title":"varchar(n) 中 n 最大取值为多少？","slug":"varchar-n-中-n-最大取值为多少","link":"#varchar-n-中-n-最大取值为多少","children":[{"level":4,"title":"单字段的情况 (一个字符占用一个字节)","slug":"单字段的情况-一个字符占用一个字节","link":"#单字段的情况-一个字符占用一个字节","children":[{"level":5,"title":"原因、计算分析","slug":"原因、计算分析","link":"#原因、计算分析","children":[]},{"level":5,"title":"实验","slug":"实验","link":"#实验","children":[]}]},{"level":4,"title":"多字段的情况 (一个字符占用多个字节)","slug":"多字段的情况-一个字符占用多个字节","link":"#多字段的情况-一个字符占用多个字节","children":[]}]},{"level":3,"title":"行溢出后，MySQL 是怎么处理的？","slug":"行溢出后-mysql-是怎么处理的","link":"#行溢出后-mysql-是怎么处理的","children":[{"level":4,"title":"行溢出现象","slug":"行溢出现象","link":"#行溢出现象","children":[]},{"level":4,"title":"解决方案 (「数据页」与「溢出页」)","slug":"解决方案-「数据页」与「溢出页」","link":"#解决方案-「数据页」与「溢出页」","children":[]}]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}]}],"git":{},"readingTime":{"minutes":21.58,"words":6473},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/03. 图解MySQL/01. 基础/02. MySQL一行记录是怎么存储的？.md","excerpt":"\\n<p>如果你知道 MySQL 一行记录的存储结构，那么这个问题对你没什么难度。</p>\\n<p>如果你不知道也没关系，这次我跟大家聊聊 <strong>MySQL 一行记录是怎么存储的？</strong></p>\\n<p>知道了这个之后，除了能应解锁前面这道面试题，你还会解锁这些面试题：</p>\\n<ul>\\n<li>MySQL 的 NULL 值会占用空间吗？</li>\\n<li>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</li>\\n<li>varchar(n) 中 n 最大取值为多少？</li>\\n<li>行溢出后，MySQL 是怎么处理的？</li>\\n</ul>\\n<p>这些问题看似毫不相干，其实都是在围绕「 MySQL 一行记录的存储结构」这一个知识点，所以攻破了这个知识点后，这些问题就引刃而解了。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/03. 图解MySQL/01. 基础/02. MySQL一行记录是怎么存储的？.md","value":{"title":"02. MySQL一行记录是怎么存储的？","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/03. 图解MySQL/01. 基础/02. MySQL一行记录是怎么存储的？.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{M as comp,N as data};
