import{_ as i,e as a,g as p,o as r}from"./app-HvNDXJEG.js";const l="/assets/2013050217125642416-CzJYeOHn.png",o="/assets/2013050217125736394-ET6q57Aw.png",s="/assets/2013050217125787134-DoVu9OIK.png",n="/assets/2013050217125714223-dhT2foXE.png",t="/assets/2013050217125854801-vj080-43.png",c="/assets/2013050217125843584-BnfbrrRA.png",h="/assets/2013050217125855065-CbG9a9gE.png",d="/assets/2013050217125894588-CgXl18a3.png",u="/assets/image-20210126144444965-B7sDdkXn.png",g="/assets/5465416_-9ZKXYCB_.png",k="/assets/image-20210126141330881-FO9LHsYC.png",T={};function b(P,e){return r(),a("div",null,e[0]||(e[0]=[p('<h1 id="wireshark" tabindex="-1"><a class="header-anchor" href="#wireshark"><span>Wireshark</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><p>[toc]</p><h1 id="工具" tabindex="-1"><a class="header-anchor" href="#工具"><span>工具</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><blockquote><p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。</p><p>使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。</p><p>为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p></blockquote><h2 id="抓包协议" tabindex="-1"><a class="header-anchor" href="#抓包协议"><span>抓包协议</span></a></h2><blockquote><p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容</p><p>如果是处理HTTP,HTTPS 还是用Fiddler</p><p>其他协议比如TCP,UDP 就用wireshark</p></blockquote><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h2><p><strong>wireshark是捕获机器上的某一块网卡的网络包</strong>，当你的机器上有多块网卡的时候，你需要选择一个网卡。</p><h2 id="窗口介绍" tabindex="-1"><a class="header-anchor" href="#窗口介绍"><span>窗口介绍</span></a></h2><p><img src="'+l+'" alt="2013050217125642416" loading="lazy"></p><h2 id="过滤器" tabindex="-1"><a class="header-anchor" href="#过滤器"><span>过滤器</span></a></h2><p>过滤器有两种：</p><blockquote><ul><li>一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录</li><li>一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -&gt; Capture Filters 中设置</li></ul></blockquote><p>保存过滤：</p><blockquote><ul><li>在Filter栏上，填好Filter的表达式后，点击Save按钮， 取个名字。新版本点表达式左侧的标签图标</li></ul></blockquote><p>表达式规则：</p><blockquote><ul><li><p>协议过滤</p><p>​ 如：<code>TCP</code></p></li><li><p>IP过滤</p><p>​ 如：<code>ip.src ==192.168.1.102</code>和<code>ip.dst==192.168.1.102</code>分别为源地址和目标地址</p></li><li><p>端口过滤</p><p>​ 如：<code>tcp.port ==80</code>和<code>tcp.srcport == 80</code>，后者只显示TCP协议的源端口为80的</p></li><li><p>Http模式过滤</p><p>​ 如：<code>http.request.method==&quot;GET&quot;</code>, 只显示HTTP GET方法的</p></li><li><p>逻辑运算符</p><p>​ 如：<code>AND</code>、<code>OR</code></p></li></ul></blockquote><h1 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点"><span>知识点</span></a></h1><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="wireshark对应osi七层模型" tabindex="-1"><a class="header-anchor" href="#wireshark对应osi七层模型"><span>wireshark对应OSI七层模型</span></a></h3><p>这里只有五层，因为它对应的是现代的因特网协议栈（详见《计算机网络 - 自顶向下方法》，而国内大学一般都是按七层教，但实际上只有五层）</p><p><img src="'+o+'" alt="2013050217125736394" loading="lazy"></p><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp"><span>TCP</span></a></h2><h3 id="tcp包具体内容" tabindex="-1"><a class="header-anchor" href="#tcp包具体内容"><span>TCP包具体内容</span></a></h3><p><img src="'+s+'" alt="2013050217125787134" loading="lazy"></p><h3 id="分析tcp三次握手" tabindex="-1"><a class="header-anchor" href="#分析tcp三次握手"><span>分析TCP三次握手</span></a></h3><p><img src="'+n+'" alt="2013050217125714223" loading="lazy"></p><p>这图我都看过很多遍了， 这次我们用wireshark实际分析下三次握手的过程。</p><p>打开wireshark, 打开浏览器输入 http://www.cr173.com</p><p>在wireshark中输入http过滤， 然后选中GET /tankxiao HTTP/1.1的那条记录，右键然后点击&quot;Follow TCP Stream&quot;,</p><p>这样做的目的是为了得到与浏览器打开网站相关的数据包，将得到如下图</p><p><img src="'+t+'" alt="2013050217125854801" loading="lazy"></p><p>图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。</p><h4 id="第一次握手数据包" tabindex="-1"><a class="header-anchor" href="#第一次握手数据包"><span>第一次握手数据包</span></a></h4><p>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图</p><p><img src="'+c+'" alt="2013050217125843584" loading="lazy"></p><h4 id="第二次握手的数据包" tabindex="-1"><a class="header-anchor" href="#第二次握手的数据包"><span>第二次握手的数据包</span></a></h4><p>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1=1, 如下图</p><p><img src="'+h+'" alt="2013050217125855065" loading="lazy"></p><h4 id="第三次握手的数据包" tabindex="-1"><a class="header-anchor" href="#第三次握手的数据包"><span>第三次握手的数据包</span></a></h4><p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:</p><p><img src="'+d+'" alt="2013050217125894588" loading="lazy"></p><p>就这样通过了TCP三次握手，建立了连接</p><h2 id="一些其他协议" tabindex="-1"><a class="header-anchor" href="#一些其他协议"><span>一些其他协议</span></a></h2><h3 id="http" tabindex="-1"><a class="header-anchor" href="#http"><span>HTTP</span></a></h3><p>要注意缓存问题</p><h4 id="着色" tabindex="-1"><a class="header-anchor" href="#着色"><span>着色</span></a></h4><ul><li>一般而言全是绿底黑字</li><li>偶尔出现黑底红字表示<code>Bad TCP</code></li><li>偶尔出现红底黄字表示<code>TCP RST</code>或<code>SCTP ABORT</code></li></ul><h4 id="协议" tabindex="-1"><a class="header-anchor" href="#协议"><span>协议</span></a></h4><ul><li>网络层：IP，不显示为包，而是会显示在传输层和应用层的头部</li><li>传输层：TCP（三次握手，四次挥手）</li><li>应用层：HTTP</li></ul><h4 id="抓包结果" tabindex="-1"><a class="header-anchor" href="#抓包结果"><span>抓包结果</span></a></h4><ul><li><p>(1) 第一次握手</p><ul><li>Protocol：TCP</li><li>Info：[SYN]</li><li>inspector <ul><li>三次握手少了应用层</li></ul></li></ul></li><li><p>(2) 第二次握手</p><ul><li>Protocol：TCP</li><li>Info：[SYN，ACK]</li><li>inspector <ul><li>三次握手少了应用层</li></ul></li></ul></li><li><p>(3) 第三次握手</p><ul><li>Protocol：TCP</li><li>Info：[ACK]</li><li>inspector <ul><li>三次握手少了应用层</li></ul></li></ul></li><li><p>(4) HTTP响应</p><ul><li><p>Protocol：HTTP</p></li><li><p>inspector</p><ul><li><p>帧：Frame 187，这里是表示wireshark抓取的id</p><p><code>Frame 187: 1036 bytes on wire (8288 bits), 1036 bytes captured (8288 bits) on interface \\Device\\NPF_{C52ECB1F-B415-4A45-B5FF-FACD70E0F629}, id 0</code></p></li><li><p>链路层：Ethernet II，这里的Dst是网关的，我这里抓到的是个人路由器名称和物理地址（可通过<code>arp -a</code>查证）</p><p><code>Ethernet II, Src: IntelCor_43:27:b8 (54:8d:5a:43:27:b8), Dst: Tp-LinkT_c4:a7:b2 (54:a7:03:c4:a7:b2)</code></p></li><li><p>网络层：<strong>I</strong>nternet <strong>P</strong>rotocol <strong>V</strong>ersion <strong>4</strong>，IPv4协议</p><p><code>Internet Protocol Version 4, Src: 192.168.1.107, Dst: 140.143.51.136</code></p></li><li><p>传输层：<strong>T</strong>ransmission <strong>C</strong>ontrl <strong>P</strong>rotocol，传输控制协议</p><p><code>Transmission Control Protocol, Src Port: 5168, Dst Port: 80, Seq: 1, Ack: 1, Len: 982</code></p></li><li><p>应用层：<strong>H</strong>yper<strong>t</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，超文本传输协议</p><p><code>Hypertext Transfer Protocol</code></p></li></ul></li></ul></li></ul><h3 id="icmp" tabindex="-1"><a class="header-anchor" href="#icmp"><span>ICMP</span></a></h3><p>在CMD里<code>Ping</code>的过程使用的就是这个</p><p><code>Info</code>信息一般是<code>Echo (ping) request</code>（请求）和<code>Echo (ping) reply</code>（响应）</p><p>Windows中CMD的Ping命令一般是四次请求和四次响应，交替出现，一共8个包</p><p>（但我试出来是两次请求（第一次是no response found，第二次才是reply in），一次响应，共12个包）</p><h3 id="smpp" tabindex="-1"><a class="header-anchor" href="#smpp"><span>SMPP</span></a></h3><p>short message peer to peer，短消息对等协议，TCP流</p><p>刚开始我以为是对应的QQ的短信息，但后来看了下是TCP流，应该不是</p><p>隐约能看到进行QQ通信的QQ号信息</p><p>特征</p><ul><li>最顶层结果中的Password字符串里面隐含了QQ号信息</li><li>Info是Outbind</li><li>目标ip不对，定位到了天津的服务器</li><li>有多次握手</li><li>发信息无需对方应答</li><li>有的字节看不到，但切换搜索模式为<code>分组字节流</code>后能搜到</li></ul><p><img src="'+u+'" alt="image-20210126144444965" loading="lazy"></p><h3 id="ssdp" tabindex="-1"><a class="header-anchor" href="#ssdp"><span>SSDP</span></a></h3><p>Simple Service Discovery Protocol，简单服务发现协议，UDP流</p><h3 id="tlsv1-2" tabindex="-1"><a class="header-anchor" href="#tlsv1-2"><span>TLSv1.2</span></a></h3><p>UDP流 + TLS流</p><p>TLS的作用三个作用</p><ul><li>（1）身份认证<br> 通过证书认证来确认对方的身份，防止中间人攻击</li><li>（2）数据私密性<br> 使用对称性密钥加密传输的数据，由于密钥只有客户端/服务端有，其他人无法窥探。</li><li>（3）数据完整性<br> 使用摘要算法对报文进行计算，收到消息后校验该值防止数据被篡改或丢失。</li></ul><h1 id="过滤器-filter" tabindex="-1"><a class="header-anchor" href="#过滤器-filter"><span>过滤器 Filter</span></a></h1><h2 id="善用补全提示" tabindex="-1"><a class="header-anchor" href="#善用补全提示"><span>善用补全提示</span></a></h2><p>例如<code>ip.</code>，然后什么都不用按，就有各种补全选项</p><h2 id="常用的过滤器" tabindex="-1"><a class="header-anchor" href="#常用的过滤器"><span>常用的过滤器</span></a></h2><p>用双方ip筛选</p><ul><li><code>ip.src == ip地址</code>，源地址</li><li><code> ip.dst == ip地址</code>，目标地址</li><li><code>ip.addr == ip地址</code>，地址（源/目标），等同于<code>ip.src == ip地址 or ip.dst == ip地址</code></li></ul><p>布尔</p><h1 id="实操" tabindex="-1"><a class="header-anchor" href="#实操"><span>实操</span></a></h1><h1 id="实战" tabindex="-1"><a class="header-anchor" href="#实战"><span>实战</span></a></h1><h2 id="干扰项太多的问题" tabindex="-1"><a class="header-anchor" href="#干扰项太多的问题"><span>干扰项太多的问题</span></a></h2><p>尽量选用副Q以减少干扰，而且虚拟机也能很好地解决这个问题！</p><p><strong>kali自带wireshark</strong>，在09-嗅探/欺骗一分类中，不用下载Linux版本和安装！！！挺干净的</p><h2 id="qq的iocq协议" tabindex="-1"><a class="header-anchor" href="#qq的iocq协议"><span>QQ的iocq协议</span></a></h2><p>可获得对方的ip？</p><p>但是这里的QQ只能看到自己的，看不到别人的</p><p>Filter: <code>iocq</code></p><p><img src="'+g+'" alt="5465416+" loading="lazy"></p><h2 id="利用qq电话获取对方ip地址" tabindex="-1"><a class="header-anchor" href="#利用qq电话获取对方ip地址"><span>利用QQ电话获取对方ip地址</span></a></h2><ul><li>(1) 打开wireshark捕获</li><li>(2) 给对方QQ电话 <ul><li>是否需要对方接通：有的版本的QQ不需要，20210126测得需要接通才行</li></ul></li><li>(3) ctrl+f在信息流中搜索，<code>分组列表</code>改为<code>分组详情</code>，搜索内容为<code>020048</code>（其实是以该字符串开头的Data数据），搜索到的就是</li><li>(4) Internet Protocol Version（网络层）中查看 <ul><li>Source（自己的ip，内网中会显示为内网ip）</li><li>Destination（目标ip，有内网和外网ip，忽略前者，找外网ip，得到的便是对方的ip地址）</li></ul></li></ul><p><img src="'+k+'" alt="image-20210126141330881" loading="lazy"></p><h2 id="抓取手机数据报" tabindex="-1"><a class="header-anchor" href="#抓取手机数据报"><span>抓取手机数据报</span></a></h2><h3 id="坑-支付宝" tabindex="-1"><a class="header-anchor" href="#坑-支付宝"><span>坑：支付宝</span></a></h3><p>暂时还没有哪个手机模拟器能够登陆上支付宝</p><p>放弃了使用手机模拟器，直接电脑开热点抓手机包</p><h3 id="坑-电脑热点" tabindex="-1"><a class="header-anchor" href="#坑-电脑热点"><span>坑：电脑热点</span></a></h3><ul><li>踩坑一：刚开始我试了很多的移动wifi软件，包括360wifi、捷豹wifi、wifi共享精灵等，都不行。wifi共享精灵报错：开启失败，无线网卡不支持WiFi</li><li>解决一：后来发现1709版本自带了<code>移动热点</code>，可以在消息栏（对应快捷键<code>Win+A</code>）中开启</li><li>踩坑一：win10移动热点，手机无法连接或连接超时</li><li>解决二：在<code>控制面板\\所有控制面板项\\网络连接</code>的页面中，发现开启后多出来<code>本地连接*2</code>。然后设置：WLAN &gt; 属性 &gt; 共享 &gt; 勾选允许共享，且<code>家庭网络连接</code>中选择新增的网络连接，这里是<code>本地连接*2</code></li></ul><h3 id="信息所属ip" tabindex="-1"><a class="header-anchor" href="#信息所属ip"><span>信息所属ip</span></a></h3><ul><li><p>结论</p><ul><li><p>手机连上电脑热点以后，刚开始我为了避免电脑的通话干扰，屏蔽了电脑ip，只抓手机ip</p></li><li><p>可惜什么都没抓到，后来用被访问的ip过滤发现抓到的都是电脑ip的包，即用电脑ip来抓即可，不用管手机ip</p></li></ul></li><li><p>原因分析</p><ul><li>不太懂手机难道不传包给电脑吗？我猜测原因可能是路由器需要分配给局域网ip，而手机连电脑热点的ip不在局域网内</li><li>如果ip协议中使用的是手机的ip，那么家庭路由器可能就不知道应该把这个通信包发给谁</li><li>所以这个通信包一开始就是使用电脑的ip</li></ul></li><li><p>难题</p><ul><li>但如果是这样的话，手机的通信包和电脑的通信包混在一起了，只用ip就很难过滤了</li><li>如果是使用http协议的话，可以通过<code>http contains &quot;User-Agent:&quot;</code>的方式进行过滤，或者在分组详细里搜索</li><li>如<code>User-Agent: Mozilla/5.0 (Android 10; Mobile; rv:85.0) Gecko/85.0 Firefox/85.0\\r\\n</code>筛选Android设备</li></ul></li></ul><h2 id="支付宝app抓包总结" tabindex="-1"><a class="header-anchor" href="#支付宝app抓包总结"><span>支付宝App抓包总结</span></a></h2><p>踩坑</p><ul><li>亲测Fiddler无效，Fiddler原理是设置系统代理，但支付宝会绕开系统代理进行通信</li><li>为排除干扰使用虚拟机，但Linux无法安装手机模拟器 <ul><li>Genymotion：但后来了解了下是VirtualBox平台的，不支持VMWare平台</li><li>anbox：好像也不行</li><li>xdroid：理论上支持Kali系统，但安装过程中出错，可能和虚拟机环境有关</li></ul></li><li>之所以用Linux是因为Kali自带了Wireshark，不用安装那么麻烦，后来没办法，只能在虚拟机用Windows7 <ul><li>Windows7下Wireshark安装后打开显示没有找到接口：应该是无法检测到网卡</li><li>解决方案：https://blog.csdn.net/littlle_yan/article/details/79403680，手动安装Winpcap</li></ul></li><li>然后发现目前网上的所有手机模拟器均无法进行支付宝的登录，后来只能进行手机联电脑热点，走电脑网卡进行抓包</li></ul>',103)]))}const B=i(T,[["render",b],["__file","Wireshark.html.vue"]]),E=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/Capture/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Wireshark.html","title":"Wireshark","lang":"zh-CN","frontmatter":{"description":"Wireshark 目录 [toc] 工具 介绍 wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。 使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。 为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。 抓包协议 wireshark能...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/Capture/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Wireshark.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Wireshark"}],["meta",{"property":"og:description","content":"Wireshark 目录 [toc] 工具 介绍 wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。 使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。 为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。 抓包协议 wireshark能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Wireshark\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":8.78,"words":2634},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络工具/Capture/软件工具/Wireshark.md","excerpt":"\\n<h1>目录</h1>\\n<p>[toc]</p>\\n<h1>工具</h1>\\n<h2>介绍</h2>\\n<blockquote>\\n<p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。</p>\\n<p>使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。</p>\\n<p>为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p>\\n</blockquote>\\n<h2>抓包协议</h2>\\n<blockquote>\\n<p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容</p>\\n<p>如果是处理HTTP,HTTPS 还是用Fiddler</p>\\n<p>其他协议比如TCP,UDP 就用wireshark</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络工具/Capture/软件工具/Wireshark.md","value":{"title":"Wireshark","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络工具/Capture/软件工具/Wireshark.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{B as comp,E as data};
