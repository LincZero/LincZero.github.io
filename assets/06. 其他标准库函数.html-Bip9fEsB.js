import{_ as i,c as e,e as t,o as s}from"./app-_6RECMRt.js";const n={};function a(d,l){return s(),e("div",null,l[0]||(l[0]=[t(`<h1 id="多线程-其他标准库函数" tabindex="-1"><a class="header-anchor" href="#多线程-其他标准库函数"><span>多线程 - 其他标准库函数</span></a></h1><h2 id="【总结】前面用到过的标准库函数" tabindex="-1"><a class="header-anchor" href="#【总结】前面用到过的标准库函数"><span>【总结】前面用到过的标准库函数</span></a></h2><h3 id="创建对象类" tabindex="-1"><a class="header-anchor" href="#创建对象类"><span>创建对象类</span></a></h3><ul><li><code>std::thread mythread(mythreadfn);</code>，创建线程类对象 <ul><li>参数 <ul><li>入口函数</li><li>其他要传递给入口函数的变量</li></ul></li><li>成员函数 <ul><li>join()</li><li>detach()</li><li>joinable()</li></ul></li></ul></li><li><code>std::mutex mymutex;</code>，创建互斥量对象</li><li><code>std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex);</code>，创建智能互斥量对象 <ul><li>参数 <ul><li>互斥量对象</li><li>std::adopt_lock，第二参数，标志不需要再lock</li></ul></li></ul></li><li><code>std::unique_lock&lt;std::mutex&gt; sbguard(my_mutex);</code>，创建智能互斥量对象 <ul><li>参数 <ul><li>互斥量对象</li><li>std::adopt_lock，第二参数，标志不需要再lock</li><li>std::try_to_lock，第二参数，尝试去lock()，若没有锁定成功则立即返回，而不会阻塞</li><li>std::defer_lock，第二参数，初始化一个没有加锁的mutex</li></ul></li><li>成员函数 <ul><li>lock()，加锁，和互斥量用法一样</li><li>unlock()，解锁，和互斥量用法一样</li><li>try_lock()，尝试给互斥量加锁，如果拿不到锁则返回false，否则返回true。不阻塞</li><li>release()，返回它管理的mutext对象指针，并释放所有权</li></ul></li></ul></li></ul><h3 id="其他操作类" tabindex="-1"><a class="header-anchor" href="#其他操作类"><span>其他操作类</span></a></h3><ul><li><p><code>std::this_thread::get_id();</code>，获取线程id</p></li><li><p><code>std::call_once()</code>，保证某个函数只被调用一次</p></li><li><p><code>std::ref()</code>，用于多线程中对象的引用传递</p></li><li><p><code>std::move()</code>，用于多线程中智能指针的所有权转移</p></li><li><p>休眠操作</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::chrono::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">milliseconds</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dura</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">			// 【20s】</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">this_thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep_for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(dura);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">				// 【休息20s】</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="std" tabindex="-1"><a class="header-anchor" href="#std"><span>std::</span></a></h2>`,7)]))}const h=i(n,[["render",a],["__file","06. 其他标准库函数.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/06.%20%E5%85%B6%E4%BB%96%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0.html","title":"多线程 - 其他标准库函数","lang":"zh-CN","frontmatter":{"description":"多线程 - 其他标准库函数 【总结】前面用到过的标准库函数 创建对象类 std::thread mythread(mythreadfn);，创建线程类对象 参数 入口函数 其他要传递给入口函数的变量 成员函数 join() detach() joinable() std::mutex mymutex;，创建互斥量对象 std::lock_guard<s...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/06.%20%E5%85%B6%E4%BB%96%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"多线程 - 其他标准库函数"}],["meta",{"property":"og:description","content":"多线程 - 其他标准库函数 【总结】前面用到过的标准库函数 创建对象类 std::thread mythread(mythreadfn);，创建线程类对象 参数 入口函数 其他要传递给入口函数的变量 成员函数 join() detach() joinable() std::mutex mymutex;，创建互斥量对象 std::lock_guard<s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多线程 - 其他标准库函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"多线程 - 其他标准库函数","slug":"多线程-其他标准库函数","link":"#多线程-其他标准库函数","children":[{"level":2,"title":"【总结】前面用到过的标准库函数","slug":"【总结】前面用到过的标准库函数","link":"#【总结】前面用到过的标准库函数","children":[{"level":3,"title":"创建对象类","slug":"创建对象类","link":"#创建对象类","children":[]},{"level":3,"title":"其他操作类","slug":"其他操作类","link":"#其他操作类","children":[]}]},{"level":2,"title":"std::","slug":"std","link":"#std","children":[]}]}],"git":{},"readingTime":{"minutes":1.14,"words":341},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/多线程/06. 其他标准库函数.md","excerpt":"\\n<h2>【总结】前面用到过的标准库函数</h2>\\n<h3>创建对象类</h3>\\n<ul>\\n<li><code>std::thread mythread(mythreadfn);</code>，创建线程类对象\\n<ul>\\n<li>参数\\n<ul>\\n<li>入口函数</li>\\n<li>其他要传递给入口函数的变量</li>\\n</ul>\\n</li>\\n<li>成员函数\\n<ul>\\n<li>join()</li>\\n<li>detach()</li>\\n<li>joinable()</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><code>std::mutex mymutex;</code>，创建互斥量对象</li>\\n<li><code>std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex);</code>，创建智能互斥量对象\\n<ul>\\n<li>参数\\n<ul>\\n<li>互斥量对象</li>\\n<li>std::adopt_lock，第二参数，标志不需要再lock</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><code>std::unique_lock&lt;std::mutex&gt; sbguard(my_mutex);</code>，创建智能互斥量对象\\n<ul>\\n<li>参数\\n<ul>\\n<li>互斥量对象</li>\\n<li>std::adopt_lock，第二参数，标志不需要再lock</li>\\n<li>std::try_to_lock，第二参数，尝试去lock()，若没有锁定成功则立即返回，而不会阻塞</li>\\n<li>std::defer_lock，第二参数，初始化一个没有加锁的mutex</li>\\n</ul>\\n</li>\\n<li>成员函数\\n<ul>\\n<li>lock()，加锁，和互斥量用法一样</li>\\n<li>unlock()，解锁，和互斥量用法一样</li>\\n<li>try_lock()，尝试给互斥量加锁，如果拿不到锁则返回false，否则返回true。不阻塞</li>\\n<li>release()，返回它管理的mutext对象指针，并释放所有权</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/多线程/06. 其他标准库函数.md","value":{"title":"06. 其他标准库函数","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/多线程/06. 其他标准库函数.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{h as comp,c as data};
