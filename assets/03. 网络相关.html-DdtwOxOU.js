import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as r,c as p,b as e,e as l,d as t,a as i}from"./app-CyJMR3JQ.js";const c={},d=i(`<h1 id="面试八股文" tabindex="-1"><a class="header-anchor" href="#面试八股文"><span>面试八股文</span></a></h1><h2 id="网络相关面试题" tabindex="-1"><a class="header-anchor" href="#网络相关面试题"><span>网络相关面试题</span></a></h2><p>更详细的见 Network 相关笔记，特别是 多路服用技术 的那个笔记，写得比较详细和底层</p><h3 id="tcp和udp区别" tabindex="-1"><a class="header-anchor" href="#tcp和udp区别"><span>tcp和udp区别</span></a></h3><ul><li>相同点 <ul><li>L4传输层协议</li></ul></li><li>可靠</li><li>传输效率</li><li>应用场景</li></ul><table><thead><tr><th></th><th>tcp</th><th>udp</th></tr></thead><tbody><tr><td>面向连接</td><td>面向连接<br>三次握手建立连接，四次挥手断开连接，端对端连接<br>全双工</td><td>面向无连接<br>无需握手挥手，可任意连接<br>(不算，但应用层可以实现)</td></tr><tr><td>数据传输方式</td><td>基于字节流<br>发送时可能分段和分片 (MTU、MSS的作用)<br>接收时需要处理黏包问题</td><td>基于报文<br>每次收发都是完整报文<br>_</td></tr><tr><td>是否可靠</td><td>可靠。依靠机制：<br>- 分段：来保证大小<br>- 序列号：保证排序、防止丢失和重传<br>- 确认应答机制：对端需要ACK确认防止丢失<br>- 校验和：防止篡改和误码<br>- 滑动窗口 (拥塞窗口)：实现流量控制，防止包丢失<br>- 拥塞控制<br>- 重传机制</td><td>不可靠。因为无：<br>- 不保证：是否到达<br>- 不保证：顺序<br>- 不保证：无误码检测<br>- 不进行：拥堵控制<br>-<br>-<br>-</td></tr><tr><td>效率</td><td>低<br>主要是可靠性造成性能损失，头部信息更大(20)</td><td>高<br>主要是不保证可靠，头部信息更少(8)</td></tr><tr><td>应用场景</td><td>准确、速度要求不高</td><td>不准确、速度要求快<br>适合流媒体、实时要求高</td></tr></tbody></table><p>补充：</p><ul><li>MTU（最大传输单元），常见的MTU大小为1500字节（以太网）</li><li>MSS（最大段大小）</li></ul><p>题：</p><ul><li>为什么需要序列号：为了后面我们的数据包确认</li><li>为什么三次握手好随机序列号：防止历史连接干扰当前连接建立</li></ul><h3 id="linux系统如何收发网络数据包" tabindex="-1"><a class="header-anchor" href="#linux系统如何收发网络数据包"><span>linux系统如何收发网络数据包</span></a></h3><h4 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h4><ul><li>tcp/ip <ul><li>应用层、传输层、网络层、网络接口层</li></ul></li><li>网络协议栈 <ul><li>用户态 <ul><li>应用程序</li></ul></li><li>内核态 <ul><li>系统调用</li><li>socket</li><li>L4: tcp、udp</li><li>L3: ip</li><li>L2: mac</li><li>网卡驱动程序</li></ul></li><li>硬件 <ul><li>网卡</li></ul></li></ul></li><li>数据包的形态 <ul><li>应用程序：data</li><li>tcp：segment 片段</li><li>ip：packet 包</li><li>mac：frame 帧</li><li>协议栈：sk_buf</li></ul></li></ul><h4 id="发送网络数据包流程" tabindex="-1"><a class="header-anchor" href="#发送网络数据包流程"><span>发送网络数据包流程</span></a></h4><ul><li>tcp <ul><li>send/write</li><li>(1) 系统调用，sk_buff、socket发送缓冲区。ack</li><li>(2) 克隆一个新的sk_buff。网卡发出后，删除</li><li>(3) 依次增加 tcp/udp、ip、mac帧的帧头帧尾</li><li>(4) 触发软中断：网卡驱动程序，把sk_buff写到DMA内存区域</li><li>(5) 触发网卡发送数据，如果发送成功，<strong>内核ringBuffer</strong> 里面的数据和sk_buff…………</li><li>(6) 如果收到对端ack，释放原始的sk_buff</li></ul></li><li>udp <ul><li>sendto</li><li>(1) 没有发送缓冲区</li><li>(2) 不会发生克隆</li><li>(5) 清除原始的sk_buff</li><li>(6) 没有</li></ul></li></ul><h4 id="接收网络数据包流程" tabindex="-1"><a class="header-anchor" href="#接收网络数据包流程"><span>接收网络数据包流程</span></a></h4><ul><li>tcp <ul><li>recv/read</li><li>(1) 网卡收到数据包，DMA 与 <strong>内核ringBuffer</strong></li><li>(2) 硬件中断，cpu屏蔽硬件中断，发起软中断</li><li>(3) ringbuffer，逐个取出数据帧</li><li>……</li><li>(4) 写到socket的接收缓冲区</li><li>(5) 处理所有数据包后，打开硬件中断</li></ul></li><li>udp <ul><li>recvfrom</li></ul></li></ul><h3 id="水平触发和边缘触发" tabindex="-1"><a class="header-anchor" href="#水平触发和边缘触发"><span>水平触发和边缘触发</span></a></h3><h2 id="深入tcp" tabindex="-1"><a class="header-anchor" href="#深入tcp"><span>深入TCP</span></a></h2><h3 id="tcp如何保证可靠性" tabindex="-1"><a class="header-anchor" href="#tcp如何保证可靠性"><span>tcp如何保证可靠性</span></a></h3><ol><li>重传机制 <ul><li>用处：解决数据丢失问题</li><li>如何检测：用序列号和确定应答ACK检测</li><li>如何重传： <ul><li>超时重传 (一定时间没收到就重传)</li><li>快速重传 (超时之前收到三个相同的数据包确定，直接重传丢失的数据)</li></ul></li><li>选择重传： <ul><li>SACK：根据TCP头选项中的SACK告诉缺了什么，可以只重传丢失的数据</li><li>DSACK：把重复的sack告诉发送方，解决：数据包丢失、和ack丢失 (ACK包不会重传)、网络超时</li></ul></li></ul></li><li>滑动窗口 <ul><li>解决：无需为数据包应答</li><li>窗口：没有应答的情况下，发送方可以发送多少数据</li><li>滑动：收到确认包，移动</li><li>发送滑动窗口和接收滑动窗口，三次握手时就约定了，TCP头部会有一个 ”窗口大小“ 的字段</li></ul></li><li>流量控制 <ul><li>解决通过接收方的处理能力来限制发送放的数据量，避免产生丢包</li><li>怎么控制：先收缩窗口，再缩小缓冲区</li></ul></li><li>拥塞机制 <ul><li>拥塞窗口</li><li>拥塞发生</li></ul></li></ol><h3 id="mtu、mss" tabindex="-1"><a class="header-anchor" href="#mtu、mss"><span>MTU、MSS</span></a></h3><ul><li>MTU（最大传输单元），常见的MTU大小为1500字节（以太网）</li><li>MSS（最大段大小）</li></ul><h3 id="tcp三次握手的过程" tabindex="-1"><a class="header-anchor" href="#tcp三次握手的过程"><span>tcp三次握手的过程</span></a></h3><p>参考：其他</p><h4 id="四次握手" tabindex="-1"><a class="header-anchor" href="#四次握手"><span>四次握手</span></a></h4><p>（不用，改良成三次握手更好）</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">sequenceDiagram</span>
    C<span class="token arrow operator">-&gt;&gt;</span>S<span class="token operator">:</span> SYN=1, seq=x
    S<span class="token arrow operator">--&gt;&gt;</span>C<span class="token operator">:</span> ACK=1, ack=x+1
    S<span class="token arrow operator">--&gt;&gt;</span>C<span class="token operator">:</span> SYN=1, seq=y
    C<span class="token arrow operator">-&gt;&gt;</span>S<span class="token operator">:</span> ACK=1, seq=x+1, ack=y+1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手"><span>三次握手</span></a></h4><p>（合并第二、三次）</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">sequenceDiagram</span>
    C<span class="token arrow operator">-&gt;&gt;</span>S<span class="token operator">:</span> SYN=1, seq=x
    S<span class="token arrow operator">--&gt;&gt;</span>C<span class="token operator">:</span> SYN=1, ACK=1, seq=y, ack=x+1
    C<span class="token arrow operator">-&gt;&gt;</span>S<span class="token operator">:</span> ACK=1, seq=x+1, ack=y+1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="为什么合并更好" tabindex="-1"><a class="header-anchor" href="#为什么合并更好"><span>为什么合并更好</span></a></h5><p>第二、三次握手，原则上<strong>可以分开</strong>也可以合并，一般合并，分开的话就是”四次握手“。只是一般完全没有分开的必要性，分开有害无利。</p><h4 id="补充" tabindex="-1"><a class="header-anchor" href="#补充"><span>补充</span></a></h4><p>注意握手使用随机序列号：防止历史连接干扰当前连接建立</p><p>术语</p><ul><li><p>三次握手的包类型（在wireshark中，我们可以明确看到这三种类型）</p><ul><li><p>SYN：此时进入半连接状态</p></li><li><p>SYN, ACK：看作是两个报文简化合并成了一个报文</p></li><li><p>ACK</p></li></ul></li><li><p>缩写翻译</p><ul><li><p>SYN (Synchronize, 使同步)，表示想要和对方建立连接</p></li><li><p>ACK (Acknowledgment, 确认接收)，表示愿意与对方建立连接/断开连接</p></li><li><p>FIN (Finish, 结束)，表示想要和对方断开连接</p></li><li><p>seq (Sequence Number, 序列号)，标识 TCP 数据包中的每个字节的顺序</p></li><li><p>ack (Acknowledgment Number, 确认号)，用于确认已成功接收到的数据，且指定了期望收到的<strong>下一个</strong>序列号</p></li></ul></li><li><p>自主思考</p><ul><li><p>四次握手可以合并简化，三次握手还能简化吗？不行，缺一个都会造成问题</p><p>（下一代TCP的<strong>QUIC</strong>也只是将TCP握手后的一些TLS等放在了前三次来完成，虽然精简了一些建立连接的报文数量，但三次也没有缺少掉）</p></li></ul></li></ul><h3 id="tcp四次挥手的过程" tabindex="-1"><a class="header-anchor" href="#tcp四次挥手的过程"><span>tcp四次挥手的过程</span></a></h3><p>参考：其他</p><h4 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手"><span>四次挥手</span></a></h4><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">sequenceDiagram</span>
    C<span class="token arrow operator">-&gt;&gt;</span>S<span class="token operator">:</span> FIN=1, seq=x
    S<span class="token arrow operator">--&gt;&gt;</span>C<span class="token operator">:</span> ACK=1, ack=x+1
    S<span class="token arrow operator">--&gt;&gt;</span>C<span class="token operator">:</span> FIN=1, seq=y
    C<span class="token arrow operator">-&gt;&gt;</span>S<span class="token operator">:</span> ACK=1, ack=y+1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="三次挥手" tabindex="-1"><a class="header-anchor" href="#三次挥手"><span>三次挥手</span></a></h4><h5 id="一般不可合并" tabindex="-1"><a class="header-anchor" href="#一般不可合并"><span>一般不可合并</span></a></h5>`,43),o={href:"https://www.bilibili.com/video/BV1dg411d74z",target:"_blank",rel:"noopener noreferrer"},h=i('<ul><li>连接握手需要确定两个东西：C想连接而S接受连接，S也想连接而C接受连接</li><li>断开挥手前面的东西也需要确定：S-&gt;C的两次报文的回复时间可能不同，为了避免TCP请求超时，拆开会更好 <ul><li>第一次挥手： <ul><li>C不打算发东西了，也不打算继续连接。C发完后进入 FIN_WAIT_1 状态</li></ul></li><li>第二次挥手： <ul><li>S进入CLOSE_WAIT状态，知道对方不发东西了</li><li>C进入FIN_WAIT_2状态，此时</li></ul></li><li>第三次挥手： <ul><li>S进入LAST_ACK状态</li><li>C进入TIME_WAIT状态</li></ul></li><li>第四次挥手： <ul><li>S进入CLOSE状态</li><li>C进入CLOSE状态 (经过一段时间后)</li></ul></li></ul></li></ul><h5 id="特殊情况可合并" tabindex="-1"><a class="header-anchor" href="#特殊情况可合并"><span>特殊情况可合并</span></a></h5>',2),u=e("strong",null,"在特定情况下，四次挥手是可以变成三次挥手的",-1),g={href:"https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html",target:"_blank",rel:"noopener noreferrer"},m=i('<p>在用 wireshark 工具抓包的时候，我们也会常看到 TCP 挥手过程是三次，而不是四次</p><h3 id="tcp的半关闭、半连接、半打开" tabindex="-1"><a class="header-anchor" href="#tcp的半关闭、半连接、半打开"><span>TCP的半关闭、半连接、半打开</span></a></h3><p>参考：https://blog.csdn.net/code_peak/article/details/118656287</p><h4 id="tcp-半关闭" tabindex="-1"><a class="header-anchor" href="#tcp-半关闭"><span>TCP 半关闭</span></a></h4><p>半关闭通常发生在TCP断开的四次挥手中</p><p>概念：</p><p>假设在时刻8的时候，发出一个关闭请求，我们并不能立即关闭连接，因为管道中还有其他的请求和应答，这时如果程序直接从 main 结束，并不意味着同时完成了从套接字的读入，可能有请求在去往服务器的路上，或者仍然有应答在返回客户的路上。</p><p><strong>我们需要一种关闭 TCP 连接其中一半的方法</strong>。也就是说，要给服务器发送一个 FIN，告诉服务器已经完成了数据发送，但仍然保持套接字打开以便读取，这将由 <code>shutdown</code> 函数完成。</p><h5 id="shutdown-函数" tabindex="-1"><a class="header-anchor" href="#shutdown-函数"><span>shutdown 函数</span></a></h5><p>终止网络连接的通常方法是调用 close 函数。但是 close 函数有两个限制，却可以使用 shutdown 函数来避免：</p><ul><li>close 把描述符的引用计数减一，仅在该计数变为0时才关闭套接字。但是使用 shutdown 中可以不管引用计数就激发 TCP 的正常连接终止序列。</li><li>close 终止读和写两个方向的数据传送。既然 TCP 连接是全双工的，有时候我们需要告知对端我们已经完成了数据发送，即使对端仍有数据要发送给我们。</li></ul><h4 id="tcp-半连接" tabindex="-1"><a class="header-anchor" href="#tcp-半连接"><span>TCP 半连接</span></a></h4><p>半连接通常发生在TCP建立连接的三次握手中</p><p>如果 A 向 B 发起链接，B 也按照正常情况响应了，但是 A <strong>不进行三次握手</strong>，这就是半连接。</p><p>半连接攻击：半连接，会造成 B 分配的内存资源就一直这么耗着，直到资源耗尽。（也被称为 <strong>SYN攻击</strong>）</p><h4 id="tcp-半打开" tabindex="-1"><a class="header-anchor" href="#tcp-半打开"><span>TCP 半打开</span></a></h4><p>如果<strong>一方关闭或者异常关闭</strong>（断电，断网），而另一方并不知情，这样的链接称之为半打开。</p><p>处于半打开的连接，如果双方不进行数据通信，是发现不了问题的，只有在通信时才真正的察觉到这个连接已经处于半打开状态。 如果双方不传输数据的话，仍处于连接状态的一方就不会检测另外一方已经出现异常</p><p>解决方法：</p><ul><li>如何解决半打开问题，引入<strong>心跳机制</strong>就可以察觉半打开。 如果需要发数据的话，这边收到之后 其实发现这个连接并不存在了，就会回复 RST 包告知，这个时候就需要重新建立连接了。</li></ul>',20);function b(k,v){const a=s("ExternalLinkIcon");return r(),p("div",null,[d,e("p",null,[l("不可合并：就是有一个常见的问题："),e("a",o,[l("为什么握手是三次，挥手却要四次？"),t(a)]),l("，原因：")]),h,e("p",null,[l("可合并：但是在"),u,l("，具体情况可以看这篇："),e("a",g,[l("TCP 四次挥手，可以变成三次吗？"),t(a)])]),m])}const _=n(c,[["render",b],["__file","03. 网络相关.html.vue"]]),E=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/10.%20%E9%9D%A2%E8%AF%95/C__%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/03.%20%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.html","title":"面试八股文","lang":"zh-CN","frontmatter":{"description":"面试八股文 网络相关面试题 更详细的见 Network 相关笔记，特别是 多路服用技术 的那个笔记，写得比较详细和底层 tcp和udp区别 相同点 L4传输层协议 可靠 传输效率 应用场景 补充： MTU（最大传输单元），常见的MTU大小为1500字节（以太网） MSS（最大段大小） 题： 为什么需要序列号：为了后面我们的数据包确认 为什么三次握手好随...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/10.%20%E9%9D%A2%E8%AF%95/C__%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/03.%20%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"面试八股文"}],["meta",{"property":"og:description","content":"面试八股文 网络相关面试题 更详细的见 Network 相关笔记，特别是 多路服用技术 的那个笔记，写得比较详细和底层 tcp和udp区别 相同点 L4传输层协议 可靠 传输效率 应用场景 补充： MTU（最大传输单元），常见的MTU大小为1500字节（以太网） MSS（最大段大小） 题： 为什么需要序列号：为了后面我们的数据包确认 为什么三次握手好随..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试八股文\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"面试八股文","slug":"面试八股文","link":"#面试八股文","children":[{"level":2,"title":"网络相关面试题","slug":"网络相关面试题","link":"#网络相关面试题","children":[{"level":3,"title":"tcp和udp区别","slug":"tcp和udp区别","link":"#tcp和udp区别","children":[]},{"level":3,"title":"linux系统如何收发网络数据包","slug":"linux系统如何收发网络数据包","link":"#linux系统如何收发网络数据包","children":[{"level":4,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":4,"title":"发送网络数据包流程","slug":"发送网络数据包流程","link":"#发送网络数据包流程","children":[]},{"level":4,"title":"接收网络数据包流程","slug":"接收网络数据包流程","link":"#接收网络数据包流程","children":[]}]},{"level":3,"title":"水平触发和边缘触发","slug":"水平触发和边缘触发","link":"#水平触发和边缘触发","children":[]}]},{"level":2,"title":"深入TCP","slug":"深入tcp","link":"#深入tcp","children":[{"level":3,"title":"tcp如何保证可靠性","slug":"tcp如何保证可靠性","link":"#tcp如何保证可靠性","children":[]},{"level":3,"title":"MTU、MSS","slug":"mtu、mss","link":"#mtu、mss","children":[]},{"level":3,"title":"tcp三次握手的过程","slug":"tcp三次握手的过程","link":"#tcp三次握手的过程","children":[{"level":4,"title":"四次握手","slug":"四次握手","link":"#四次握手","children":[]},{"level":4,"title":"三次握手","slug":"三次握手","link":"#三次握手","children":[{"level":5,"title":"为什么合并更好","slug":"为什么合并更好","link":"#为什么合并更好","children":[]}]},{"level":4,"title":"补充","slug":"补充","link":"#补充","children":[]}]},{"level":3,"title":"tcp四次挥手的过程","slug":"tcp四次挥手的过程","link":"#tcp四次挥手的过程","children":[{"level":4,"title":"四次挥手","slug":"四次挥手","link":"#四次挥手","children":[]},{"level":4,"title":"三次挥手","slug":"三次挥手","link":"#三次挥手","children":[{"level":5,"title":"一般不可合并","slug":"一般不可合并","link":"#一般不可合并","children":[]},{"level":5,"title":"特殊情况可合并","slug":"特殊情况可合并","link":"#特殊情况可合并","children":[]}]}]},{"level":3,"title":"TCP的半关闭、半连接、半打开","slug":"tcp的半关闭、半连接、半打开","link":"#tcp的半关闭、半连接、半打开","children":[{"level":4,"title":"TCP 半关闭","slug":"tcp-半关闭","link":"#tcp-半关闭","children":[{"level":5,"title":"shutdown 函数","slug":"shutdown-函数","link":"#shutdown-函数","children":[]}]},{"level":4,"title":"TCP 半连接","slug":"tcp-半连接","link":"#tcp-半连接","children":[]},{"level":4,"title":"TCP 半打开","slug":"tcp-半打开","link":"#tcp-半打开","children":[]}]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.61,"words":2583},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/10. 面试/C++面试八股文/03. 网络相关.md","autoDesc":true}');export{_ as comp,E as data};
