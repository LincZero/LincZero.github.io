import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,a as i}from"./app-5ajJQ-aM.js";const r={},n=i('<h1 id="io控制方式" tabindex="-1"><a class="header-anchor" href="#io控制方式"><span>IO控制方式</span></a></h1><h2 id="提前总结" tabindex="-1"><a class="header-anchor" href="#提前总结"><span>提前总结</span></a></h2><h3 id="三种io控制方式" tabindex="-1"><a class="header-anchor" href="#三种io控制方式"><span>三种IO控制方式</span></a></h3><p>三种方式：</p><ul><li><p>轮询等待</p><ul><li>原理：<strong>让CPU一直查</strong>寄存器状态</li><li>缺点：占CPU全部时间，效率低</li></ul></li><li><p>中断 - 硬中断</p><ul><li>原理：设备中断到<strong>硬件的中断控制器</strong>，中断控制器再<strong>通知CPU</strong>。 当中断产生后，CPU需要停下当前手里的事情来处理中断（插队式任务？）</li><li>优点：不用占着CPU</li></ul></li><li><p>中断 - 软中断</p><ul><li>原理：代码调用 <code>INT</code> 指令触发</li><li>优点：(同)</li></ul></li><li><p>直接内存访问 (DMA, Direct Memory Access)</p><ul><li>原理：需要有 「DMA 控制器」硬件的支持，将硬件到内存这一过程交给DMA，减少打断CPU和对CPU的使用次数。</li><li>优点：硬件到内存这一过程，无需 CPU 参与</li><li>结合中断使用：不互斥，结合中断使用。或者应该说，只是在前面中断的基础上，新增了直接内存访问个过程</li></ul></li></ul><h2 id="两种通知cpu的方式" tabindex="-1"><a class="header-anchor" href="#两种通知cpu的方式"><span>两种通知CPU的方式</span></a></h2><p>在前面我知道，每种设备都有一个设备控制器，控制器相当于一个小 CPU，它可以自己处理一些事情，但有个问题是，当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，它读完的时候，要怎么通知 CPU 呢？</p><h3 id="_1-轮询等待" tabindex="-1"><a class="header-anchor" href="#_1-轮询等待"><span>(1) 轮询等待</span></a></h3><p>控制器的寄存器一般会有状态标记位，用来标识输入或输出操作是否完成。于是，我们想到第一种<strong>轮询等待</strong>的方法，让 CPU 一直查寄存器的状态，直到状态标记为完成，很明显，这种方式非常的傻瓜，它会占用 CPU 的全部时间。</p><h3 id="_2-中断" tabindex="-1"><a class="header-anchor" href="#_2-中断"><span>(2) 中断</span></a></h3><p>那我们就想到第二种方法 —— <strong>中断</strong>，通知操作系统数据已经准备好了。我们一般会有一个硬件的<strong>中断控制器</strong>，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断。</p><p>另外，中断有两种，一种<strong>软中断</strong>，例如代码调用 <code>INT</code> 指令触发，一种是<strong>硬件中断</strong>，就是硬件通过中断控制器触发的。</p><h2 id="_3-直接内存访问-dma-direct-memory-access" tabindex="-1"><a class="header-anchor" href="#_3-直接内存访问-dma-direct-memory-access"><span>(3) 直接内存访问 (<em>DMA, Direct Memory Access</em>)</span></a></h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><p>但中断的方式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占用 CPU 大量的时间。</p><p>对于这一类设备的问题的解决方法是使用 <strong>DMA（<em>Direct Memory Access</em>）</strong> 功能，它可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I/O 数据放入到内存。那要实现 DMA 功能要有 「DMA 控制器」硬件的支持。</p><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>![img](02.%20IO 控制方式.assets/DMA工作原理.png)</p><p>DMA 的工作方式如下：（序号和上图的序号一一对应。这个过程也用到了中断，是中断的基础上增加了 DMA 来处理磁盘到内存的拷贝）</p><ol><li>CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；</li><li>接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到其内部的缓冲区中；</li><li>接着磁盘控制器将缓冲区的数据传输到内存；</li><li>当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器；</li><li>DMA 控制器收到信号后，DMA 控制器发<strong>中断</strong>通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；</li></ol><p>可以看到， CPU 当要读取磁盘数据的时候，只需给 DMA 控制器发送指令，然后返回去做其他事情，当磁盘数据拷贝到内存后，DMA 控制机器通过中断的方式，告诉 CPU 数据已经准备好了，可以从内存读数据了。仅仅在传送开始和结束时需要 CPU 干预。</p>',21),a=[n];function o(s,c){return t(),l("div",null,a)}const h=e(r,[["render",o],["__file","02. IO 控制方式.html.vue"]]),d=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/08.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/02.%20IO%20%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.html","title":"IO控制方式","lang":"zh-CN","frontmatter":{"description":"IO控制方式 提前总结 三种IO控制方式 三种方式： 轮询等待 原理：让CPU一直查寄存器状态 缺点：占CPU全部时间，效率低 中断 - 硬中断 原理：设备中断到硬件的中断控制器，中断控制器再通知CPU。 当中断产生后，CPU需要停下当前手里的事情来处理中断（插队式任务？） 优点：不用占着CPU 中断 - 软中断 原理：代码调用 INT 指令触发 优点...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/08.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/02.%20IO%20%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"IO控制方式"}],["meta",{"property":"og:description","content":"IO控制方式 提前总结 三种IO控制方式 三种方式： 轮询等待 原理：让CPU一直查寄存器状态 缺点：占CPU全部时间，效率低 中断 - 硬中断 原理：设备中断到硬件的中断控制器，中断控制器再通知CPU。 当中断产生后，CPU需要停下当前手里的事情来处理中断（插队式任务？） 优点：不用占着CPU 中断 - 软中断 原理：代码调用 INT 指令触发 优点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"IO控制方式\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"IO控制方式","slug":"io控制方式","link":"#io控制方式","children":[{"level":2,"title":"提前总结","slug":"提前总结","link":"#提前总结","children":[{"level":3,"title":"三种IO控制方式","slug":"三种io控制方式","link":"#三种io控制方式","children":[]}]},{"level":2,"title":"两种通知CPU的方式","slug":"两种通知cpu的方式","link":"#两种通知cpu的方式","children":[{"level":3,"title":"(1) 轮询等待","slug":"_1-轮询等待","link":"#_1-轮询等待","children":[]},{"level":3,"title":"(2) 中断","slug":"_2-中断","link":"#_2-中断","children":[]}]},{"level":2,"title":"(3) 直接内存访问 (DMA, Direct Memory Access)","slug":"_3-直接内存访问-dma-direct-memory-access","link":"#_3-直接内存访问-dma-direct-memory-access","children":[{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.47,"words":1041},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/08. 设备管理/02. IO 控制方式.md","autoDesc":true}');export{h as comp,d as data};
