import{_ as i,c as n,e as l,o as t}from"./app-BHdORQJ2.js";const a={};function o(d,e){return t(),n("div",null,e[0]||(e[0]=[l('<h1 id="联编" tabindex="-1"><a class="header-anchor" href="#联编"><span>联编</span></a></h1><h2 id="联编-1" tabindex="-1"><a class="header-anchor" href="#联编-1"><span>联编</span></a></h2><h3 id="函数名联编-binding" tabindex="-1"><a class="header-anchor" href="#函数名联编-binding"><span>函数名联编（<em>binding</em>）</span></a></h3><ul><li>行为 <ul><li>将源代码中的函数调用解释为执行特定的函数代码块</li></ul></li><li>实现机理 <ul><li>C：每个函数名都对应一个不同的函数，实现非常简单</li><li>C++：由于重载，实现变得复杂。但还是能在编译过程完成这种联编。但涉及到虚函数时，静态联编无法实现，需要动态联编</li></ul></li></ul><h2 id="静态联编" tabindex="-1"><a class="header-anchor" href="#静态联编"><span>静态联编</span></a></h2><p>静态联编（<em>static binding</em>），又称早期联编（<em>early binding</em>）</p><h2 id="动态联编" tabindex="-1"><a class="header-anchor" href="#动态联编"><span>动态联编</span></a></h2><p>动态联编（<em>dynamic binding</em>），又称晚期联编（<em>late binding</em>）</p><ul><li>举例 <ul><li>动态内存</li><li>虚函数/纯虚函数</li></ul></li></ul><h2 id="一些动态的操作" tabindex="-1"><a class="header-anchor" href="#一些动态的操作"><span>一些动态的操作</span></a></h2><ul><li>动态指定编程代码：函数模板的底层原理就是</li><li>动态指定变量地址：动态内存new</li><li>动态指定变量值：普通赋值，css3的calc属性</li><li>动态指定变量类型：（模板提供参数化类型）函数模板、类模板</li><li>动态指定变量名：一般是字典，key属于变量也属于变量名</li></ul>',11)]))}const c=i(a,[["render",o],["__file","03. 联编.html.vue"]]),s=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/03.%20%E8%81%94%E7%BC%96.html","title":"联编","lang":"zh-CN","frontmatter":{"description":"联编 联编 函数名联编（binding） 行为 将源代码中的函数调用解释为执行特定的函数代码块 实现机理 C：每个函数名都对应一个不同的函数，实现非常简单 C++：由于重载，实现变得复杂。但还是能在编译过程完成这种联编。但涉及到虚函数时，静态联编无法实现，需要动态联编 静态联编 静态联编（static binding），又称早期联编（early bin...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/03.%20%E8%81%94%E7%BC%96.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"联编"}],["meta",{"property":"og:description","content":"联编 联编 函数名联编（binding） 行为 将源代码中的函数调用解释为执行特定的函数代码块 实现机理 C：每个函数名都对应一个不同的函数，实现非常简单 C++：由于重载，实现变得复杂。但还是能在编译过程完成这种联编。但涉及到虚函数时，静态联编无法实现，需要动态联编 静态联编 静态联编（static binding），又称早期联编（early bin..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"联编\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"联编","slug":"联编","link":"#联编","children":[{"level":2,"title":"联编","slug":"联编-1","link":"#联编-1","children":[{"level":3,"title":"函数名联编（binding）","slug":"函数名联编-binding","link":"#函数名联编-binding","children":[]}]},{"level":2,"title":"静态联编","slug":"静态联编","link":"#静态联编","children":[]},{"level":2,"title":"动态联编","slug":"动态联编","link":"#动态联编","children":[]},{"level":2,"title":"一些动态的操作","slug":"一些动态的操作","link":"#一些动态的操作","children":[]}]}],"git":{},"readingTime":{"minutes":0.87,"words":261},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/03. 联编.md","excerpt":"\\n<h2>联编</h2>\\n<h3>函数名联编（<em>binding</em>）</h3>\\n<ul>\\n<li>行为\\n<ul>\\n<li>将源代码中的函数调用解释为执行特定的函数代码块</li>\\n</ul>\\n</li>\\n<li>实现机理\\n<ul>\\n<li>C：每个函数名都对应一个不同的函数，实现非常简单</li>\\n<li>C++：由于重载，实现变得复杂。但还是能在编译过程完成这种联编。但涉及到虚函数时，静态联编无法实现，需要动态联编</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>静态联编</h2>\\n<p>静态联编（<em>static binding</em>），又称早期联编（<em>early binding</em>）</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/03. 联编.md","value":{"title":"03. 联编","path":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/03. 联编.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{c as comp,s as data};
