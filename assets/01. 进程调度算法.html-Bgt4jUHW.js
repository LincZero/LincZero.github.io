import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as a,e as t}from"./app-D9NcyM5y.js";const i={},n=t('<h1 id="进程调度算法-重复" tabindex="-1"><a class="header-anchor" href="#进程调度算法-重复"><span>进程调度算法 (重复)</span></a></h1><p><mark>（话说在之前 “进程管理” 那章，也说过一遍了吧。这里重复了）</mark></p><p>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。</p><p>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</p><h2 id="发生场景" tabindex="-1"><a class="header-anchor" href="#发生场景"><span>发生场景</span></a></h2><p>什么时候会发生 CPU 调度呢？通常有以下情况：</p><ol><li>当进程从运行状态转到等待状态；</li><li>当进程从运行状态转到就绪状态；</li><li>当进程从等待状态转到就绪状态；</li><li>当进程从运行状态转到终止状态；</li></ol><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h2><p>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。</p><p>非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</p><p>而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</p><p>你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态，一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。</p><p>那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。</p><h2 id="进程调度算法" tabindex="-1"><a class="header-anchor" href="#进程调度算法"><span>进程调度算法</span></a></h2><p>调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程真在使用 CPU 的时间和 I/O 时间。</p><p>接下来，说说常见的调度算法：</p><ul><li>先来先服务调度算法</li><li>最短作业优先调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h3 id="先来先服务调度算法" tabindex="-1"><a class="header-anchor" href="#先来先服务调度算法"><span>先来先服务调度算法</span></a></h3><h3 id="先来先服务调度算法-1" tabindex="-1"><a class="header-anchor" href="#先来先服务调度算法-1"><span>先来先服务调度算法</span></a></h3><h3 id="最短作业优先调度算法" tabindex="-1"><a class="header-anchor" href="#最短作业优先调度算法"><span>最短作业优先调度算法</span></a></h3><h3 id="高响应比优先调度算法" tabindex="-1"><a class="header-anchor" href="#高响应比优先调度算法"><span>高响应比优先调度算法</span></a></h3><h3 id="时间片轮转调度算法" tabindex="-1"><a class="header-anchor" href="#时间片轮转调度算法"><span>时间片轮转调度算法</span></a></h3><h3 id="最高优先级调度算法" tabindex="-1"><a class="header-anchor" href="#最高优先级调度算法"><span>最高优先级调度算法</span></a></h3><h3 id="多级反馈队列调度算法" tabindex="-1"><a class="header-anchor" href="#多级反馈队列调度算法"><span>多级反馈队列调度算法</span></a></h3>',24),E=[n];function r(h,o){return l(),a("div",null,E)}const c=e(i,[["render",r],["__file","01. 进程调度算法.html.vue"]]),B=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/06.%20%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/01.%20%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html","title":"进程调度算法 (重复)","lang":"zh-CN","frontmatter":{"description":"进程调度算法 (重复) （话说在之前 “进程管理” 那章，也说过一遍了吧。这里重复了） 进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。 当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。 发生场景 什么时候会发生 CPU 调度呢？通常有以下情况： 当进程从运行状态转到等待状态； 当进程从运行状态转...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/06.%20%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/01.%20%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"进程调度算法 (重复)"}],["meta",{"property":"og:description","content":"进程调度算法 (重复) （话说在之前 “进程管理” 那章，也说过一遍了吧。这里重复了） 进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。 当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。 发生场景 什么时候会发生 CPU 调度呢？通常有以下情况： 当进程从运行状态转到等待状态； 当进程从运行状态转..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进程调度算法 (重复)\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"进程调度算法 (重复)","slug":"进程调度算法-重复","link":"#进程调度算法-重复","children":[{"level":2,"title":"发生场景","slug":"发生场景","link":"#发生场景","children":[]},{"level":2,"title":"分类","slug":"分类","link":"#分类","children":[]},{"level":2,"title":"进程调度算法","slug":"进程调度算法","link":"#进程调度算法","children":[{"level":3,"title":"先来先服务调度算法","slug":"先来先服务调度算法","link":"#先来先服务调度算法","children":[]},{"level":3,"title":"先来先服务调度算法","slug":"先来先服务调度算法-1","link":"#先来先服务调度算法-1","children":[]},{"level":3,"title":"最短作业优先调度算法","slug":"最短作业优先调度算法","link":"#最短作业优先调度算法","children":[]},{"level":3,"title":"高响应比优先调度算法","slug":"高响应比优先调度算法","link":"#高响应比优先调度算法","children":[]},{"level":3,"title":"时间片轮转调度算法","slug":"时间片轮转调度算法","link":"#时间片轮转调度算法","children":[]},{"level":3,"title":"最高优先级调度算法","slug":"最高优先级调度算法","link":"#最高优先级调度算法","children":[]},{"level":3,"title":"多级反馈队列调度算法","slug":"多级反馈队列调度算法","link":"#多级反馈队列调度算法","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.32,"words":695},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/01. 进程调度算法.md","autoDesc":true}');export{c as comp,B as data};
