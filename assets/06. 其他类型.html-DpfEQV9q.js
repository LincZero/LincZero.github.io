import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as n,a as t}from"./app-Dtl9Pch1.js";const a={},i=t(`<h1 id="_06-其他类型" tabindex="-1"><a class="header-anchor" href="#_06-其他类型"><span>06. 其他类型</span></a></h1><h2 id="复合类型-类型模板类-共用体-union" tabindex="-1"><a class="header-anchor" href="#复合类型-类型模板类-共用体-union"><span><strong>复合类型</strong> &gt; 类型模板类 &gt; 共用体 union</span></a></h2><h3 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h3><ul><li><p>说明：能存储不同的数据类型，但只能同时存储其中的一种类型</p></li><li><p>共用体与结构的区别：语法相似但含义不同</p><p>比方说，前者可以同时存储int、long、double，后者只能存储int、long、double中的其中一种</p></li><li><p>注意项：需要有足够的空间来存储最大的成员</p></li><li><p><strong>使用场景</strong>：当数据项使用两种或更多格式（但不会同时使用）时，<strong>可节省空间</strong></p></li></ul><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><blockquote><h4 id="字面量方式" tabindex="-1"><a class="header-anchor" href="#字面量方式"><span>字面量方式</span></a></h4></blockquote><ul><li><p><strong>类型定义</strong>：例<code>union one4all{int i_val; long l_val; double d_val;}</code></p></li><li><p><strong>类型定义 - 匿名共用体</strong>：没有名称，成员将成为位于相同地址处的变量（每次只有一个成员是当前成员）</p><p>例<code>struct widget{union{ long l_val; char arc_val[20]; }};</code> <code>widget prize.l_val = 12;</code></p></li><li><p><strong>声明</strong>：例<code>one4all pail</code></p></li><li><p><strong>赋值</strong>：例<code>pail.i_val = 26</code>，<code>pail.d_val = 1.38</code>会覆盖前一个</p></li></ul><h2 id="复合类型-类型模板类-枚举-enum" tabindex="-1"><a class="header-anchor" href="#复合类型-类型模板类-枚举-enum"><span><strong>复合类型</strong> &gt; 类型模板类 &gt; 枚举 enum</span></a></h2><h3 id="简概-1" tabindex="-1"><a class="header-anchor" href="#简概-1"><span>简概</span></a></h3><ul><li>作用：创建符号常量，可以代替const，</li><li>使用上：与结构体相似</li><li>运算：没有未枚举定义算术运算，不能进行此类操作</li><li><strong>使用场景</strong>：可以配合switch-case使用，或者使用匿名枚举创建符号常量</li><li>技巧：匿名枚举 <ul><li>与结构体不同的是，可以将枚举的使用拆成两部分：定义符号常量（枚举量）和定义枚举变量，而后者并不是必须的</li></ul></li></ul><h3 id="使用-1" tabindex="-1"><a class="header-anchor" href="#使用-1"><span>使用</span></a></h3><h4 id="字面量方式-1" tabindex="-1"><a class="header-anchor" href="#字面量方式-1"><span>字面量方式</span></a></h4><ul><li><p><strong>类型定义</strong>：例<code>enum spectrum {red, orange, yellow}</code></p><ul><li><p>枚举量：其中red、orange、yellow等作为符号常量，对应整数值0~2，这些常量叫作<code>枚举量</code></p></li><li><p>枚举量的值：可以设置枚举的值，如<code>enum bits {one=1, two=2, four=4, eight=8}</code></p><p>枚举量的值可以相同，如<code>enum {zero, null=0}</code></p></li><li><p><strong>匿名枚举</strong>：如果只打算使用常量而不创建枚举类型的变量，则可以省略枚举类型的名称</p></li></ul></li><li><p><strong>声明</strong>：例<code>spectrum band;</code></p></li><li><p><strong>赋值</strong>：只能将定义枚举时使用的枚举量赋值给这种枚举的变量，如<code>band = red</code>，否则不合法</p></li></ul><h4 id="内置函数方法" tabindex="-1"><a class="header-anchor" href="#内置函数方法"><span>内置函数方法</span></a></h4><ul><li><strong>类型转换</strong>：枚举量可以被提升为int类型，被转换为序列量，但反之不行，除非使用强制类型转换<code>band = spectrum(2)</code></li></ul><h4 id="【缺陷补丁】作用域内枚举-c-11" tabindex="-1"><a class="header-anchor" href="#【缺陷补丁】作用域内枚举-c-11"><span>【缺陷补丁】作用域内枚举（C++11）</span></a></h4><ul><li>问题 <ul><li>两个枚举定义的枚举量可能发生冲突</li><li>例如：<code>enum egg {Samll, Medium, Large, Jumbo};</code> <code>enum t_shirt {Small, Medium, Large, Xlarge};</code></li><li>这将无法通过编译</li></ul></li><li>解决 <ul><li>C++11提供了一种新枚举，其枚举作用域为类</li></ul></li><li>使用 <ul><li>enum后加上关键字<code>class</code></li><li>定义：<code>enum class egg {Samll, Medium, Large, Jumbo};</code></li><li>调用：<code>egg choice = egg::Large;</code></li></ul></li><li>补充 <ul><li>C++11还提高了作用域枚举的类型安全，如不能隐式地转换为整型</li></ul></li></ul><h2 id="特殊类型-自动类型" tabindex="-1"><a class="header-anchor" href="#特殊类型-自动类型"><span><strong>特殊类型</strong> &gt; 自动类型</span></a></h2><h3 id="auto" tabindex="-1"><a class="header-anchor" href="#auto"><span>auto</span></a></h3><h3 id="decltype" tabindex="-1"><a class="header-anchor" href="#decltype"><span>decltype</span></a></h3><blockquote><h4 id="关键字decltype-c-11" tabindex="-1"><a class="header-anchor" href="#关键字decltype-c-11"><span>关键字decltype（C++11）</span></a></h4></blockquote><ul><li><p>作用</p><ul><li>decltype和auto有异曲同工之妙，均可用来自动判断类型</li></ul></li><li><p>使用</p><ul><li>通用：<code>decltype(expression) var;</code></li><li>举例：<code>decltype(x+y) xpy; xpy=x+y;</code>或者<code>decltype(x+y) xpy = x+y;</code></li></ul></li><li><p>使用场景</p><ul><li>通常与函数模板结合使用</li></ul></li><li><p>核对表：<code>decltype(expression) var;</code>中</p><ul><li><table><thead><tr><th>expression</th><th>举例</th><th>var的类型</th></tr></thead><tbody><tr><td>一个没有用括号括起的标识符</td><td></td><td>与该标识符的类型相同</td></tr><tr><td>一个函数调用</td><td></td><td>与返回值类型相同</td></tr><tr><td>一个左值且不为情况一</td><td><code>((n))</code></td><td>为指向其类型的引用</td></tr><tr><td>前面的条件都不满足</td><td>比如表达式</td><td>与expression类型相同</td></tr></tbody></table></li></ul></li></ul><blockquote><h4 id="【缺陷补丁】后置返回类型-c-新增语法" tabindex="-1"><a class="header-anchor" href="#【缺陷补丁】后置返回类型-c-新增语法"><span>【缺陷补丁】后置返回类型（C++新增语法）</span></a></h4></blockquote><ul><li><p>使用</p><ul><li><p>举例：<code>double h(int x, float y);</code>可写成<code>auto h(int x,float y)-&gt;doublw</code></p><p>其中<code>-&gt;double</code>被称为<code>后置返回类型</code>（<em>trailing return type</em>），其中auto是一个占位符用于表示后置返回类型提供的类型</p></li><li><p>话说Typescript函数的返回类型就是经典的后置返回类型，原理就不知道是不是一样的了</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// ts函数定义式，返回值写在后面，前面用\`:\`符号</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span>n1<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> n2<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// ts函数声明式，返回值也是写在后面，前面用\`=&gt;\`符号</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">i1</span><span class="token punctuation">{</span>
    <span class="token function-variable function">f2</span><span class="token operator">:</span> <span class="token punctuation">(</span>n1<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> n2<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token builtin">number</span><span class="token operator">|</span><span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>使用场景</p><ul><li>用于解决decltype本身的一个缺陷。可配合auto、decltype使用</li><li>使用decltype有一个缺陷 <ul><li>比如<code>?type? ge(T1 x, T2 y){...return x+y}</code>时无法得知返回的类型</li><li>此时不能使用<code>decltype(x+y)</code>作为返回类型，因为此时x和y未声明</li><li>于是可以把返回类型移到参数声明的后面</li></ul></li></ul></li><li><p>auto和decltype区别</p><ul><li>decltype<strong>可用于指定自定义的类型而并非完全是自动类型</strong></li><li><mark>但为什么不能用auto代替decltype？？？新增这个新的关键字有意义吗？？？</mark></li></ul></li></ul>`,24),s=[i];function o(c,p){return l(),n("div",null,s)}const u=e(a,[["render",o],["__file","06. 其他类型.html.vue"]]),h=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/02.%20%E6%95%B0%E6%8D%AE_%E7%AE%97%E6%B3%95/06.%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B.html","title":"06. 其他类型","lang":"zh-CN","frontmatter":{"description":"06. 其他类型 复合类型 > 类型模板类 > 共用体 union 简概 说明：能存储不同的数据类型，但只能同时存储其中的一种类型 共用体与结构的区别：语法相似但含义不同 比方说，前者可以同时存储int、long、double，后者只能存储int、long、double中的其中一种 注意项：需要有足够的空间来存储最大的成员 使用场景：当数据项使用两种或...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/02.%20%E6%95%B0%E6%8D%AE_%E7%AE%97%E6%B3%95/06.%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"06. 其他类型"}],["meta",{"property":"og:description","content":"06. 其他类型 复合类型 > 类型模板类 > 共用体 union 简概 说明：能存储不同的数据类型，但只能同时存储其中的一种类型 共用体与结构的区别：语法相似但含义不同 比方说，前者可以同时存储int、long、double，后者只能存储int、long、double中的其中一种 注意项：需要有足够的空间来存储最大的成员 使用场景：当数据项使用两种或..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"06. 其他类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"06. 其他类型","slug":"_06-其他类型","link":"#_06-其他类型","children":[{"level":2,"title":"复合类型 > 类型模板类 >  共用体 union","slug":"复合类型-类型模板类-共用体-union","link":"#复合类型-类型模板类-共用体-union","children":[{"level":3,"title":"简概","slug":"简概","link":"#简概","children":[]},{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]}]},{"level":2,"title":"复合类型 > 类型模板类 >  枚举 enum","slug":"复合类型-类型模板类-枚举-enum","link":"#复合类型-类型模板类-枚举-enum","children":[{"level":3,"title":"简概","slug":"简概-1","link":"#简概-1","children":[]},{"level":3,"title":"使用","slug":"使用-1","link":"#使用-1","children":[{"level":4,"title":"字面量方式","slug":"字面量方式-1","link":"#字面量方式-1","children":[]},{"level":4,"title":"内置函数方法","slug":"内置函数方法","link":"#内置函数方法","children":[]},{"level":4,"title":"【缺陷补丁】作用域内枚举（C++11）","slug":"【缺陷补丁】作用域内枚举-c-11","link":"#【缺陷补丁】作用域内枚举-c-11","children":[]}]}]},{"level":2,"title":"特殊类型 > 自动类型","slug":"特殊类型-自动类型","link":"#特殊类型-自动类型","children":[{"level":3,"title":"auto","slug":"auto","link":"#auto","children":[]},{"level":3,"title":"decltype","slug":"decltype","link":"#decltype","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.94,"words":1182},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/02. 数据+算法/06. 其他类型.md","autoDesc":true}');export{u as comp,h as data};
