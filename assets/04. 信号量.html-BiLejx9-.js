import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,e as n}from"./app-yixEWCFr.js";const i="/assets/10-信号量-互斥-CyXY2B3o.jpg",o="/assets/11-信号量-同步-4ZkQky2f.jpg",r={},a=n('<h1 id="信号量" tabindex="-1"><a class="header-anchor" href="#信号量"><span>信号量</span></a></h1><h2 id="工作场景、解决痛点" tabindex="-1"><a class="header-anchor" href="#工作场景、解决痛点"><span>工作场景、解决痛点</span></a></h2><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="本质" tabindex="-1"><a class="header-anchor" href="#本质"><span>本质</span></a></h3><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong></p><h3 id="两种原子操作-p、v操作" tabindex="-1"><a class="header-anchor" href="#两种原子操作-p、v操作"><span>两种原子操作（P、V操作）</span></a></h3><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li><p><strong>P 操作</strong>：这个操作会把信号量减去 1</p><ul><li>若相减后如果信号量 &lt; 0，则表明资源已被占用，进程需<strong>阻塞</strong>等待；</li><li>若相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续<strong>执行</strong>。</li></ul></li><li><p><strong>V 操作</strong>：这个操作会把信号量加上 1</p><ul><li>若相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程<strong>唤醒</strong>运行；</li><li>若相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul></li><li><p>原则：P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p></li></ul><h2 id="两种用法及原理" tabindex="-1"><a class="header-anchor" href="#两种用法及原理"><span>两种用法及原理</span></a></h2><p>信号量记数 个人吐槽：</p><p>刚开始我感觉这个计数方式有点反常识，为什么让计数值等于 使用+等待 进程数呢？ 这样不就很直观了吗？为什么要取<code> [-n, 1]</code> 区间这么怪呢。</p><p>主要是因为他这里可以有两种用法，该记数还要用于标识是 <strong>互斥信号量</strong> 还是 <strong>同步信号量</strong></p><h3 id="用法-——-互斥信号量-初始为1-无先后顺序" tabindex="-1"><a class="header-anchor" href="#用法-——-互斥信号量-初始为1-无先后顺序"><span>用法 —— 互斥信号量 (初始为1，无先后顺序)</span></a></h3><p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</p><figure><img src="'+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>具体的过程如下：</p><ol><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ol><p>可以发现，信号初始化为 <code>1</code>，就代表着是 <strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>另外，在多进程里，每个进程并<strong>不一定是顺序执行</strong>的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><h3 id="用法-——-同步信号量-初始为0-有前后顺序" tabindex="-1"><a class="header-anchor" href="#用法-——-同步信号量-初始为0-有前后顺序"><span>用法 —— 同步信号量 (初始为0，有前后顺序)</span></a></h3><p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的。</p><p>进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是<strong>有前后顺序</strong>的。</p><p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 <code>0</code>。</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>具体过程：</p><ol><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ol><p>可以发现，信号初始化为 <code>0</code>，就代表着是 <strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p>',29),s=[a];function p(E,c){return t(),l("div",null,s)}const h=e(r,[["render",p],["__file","04. 信号量.html.vue"]]),g=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/02.%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/04.%20%E4%BF%A1%E5%8F%B7%E9%87%8F.html","title":"信号量","lang":"zh-CN","frontmatter":{"description":"信号量 工作场景、解决痛点 用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。 为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。 原理 本质 ...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/02.%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/04.%20%E4%BF%A1%E5%8F%B7%E9%87%8F.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"信号量"}],["meta",{"property":"og:description","content":"信号量 工作场景、解决痛点 用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。 为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。 原理 本质 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"信号量\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"信号量","slug":"信号量","link":"#信号量","children":[{"level":2,"title":"工作场景、解决痛点","slug":"工作场景、解决痛点","link":"#工作场景、解决痛点","children":[]},{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"本质","slug":"本质","link":"#本质","children":[]},{"level":3,"title":"两种原子操作（P、V操作）","slug":"两种原子操作-p、v操作","link":"#两种原子操作-p、v操作","children":[]}]},{"level":2,"title":"两种用法及原理","slug":"两种用法及原理","link":"#两种用法及原理","children":[{"level":3,"title":"用法 —— 互斥信号量 (初始为1，无先后顺序)","slug":"用法-——-互斥信号量-初始为1-无先后顺序","link":"#用法-——-互斥信号量-初始为1-无先后顺序","children":[]},{"level":3,"title":"用法 —— 同步信号量 (初始为0，有前后顺序)","slug":"用法-——-同步信号量-初始为0-有前后顺序","link":"#用法-——-同步信号量-初始为0-有前后顺序","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.17,"words":1252},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/02. 通信方式/04. 信号量.md","autoDesc":true}');export{h as comp,g as data};
