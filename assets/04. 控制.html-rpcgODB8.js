import{_ as s,c as a,b as n,o as l}from"./app-CcItmy2w.js";const i={};function t(c,e){return l(),a("div",null,e[0]||(e[0]=[n(`<h1 id="computersystems" tabindex="-1"><a class="header-anchor" href="#computersystems"><span>ComputerSystems</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="控制" tabindex="-1"><a class="header-anchor" href="#控制"><span>控制</span></a></h1><h2 id="loop-循环" tabindex="-1"><a class="header-anchor" href="#loop-循环"><span>loop 循环</span></a></h2><p>基本使用</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>; 每次执行到\`loop标号\`时会自动将cx减1，并检测cx是否为0，不需要手动完成
标号
	...
	循环体
	...
loop 标号	
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>demo：从1加至100的和</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>; 设定循环次数
mov cx, 100
; 初始化ax
mov ax, 0x0000
; 循环部分
sum:
	add ax, cx
	loop sum
jmp $
times 510-($-$$) db 0

; 最后在寄存器ax的数据是13BAh，即5050，答案正确
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="jmp-跳转" tabindex="-1"><a class="header-anchor" href="#jmp-跳转"><span>jmp 跳转</span></a></h2><p>直接跳转，类似于于C语言的goto</p><h2 id="jcc-条件" tabindex="-1"><a class="header-anchor" href="#jcc-条件"><span>jcc 条件</span></a></h2><p><code>jmp</code>是直接跳转，而<code>jcc</code>是符合条件才会跳转</p><p>场景：FLAGS (标志寄存器) 要结合<code>Jcc</code>（条件转移指令）来使用</p><h3 id="jcc衍生指令-jz-jnz" tabindex="-1"><a class="header-anchor" href="#jcc衍生指令-jz-jnz"><span>jcc衍生指令 jz/jnz</span></a></h3><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>jz	; Jump if zero		(ZF=1)
jnz	; Jump if not zero	(ZF=0)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="section-分段-疑似汇编器命令" tabindex="-1"><a class="header-anchor" href="#section-分段-疑似汇编器命令"><span>section 分段（疑似汇编器命令）</span></a></h2><p>类似于高级语言的程序块？</p><p>（不是segment）</p><p>这是nasm提供的分段关键字，不是原生的汇编指令关键字？</p><p>作用：可以自定义分段</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>section 名字 align=无/16/32 vstart=0x7c00
; section 语句之后，到碰到下个section之前都属于section
; align可选参数：可以让你分段的位置处于16/32字节的倍数，原理是用0给你补到16字节，默认不设置
; vstart可选参数：设置段内的偏移地址的基准地址，默认不设置则基于程序头（一般为0x0000）进行偏移
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="call-指令" tabindex="-1"><a class="header-anchor" href="#call-指令"><span>call 指令</span></a></h2><p>类似于高级语言的函数传参，是jmp的高级封装（可以跳转回来、使用了栈、可以传参）</p><p>原理：</p><ul><li>流程是先顺序执行指令，遇到call指令后来到call后面的标号处，遇到ret指令后返回到原来的位置继续顺序执行指令</li><li>传参时用寄存器来存储参数和返回值即可</li></ul><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>; 后接标号/寄存器/内存地址
; 注意在代码块的最后要加一个ret指令，即return
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,26)]))}const o=s(i,[["render",t],["__file","04. 控制.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/04.%20%E6%8E%A7%E5%88%B6.html","title":"ComputerSystems","lang":"zh-CN","frontmatter":{"description":"ComputerSystems 目录 控制 loop 循环 基本使用 demo：从1加至100的和 jmp 跳转 直接跳转，类似于于C语言的goto jcc 条件 jmp是直接跳转，而jcc是符合条件才会跳转 场景：FLAGS (标志寄存器) 要结合Jcc（条件转移指令）来使用 jcc衍生指令 jz/jnz section 分段（疑似汇编器命令） 类似...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/04.%20%E6%8E%A7%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"ComputerSystems"}],["meta",{"property":"og:description","content":"ComputerSystems 目录 控制 loop 循环 基本使用 demo：从1加至100的和 jmp 跳转 直接跳转，类似于于C语言的goto jcc 条件 jmp是直接跳转，而jcc是符合条件才会跳转 场景：FLAGS (标志寄存器) 要结合Jcc（条件转移指令）来使用 jcc衍生指令 jz/jnz section 分段（疑似汇编器命令） 类似..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ComputerSystems\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"ComputerSystems","slug":"computersystems","link":"#computersystems","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"控制","slug":"控制","link":"#控制","children":[{"level":2,"title":"loop 循环","slug":"loop-循环","link":"#loop-循环","children":[]},{"level":2,"title":"jmp 跳转","slug":"jmp-跳转","link":"#jmp-跳转","children":[]},{"level":2,"title":"jcc 条件","slug":"jcc-条件","link":"#jcc-条件","children":[{"level":3,"title":"jcc衍生指令 jz/jnz","slug":"jcc衍生指令-jz-jnz","link":"#jcc衍生指令-jz-jnz","children":[]}]},{"level":2,"title":"section 分段（疑似汇编器命令）","slug":"section-分段-疑似汇编器命令","link":"#section-分段-疑似汇编器命令","children":[]},{"level":2,"title":"call 指令","slug":"call-指令","link":"#call-指令","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/04. 控制.md","excerpt":"\\n<h1>目录</h1>\\n<h1>控制</h1>\\n<h2>loop 循环</h2>\\n<p>基本使用</p>\\n<div class=\\"language-assembly\\" data-ext=\\"assembly\\" data-title=\\"assembly\\"><pre class=\\"language-assembly\\"><code>; 每次执行到`loop标号`时会自动将cx减1，并检测cx是否为0，不需要手动完成\\n标号\\n\\t...\\n\\t循环体\\n\\t...\\nloop 标号\\t\\n</code></pre></div><p>demo：从1加至100的和</p>\\n<div class=\\"language-assembly\\" data-ext=\\"assembly\\" data-title=\\"assembly\\"><pre class=\\"language-assembly\\"><code>; 设定循环次数\\nmov cx, 100\\n; 初始化ax\\nmov ax, 0x0000\\n; 循环部分\\nsum:\\n\\tadd ax, cx\\n\\tloop sum\\njmp $\\ntimes 510-($-$$) db 0\\n\\n; 最后在寄存器ax的数据是13BAh，即5050，答案正确\\n</code></pre></div>","autoDesc":true}');export{o as comp,r as data};
