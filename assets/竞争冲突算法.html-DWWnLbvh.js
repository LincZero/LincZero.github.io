import{_ as a,e as p,f as e,g as n,j as o,h as t,i as E,r,o as u}from"./app-DPU1xou8.js";const s={};function A(d,l){const i=r("RouteLink"),B=r("Mermaid");return u(),p("div",null,[l[13]||(l[13]=e("h1",{id:"竞争算法",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#竞争算法"},[e("span",null,"竞争算法")])],-1)),l[14]||(l[14]=e("p",null,"详细见：",-1)),e("ul",null,[e("li",null,[l[1]||(l[1]=o("线程冲突：")),t(i,{to:"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/"},{default:E(()=>l[0]||(l[0]=[o("../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突/")])),_:1})]),e("li",null,[l[3]||(l[3]=o("Cache冲突：")),t(i,{to:"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/06.%20Cache%E4%B8%80%E8%87%B4%E6%80%A7.html"},{default:E(()=>l[2]||(l[2]=[o("../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md")])),_:1})])]),l[15]||(l[15]=n('<h2 id="竞争冲突算法-vs-竞争调度算法" tabindex="-1"><a class="header-anchor" href="#竞争冲突算法-vs-竞争调度算法"><span>竞争冲突算法 vs 竞争调度算法</span></a></h2><p>这两个词的前缀 “竞争” 我是加上的，这两个东西其实都是一种 “竞争”，但本质大有不同：</p><ul><li><p>调度算法：<em>多个任务去竞争一个处理器 / 多个数据去竞争一块内存</em>。竞争的结果是用算法去计算竞争者的<strong>优先级</strong>。</p></li><li><p>竞争算法：<em>多个处理器核/线程去竞争一个资源 (内存/Cache等)</em>，和上面反过来。竞争的结果是<strong>错峰避免同时使用</strong>。</p><p>竞争算法也可以说是<strong>一致性算法</strong> (Cache一致性或者是其他的什么一致性)</p></li></ul><h2 id="竞争冲突" tabindex="-1"><a class="header-anchor" href="#竞争冲突"><span>竞争冲突</span></a></h2><h3 id="情景" tabindex="-1"><a class="header-anchor" href="#情景"><span>情景</span></a></h3><p>按多线程还是多核引起分类：</p>',6)),e("ul",null,[l[11]||(l[11]=e("li",null,[e("p",null,"多线程冲突"),e("ul",null,[e("li",null,[o("普通内存冲突，可以是"),e("strong",null,"寄存器与内存不一致"),o("冲突 "),e("ul",null,[e("li",null,[e("em",null,"锁"),o("：加锁、解锁操作（Test-and-Set 原子指令）")]),e("li",null,[e("em",null,"信号量"),o("：P、V 操作（P、V 原子指令）")])])])])],-1)),e("li",null,[l[10]||(l[10]=e("p",null,"多核冲突",-1)),e("ul",null,[l[8]||(l[8]=n("<li><p>**Cache与内存不一致 (Cache一致性)**问题。<em>一致性算法</em>：</p><ul><li>低性能错误方案： 不独占Cache</li><li>DPDK方法： 避免多个数据备份、避免多个核访问同一内存地址 <ul><li>多个核同时需要一些数据结构，为每个核都单独定义一份</li><li>多个核访问同一个网卡的接收队列/发送队列，为每个核都准备一个单独的接收队列/发送队列</li></ul></li><li>基于目录的协议（Directory-based protocol）： 全局统一管理</li><li>总线窥探协议（Bus snooping protocol）： 利用总线进行的分布式的广播和被通知</li><li>Snarfing协议： 在此不作讨论</li></ul></li>",1)),e("li",null,[l[4]||(l[4]=e("p",null,[e("strong",null,"寄存器与内存不一致"),o("冲突、即寄存器一致性问题？")],-1)),l[5]||(l[5]=e("p",null,[e("em",null,"（不一定存在。如果寄存器和Cache的数据交换是原子性的，那么不存在这个问题。问题保留，待验证）")],-1)),l[6]||(l[6]=e("p",null,"如果存在，但本质上感觉和Cache一致性是一个原理。Cache一致性能用的，对于寄存器内存应该也能用。",-1)),l[7]||(l[7]=e("p",null,"区别应该就只有对于三级Cache，不存在Cache一致性问题，只存在寄存器一致性问题。",-1)),t(B,{id:"mermaid-135",code:"eJxLL0osyFAIceLiKi5NgnCcA0LjnfOLUuMNuZ6ub3m6dsbTmSsMo+FMq8RnM9YbGsVyOScmZ6QaGkY/2dHwfNdyMA9Vzggot6sHJheLZJquni5UBbKgLkTQ0JArNS+FC2KGMdD4TnxGGCPEjBBiWHxjhKQQwzdP9q97NmXnkx27QFwjE5jnjLB4DrtSI6BSrH41gnsL2QHwADCC+PVpWytQJhpCoYcw0ASIBMxVaAJGoMBAEQCZjyxgjOADAA+J404="})]),l[9]||(l[9]=e("li",null,[e("p",null,"内存冲突、内存一致性问题？"),e("p",null,[e("em",null,"（不一定存在。感觉应该不会出现多个内存去缓存同一个硬盘数据的情况，那么就不存在这个问题。问题保留，待验证）"),e("br"),o(" （搜了下好像是有这么个概念，但可能和我想象中的不同）")]),e("ul",null,[e("li",null,"CPU Cache缓存的是内存数据，内存缓存的是硬盘数据")])],-1))])]),l[12]||(l[12]=n("<li><p>网络并发 (Server端多协程/线程/进程都有可能)</p><ul><li>MySQL的<em>并发</em>导致<strong>用户获取和数据库不一致 (事务隔离性)</strong>：MySQL 的 MVCC（Multi-Version Concurrency Control，多版本并发控制）</li><li>Redis缓存和数据库保证一致性。<em>并发</em>以及缓存和数据库修改先后的问题，可能导致<strong>数据库和缓存不一致</strong>问题。</li><li><strong>Redis集群的一致性</strong>：主从模式、哨兵模式、切片集群模式</li></ul></li>",1))]),l[16]||(l[16]=n('<h3 id="情景-总结" tabindex="-1"><a class="header-anchor" href="#情景-总结"><span>情景 - 总结</span></a></h3><p>共同点：</p><ul><li>几乎都是<em>并发引起</em>的</li><li>几乎都是<em>两个存储空间的一致性</em>问题</li><li>几乎都是<em>双写一致性</em>的问题（例外：<em>读写一致性</em>也可能有问题，这种一般通过过期时间来解决）</li></ul><h3 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h3><ul><li>多线程冲突 <ul><li>基本通过原子操作解决 (锁/信号量)，避免指令乱序</li></ul></li><li>一致性冲突 (多个数据备份) <ul><li>通过全局统一管理</li><li>分布式的广播/被广播</li></ul></li><li>其他 <ul><li>MySQL 的 MVCC（Multi-Version Concurrency Control，多版本并发控制）</li></ul></li></ul><h3 id="解决方法-总结" tabindex="-1"><a class="header-anchor" href="#解决方法-总结"><span>解决方法 - 总结</span></a></h3><p>共同点：</p><ul><li>（待总结）</li></ul><h2 id="其他-杂项" tabindex="-1"><a class="header-anchor" href="#其他-杂项"><span>其他？杂项？</span></a></h2><p>（<strong>GPT</strong>）</p><blockquote><ul><li>共享内存</li><li>总线</li><li>互斥锁</li><li>IO设备</li><li>其他共享资源 <ul><li>信号量 <ul><li>事件</li><li>队列</li></ul></li></ul></li></ul><p>方法</p><ul><li><strong>锁优化：</strong> 使用更细粒度的锁、自旋锁、读写锁等技术来减少锁竞争。</li><li><strong>无锁算法：</strong> 采用无锁或无等待的数据结构和算法，避免使用锁。</li><li><strong>缓存优化：</strong> 使用缓存一致性协议、伪共享填充等技术来提高缓存利用率。</li><li><strong>线程池：</strong> 通过线程池管理线程，避免线程频繁创建和销毁。</li><li><strong>异步I/O：</strong> 使用异步I/O操作，避免线程阻塞。</li><li><strong>负载均衡：</strong> 将任务均匀分配给各个核心，避免单个核心负载过重。</li></ul></blockquote><blockquote><p>我有一个疑问，Cache一致性那里有三个前提条件。但这里不考虑寄存器的吗？为什么限制了那么多原因？我感觉非独占Cache也会出现问题啊，多核是独占寄存器的啊。</p><p>目前我个人的理解是，也会有冲突，但这种冲突不叫 “Cache一致性的竞争冲突”，而是别的冲突，姑且叫 “寄存器的竞争冲突” 好了。</p><p>不确定</p></blockquote>',12))])}const D=a(s,[["render",A],["__file","竞争冲突算法.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E5%86%B2%E7%AA%81%E7%AE%97%E6%B3%95.html","title":"竞争算法","lang":"zh-CN","frontmatter":{"description":"竞争算法 详细见： 线程冲突： Cache冲突： 竞争冲突算法 vs 竞争调度算法 这两个词的前缀 “竞争” 我是加上的，这两个东西其实都是一种 “竞争”，但本质大有不同： 调度算法：多个任务去竞争一个处理器 / 多个数据去竞争一块内存。竞争的结果是用算法去计算竞争者的优先级。 竞争算法：多个处理器核/线程去竞争一个资源 (内存/Cache等)，和上面...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E5%86%B2%E7%AA%81%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"竞争算法"}],["meta",{"property":"og:description","content":"竞争算法 详细见： 线程冲突： Cache冲突： 竞争冲突算法 vs 竞争调度算法 这两个词的前缀 “竞争” 我是加上的，这两个东西其实都是一种 “竞争”，但本质大有不同： 调度算法：多个任务去竞争一个处理器 / 多个数据去竞争一块内存。竞争的结果是用算法去计算竞争者的优先级。 竞争算法：多个处理器核/线程去竞争一个资源 (内存/Cache等)，和上面..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"竞争算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":4.85,"words":1454},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","excerpt":"\\n<p>详细见：</p>\\n<ul>\\n<li>线程冲突：<a href=\\"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/\\" target=\\"_blank\\">../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突/</a></li>\\n<li>Cache冲突：<a href=\\"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/06.%20Cache%E4%B8%80%E8%87%B4%E6%80%A7.html\\" target=\\"_blank\\">../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md</a></li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[{"title":"06. Cache一致性","link":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.html"}],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","value":{"title":"竞争冲突算法","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","outlink":["MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md"],"backlink":[]}},{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md","value":{"title":"06. Cache一致性","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md","outlink":[],"backlink":[]}}],"links":[{"source":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","target":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md"}]}}}');export{D as comp,m as data};
