import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as e}from"./app-OHhlwNoJ.js";const t={},l=e(`<h1 id="《c-设计模式》视频-李建忠" tabindex="-1"><a class="header-anchor" href="#《c-设计模式》视频-李建忠"><span>《C++设计模式》视频_李建忠</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><p>[toc]</p><h1 id="代理模式-proxy" tabindex="-1"><a class="header-anchor" href="#代理模式-proxy"><span>代理模式 Proxy</span></a></h1><h2 id="所属分类——-接口隔离-模式" tabindex="-1"><a class="header-anchor" href="#所属分类——-接口隔离-模式"><span>所属分类——“接口隔离” 模式</span></a></h2><p>略</p><h2 id="动机-motivation" tabindex="-1"><a class="header-anchor" href="#动机-motivation"><span>动机（Motivation）</span></a></h2><h3 id="简概" tabindex="-1"><a class="header-anchor" href="#简概"><span>简概</span></a></h3><ul><li>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。</li><li>如何在不失去<strong>透明操作</strong>对象的同时来<strong>管理/控制</strong>这些对象特有的复杂性？增加一层<strong>间接层</strong>是软件开发中常见的解决方式</li></ul><h3 id="代码体现" tabindex="-1"><a class="header-anchor" href="#代码体现"><span>代码体现</span></a></h3><h4 id="举例-写法1" tabindex="-1"><a class="header-anchor" href="#举例-写法1"><span>举例 - 写法1</span></a></h4><p>client.cpp</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class ISubject{
public:
    virtual void process();
}

class RealSubject: public ISubject{
public:
    virtual void process(){
        //...
    }
};

class ClientApp{
    ISubject* subject;
public:
    ClientApp(){
        subject = new RealSubject();	// 假设这里是通过工厂模式等方法返回
    }
    void DoTask(){
        //...
        subject-&gt;process();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="分析-写法1" tabindex="-1"><a class="header-anchor" href="#分析-写法1"><span>分析 - 写法1</span></a></h4><p>有时候可能会拿不到RealSubject对象或不方便<strong>直接</strong>使用RealSubject对象</p><h4 id="举例-写法2-代理模式" tabindex="-1"><a class="header-anchor" href="#举例-写法2-代理模式"><span>举例 - 写法2（代理模式）</span></a></h4><p>client.cpp</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>//不变
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>proxy.cpp【新增】</p><p>（有时这个cpp可能会通过一些框架中的工具自动生成，手动写可能会比较麻烦）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class ISubject{
public:
    virtual void process();
}

// Proxy的设计（设计有时会比较复杂，所以有时是通过一些工具来生成）
class SubjectProxy: public ISubject{	// 【修改】代理类，RealSubject替换为SubjectProxy类
public:
    virtual void process(){
        //对RealSubject的一种间接访问
    }
};

class ClientApp{
    ISubject* subject;
public:
    ClientApp(){
        subject = new RealSubject();	// 通过工厂模式等方法
    }
    void DoTask(){
        //...
        subject-&gt;process();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h2><h3 id="模式定义" tabindex="-1"><a class="header-anchor" href="#模式定义"><span>模式定义</span></a></h3><blockquote><p>为其他对象提供—种代理以**控制（隔离，使用接口）**对这个对象的访问。</p><p>——《设计模式》GoF</p></blockquote><h3 id="结构-structure" tabindex="-1"><a class="header-anchor" href="#结构-structure"><span>结构（Structure）</span></a></h3><p>（红色表示稳定）</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
<span class="token keyword">subgraph</span> Subject 抽象接口
	A<span class="token text string">[Request]</span><span class="token punctuation">;</span>class A red
<span class="token keyword">end</span>
<span class="token keyword">subgraph</span> RealSubject
	B<span class="token text string">[Request]</span>
<span class="token keyword">end</span>
<span class="token keyword">subgraph</span> Proxy 代理
	C<span class="token text string">[Request]</span>
<span class="token keyword">end</span>

Client<span class="token text string">(Client)</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">调用</span><span class="token arrow operator">--&gt;</span></span>A
A<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">派生</span><span class="token arrow operator">--&gt;</span></span>B
A<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">派生</span><span class="token arrow operator">--&gt;</span></span>C
C<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">-.</span><span class="token label property">realSubject 间接访问或实现</span><span class="token arrow operator">.-&gt;</span></span>B

<span class="token keyword">classDef</span> red <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#f9f<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>4px</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析</p><p>这里如果不能直接访问RealSubject，可以访问代理，由代理对象这个间接层来间接访问RealSubject</p><p>代理对象和RealSubject对继承自同一个接口，使客户端在使用时有一致性</p><h3 id="要点总结" tabindex="-1"><a class="header-anchor" href="#要点总结"><span>要点总结</span></a></h3><ul><li>“增加一层间接层&quot; 是软件系统中对许多复杂问题的一种常见解决方法。 在面向对象系统中，<strong>直接使用某些对象会带来很多问题</strong>，<strong>作为间接层的proxy对象</strong>便是解决这一问题的常用手段</li><li>具体proxy设计模式的实现方法、实现粒度都<strong>相差很大</strong>， 有些可能对单个对象做细粒度的控制，如copy-on-write技术， 有些可能对组件模块提供抽象代理层,在架构层次对对象做proxy</li><li>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的</li></ul><h2 id="多种语言中的代理模式-gpt" tabindex="-1"><a class="header-anchor" href="#多种语言中的代理模式-gpt"><span>多种语言中的代理模式（GPT）</span></a></h2><p>代理（Proxy）是一种设计模式，用于在访问对象时引入一个替代对象，称为代理对象。 代理模式可以用于多种目的，如：</p><ul><li>访问控制</li><li>性能优化</li><li>远程访问</li><li>等</li></ul><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><p>代理模式的理念是通过引入一个替代对象（代理对象）来控制对实际对象的访问。它主要用于以下场景：</p><ol><li>访问控制：当需要控制对某个对象的访问权限时，可以使用代理模式。例如，在一个文件系统中，代理可以用于控制对特定文件的读取、写入和删除权限。</li><li>虚拟代理：当创建一个对象需要大量资源（如内存、计算能力）时，可以使用虚拟代理。虚拟代理可以延迟对象的创建，直到实际需要时才创建对象。例如，一个图片查看器程序可以使用虚拟代理来延迟加载高清图片，以提高初始加载速度。</li><li>缓存代理：当需要缓存对象的结果以提高性能时，可以使用代理模式。例如，一个Web代理服务器可以缓存请求的网页，从而减少对原始服务器的负载。</li><li>远程代理：当需要在不同的地址空间（例如，不同的计算机或进程）上访问对象时，可以使用代理模式。例如，Java RMI（远程方法调用）使用代理模式来让客户端在本地调用远程对象的方法。</li><li>保护代理：当需要对一个对象添加额外的保护或验证逻辑时，可以使用代理模式。例如，在一个电子商务网站中，代理可以用于验证用户的信用卡信息，以确保交易安全。</li></ol><p>通俗的使用场景：</p><ol><li>视频网站：在一些视频网站中，可能会有一个视频对象，但是在访问这个视频之前，需要先检查用户是否具有观看权限。在这种情况下，可以使用代理模式来实现访问控制。</li><li>数据库查询：在执行数据库查询时，可以使用代理模式来缓存查询结果。当相同的查询再次执行时，代理可以直接返回缓存的结果，而不需要实际执行查询。</li><li>网络请求：在发送网络请求时，可以使用代理服务器来转发请求。代理服务器可以对请求进行缓存、负载均衡和安全检查等操作。</li><li>图片懒加载：在一个图库应用中，可以使用代理模式来实现图片的懒加载。代理对象可以在用户滚动到图片时，才真正地加载图片资源，从而提高应用的加载速度和性能。</li><li>API限流：在访问第三方API时，可以使用代理模式来限制API的访问速率。代理对象可以通过计数和时间戳来实现限流功能，以确保不超过API的调用限制。</li></ol><h3 id="不同语言的实现" tabindex="-1"><a class="header-anchor" href="#不同语言的实现"><span>不同语言的实现</span></a></h3><p>在不同的编程语言中，Proxy 的实现方式可能会有所不同，但核心概念是相同的。 以下是在 Java、C++、Qt、JavaScript 和 Python 中使用代理的一些例子：</p><h4 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h4><p>在 Java 中，代理模式通常通过接口和实现类来实现。一个常见的用例是创建一个远程接口（Remote Interface），代理对象负责处理远程方法调用的底层细节。例如，Java RMI（远程方法调用）就使用了代理模式。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 定义接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealService</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Do something in RealService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 代理类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyService</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">RealService</span> realService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ProxyService</span><span class="token punctuation">(</span><span class="token class-name">RealService</span> realService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>realService <span class="token operator">=</span> realService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Before calling RealService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        realService<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;After calling RealService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C++</span></a></h4><p>在 C++ 中，代理模式可以通过抽象基类、继承和组合来实现。一个常见的用例是通过智能指针实现引用计数。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">// 基类</span>
<span class="token keyword">class</span> <span class="token class-name">IService</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 实现类</span>
<span class="token keyword">class</span> <span class="token class-name">RealService</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">IService</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Do something in RealService&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 代理类</span>
<span class="token keyword">class</span> <span class="token class-name">ProxyService</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">IService</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">ProxyService</span><span class="token punctuation">(</span>RealService<span class="token operator">*</span> realService<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">realService</span><span class="token punctuation">(</span>realService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Before calling RealService&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        realService<span class="token operator">-&gt;</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;After calling RealService&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    RealService<span class="token operator">*</span> realService<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>QT</span></a></h4><p>在 Qt 中，代理模式通常用于处理 Model/View 架构中的数据。QSortFilterProxyModel 类可以用作一个代理模型，用于在不改变原始数据的情况下，对数据进行排序和过滤。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>QTableView <span class="token operator">*</span>view <span class="token operator">=</span> <span class="token keyword">new</span> QTableView<span class="token punctuation">;</span>
QStandardItemModel <span class="token operator">*</span>model <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QStandardItemModel</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
QSortFilterProxyModel <span class="token operator">*</span>proxyModel <span class="token operator">=</span> <span class="token keyword">new</span> QSortFilterProxyModel<span class="token punctuation">;</span>

proxyModel<span class="token operator">-&gt;</span><span class="token function">setSourceModel</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">;</span>
view<span class="token operator">-&gt;</span><span class="token function">setModel</span><span class="token punctuation">(</span>proxyModel<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript"><span>JavaScript</span></a></h4><p>在 JavaScript 中，代理模式可以通过 Proxy 对象实现。 代理对象可以用于拦截并改变底层操作，如属性访问、函数调用等。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> realService <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">doSomething</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Do something in RealService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">apply</span><span class="token operator">:</span> <span class="token keyword">function</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3"><span>Vue3</span></a></h4><p>Vue3 也是主要是使用 js的proxy</p><h3 id="get-set-方法" tabindex="-1"><a class="header-anchor" href="#get-set-方法"><span>get/set 方法</span></a></h3><blockquote><p>我能认为proxy模式是类似于 python 的get/set魔术方法 的一种进阶版本吗</p></blockquote><blockquote><p>虽然代理模式和 Python 的 get/set 魔术方法有一定的相似之处，但它们并不完全相同。 代理模式主要关注的是在访问对象时引入一个替代对象（代理对象），这个代理对象可以控制对实际对象的访问，并在需要时执行额外的操作。 代理模式具有更广泛的应用范围，可以用于访问控制、性能优化、远程访问等多种场景。</p><p>Python 的 get/set 魔术方法（<code>__getattr__</code>、<code>__setattr__</code> 等）主要用于自定义属性访问的行为。 当访问或修改一个对象的属性时，Python 会自动调用这些魔术方法。这些方法通常用于实现属性的计算、验证和访问控制等功能。</p><p>尽管这些方法可以实现类似代理模式的某些功能，但它们并不能覆盖代理模式的全部用途。 所以，你可以将 Python 的 get/set 魔术方法视为一种实现代理模式的方式之一，但它们并不是代理模式的进阶版本。 代理模式更关注于抽象层面的设计，而 Python 的 get/set 魔术方法是一种具体的实现手段。</p></blockquote>`,59),i=[l];function p(c,o){return s(),a("div",null,i)}const u=n(t,[["render",p],["__file","13. 代理模式 Proxy.html.vue"]]),v=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/03.%20Tools/02.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/13.%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%20Proxy.html","title":"《C++设计模式》视频_李建忠","lang":"zh-CN","frontmatter":{"description":"《C++设计模式》视频_李建忠 目录 [toc] 代理模式 Proxy 所属分类——“接口隔离” 模式 略 动机（Motivation） 简概 在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。 如何在不失去透明操作对象的同时来管理/控制这些...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/03.%20Tools/02.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/13.%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%20Proxy.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《C++设计模式》视频_李建忠"}],["meta",{"property":"og:description","content":"《C++设计模式》视频_李建忠 目录 [toc] 代理模式 Proxy 所属分类——“接口隔离” 模式 略 动机（Motivation） 简概 在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。 如何在不失去透明操作对象的同时来管理/控制这些..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《C++设计模式》视频_李建忠\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《C++设计模式》视频_李建忠","slug":"《c-设计模式》视频-李建忠","link":"#《c-设计模式》视频-李建忠","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"代理模式 Proxy","slug":"代理模式-proxy","link":"#代理模式-proxy","children":[{"level":2,"title":"所属分类——“接口隔离” 模式","slug":"所属分类——-接口隔离-模式","link":"#所属分类——-接口隔离-模式","children":[]},{"level":2,"title":"动机（Motivation）","slug":"动机-motivation","link":"#动机-motivation","children":[{"level":3,"title":"简概","slug":"简概","link":"#简概","children":[]},{"level":3,"title":"代码体现","slug":"代码体现","link":"#代码体现","children":[{"level":4,"title":"举例 - 写法1","slug":"举例-写法1","link":"#举例-写法1","children":[]},{"level":4,"title":"分析 - 写法1","slug":"分析-写法1","link":"#分析-写法1","children":[]},{"level":4,"title":"举例 - 写法2（代理模式）","slug":"举例-写法2-代理模式","link":"#举例-写法2-代理模式","children":[]}]}]},{"level":2,"title":"设计模式","slug":"设计模式","link":"#设计模式","children":[{"level":3,"title":"模式定义","slug":"模式定义","link":"#模式定义","children":[]},{"level":3,"title":"结构（Structure）","slug":"结构-structure","link":"#结构-structure","children":[]},{"level":3,"title":"要点总结","slug":"要点总结","link":"#要点总结","children":[]}]},{"level":2,"title":"多种语言中的代理模式（GPT）","slug":"多种语言中的代理模式-gpt","link":"#多种语言中的代理模式-gpt","children":[{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":3,"title":"不同语言的实现","slug":"不同语言的实现","link":"#不同语言的实现","children":[{"level":4,"title":"Java","slug":"java","link":"#java","children":[]},{"level":4,"title":"C++","slug":"c","link":"#c","children":[]},{"level":4,"title":"QT","slug":"qt","link":"#qt","children":[]},{"level":4,"title":"JavaScript","slug":"javascript","link":"#javascript","children":[]},{"level":4,"title":"Vue3","slug":"vue3","link":"#vue3","children":[]}]},{"level":3,"title":"get/set 方法","slug":"get-set-方法","link":"#get-set-方法","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.8,"words":2339},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/03. Tools/02. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/13. 代理模式 Proxy.md","autoDesc":true}');export{u as comp,v as data};
