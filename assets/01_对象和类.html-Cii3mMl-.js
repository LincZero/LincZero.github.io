import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as e}from"./app-BAt33Ddg.js";const t={},p=e(`<h1 id="对象和类" tabindex="-1"><a class="header-anchor" href="#对象和类"><span>对象和类</span></a></h1><h2 id="摘自-语言区别-一章-go中的面向对象" tabindex="-1"><a class="header-anchor" href="#摘自-语言区别-一章-go中的面向对象"><span>(摘自“语言区别”一章) Go中的面向对象</span></a></h2><p><strong>与其他语言不同</strong>：</p><p>各语言中，什么是类 / 对象 / 面向对象语言</p><h3 id="什么是类" tabindex="-1"><a class="header-anchor" href="#什么是类"><span>什么是类？</span></a></h3><p>（结合下一节一起看）</p><ul><li>类：我个人认为只要能将数据和方法绑定在一起，且能实现面向对象三大特性 (封装/继承/多态)，都能称之为类。</li><li><strong>Class类</strong> (大多数语言，如C++、Java、C#)：用 Class 关键字声明类，这是传统的类</li><li><strong>Struct类</strong> (C++/C、Go、Rust)：有的语言用 Struct 当作类，或允许 (C++、Go) 或不允许 (C) 数据和方法定义在一起 (C++结构体在C的基础上支持了方法的定义，但似乎一般不叫这个为类，也一般不这样用)</li><li><strong>原型类</strong> (JavaScript)：一个对象的原型相当于实例化自己的类，原型链上有自己的类、父类及祖先类 （在ES6及以后的版本中，JavaScript引入了 class 关键字，它提供了一种更接近传统面向对象语言的语法糖，但本质上仍然是基于原型的）</li><li><strong>无类</strong> (C)：没有类的概念，通常不支持数据与方法的绑定写法，不支持继承等操作。 通常没有面向对象三大特性 (封装/继承/多态)。虽然强行用面向对象的方式写也没问题。但最多只能叫无类的面向对象。 强行写的话：由于数据和方法无绑定，通常根据文件和命名方式绑定。无权限控制，我习惯用 <code>_</code> 结尾表示私有方法。继承上用组合替代继承。</li><li><strong>自定义类型类</strong> (Go)：Go的类不仅局限于Struct，自定义的类型通常都可以当作类来使用，都有面向对象的特性：可以继承任意类型、扩展类方法、实现接口</li></ul><h3 id="什么是对象" tabindex="-1"><a class="header-anchor" href="#什么是对象"><span>什么是对象？</span></a></h3><p>（结合上一节一起看）</p><ul><li>对象：这个不同语言定义的就不同了。我认为只要能有模板个创建多个有相同特征变量的，都能叫对象。当然，这不总是对的。最简单的就是“基本类型”到底算不算对象</li><li><strong>类对象</strong> / <strong>Class对象</strong> (大多数语言，如C++、Java、C#)：一般有Class关键字，支持类的继承，权限控制等。通过实例化Class类出来的东西才是类，而基本类型不是。对象是基于类的实例</li><li><strong>Struct对象</strong>：略</li><li><strong>原型对象</strong> (JavaScript)：每个对象都有一个Prototype链，原型能继承，所有对象的共同根祖先是Object</li><li><strong>皆对象</strong> (JavaScript、Python、Ruby)：所有东西，乃至 int / 函数 / 模块 都属于对象</li><li><strong>无对象</strong> (C)</li></ul><h3 id="什么是面向对象语言" tabindex="-1"><a class="header-anchor" href="#什么是面向对象语言"><span>什么是面向对象语言？</span></a></h3><ul><li><strong>面向对象语言 / 　类对象</strong> (大多数语言，如C++、Java、C#) <ul><li><strong>完全面向对象</strong> (Java)：根部只有类定义，包括 main 函数要在任意一个自定义类里 (如果定义在多个类里，编译要指定，如 <code>java ClassA</code>)</li><li><strong>支持面向对象 / 多范式编程语言</strong> (大多数语言，C++、C#、Go)：支持面向对象、面向过程、函数式、过程式。根部可以有类、函数、基本类型。 其中 Go 其实和 Java 有些类似的理念：Go 的资源全在包中，包括 main 函数要在 main 包中。</li></ul></li><li><strong>基于原型语言 / 　皆对象 / 原型对象</strong> (JavaScript)</li><li><strong>基于对象语言 / 　皆对象</strong> (Python、Ruby)</li><li><strong>非 class &quot;类&quot;</strong> (Go、Rust) <ul><li>(Go)：没有传统意义上的“类”概念，取而代之的是“类型”（Type）和“接口”（Interface）。 <ul><li>类型：结构体可以包含字段（Field）和方法（Method），方法可以与结构体关联。</li><li>接口：定义了一组方法签名。任何实现了这些方法的类型都可以被看作是该接口的实例。接口在Go中用于实现多态性，而不是通过继承实现</li></ul></li><li>(Rust)：没有传统意义上的类和对象，但它提供了其他机制来实现类似面向对象编程的功能 <ul><li>结构体：Rust中的结构体类似于其他语言中的对象，可以包含字段和方法。</li><li>枚举：不仅可以表示一组值，还可以为不同的枚举值定义不同的方法</li><li>特质 (Trait)：定义了一组方法签名，类似接口和多态性的功能</li></ul></li></ul></li><li><strong>面向过程编程语言</strong> (如 C)</li><li><strong>函数式编程语言</strong> (如 Haskell、Erlang)：更侧重于函数和不可变数据结构。计算是通过纯函数的应用来进行的，而不是通过对象的状态变化</li><li><strong>逻辑编程语言</strong> (如 Prolog)：逻辑编程语言中的对象通常是指事实和规则，而不是传统意义上的对象。在Prolog中，程序是由一系列的事实和规则组成的，这些事实和规则可以被视为“对象”，它们通过逻辑运算来表达程序的逻辑。</li></ul><h2 id="类-结构体-type-struct" tabindex="-1"><a class="header-anchor" href="#类-结构体-type-struct"><span>“类”/结构体 (type ... struct)</span></a></h2><p><strong>与其他语言不同</strong>：</p><p>Go 特色的面向对象：</p><ul><li><p>Go面向对象功能</p><ul><li>去除了：Go的类去掉了传统OOP语言的：方法重载、构造函数、析构函数、隐藏的this指针等</li><li>封装：保留但不同。方法不写在结构体内，访问权限作用域是包</li><li>继承：保留但不同。没有extends关键字，通过匿名字段实现的</li><li>接口：保留但不同。没有implement关键字，实现接口基于方法而非接口</li><li>多态：保留但不同。并非通过继承关系的里氏替换原则，而是通过接口实现的，也就是所谓的鸭子方法</li></ul></li><li><p>自动添加解引用和取地址符</p><ul><li>Go的底层编译器做了优化，对于调用方法的变量，编译器自动添加解引用和取地址符 (<code>&amp;*</code> 符号，编译器操作，便于少写点东西。注意仅对调用方法的变量有效，对传入方法的变量是无效的。个人觉得这是个<strong>垃圾设计</strong>，违背单一写法原则、新增了语法、隐藏了原理，还不如编辑器/编译报错)</li><li><code>(*o).data</code> 等同 <code>o.data</code></li><li><code>(&amp;o).fn()</code> 等同 <code>o.fn()</code></li></ul></li><li><p>任意类型绑定方法，组合继承</p><ul><li><p>Go 的方法可以绑定在任意数据上，结构体、int、float32 等。 为此，需要先重命名，然后才可以绑定。类似扩展，属于组合继承，而非真继承</p></li><li><p>这点和 JavaScript 很像，Js 万物皆对象，Js也能扩展number这种基础类型，但依靠的原型链机制</p><p>可以通过原型链的方式扩展对象 <code>Number.prototype.myMethod = function() {...};</code>。</p><p>在ES6后，更可以用类语法糖 (但本质还是原型) <code>class ClNumber extends Number</code>。</p></li></ul></li></ul><h3 id="类型定义" tabindex="-1"><a class="header-anchor" href="#类型定义"><span>类型定义</span></a></h3><p>方法和成员变量，通过首字母大小写进行访问权限控制</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token comment">// 定义结构体</span>
<span class="token keyword">type</span> Teacher <span class="token keyword">struct</span> <span class="token punctuation">{</span>	<span class="token comment">// 居然需要用 type 关键字，这个关键字复用怪怪的，上次使用还是：type 新名 旧名</span>
    Name <span class="token builtin">string</span>
    Age <span class="token builtin">int</span>
    School <span class="token builtin">string</span>
    
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="声明定义、使用-四种方式" tabindex="-1"><a class="header-anchor" href="#声明定义、使用-四种方式"><span>声明定义、使用 (四种方式)</span></a></h3><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 方式1：声明定义</span>
<span class="token keyword">var</span> t1 Teacher
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span>

<span class="token comment">// 方式2：声明定义，并初始化方式</span>
<span class="token keyword">var</span> t21 Teacher <span class="token operator">=</span> Teacher <span class="token punctuation">{</span><span class="token string">&quot;李四&quot;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">&quot;AA大学&quot;</span><span class="token punctuation">}</span>  <span class="token comment">// 2.1 按顺序版</span>
<span class="token keyword">var</span> t22 Teacher <span class="token operator">=</span> Teacher <span class="token punctuation">{</span>						<span class="token comment">// 2.2 按字段版</span>
    Name<span class="token punctuation">:</span> <span class="token string">&quot;李四&quot;</span><span class="token punctuation">,</span>
    Age<span class="token punctuation">:</span> <span class="token number">19</span><span class="token punctuation">,</span>
    School<span class="token punctuation">:</span> <span class="token string">&quot;AA大学&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> t23 <span class="token operator">*</span>Teacher <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token punctuation">{</span><span class="token punctuation">}</span>					<span class="token comment">// 2.3 可返回指针</span>

<span class="token comment">// 方式3：new方式 （返回的是指针，前面的方式都是值类型）</span>
<span class="token keyword">var</span> t3 <span class="token operator">*</span>Teacher <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>Teacher<span class="token punctuation">)</span>

<span class="token comment">// 可修改值</span>
t1<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">&quot;张三&quot;</span>
t1<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">18</span>
t1<span class="token punctuation">.</span>School <span class="token operator">=</span> <span class="token string">&quot;XX大学&quot;</span>

<span class="token punctuation">(</span><span class="token operator">*</span>t3<span class="token punctuation">)</span><span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">&quot;王五&quot;</span>

t3<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment">// 赋值语法糖。Go底层会先转地址再运行点运算符。居然不是用(-&gt;)符号</span>
			<span class="token comment">// \`(*t3).\` 等同 \`t3.\` 感觉这个设计容易误导人</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="通用方法" tabindex="-1"><a class="header-anchor" href="#通用方法"><span>通用方法</span></a></h3><p>这里是指不是 类方法、非自定义 方法</p><h4 id="转换" tabindex="-1"><a class="header-anchor" href="#转换"><span>转换</span></a></h4><ul><li>Go的结构体相当于是用户定义的类型，和其他类型转化时需要有完全相同的字段 (名字、个数、类型)</li><li>结构体通过 type 取别名 (相当于重新定义)，Go认为是新的数据类型，但彼此可以强制转换</li><li>有点类似于鸭子方法的判断</li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> Student <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Age <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Age <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Stu Student		<span class="token comment">// Go的别名会认为是两种不同的类型 (虽然可以互相强转)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> s Student
    <span class="token keyword">var</span> p Person
    <span class="token keyword">var</span> s2 Stu
    s <span class="token operator">=</span> <span class="token function">Student</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>		<span class="token comment">// 类型转换</span>
    s <span class="token operator">=</span> <span class="token function">Student</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span>		<span class="token comment">// 类型转换</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类方法" tabindex="-1"><a class="header-anchor" href="#类方法"><span>类方法</span></a></h3><h4 id="定义-自定义方法" tabindex="-1"><a class="header-anchor" href="#定义-自定义方法"><span>定义，自定义方法</span></a></h4><p>类/结构体 没有自己的方法，需要自己定义</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 定义</span>
<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Name <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// 需要引用类型，才能改变值</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">&quot;LiSi&quot;</span>		<span class="token comment">// 或可以简写成 p.Name (原因：编译器会自动加&amp;*符号)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token keyword">var</span> person Person
person<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">&quot;ZhangSan&quot;</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>			<span class="token comment">// 这里几种写法都可以。写成 person.test() 也是对的 (原因：编译器会自动加&amp;*符号)</span>
<span class="token comment">// test(&amp;person)			// 不能使用这种写法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="为非结构体绑定方法" tabindex="-1"><a class="header-anchor" href="#为非结构体绑定方法"><span>为非结构体绑定方法</span></a></h4><p>Go 的方法可以绑定在任意数据上，结构体、int、float32 等。</p><p>为此，需要先重命名，然后才可以绑定。类似扩展，属于组合继承，而非真继承。</p><p>非常神奇</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> integer <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i integer<span class="token punctuation">)</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;i = &quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i <span class="token operator">*</span>integer<span class="token punctuation">)</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>i <span class="token operator">=</span> <span class="token number">30</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;i = &quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> i integer <span class="token operator">=</span> <span class="token number">20</span>
    i<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    i<span class="token punctuation">.</span><span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="特殊方法-——-string" tabindex="-1"><a class="header-anchor" href="#特殊方法-——-string"><span>特殊方法 —— String()</span></a></h4><p>如果一个类型实现了 String() 这个方法，那么 fmt.Println 默认调用该方法进行输出</p><h3 id="底层原理" tabindex="-1"><a class="header-anchor" href="#底层原理"><span>底层原理</span></a></h3><h4 id="函数和方法区别" tabindex="-1"><a class="header-anchor" href="#函数和方法区别"><span>函数和方法区别</span></a></h4><ul><li><p>定义与使用</p><ul><li><p>函数</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 定义函数</span>
<span class="token keyword">func</span> <span class="token function">fn</span><span class="token punctuation">(</span>s Student<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// 无需绑定数据类型</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用函数</span>
函数名<span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>方法</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 定义方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s Student<span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// 需要绑定指定数据类型</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用方法</span>
变量<span class="token punctuation">.</span>方法名<span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>传入类型</p><ul><li>函数：参数类型是什么就传入什么</li><li>方法：接收值为值或指针类型时，可允许传入值或指针类型 (原理：对于调用方法的变量，编译器自动增加解引用和取地址符。而对于传入函数的变量则不进行此操作)</li></ul></li></ul><h3 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展"><span>扩展</span></a></h3><h4 id="跨包创建结构体" tabindex="-1"><a class="header-anchor" href="#跨包创建结构体"><span>跨包创建结构体</span></a></h4><p>和其他语言的访问权限控制一样。结构体首字母要大写才能直接访问，否则也可以通过一个首字母大写的工厂方法来创建并返回该结构体</p><h2 id="三大特性-1-封装" tabindex="-1"><a class="header-anchor" href="#三大特性-1-封装"><span>三大特性 (1) 封装</span></a></h2><p><strong>与其他语言不同</strong>：</p><ul><li>私有作用域：Go私有的作用域是仅限同包使用，而大多数语言是仅限类内部使用 (优点：同一个包的各个类和函数相当于互为友元。缺点：如果我要写简易的独立类，想严格控制权限岂不是要一个文件一个文件夹一个包，太丑了)</li><li>写法：其他语言语言是private之类的关键字，Go是命名的首字母大小写。写法好丑陋</li><li>特殊函数：没有析构函数因为自动GC，没有构造函数但建议类名小写而通过自定义工厂函数构造。特殊函数似乎就只有 String() 函数</li></ul><p>通用知识</p><ul><li>What 核心：绑定数据和方法、以及权限控制。不过Go的封装不太严格</li><li>Why 好处：隐藏细节、访问控制</li><li>How Go如何封装：建议将结构体名和字段名均小写，工厂方法和 Set Get 方法大写</li></ul><h2 id="三大特性-2-继承" tabindex="-1"><a class="header-anchor" href="#三大特性-2-继承"><span>三大特性 (2) 继承</span></a></h2><h3 id="通用" tabindex="-1"><a class="header-anchor" href="#通用"><span>通用</span></a></h3><p><strong>与其他语言不同</strong>：</p><ul><li>匿名结构体写法 <ul><li>写法：没有extends关键字，通过匿名结构体实现的继承</li><li>本质：本质是组合替换继承，调用上 <code>子类.匿名结构体名.匿名结构体方法</code>（可使用语法糖不写匿名结构体，简写：<code>子类.匿名结构体方法</code>）</li></ul></li><li>作用对象：可继承自任意类型</li><li>？别名并增添方法 <ul><li>话说用 typeof 重命名再增加新方法，这种形式也可以吧。不过这种形式只能扩展方法不能扩展字段</li></ul></li></ul><p>通用知识</p><ul><li>What 核心：is关系的复用</li><li>Why 好处：提高复用</li><li>How Go如何继承：没有extends关键字，通过匿名结构体实现的</li></ul><p>写法举例</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;fmt&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// 父类</span>
<span class="token keyword">type</span> Animal <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Age <span class="token builtin">int</span>
    Weight <span class="token builtin">float32</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>an <span class="token operator">*</span>Animal<span class="token punctuation">)</span> <span class="token function">ShowInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;年龄%v, 体重%v\\n&quot;</span><span class="token punctuation">,</span> an<span class="token punctuation">.</span>Age<span class="token punctuation">,</span> an<span class="token punctuation">.</span>Weight<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子类</span>
<span class="token keyword">type</span> Cat <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Animal
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cat<span class="token punctuation">)</span> <span class="token function">scratch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;我是猫，可以挠人&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cat <span class="token operator">:=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">{</span><span class="token punctuation">}</span>				<span class="token comment">// 若初始化，写法也比较简洁 c := C{A{10,&quot;aaa&quot;}, B{20, &quot;bbb, 50&quot;}}</span>
    cat<span class="token punctuation">.</span>Animal<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">3</span>			<span class="token comment">// 可简化为不写匿名结构体</span>
    cat<span class="token punctuation">.</span>Animal<span class="token punctuation">.</span>Weight <span class="token operator">=</span> <span class="token number">10.6</span>	<span class="token comment">// 可简化为不写匿名结构体</span>
    cat<span class="token punctuation">.</span>Animal<span class="token punctuation">.</span><span class="token function">ShowInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token comment">// 可简化为不写匿名结构体</span>
    cat<span class="token punctuation">.</span><span class="token function">scratch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><ol><li><p>结构体可以使用嵌套结构体的公有字段和方法（同包情况下可以访问所有字段和方法）</p></li><li><p>函数寻址原理：可简化不写匿名结构体的字段。<code>子类.匿名结构体名.匿名结构体方法</code> 简写为 <code>子类.匿名结构体方</code>。</p><p>省略时，若子类和父类有同名字段或方法时，编译器采用<strong>就近访问</strong>原则。如果希望访问匿名结构体的字段和方法，则加上匿名结构体名</p></li><li><p>多继承：支持，但不建议使用（虽然他这个本质是组合啊，但问题在于匿名结构体和具名结构体字段在是否能省略结构体名上还是有区别的）</p><p>冲突：在省略结构体名时，若两父亲有同名函数，编译器就近原则寻找父类名字时会编译报错。</p><p>解决1：我的理解是可以有多个具名结构体字段，但匿名结构体最好只定义一个。</p><p>解决2：但如果真需要定义多个匿名结构体，在访问时需要用匿名结构体类型名区分。</p><p>解决3：干脆子类定义一个同名方法覆盖掉这个函数</p></li><li><p>作用对象：结构体的匿名字段可以是其他类型。用法有点诡异，不建议</p><ol><li><p>可以是基本数据类型</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> ClassC <span class="token keyword">struct</span><span class="token punctuation">{</span>
    ClassA
    ClassB
    <span class="token builtin">int</span>			<span class="token comment">// 访问：c := ClassC{A{10}, B{&quot;b&quot;}, 888}; c.int == 888</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>可以是结构体指针</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> ClassC <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token operator">*</span>ClassA
    <span class="token operator">*</span>ClassB
    <span class="token builtin">int</span>			<span class="token comment">// 访问：c := ClassC{&amp;A{10}, &amp;B{&quot;b&quot;}, 888}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p>非匿名结构体。匿名结构体和具名结构体还是有些不同的 (体现是否能缺省匿名结构体名)</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> D <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    a <span class="token builtin">int</span>
    b B		<span class="token comment">// 组合模式</span>
<span class="token punctuation">}</span>

<span class="token comment">// 访问</span>
d <span class="token operator">:=</span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> B<span class="token punctuation">{</span><span class="token number">666</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="接口-type-interface" tabindex="-1"><a class="header-anchor" href="#接口-type-interface"><span>接口 (type ... interface)</span></a></h2><p><strong>与其他语言不同</strong>：</p><ul><li><p>作用对象：任意自定义类型均可实现接口</p></li><li><p>没有implement关键字。Go实现接口<strong>并不</strong>声明某结构体或其方法实现了哪个接口，<strong>只能</strong>判断某结构体是否实现了某个接口</p><p>ps. 挺怪的。优点是和接口的耦合性很低。缺点是岂不是说无法去强制别人去实现这某个方法？他不实现接口也不会报错？这点我认为不好</p></li></ul><p>Go</p><ul><li>接口定义：定义一组不实现的方法，不定义变量。</li><li>接口实现：需要实现接口定义的所有方法，才算实现了这个接口。无需声名该结构体或方法是实现了什么接口，接口判断的流程属于是 “鸭子方法”</li></ul><h3 id="类型定义-1" tabindex="-1"><a class="header-anchor" href="#类型定义-1"><span>类型定义</span></a></h3><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 接口。定义规则、规范、能力</span>
<span class="token keyword">type</span> SayHello <span class="token keyword">interface</span><span class="token punctuation">{</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment">// 声明没有实现的方法</span>
<span class="token punctuation">}</span>

<span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="声明定义、使用" tabindex="-1"><a class="header-anchor" href="#声明定义、使用"><span>声明定义、使用</span></a></h3><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 接口。定义规则、规范、能力</span>
<span class="token keyword">type</span> SayHello <span class="token keyword">interface</span><span class="token punctuation">{</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment">// 声明没有实现的方法</span>
<span class="token punctuation">}</span>

<span class="token comment">// 类A</span>
<span class="token keyword">type</span> Chinese <span class="token keyword">struct</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

<span class="token comment">// 类A 实现接口的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>person Chinese<span class="token punctuation">)</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 类B</span>
<span class="token keyword">type</span> American <span class="token keyword">struct</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

<span class="token comment">// 类B 实现接口的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>person American<span class="token punctuation">)</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义一个函数处理各国人打召唤的函数</span>
<span class="token keyword">func</span> <span class="token function">greet</span><span class="token punctuation">(</span>s SayHello<span class="token punctuation">)</span><span class="token punctuation">{</span>		<span class="token comment">// 接收具有SayHello接口能力的变量</span>
    s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">:=</span> Chinese<span class="token punctuation">{</span><span class="token punctuation">}</span>
    a <span class="token operator">:=</span> American<span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">greet</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token function">greet</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="注意事项-1" tabindex="-1"><a class="header-anchor" href="#注意事项-1"><span>注意事项</span></a></h3><ol><li><p>实例化：接口不能实例化，只能指向一个实现了该接口的自定义类型的变量（这的和Java接口或C++纯虚基类一样）</p></li><li><p>作用对象：自定义类型均能实现接口（非结构体也行）</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> SayHello <span class="token keyword">interface</span><span class="token punctuation">{</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> interfer <span class="token builtin">int</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>i integer<span class="token punctuation">)</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;say hi + &quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>多接口：一个自定义类型可以实现多个接口</p></li><li><p>接口多继承：多一个接口可以继承多个别的接口。这时如果要实现接口A，也必须实现接口B、C</p><p>冲突1：如果两个被继承接口有同名函数，函数签名完全相同的话，应该是不需要去管，实现一遍就行</p><p>冲突2：但如果是同方法名不同签名呢？Go不支持函数重载，会冲突导致编译错误</p><p>解决：需要InterfaceC中定义一个同名的方法，覆盖掉两个被继承接口里的同名方法</p></li><li><p>空接口：没有任何方法的接口 (即所有类型均实现了空接口)</p><p>妙用：可以用该方法来定义接受任意类型的形参，做类似泛型的效果</p><p>类似 JavaScript 中所有类的祖先都是 Object</p></li><li><p>interface类型默认是一个指针，如果没对interface初始化则为nil</p></li></ol><h2 id="三大特性-3-多态" tabindex="-1"><a class="header-anchor" href="#三大特性-3-多态"><span>三大特性 (3) 多态</span></a></h2><h3 id="派生类转基类" tabindex="-1"><a class="header-anchor" href="#派生类转基类"><span>派生类转基类</span></a></h3><p>并非通过继承关系的里氏替换原则，而是通过接口实现的，也就是所谓的鸭子方法</p><p>鸭子方法的多态非常简单</p><p>接口体现多态特征</p><ul><li><p>多态参数</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">greet</span><span class="token punctuation">(</span>s SayHello<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// 这里允许所有有该接口的变量传入 (无论是类还是自定义变量等)</span>
    s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>多态数组</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>SayHello
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> American<span class="token punctuation">{</span><span class="token string">&quot;rose&quot;</span><span class="token punctuation">}</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Chinese<span class="token punctuation">{</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="基类转派生类" tabindex="-1"><a class="header-anchor" href="#基类转派生类"><span>基类转派生类</span></a></h3><p>这里可以通过Go的类型断言来实现，详见断言一章</p>`,77),l=[p];function i(o,c){return s(),a("div",null,l)}const d=n(t,[["render",i],["__file","01_对象和类.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Go/06_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB.html","title":"对象和类","lang":"zh-CN","frontmatter":{"description":"对象和类 (摘自“语言区别”一章) Go中的面向对象 与其他语言不同： 各语言中，什么是类 / 对象 / 面向对象语言 什么是类？ （结合下一节一起看） 类：我个人认为只要能将数据和方法绑定在一起，且能实现面向对象三大特性 (封装/继承/多态)，都能称之为类。 Class类 (大多数语言，如C++、Java、C#)：用 Class 关键字声明类，这是传...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/Go/06_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"对象和类"}],["meta",{"property":"og:description","content":"对象和类 (摘自“语言区别”一章) Go中的面向对象 与其他语言不同： 各语言中，什么是类 / 对象 / 面向对象语言 什么是类？ （结合下一节一起看） 类：我个人认为只要能将数据和方法绑定在一起，且能实现面向对象三大特性 (封装/继承/多态)，都能称之为类。 Class类 (大多数语言，如C++、Java、C#)：用 Class 关键字声明类，这是传..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"对象和类\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"对象和类","slug":"对象和类","link":"#对象和类","children":[{"level":2,"title":"(摘自“语言区别”一章) Go中的面向对象","slug":"摘自-语言区别-一章-go中的面向对象","link":"#摘自-语言区别-一章-go中的面向对象","children":[{"level":3,"title":"什么是类？","slug":"什么是类","link":"#什么是类","children":[]},{"level":3,"title":"什么是对象？","slug":"什么是对象","link":"#什么是对象","children":[]},{"level":3,"title":"什么是面向对象语言？","slug":"什么是面向对象语言","link":"#什么是面向对象语言","children":[]}]},{"level":2,"title":"“类”/结构体 (type ... struct)","slug":"类-结构体-type-struct","link":"#类-结构体-type-struct","children":[{"level":3,"title":"类型定义","slug":"类型定义","link":"#类型定义","children":[]},{"level":3,"title":"声明定义、使用 (四种方式)","slug":"声明定义、使用-四种方式","link":"#声明定义、使用-四种方式","children":[]},{"level":3,"title":"通用方法","slug":"通用方法","link":"#通用方法","children":[{"level":4,"title":"转换","slug":"转换","link":"#转换","children":[]}]},{"level":3,"title":"类方法","slug":"类方法","link":"#类方法","children":[{"level":4,"title":"定义，自定义方法","slug":"定义-自定义方法","link":"#定义-自定义方法","children":[]},{"level":4,"title":"为非结构体绑定方法","slug":"为非结构体绑定方法","link":"#为非结构体绑定方法","children":[]},{"level":4,"title":"特殊方法 —— String()","slug":"特殊方法-——-string","link":"#特殊方法-——-string","children":[]}]},{"level":3,"title":"底层原理","slug":"底层原理","link":"#底层原理","children":[{"level":4,"title":"函数和方法区别","slug":"函数和方法区别","link":"#函数和方法区别","children":[]}]},{"level":3,"title":"扩展","slug":"扩展","link":"#扩展","children":[{"level":4,"title":"跨包创建结构体","slug":"跨包创建结构体","link":"#跨包创建结构体","children":[]}]}]},{"level":2,"title":"三大特性 (1) 封装","slug":"三大特性-1-封装","link":"#三大特性-1-封装","children":[]},{"level":2,"title":"三大特性 (2) 继承","slug":"三大特性-2-继承","link":"#三大特性-2-继承","children":[{"level":3,"title":"通用","slug":"通用","link":"#通用","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]}]},{"level":2,"title":"接口 (type ... interface)","slug":"接口-type-interface","link":"#接口-type-interface","children":[{"level":3,"title":"类型定义","slug":"类型定义-1","link":"#类型定义-1","children":[]},{"level":3,"title":"声明定义、使用","slug":"声明定义、使用","link":"#声明定义、使用","children":[]},{"level":3,"title":"注意事项","slug":"注意事项-1","link":"#注意事项-1","children":[]}]},{"level":2,"title":"三大特性 (3) 多态","slug":"三大特性-3-多态","link":"#三大特性-3-多态","children":[{"level":3,"title":"派生类转基类","slug":"派生类转基类","link":"#派生类转基类","children":[]},{"level":3,"title":"基类转派生类","slug":"基类转派生类","link":"#基类转派生类","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":15.15,"words":4544},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/Go/06_面向对象/面向对象/01_对象和类.md","autoDesc":true}');export{d as comp,k as data};
