import{_ as l,c as s,e as a,o as e}from"./app-CcegWvWz.js";const n="/assets/image-20240228220139063-BFsx_unB.png",t="/assets/image-20240228220150918-CBYLwp-P.png",p="/assets/image-20240228220621158-FrL5_u9b.png",h={};function r(d,i){return e(),s("div",null,i[0]||(i[0]=[a(`<h1 id="操作系统-cpu管理" tabindex="-1"><a class="header-anchor" href="#操作系统-cpu管理"><span>操作系统 - CPU管理</span></a></h1><h2 id="启动流程" tabindex="-1"><a class="header-anchor" href="#启动流程"><span>启动流程</span></a></h2><p>细节不同系统不同</p><p>物理存储</p><ul><li>磁盘 <ul><li>Bootloader (且在磁盘的第一个主引导扇区，且512MB。自己写系统的话首先就会先接触这个东西)</li><li>OS</li></ul></li><li>主板内存 <ul><li>BIOS</li></ul></li></ul><p>流程</p><ol><li>CPU执行BIOS指令：(1) 自检，(2) 加载 BootLoader 的内存</li><li>CPU执行BootLoader指令：将OS和数据加载到内存</li><li>CPU执行OS指令：(1) 开始操作系统初始化工作，(2) 创建各种应用，(3) 直至启动完成</li></ol><p>操作系统、CPU、内存三者 关系：CPU不断从内存中取出操作系统/应用的指令执行</p><h2 id="内核态-vs-用户态" tabindex="-1"><a class="header-anchor" href="#内核态-vs-用户态"><span>内核态 vs 用户态</span></a></h2><h3 id="vs" tabindex="-1"><a class="header-anchor" href="#vs"><span>vs</span></a></h3><p>运行的东西</p><ul><li>软件 <ul><li>用户态：应用程序、用户接口程序</li><li>内核态：操作系统</li></ul></li><li>硬件</li></ul><p>权限</p><ul><li>用户态：只能执行一部分机器指令 (mov、add、sub、push、ret ……)</li><li>内核态：完全访问所有的硬件 (in、out、……等特权指令，能控制计算机、直接操作硬件)</li></ul><p>定义</p><ul><li>用户态：应用程序在运行时CPU所属的状态，此时CPU为低级别，不能直接访问某些机器指令，或不能直接访问I/O</li><li>内核态：操作系统在运行CPU所属的状态，此时CPU为高级别，可以运行任何指令（包括特权指令、直接访问I/O）</li></ul><h3 id="系统调用-用户态和内核态的切换" tabindex="-1"><a class="header-anchor" href="#系统调用-用户态和内核态的切换"><span>系统调用 - 用户态和内核态的切换</span></a></h3><h4 id="用户态-陷入-trap-内核态" tabindex="-1"><a class="header-anchor" href="#用户态-陷入-trap-内核态"><span>用户态**陷入(trap)**内核态</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> c </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, c);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用链：（从上往下）</p><ol><li>用户态部分 <ol><li>应用程序部分 <ol><li>main()</li></ol></li><li>用户接口程序 (库函数 glibc) <ol><li>printf()</li><li>……</li><li>用户态write()</li></ol></li></ol></li><li>内核态部分 <ol><li>内核态write()</li><li>……</li><li>sys_write()</li><li><strong>out</strong></li></ol></li></ol><p>这里面</p><ul><li>用户态调用用户态函数有栈</li><li>内核态调用内核态函数，也有个内核栈</li><li>问题在于 —— 如何从用户态**陷入(trap)**内核态。方法： <ul><li>linux 32位操作系统：80中断</li><li>linux 64位操作系统：syscall 汇编指令</li></ul></li></ul><h5 id="_80软中断" tabindex="-1"><a class="header-anchor" href="#_80软中断"><span>80软中断</span></a></h5><p>write()会使用 <code>ENTER_KERNEL</code>，产生中断的指令，int $0x80</p><p>然后CPU会指向：系统调用中断服务程序 entry_INT80_32</p><p>……</p><p>系统调用号，用来查 系统调用表 (sys_call_table)</p><p>……</p><ol><li>用户态的寄存器保存到 pt_regs 中</li><li>在 sys_call_table 中根据调用号找到对应的函数</li><li>执行函数实现，将返回值写入 pt_regs 的 ax 位置</li><li>通过指令 iret 根据 pt_regs 恢复用户态程序</li></ol><p>64位过程差不多</p><h5 id="syscall-汇编指令" tabindex="-1"><a class="header-anchor" href="#syscall-汇编指令"><span>syscall 汇编指令</span></a></h5><p>特殊模块寄存器 (Model Specific Registers, MSR)</p><p>……</p><p>……</p><h4 id="内核态回用户态" tabindex="-1"><a class="header-anchor" href="#内核态回用户态"><span>内核态回用户态</span></a></h4><p>无</p><h2 id="cpu-和-io-设备交互" tabindex="-1"><a class="header-anchor" href="#cpu-和-io-设备交互"><span>CPU 和 IO 设备交互</span></a></h2><p>操作系统如何和外设交互，两种方式：</p><ul><li>汇编指令：in、out、mov 等 (通常都是特权指令)</li><li>中断机制</li></ul><h3 id="方式一-汇编方式" tabindex="-1"><a class="header-anchor" href="#方式一-汇编方式"><span>方式一：汇编方式</span></a></h3><h4 id="分层架构与总线" tabindex="-1"><a class="header-anchor" href="#分层架构与总线"><span>分层架构与总线</span></a></h4><p><img src="`+n+'" alt="image-20240228220139063" loading="lazy"></p><h4 id="设备控制器" tabindex="-1"><a class="header-anchor" href="#设备控制器"><span>设备控制器</span></a></h4><ul><li>设备控制器 <ul><li>命令寄存器</li><li>数据寄存器</li><li>状态寄存器</li><li>接口控制电路</li></ul></li></ul><p><img src="'+t+'" alt="image-20240228220150918" loading="lazy"></p><p>轮询 / 忙等待</p><p><img src="'+p+'" alt="image-20240228220621158" loading="lazy"></p><h4 id="端口映射io-和-内存映射io" tabindex="-1"><a class="header-anchor" href="#端口映射io-和-内存映射io"><span>端口映射IO 和 内存映射IO</span></a></h4><p>Out指令，如：<code>out 0x03B0 EAX</code>，这里的0x03B0是数据寄存器</p><ul><li><p>CPU怎么知道将数据给哪个控制器的寄存器？</p><ul><li><p>方式一：端口映射IO。操作系统为每个控制器中的寄存器设置唯一的端口号</p><p>方式二：内存映射IO。把IO设备的各个寄存器都编址，看成 “内存地址”</p><p>两种方式都有，各位有优缺点。</p><p>Windows可以这样查看：设备管理器 &gt; 选中设备右击属性 &gt; 资源 标签栏 &gt; 资源类型，会看到 “内存范围” 和 “IO范围”，分别是内存映射IO和端口映射IO</p></li></ul></li></ul><h3 id="方式二-中断机制-键盘原理" tabindex="-1"><a class="header-anchor" href="#方式二-中断机制-键盘原理"><span>方式二：中断机制 - 键盘原理</span></a></h3><p>为什么需要中断机制：在上面的基础上，不忙等待，而是充分利用CPU时间，提高CPU利用率</p><p>例如CPU通知打印机打印，并去做其他事了，那CPU怎么知道打印机设备完成了？</p><h4 id="键盘原理" tabindex="-1"><a class="header-anchor" href="#键盘原理"><span>键盘原理</span></a></h4><ol><li>键盘：输入字符 -&gt; 键盘编码器</li><li>键盘编码器：知道按了什么，上报数据给键盘控制器</li><li>键盘控制器：解码保存数据到数据寄存器</li><li>中断控制器：由中断控制器发起中断请求 (InterruptRequest)，将对应的键盘中断号发给CPU <ul><li>Windows可以这样查看：设备管理器 &gt; 选中键盘右击属性 &gt; 资源 &gt; IRQ (InterruptRequestQuest)</li></ul></li><li>CPU：维护一张中断向量表 (map&lt;中断号, 中断服务程序内存基地址&gt;)，然后CPU找到对应的地址中，对应的是 “键盘中断服务程序” <ul><li>向量表在系统初始化时就有了</li></ul></li><li>中断服务程序：具体流程 <ul><li>(1) 保存之前程序的状态</li><li>(2) IN EAX 0x03FA (将这个地址写到寄存器中)</li><li>(3) OUT 0x06B1 EAX (将寄存器内容输出到显卡)</li><li>(4) 恢复之前的程序状态</li></ul></li></ol><p>Q：中断后，CPU寄存器状态存在哪？rip、rsp、状态寄存器等，放在内存中</p><h4 id="中断机制如何提高cpu利用率" tabindex="-1"><a class="header-anchor" href="#中断机制如何提高cpu利用率"><span>中断机制如何提高CPU利用率</span></a></h4><p>（步骤序号根据打印机中断服务程序来）</p><ol><li><p>CPU指向应用程序1：该程序为打印字符串</p></li><li><p>CPU指向内核态：处理out命令进行打印，而后打印机需要10ms来处理，但CPU不等待</p></li><li><p>CPU指向应用程序2：处理其他东西 (打印机正在打印的同时)</p><p>打印机完成后，直到发出中断信号给中断控制器，中断控制器再告诉CPU</p><p>CPU去中断向量表去找，根据中断号找到 “中断服务程序内存基地址”</p></li><li><p>CPU指向打印机中断服务程序：继续处理打印相关的事项，从步骤二开始循环流程，直到中断服务程序的所有事件处理完成</p></li><li><p>CPU指向回应用程序1</p></li></ol><h3 id="dma再加速-dma-中断" tabindex="-1"><a class="header-anchor" href="#dma再加速-dma-中断"><span>DMA再加速 (DMA+中断)</span></a></h3><p>前面还是比较慢，打印1个字符中断一次，原因在于CPU参与的移动比较多</p><p>可以使用 DMA (DIrect Memory Access，直接内存访问) 机制减少CPU开销。</p><p>DMA是什么：</p><blockquote><p>DMA控制器是设备上配套的，如打印机有打印机的DMA控制器，磁盘有磁盘的DMA控制器。</p><p>DMA内容：</p><ul><li>数据源地址</li><li>数据目的地址</li><li>数据长度</li></ul></blockquote><p>新流程</p><ol><li>CPU设置DMA控制器，设置完后，其他事情都交给DMA控制器。CPU不再参与移动，DMA参与移动</li><li>DMA负责持续从内存中读取字符，并交给打印机，将所有输出完成后，才再来通知CPU返回打印机中断服务程序</li></ol><p>这种方式，不会再那么频繁去用CPU</p>',68)]))}const c=l(h,[["render",r],["__file","02. CPU管理.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20(%E9%9D%A2%E8%AF%95%E7%89%88)/02.%20CPU%E7%AE%A1%E7%90%86.html","title":"操作系统 - CPU管理","lang":"zh-CN","frontmatter":{"description":"操作系统 - CPU管理 启动流程 细节不同系统不同 物理存储 磁盘 Bootloader (且在磁盘的第一个主引导扇区，且512MB。自己写系统的话首先就会先接触这个东西) OS 主板内存 BIOS 流程 CPU执行BIOS指令：(1) 自检，(2) 加载 BootLoader 的内存 CPU执行BootLoader指令：将OS和数据加载到内存 CP...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20(%E9%9D%A2%E8%AF%95%E7%89%88)/02.%20CPU%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"操作系统 - CPU管理"}],["meta",{"property":"og:description","content":"操作系统 - CPU管理 启动流程 细节不同系统不同 物理存储 磁盘 Bootloader (且在磁盘的第一个主引导扇区，且512MB。自己写系统的话首先就会先接触这个东西) OS 主板内存 BIOS 流程 CPU执行BIOS指令：(1) 自检，(2) 加载 BootLoader 的内存 CPU执行BootLoader指令：将OS和数据加载到内存 CP..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"操作系统 - CPU管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"操作系统 - CPU管理","slug":"操作系统-cpu管理","link":"#操作系统-cpu管理","children":[{"level":2,"title":"启动流程","slug":"启动流程","link":"#启动流程","children":[]},{"level":2,"title":"内核态 vs 用户态","slug":"内核态-vs-用户态","link":"#内核态-vs-用户态","children":[{"level":3,"title":"vs","slug":"vs","link":"#vs","children":[]},{"level":3,"title":"系统调用 - 用户态和内核态的切换","slug":"系统调用-用户态和内核态的切换","link":"#系统调用-用户态和内核态的切换","children":[{"level":4,"title":"用户态**陷入(trap)**内核态","slug":"用户态-陷入-trap-内核态","link":"#用户态-陷入-trap-内核态","children":[{"level":5,"title":"80软中断","slug":"_80软中断","link":"#_80软中断","children":[]},{"level":5,"title":"syscall 汇编指令","slug":"syscall-汇编指令","link":"#syscall-汇编指令","children":[]}]},{"level":4,"title":"内核态回用户态","slug":"内核态回用户态","link":"#内核态回用户态","children":[]}]}]},{"level":2,"title":"CPU 和 IO 设备交互","slug":"cpu-和-io-设备交互","link":"#cpu-和-io-设备交互","children":[{"level":3,"title":"方式一：汇编方式","slug":"方式一-汇编方式","link":"#方式一-汇编方式","children":[{"level":4,"title":"分层架构与总线","slug":"分层架构与总线","link":"#分层架构与总线","children":[]},{"level":4,"title":"设备控制器","slug":"设备控制器","link":"#设备控制器","children":[]},{"level":4,"title":"端口映射IO 和 内存映射IO","slug":"端口映射io-和-内存映射io","link":"#端口映射io-和-内存映射io","children":[]}]},{"level":3,"title":"方式二：中断机制 - 键盘原理","slug":"方式二-中断机制-键盘原理","link":"#方式二-中断机制-键盘原理","children":[{"level":4,"title":"键盘原理","slug":"键盘原理","link":"#键盘原理","children":[]},{"level":4,"title":"中断机制如何提高CPU利用率","slug":"中断机制如何提高cpu利用率","link":"#中断机制如何提高cpu利用率","children":[]}]},{"level":3,"title":"DMA再加速 (DMA+中断)","slug":"dma再加速-dma-中断","link":"#dma再加速-dma-中断","children":[]}]}]}],"git":{},"readingTime":{"minutes":5.71,"words":1714},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/操作系统 (面试版)/02. CPU管理.md","excerpt":"\\n<h2>启动流程</h2>\\n<p>细节不同系统不同</p>\\n<p>物理存储</p>\\n<ul>\\n<li>磁盘\\n<ul>\\n<li>Bootloader (且在磁盘的第一个主引导扇区，且512MB。自己写系统的话首先就会先接触这个东西)</li>\\n<li>OS</li>\\n</ul>\\n</li>\\n<li>主板内存\\n<ul>\\n<li>BIOS</li>\\n</ul>\\n</li>\\n</ul>\\n<p>流程</p>\\n<ol>\\n<li>CPU执行BIOS指令：(1) 自检，(2) 加载 BootLoader 的内存</li>\\n<li>CPU执行BootLoader指令：将OS和数据加载到内存</li>\\n<li>CPU执行OS指令：(1) 开始操作系统初始化工作，(2) 创建各种应用，(3) 直至启动完成</li>\\n</ol>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/操作系统 (面试版)/02. CPU管理.md","value":{"title":"02. CPU管理","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/操作系统 (面试版)/02. CPU管理.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{c as comp,k as data};
