import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as l,c,a as n,b as a,d as t,e}from"./app-FiwKXEJX.js";const i={},r=e('<h1 id="md与元数据原理" tabindex="-1"><a class="header-anchor" href="#md与元数据原理"><span>Md与元数据原理</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="md与元数据原理-1" tabindex="-1"><a class="header-anchor" href="#md与元数据原理-1"><span>Md与元数据原理</span></a></h1><p>参考：</p>',4),u={href:"https://blog.csdn.net/junecscscs/article/details/89435699",target:"_blank",rel:"noopener noreferrer"},d=n("h2",{id:"ast-abstract-syntax-tree-抽象语法树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#ast-abstract-syntax-tree-抽象语法树"},[n("span",null,"AST (Abstract Syntax Tree，抽象语法树)")])],-1),k=n("p",null,"参考：",-1),m={href:"https://www.jianshu.com/p/6fa90ee14d0e",target:"_blank",rel:"noopener noreferrer"},h={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md",target:"_blank",rel:"noopener noreferrer"},v={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fblog.arvinh.info%2F2018%2F08%2F25%2Fvisit-ast-with-babel-plugin%2F",target:"_blank",rel:"noopener noreferrer"},b={href:"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.imooc.com%2Farticle%2F290884",target:"_blank",rel:"noopener noreferrer"},g=n("p",null,"（详见 Computer > 编译原理 > AST 笔记）",-1),_=n("h2",{id:"md解析原理-lute工具",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#md解析原理-lute工具"},[n("span",null,"Md解析原理（Lute工具）")])],-1),f={href:"https://88250.b3log.org/articles/2020/04/23/1587637426085.html",target:"_blank",rel:"noopener noreferrer"},y=n("h3",{id:"这篇文章中涉及的开源项目",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#这篇文章中涉及的开源项目"},[n("span",null,"这篇文章中涉及的开源项目")])],-1),w={href:"https://github.com/commonmark/commonmark-spec",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/88250/lute",target:"_blank",rel:"noopener noreferrer"},x={href:"https://github.com/Vanessa219/vditor",target:"_blank",rel:"noopener noreferrer"},A=e(`<h3 id="编译原理" tabindex="-1"><a class="header-anchor" href="#编译原理"><span>编译原理</span></a></h3><p>我们通过编译原理实现了 Lute ，大致步骤是 ① 预处理、② 词法分析、③ 语法分析、④ 代码生成 这几个步骤。</p><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h3><p>Lute 的使用</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Markdown 将 markdown 文本字节数组处理为相应的 html 字节数组。</span>
<span class="token comment">// name 参数仅用于标识文本，比如可传入 id 或者标题，也可以传入 &quot;&quot;。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>lute <span class="token operator">*</span>Lute<span class="token punctuation">)</span> <span class="token function">Markdown</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> markdown <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>html <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	tree <span class="token operator">:=</span> parse<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> markdown<span class="token punctuation">,</span> lute<span class="token punctuation">.</span>Options<span class="token punctuation">)</span>
	renderer <span class="token operator">:=</span> render<span class="token punctuation">.</span><span class="token function">NewHtmlRenderer</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span>
	html <span class="token operator">=</span> renderer<span class="token punctuation">.</span><span class="token function">Render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析过程用于从 Markdown 原文构造抽象语法树。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Parse 会将 markdown 原始文本字节数组解析为一颗语法树。</span>
<span class="token keyword">func</span> <span class="token function">Parse</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> markdown <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> options <span class="token operator">*</span>Options<span class="token punctuation">)</span> <span class="token punctuation">(</span>tree <span class="token operator">*</span>Tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	tree <span class="token operator">=</span> <span class="token operator">&amp;</span>Tree<span class="token punctuation">{</span>Name<span class="token punctuation">:</span> name<span class="token punctuation">,</span> Context<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Context<span class="token punctuation">{</span>Option<span class="token punctuation">:</span> options<span class="token punctuation">}</span><span class="token punctuation">}</span>
	tree<span class="token punctuation">.</span>Context<span class="token punctuation">.</span>Tree <span class="token operator">=</span> tree
	tree<span class="token punctuation">.</span>lexer <span class="token operator">=</span> lex<span class="token punctuation">.</span><span class="token function">NewLexer</span><span class="token punctuation">(</span>markdown<span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span>Root <span class="token operator">=</span> <span class="token operator">&amp;</span>ast<span class="token punctuation">.</span>Node<span class="token punctuation">{</span>Type<span class="token punctuation">:</span> ast<span class="token punctuation">.</span>NodeDocument<span class="token punctuation">}</span>
	tree<span class="token punctuation">.</span><span class="token function">parseBlocks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span><span class="token function">parseInlines</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span>lexer <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码结构方面我们分为两部分：解析和渲染</p><ul><li>渲染过程将遍历语法树生成 HTML 代码，本文略过</li><li>解析过程下面我们将着重介绍，从预处理阶段开始</li></ul><h4 id="_1-预处理" tabindex="-1"><a class="header-anchor" href="#_1-预处理"><span>① 预处理</span></a></h4><p>预处理阶段主要是将输入的 Markdown 文本字节数组结尾添加换行符 <code>\\n</code>，以方便后续解析可以统一按行读取。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>
<span class="token comment">// NewLexer 创建一个词法分析器。</span>
<span class="token keyword">func</span> <span class="token function">NewLexer</span><span class="token punctuation">(</span>input <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ret <span class="token operator">*</span>Lexer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ret <span class="token operator">=</span> <span class="token operator">&amp;</span>Lexer<span class="token punctuation">{</span><span class="token punctuation">}</span>
	ret<span class="token punctuation">.</span>input <span class="token operator">=</span> input
	ret<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> ret<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> ItemNewline <span class="token operator">!=</span> ret<span class="token punctuation">.</span>input<span class="token punctuation">[</span>ret<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
		<span class="token comment">// 以 \\n 结尾预处理</span>
		ret<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>input<span class="token punctuation">,</span> ItemNewline<span class="token punctuation">)</span>
		ret<span class="token punctuation">.</span>length<span class="token operator">++</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-词法分析" tabindex="-1"><a class="header-anchor" href="#_2-词法分析"><span>② 词法分析</span></a></h4><p>词法分析的目的是将 Markdown 文本转换为 token 数组。标准的编译原理中词法分析产生的 token 将带有如下这样一些属性：</p><ul><li>类型（token type），比如标识符、操作符、数字、字符等</li><li>词素（lexeme），原始的文本字节数组</li><li>位置（pos），该 token 的第一个字节相对于整个文本字节数组的下标</li></ul><p>Markdown 的词法分析进行了简化，仅返回词素作为 token，因为：</p>`,16),E=n("li",null,[a("Markdown 解析不需要类型信息，使用的标记符（比如 "),n("code",null,"#"),a("、"),n("code",null,"*"),a(" 等）本身就是 token 类型和词素")],-1),F={href:"https://88250.b3log.org/articles/2020/04/23/1587637426085.html#sourcemap",target:"_blank",rel:"noopener noreferrer"},L=n("li",null,"提升性能",-1),S=e(`<p>另外，编译原理教科书中是将词法分析和语法分析完全分开介绍的，即词法分析器产生 token 数组后作为参数传入语法分析器，而实际工程上因为性能考虑，是在语法分析中调用词法分析来按需获得 token 数组，这样可以减少内存分配。</p><p>Markdown 词法分析的具体实现是按行进行处理的，每次处理后词法分析器会记录当前读取位置，以便下次继续按行处理。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>
<span class="token comment">// Lexer 描述了词法分析器结构。</span>
<span class="token keyword">type</span> Lexer <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	input  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token comment">// 输入的文本字节数组</span>
	length <span class="token builtin">int</span>    <span class="token comment">// 输入的文本字节数组的长度</span>
	offset <span class="token builtin">int</span>    <span class="token comment">// 当前读取字节位置</span>
	width  <span class="token builtin">int</span>    <span class="token comment">// 最新一个字符的长度（字节数）</span>
<span class="token punctuation">}</span>

<span class="token comment">// NextLine 返回下一行。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Lexer<span class="token punctuation">)</span> <span class="token function">NextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ret <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> l<span class="token punctuation">.</span>offset <span class="token operator">&gt;=</span> l<span class="token punctuation">.</span>length <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> b<span class="token punctuation">,</span> nb <span class="token builtin">byte</span>
	i <span class="token operator">:=</span> l<span class="token punctuation">.</span>offset
	<span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> l<span class="token punctuation">.</span>width <span class="token punctuation">{</span>
		b <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> ItemNewline <span class="token operator">==</span> b <span class="token punctuation">{</span>
			i<span class="token operator">++</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> ItemCarriageReturn <span class="token operator">==</span> b <span class="token punctuation">{</span>
			<span class="token comment">// 处理 \\r</span>
			<span class="token keyword">if</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
				nb <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
				<span class="token keyword">if</span> ItemNewline <span class="token operator">==</span> nb <span class="token punctuation">{</span>
					l<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 移除 \\r，依靠下一个的 \\n 切行</span>
					l<span class="token punctuation">.</span>length<span class="token operator">--</span>                                      <span class="token comment">// 重新计算总长</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			i<span class="token operator">++</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token char">&#39;\\u0000&#39;</span> <span class="token operator">==</span> b <span class="token punctuation">{</span>
			<span class="token comment">// 将 \\u0000 替换为 \\uFFFD</span>
			l<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token function">copy</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token comment">// \\uFFFD 的 UTF-8 编码为 \\xEF\\xBF\\xBD 共三个字节</span>
			l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;\\xEF&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;\\xBF&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;\\xBD&#39;</span>
			l<span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token number">2</span> <span class="token comment">// 重新计算总长</span>
			l<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">3</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> utf8<span class="token punctuation">.</span>RuneSelf <span class="token operator">&lt;=</span> b <span class="token punctuation">{</span> <span class="token comment">// 说明占用多个字节</span>
			<span class="token boolean">_</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>width <span class="token operator">=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRune</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			l<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">1</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	ret <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>l<span class="token punctuation">.</span>offset<span class="token punctuation">:</span>i<span class="token punctuation">]</span>
	l<span class="token punctuation">.</span>offset <span class="token operator">=</span> i
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-语法分析" tabindex="-1"><a class="header-anchor" href="#_3-语法分析"><span>③ 语法分析</span></a></h4>`,4),T={href:"https://spec.commonmark.org/0.29/#appendix-a-parsing-strategy",target:"_blank",rel:"noopener noreferrer"},B=n("ol",null,[n("li",null,"构造所有块级节点，包括标题、块引用、代码块、分隔线、列表、段落等，还需要构造好链接引用定义映射表"),n("li",null,"遍历每个块级节点，构造行级节点，包括文本、链接、强调、加粗等，链接的处理可能会需要查找步骤 1 中构造好的链接引用定义映射表")],-1),N={href:"https://hacpai.com/article/1566893557720",target:"_blank",rel:"noopener noreferrer"},C={href:"https://hacpai.com/article/1567062979327",target:"_blank",rel:"noopener noreferrer"},D=e('<h4 id="_4-代码生成" tabindex="-1"><a class="header-anchor" href="#_4-代码生成"><span>④ 代码生成</span></a></h4><h3 id="抽象语法树" tabindex="-1"><a class="header-anchor" href="#抽象语法树"><span>抽象语法树</span></a></h3><p>Markdown 抽象语法树是由节点构成的树，从包含关系来说节点可以分为四类：</p><ol><li>根节点，可以包含所有其他任意节点</li><li>块级容器节点，可以包含非根节点的其他任意节点，比如列表项包含段落</li><li>块级节点，可以包含行级节点，比如段落包含强调</li><li>行级节点，可以包含行级节点，比如强调包含文本</li></ol><p>我们在实现 Lute 时做了“最细粒度”的节点结构，比如对于超链接 <code>[foo](bar)</code> 形成的节点结构包含了左方括号 <code>[</code>、链接文本 <code>foo</code>、右方括号 <code>]</code>、左圆括号 <code>(</code>、链接地址 <code>bar</code> 和右圆括号 <code>)</code>。这样做的优点是方便处理细致的节点操作，缺点是性能稍差，因为需要构造和遍历更多的节点。</p>',5),P={href:"https://github.com/Vanessa219/vditor",target:"_blank",rel:"noopener noreferrer"},Y={href:"https://hacpai.com/guide/markdown",target:"_blank",rel:"noopener noreferrer"},j={href:"https://github.com/88250/lute/blob/master/ast/node.go",target:"_blank",rel:"noopener noreferrer"},J=e('<h2 id="元数据-metadata-前辅文-front-matter" tabindex="-1"><a class="header-anchor" href="#元数据-metadata-前辅文-front-matter"><span>元数据 (Metadata) / 前辅文 (Front Matter)</span></a></h2><p>元数据 (Metadata）也叫 MdMeta 或 frontmatter（前辅文、前页）</p><p>这是给诸如<code> Jekyll</code> 这类静态页面生成器 (SSG) 用的</p><p>程序可以抽取 Markdown 文件中 frontmatter——就是你标记的那部分——的数据 用来确定：<strong>URL</strong>、<strong>显示标签</strong>跟<strong>文章分类</strong>，乃至是根据特定字段选择对应的<strong>页面布局</strong>，显示特定的<strong>题图</strong>，等等。</p><p>当然这些功能需要在 SSG 的主题系统中写好</p><h3 id="md元数据的三种格式" tabindex="-1"><a class="header-anchor" href="#md元数据的三种格式"><span>Md元数据的三种格式</span></a></h3><p>参考：https://qa.1r1g.com/sf/ask/3095112751/（搬运于overflow）</p><p>有两种常见的格式看起来非常相似,但在某些非常具体的方面实际上是不同的.第三个是非常不同的.</p><h4 id="yaml元数据-yaml-front-matter" tabindex="-1"><a class="header-anchor" href="#yaml元数据-yaml-front-matter"><span>YAML元数据 (YAML Front Matter)</span></a></h4>',9),V={href:"http://www.yaml.org/spec/1.2/spec.html#id2760395",target:"_blank",rel:"noopener noreferrer"},I=n("strong",null,"破折号实际上是YAML语法的一部分",-1),R={href:"https://jekyllrb.com/docs/frontmatter/",target:"_blank",rel:"noopener noreferrer"},O=e(`<div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token punctuation">---</span>
<span class="token key atrule">layout</span><span class="token punctuation">:</span> post
<span class="token key atrule">title</span><span class="token punctuation">:</span> Blogging Like a Hacker
<span class="token punctuation">---</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，Markdown解析器不会解析YAML前端问题，但会在Jekyll（或您正在使用的任何工具）解析之前将其删除，并且实际上可以用于请求与该页面的默认Markdown解析器不同的解析器（不要记得Jekyll是否这样做,但我已经看到了一些工具）</p><h4 id="multimarkdown元数据" tabindex="-1"><a class="header-anchor" href="#multimarkdown元数据"><span>MultiMarkdown元数据</span></a></h4>`,3),U={href:"http://fletcher.github.io/MultiMarkdown-5/metadata.html",target:"_blank",rel:"noopener noreferrer"},H=e(`<p>以下是MultiMarkdown文档中的示例：</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">Title</span><span class="token punctuation">:</span>    A Sample MultiMarkdown Document  
<span class="token key atrule">Author</span><span class="token punctuation">:</span>   Fletcher T. Penney  
<span class="token key atrule">Date</span><span class="token punctuation">:</span>     February 9<span class="token punctuation">,</span> <span class="token number">2011</span>  
<span class="token key atrule">Comment</span><span class="token punctuation">:</span>  This is a comment intended to demonstrate  
          metadata that spans multiple lines<span class="token punctuation">,</span> yet  
          is treated as a single value.  
<span class="token key atrule">CSS</span><span class="token punctuation">:</span>      http<span class="token punctuation">:</span>//example.com/standard.css
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MultiMarkdown解析器包含一组对该解析器唯一的附加选项，但键值元数据用于多个解析器。不幸的是，我从未见过任何两个行为完全相同的人。如果没有定义这种格式的Markdown规则，每个人都会做出自己略有不同的解释，从而导致种类繁多. 更常见的一件事是对YAML分隔符和基本键值定义的支持</p><h4 id="pandoc标题栏" tabindex="-1"><a class="header-anchor" href="#pandoc标题栏"><span>Pandoc标题栏</span></a></h4>`,4),q={href:"https://pandoc.org/MANUAL.html#extension-pandoc_title_block",target:"_blank",rel:"noopener noreferrer"},z={href:"https://pandoc.org/MANUAL.html#extension-pandoc_title_block",target:"_blank",rel:"noopener noreferrer"},G=e(`<p>它只支持三种类型的数据：<strong>标题、作者、日期</strong></p><p>以下是Pandoc文档中的示例:</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token directive important">% title</span>
<span class="token directive important">% author(s) (separated by semicolons)</span>
<span class="token directive important">% date</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),Z={href:"https://pandoc.org/MANUAL.html#extension-yaml_metadata_block",target:"_blank",rel:"noopener noreferrer"},K=n("h3",{id:"检索-更新-缓存",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#检索-更新-缓存"},[n("span",null,"检索 更新 缓存")])],-1),Q=n("p",null,"好像并没有这些东西、感觉都是重新遍历的，至少Obsidian的OB Folder和DataView是这样的",-1),W=n("h2",{id:"jekyllrb",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#jekyllrb"},[n("span",null,"Jekyllrb")])],-1);function X($,nn){const s=p("ExternalLinkIcon");return l(),c("div",null,[r,n("ul",null,[n("li",null,[n("a",u,[a("【CSDN】【Markdown】Markdown基础——概述、工作原理以及用途"),t(s)])])]),d,k,n("ul",null,[n("li",null,[n("p",null,[n("a",m,[a("【简书】AST 介绍"),t(s)]),a(" 资源&文章推荐")]),n("ul",null,[n("li",null,[n("p",null,[n("a",h,[a("Babel 插件手册"),t(s)])])]),n("li",null,[n("p",null,[n("a",v,[a("透過製作 Babel-plugin 初訪 AST"),t(s)])])]),n("li",null,[n("p",null,[n("a",b,[a("AST 与前端工程化实战"),t(s)])])])])])]),g,_,n("p",null,[a("参考："),n("a",f,[a("Markdown 解析原理详解和 Markdown AST 描述"),t(s)])]),y,n("ul",null,[n("li",null,[n("a",w,[a("CommonMark Spec"),t(s)])]),n("li",null,[n("a",M,[a("Lute"),t(s)]),a(" 一款对中文语境优化的 Markdown 引擎，支持 Go 和 JavaScript")]),n("li",null,[n("a",x,[a("Vditor"),t(s)]),a(" 一款浏览器端的 Markdown 编辑器，支持所见即所得、即时渲染（类似 Typora）和分屏预览模式")])]),A,n("ul",null,[E,n("li",null,[a("大部分场景下的 Markdown 解析不需要实现"),n("a",F,[a("源码映射"),t(s)])]),L]),S,n("p",null,[a("CommonMark 规范中介绍了一种"),n("a",T,[a("解析算法"),t(s)]),a("，分为两个阶段：")]),B,n("p",null,[a("关于 CommonMark 规范的一些实现细节可参考我之前的笔记（"),n("a",N,[a("CommonMark 规范要点解读"),t(s)]),a("、"),n("a",C,[a("Lute 实现后记"),t(s)]),a("），这里就不展开了，如果感兴趣欢迎跟帖讨论。")]),D,n("p",null,[a("如果你想看到较粗粒度的语法树，可以通过 "),n("a",P,[a("Vditor Markdown 编辑器"),t(s)]),a("的开发者工具来查看，请"),n("a",Y,[a("到此"),t(s)]),a("进行测试（点击编辑器工具栏上的“开发者工具”按钮就可以看到根据输入进行实时渲染的语法树了）。")]),n("p",null,[a("下面我们按 Lute 源码中的"),n("a",j,[a("节点"),t(s)]),a("类型常量顺序来逐一描述。")]),J,n("p",null,[a("Jekyll静态站点生成器推广了YAML前端物质，该物质由"),n("a",V,[a("YAML部分标记"),t(s)]),a("消除。 是的，"),I,a("。并且使用任何有效的YAML语法定义元数据。")]),n("p",null,[a("以下是"),n("a",R,[a("Jekyll文档中的"),t(s)]),a("一个示例:")]),O,n("p",null,[a("较旧且更简单的 "),n("a",U,[a("MultiMarkdown Metadata"),t(s)]),a(" 实际上已合并到一些Markdown解析器中。 虽然它最近更新为可选支持YAML分隔符，但传统上，元数据结束，Markdown文档从第一个空行开始（如果第一行是空白，则没有元数据） 虽然语法看起来与YAML非常相似，但只支持键值对而没有隐含类型")]),H,n("p",null,[a("为了完整"),n("a",q,[a("起见,"),t(s)]),a("还有"),n("a",z,[a("Pandoc Title Block"),t(s)]),a("。如果有一个非常不同的语法，并不容易与其他两个混淆。据我所知，它只受Pandoc支持（如果启用）")]),G,n("p",null,[a("请注意，Pandoc Title Blocks是Pandoc支持的两种样式之一。Pandoc还支持如上所述的"),n("a",Z,[a("YAML元数据"),t(s)]),a("。默认情况下，两个扩展都未启用")]),K,Q,W])}const tn=o(i,[["render",X],["__file","Md与元数据原理.html.vue"]]),en=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Doc/Note%20Skill/Md%E4%B8%8E%E5%85%83%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.html","title":"Md与元数据原理","lang":"zh-CN","frontmatter":{"description":"Md与元数据原理 目录 Md与元数据原理 参考： 【CSDN】【Markdown】Markdown基础——概述、工作原理以及用途 AST (Abstract Syntax Tree，抽象语法树) 参考： 【简书】AST 介绍 资源&文章推荐 Babel 插件手册 透過製作 Babel-plugin 初訪 AST AST 与前端工程化实战 （详见 Com...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Doc/Note%20Skill/Md%E4%B8%8E%E5%85%83%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Md与元数据原理"}],["meta",{"property":"og:description","content":"Md与元数据原理 目录 Md与元数据原理 参考： 【CSDN】【Markdown】Markdown基础——概述、工作原理以及用途 AST (Abstract Syntax Tree，抽象语法树) 参考： 【简书】AST 介绍 资源&文章推荐 Babel 插件手册 透過製作 Babel-plugin 初訪 AST AST 与前端工程化实战 （详见 Com..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Md与元数据原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Md与元数据原理","slug":"md与元数据原理","link":"#md与元数据原理","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"Md与元数据原理","slug":"md与元数据原理-1","link":"#md与元数据原理-1","children":[{"level":2,"title":"AST (Abstract Syntax Tree，抽象语法树)","slug":"ast-abstract-syntax-tree-抽象语法树","link":"#ast-abstract-syntax-tree-抽象语法树","children":[]},{"level":2,"title":"Md解析原理（Lute工具）","slug":"md解析原理-lute工具","link":"#md解析原理-lute工具","children":[{"level":3,"title":"这篇文章中涉及的开源项目","slug":"这篇文章中涉及的开源项目","link":"#这篇文章中涉及的开源项目","children":[]},{"level":3,"title":"编译原理","slug":"编译原理","link":"#编译原理","children":[]},{"level":3,"title":"解析","slug":"解析","link":"#解析","children":[{"level":4,"title":"① 预处理","slug":"_1-预处理","link":"#_1-预处理","children":[]},{"level":4,"title":"② 词法分析","slug":"_2-词法分析","link":"#_2-词法分析","children":[]},{"level":4,"title":"③ 语法分析","slug":"_3-语法分析","link":"#_3-语法分析","children":[]},{"level":4,"title":"④ 代码生成","slug":"_4-代码生成","link":"#_4-代码生成","children":[]}]},{"level":3,"title":"抽象语法树","slug":"抽象语法树","link":"#抽象语法树","children":[]}]},{"level":2,"title":"元数据 (Metadata) / 前辅文 (Front Matter)","slug":"元数据-metadata-前辅文-front-matter","link":"#元数据-metadata-前辅文-front-matter","children":[{"level":3,"title":"Md元数据的三种格式","slug":"md元数据的三种格式","link":"#md元数据的三种格式","children":[{"level":4,"title":"YAML元数据  (YAML Front Matter)","slug":"yaml元数据-yaml-front-matter","link":"#yaml元数据-yaml-front-matter","children":[]},{"level":4,"title":"MultiMarkdown元数据","slug":"multimarkdown元数据","link":"#multimarkdown元数据","children":[]},{"level":4,"title":"Pandoc标题栏","slug":"pandoc标题栏","link":"#pandoc标题栏","children":[]}]},{"level":3,"title":"检索 更新 缓存","slug":"检索-更新-缓存","link":"#检索-更新-缓存","children":[]}]},{"level":2,"title":"Jekyllrb","slug":"jekyllrb","link":"#jekyllrb","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.2,"words":2460},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Doc/Note Skill/Md与元数据原理.md","autoDesc":true}');export{tn as comp,en as data};
