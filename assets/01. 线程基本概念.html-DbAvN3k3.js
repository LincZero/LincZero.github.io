import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as r,c as d,b as l,e,d as t,a as n}from"./app-CyJMR3JQ.js";const c={},h=l("h1",{id:"多线程-线程基本概念",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#多线程-线程基本概念"},[l("span",null,"多线程 - 线程基本概念")])],-1),o=l("p",null,"参考：",-1),p={href:"https://www.bilibili.com/video/BV1Yb411L7ak",target:"_blank",rel:"noopener noreferrer"},u=l("li",null,"《Qt5开发及实例（第四版）》第12章，及配套ppt",-1),g=l("li",null,"《C++并发编程实战（中文版）》，pdf版，（英名《C++ Concurrency In Action》）",-1),_={href:"https://blog.csdn.net/hujingshuang/article/details/70208443",target:"_blank",rel:"noopener noreferrer"},E=n('<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><h3 id="并行、并发" tabindex="-1"><a class="header-anchor" href="#并行、并发"><span>并行、并发</span></a></h3><h4 id="并行" tabindex="-1"><a class="header-anchor" href="#并行"><span>并行</span></a></h4><ul><li>两个或更多的任务同时发生。这里可以在任务管理器中查看线程</li></ul><h4 id="并发" tabindex="-1"><a class="header-anchor" href="#并发"><span>并发</span></a></h4><ul><li>硬件并发</li><li>同时可以干多件事、提高性能</li></ul><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h4><ul><li>并行不等于并发，并发是物理上的同时执行，并行是并发的子级</li><li>旧计算机只有单核cpu，由操作系统调度，每个时间片进行多次任务切换，这种上下文切换需要额外时间开销 只能实现并行，是并发的假象</li><li>现在是的cpu，多核指一个芯片上多个cpu（双核、4核、8核、16核） 这个可以在 “任务管理器 &gt; 性能 &gt; CPU &gt; 右侧右键 &gt; 将图形更改为 &gt; 逻辑处理器” 中查看 能实现真正意义上的并发</li></ul><h3 id="程序、进程、线程" tabindex="-1"><a class="header-anchor" href="#程序、进程、线程"><span>程序、进程、线程</span></a></h3><h4 id="程序-可执行程序" tabindex="-1"><a class="header-anchor" href="#程序-可执行程序"><span>程序（可执行程序）</span></a></h4><ul><li>windows下，扩展名为exe</li><li>linux下，执行ls -la后显示rwx中的x表示执行权限</li></ul><h4 id="进程" tabindex="-1"><a class="header-anchor" href="#进程"><span>进程</span></a></h4><ul><li>进程是运行着的可执行程序</li><li>每个进程都会有一个PID</li><li>一个可执行程序运行起来了，就创建了一个进程。如果运行两次，则会创建两个进程</li></ul><h4 id="线程" tabindex="-1"><a class="header-anchor" href="#线程"><span>线程</span></a></h4><ul><li>主线程：每个进程都有且只有一个自动生成的主线程，主线程也是main函数所在线程</li><li>非主线程：除了主线程，可以通过代码来创建其他线程。线程是用来执行代码的</li><li>缺点：线程不是越多越好，每个线程都需要一个独立的堆栈空间（&gt;1M）且切换需要额外时间开销，不建议超过200~300个</li><li>使用场景：可能阻塞或响应比较慢的代码、网络方面的操作（多线程/异步编程）</li></ul><h4 id="线程id-std-this-thread-get-id" tabindex="-1"><a class="header-anchor" href="#线程id-std-this-thread-get-id"><span>线程id（<code>std::this_thread::get_id()</code>）</span></a></h4><ul><li>概念：每个线程都有一个不重复的线程id</li><li>使用：线程id可以通过<code>std::this_thread::get_id();</code>来获取</li><li>应用：调试时可以打印线程id来方便调试</li></ul><h4 id="进程与线程-查看与查询" tabindex="-1"><a class="header-anchor" href="#进程与线程-查看与查询"><span>进程与线程 查看与查询</span></a></h4><p>查看方法</p><ul><li>可以在 “任务管理器 &gt; 性能 &gt; CPU &gt; 右侧进程与线程” 中查看进程数和线程数</li><li>可以在 “任务管理器 &gt; 进程” 中查看具体进程，且会折叠一个应用中的多个进程</li><li>可以在 “任务管理器 &gt; 用户” 中查看具体进程，但不会显示Winodws进程，且不会折叠一个应用中的多个进程</li></ul><hr><p>通过进程/线程查询</p><ul><li>通过PID查找端口和协议</li><li>CMD方法 <ul><li><code>netstat -ano</code>，列举程序PID和对应的网络端口</li><li><code>netstat -ano | findstr 6636</code>，管道符筛选指定程序PID</li></ul></li><li>PID查找端口和协议：火绒剑方法 <ul><li>图形化界面更直观，也很容易用</li></ul></li></ul><h2 id="并发的实现" tabindex="-1"><a class="header-anchor" href="#并发的实现"><span>并发的实现</span></a></h2><h3 id="两种实现方法" tabindex="-1"><a class="header-anchor" href="#两种实现方法"><span>两种实现方法</span></a></h3><p>两种并发方法</p><ul><li>多进程并发 <ul><li>进程之间通信（同一个电脑上：管道、文件、消息队列、共享内存。不同电脑上：socket通信技术）</li></ul></li><li>多线程并发 <ul><li>有点类似于轻量级进程的感觉，但一个进程中所有线程共享地址空间（共享内存）</li><li>线程之间通信。全局变量、指针、引用等都可以在线程之间传递</li><li>所有使用多线程开销远远小于多进程</li></ul></li><li>比较 <ul><li>建议优先使用多线程，开销小速度快</li><li>但要小心处理数据一致性问题，线程间的共享变量可能造成死锁的出现</li></ul></li></ul><h2 id="多线程-vs-异步编程" tabindex="-1"><a class="header-anchor" href="#多线程-vs-异步编程"><span>多线程 vs 异步编程</span></a></h2>',28),v={href:"https://www.cnblogs.com/yanan-boke/p/9395638.html",target:"_blank",rel:"noopener noreferrer"},b=n(`<p>博文很不错，推荐一看</p><hr><ul><li><p>共同点</p><ul><li>异步和多线程两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性</li></ul></li><li><p>不同点</p><ul><li><p>(1) 线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。</p><ul><li><p>多线程优点：线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。</p></li><li><p>多线程缺点：线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现</p></li></ul></li><li><p>(2) 异步操作无须额外的线程负担，并且使用回调的方式进行处理</p><ul><li><p>异步操作优点：在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少共享变量的数量），减少了死锁的可能</p></li><li><p>异步操作缺点：编写异步操作的复杂程度较高，程序<strong>主要使用回调方式进行处理</strong>，与普通人的思维方式有些 初入，而且难以调试。</p></li></ul></li></ul></li><li><p>总结</p><ul><li>在实际设计时，我们可以将两者结合起来</li><li>异步特别适用于大多数IO密集型的应用程序</li><li>线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行</li></ul></li></ul><h2 id="c-11新标准线程库" tabindex="-1"><a class="header-anchor" href="#c-11新标准线程库"><span>C++11新标准线程库</span></a></h2><h3 id="以前版本" tabindex="-1"><a class="header-anchor" href="#以前版本"><span>以前版本</span></a></h3><p>以往语言本身不支持，通过操作系统接口来实现，这些多线程代码不能跨平台，需要用一些库才能跨平台</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>winodws:
CreateThread();
_beginthread();
_beginthreadexe();
    
linux:
pthread_create();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="c-11" tabindex="-1"><a class="header-anchor" href="#c-11"><span>C++11</span></a></h3><p>C++11开始，提供了对多线程的支持，多线程代码能够跨平台实现</p>`,9);function m(C,f){const i=s("ExternalLinkIcon");return r(),d("div",null,[h,o,l("ul",null,[l("li",null,[l("a",p,[e("【Bilibili】c++11并发与多线程视频课程"),t(i)]),e("（评价：啰嗦、全面但不深，乱糟糟的，最好配合点弹幕，特别是P5）（目前看到P10）")]),u,g,l("li",null,[l("a",_,[e("【CSDN】《探索C++多线程》：thread源码（一）"),t(i)]),e("（未看）")])]),E,l("p",null,[e("参考："),l("a",v,[e("【博客园】异步编程与多线程编程的联系和区别"),t(i)])]),b])}const x=a(c,[["render",m],["__file","01. 线程基本概念.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/01.%20%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html","title":"多线程 - 线程基本概念","lang":"zh-CN","frontmatter":{"description":"多线程 - 线程基本概念 参考： 【Bilibili】c++11并发与多线程视频课程（评价：啰嗦、全面但不深，乱糟糟的，最好配合点弹幕，特别是P5）（目前看到P10） 《Qt5开发及实例（第四版）》第12章，及配套ppt 《C++并发编程实战（中文版）》，pdf版，（英名《C++ Concurrency In Action》） 【CSDN】《探索C++...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/01.%20%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"多线程 - 线程基本概念"}],["meta",{"property":"og:description","content":"多线程 - 线程基本概念 参考： 【Bilibili】c++11并发与多线程视频课程（评价：啰嗦、全面但不深，乱糟糟的，最好配合点弹幕，特别是P5）（目前看到P10） 《Qt5开发及实例（第四版）》第12章，及配套ppt 《C++并发编程实战（中文版）》，pdf版，（英名《C++ Concurrency In Action》） 【CSDN】《探索C++..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多线程 - 线程基本概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"多线程 - 线程基本概念","slug":"多线程-线程基本概念","link":"#多线程-线程基本概念","children":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[{"level":3,"title":"并行、并发","slug":"并行、并发","link":"#并行、并发","children":[{"level":4,"title":"并行","slug":"并行","link":"#并行","children":[]},{"level":4,"title":"并发","slug":"并发","link":"#并发","children":[]},{"level":4,"title":"区别","slug":"区别","link":"#区别","children":[]}]},{"level":3,"title":"程序、进程、线程","slug":"程序、进程、线程","link":"#程序、进程、线程","children":[{"level":4,"title":"程序（可执行程序）","slug":"程序-可执行程序","link":"#程序-可执行程序","children":[]},{"level":4,"title":"进程","slug":"进程","link":"#进程","children":[]},{"level":4,"title":"线程","slug":"线程","link":"#线程","children":[]},{"level":4,"title":"线程id（std::this_thread::get_id()）","slug":"线程id-std-this-thread-get-id","link":"#线程id-std-this-thread-get-id","children":[]},{"level":4,"title":"进程与线程 查看与查询","slug":"进程与线程-查看与查询","link":"#进程与线程-查看与查询","children":[]}]}]},{"level":2,"title":"并发的实现","slug":"并发的实现","link":"#并发的实现","children":[{"level":3,"title":"两种实现方法","slug":"两种实现方法","link":"#两种实现方法","children":[]}]},{"level":2,"title":"多线程 vs 异步编程","slug":"多线程-vs-异步编程","link":"#多线程-vs-异步编程","children":[]},{"level":2,"title":"C++11新标准线程库","slug":"c-11新标准线程库","link":"#c-11新标准线程库","children":[{"level":3,"title":"以前版本","slug":"以前版本","link":"#以前版本","children":[]},{"level":3,"title":"C++11","slug":"c-11","link":"#c-11","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.05,"words":1515},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/04. 优化/多线程/01. 线程基本概念.md","autoDesc":true}');export{x as comp,k as data};
