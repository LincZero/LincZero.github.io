import{_ as e,c as n,e as a,o as i}from"./app-DnpufS1x.js";const l={};function p(t,s){return i(),n("div",null,s[0]||(s[0]=[a(`<h1 id="computersystems" tabindex="-1"><a class="header-anchor" href="#computersystems"><span>ComputerSystems</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="控制" tabindex="-1"><a class="header-anchor" href="#控制"><span>控制</span></a></h1><h2 id="loop-循环" tabindex="-1"><a class="header-anchor" href="#loop-循环"><span>loop 循环</span></a></h2><p>基本使用</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>; 每次执行到\`loop标号\`时会自动将cx减1，并检测cx是否为0，不需要手动完成</span></span>
<span class="line"><span>标号</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>	循环体</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>loop 标号</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>demo：从1加至100的和</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>; 设定循环次数</span></span>
<span class="line"><span>mov cx, 100</span></span>
<span class="line"><span>; 初始化ax</span></span>
<span class="line"><span>mov ax, 0x0000</span></span>
<span class="line"><span>; 循环部分</span></span>
<span class="line"><span>sum:</span></span>
<span class="line"><span>	add ax, cx</span></span>
<span class="line"><span>	loop sum</span></span>
<span class="line"><span>jmp $</span></span>
<span class="line"><span>times 510-($-$$) db 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; 最后在寄存器ax的数据是13BAh，即5050，答案正确</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="jmp-跳转" tabindex="-1"><a class="header-anchor" href="#jmp-跳转"><span>jmp 跳转</span></a></h2><p>直接跳转，类似于于C语言的goto</p><h2 id="jcc-条件" tabindex="-1"><a class="header-anchor" href="#jcc-条件"><span>jcc 条件</span></a></h2><p><code>jmp</code>是直接跳转，而<code>jcc</code>是符合条件才会跳转</p><p>场景：FLAGS (标志寄存器) 要结合<code>Jcc</code>（条件转移指令）来使用</p><h3 id="jcc衍生指令-jz-jnz" tabindex="-1"><a class="header-anchor" href="#jcc衍生指令-jz-jnz"><span>jcc衍生指令 jz/jnz</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jz	; Jump if zero		(ZF=1)</span></span>
<span class="line"><span>jnz	; Jump if not zero	(ZF=0)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="section-分段-疑似汇编器命令" tabindex="-1"><a class="header-anchor" href="#section-分段-疑似汇编器命令"><span>section 分段（疑似汇编器命令）</span></a></h2><p>类似于高级语言的程序块？</p><p>（不是segment）</p><p>这是nasm提供的分段关键字，不是原生的汇编指令关键字？</p><p>作用：可以自定义分段</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>section 名字 align=无/16/32 vstart=0x7c00</span></span>
<span class="line"><span>; section 语句之后，到碰到下个section之前都属于section</span></span>
<span class="line"><span>; align可选参数：可以让你分段的位置处于16/32字节的倍数，原理是用0给你补到16字节，默认不设置</span></span>
<span class="line"><span>; vstart可选参数：设置段内的偏移地址的基准地址，默认不设置则基于程序头（一般为0x0000）进行偏移</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="call-指令" tabindex="-1"><a class="header-anchor" href="#call-指令"><span>call 指令</span></a></h2><p>类似于高级语言的函数传参，是jmp的高级封装（可以跳转回来、使用了栈、可以传参）</p><p>原理：</p><ul><li>流程是先顺序执行指令，遇到call指令后来到call后面的标号处，遇到ret指令后返回到原来的位置继续顺序执行指令</li><li>传参时用寄存器来存储参数和返回值即可</li></ul><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>; 后接标号/寄存器/内存地址</span></span>
<span class="line"><span>; 注意在代码块的最后要加一个ret指令，即return</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,26)]))}const d=e(l,[["render",p],["__file","04. 控制.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/04.%20%E6%8E%A7%E5%88%B6.html","title":"ComputerSystems","lang":"zh-CN","frontmatter":{"description":"ComputerSystems 目录 控制 loop 循环 基本使用 demo：从1加至100的和 jmp 跳转 直接跳转，类似于于C语言的goto jcc 条件 jmp是直接跳转，而jcc是符合条件才会跳转 场景：FLAGS (标志寄存器) 要结合Jcc（条件转移指令）来使用 jcc衍生指令 jz/jnz section 分段（疑似汇编器命令） 类似...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/04.%20%E6%8E%A7%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"ComputerSystems"}],["meta",{"property":"og:description","content":"ComputerSystems 目录 控制 loop 循环 基本使用 demo：从1加至100的和 jmp 跳转 直接跳转，类似于于C语言的goto jcc 条件 jmp是直接跳转，而jcc是符合条件才会跳转 场景：FLAGS (标志寄存器) 要结合Jcc（条件转移指令）来使用 jcc衍生指令 jz/jnz section 分段（疑似汇编器命令） 类似..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ComputerSystems\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"ComputerSystems","slug":"computersystems","link":"#computersystems","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"控制","slug":"控制","link":"#控制","children":[{"level":2,"title":"loop 循环","slug":"loop-循环","link":"#loop-循环","children":[]},{"level":2,"title":"jmp 跳转","slug":"jmp-跳转","link":"#jmp-跳转","children":[]},{"level":2,"title":"jcc 条件","slug":"jcc-条件","link":"#jcc-条件","children":[{"level":3,"title":"jcc衍生指令 jz/jnz","slug":"jcc衍生指令-jz-jnz","link":"#jcc衍生指令-jz-jnz","children":[]}]},{"level":2,"title":"section 分段（疑似汇编器命令）","slug":"section-分段-疑似汇编器命令","link":"#section-分段-疑似汇编器命令","children":[]},{"level":2,"title":"call 指令","slug":"call-指令","link":"#call-指令","children":[]}]}],"git":{},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/04. 控制.md","excerpt":"\\n<h1>目录</h1>\\n<h1>控制</h1>\\n<h2>loop 循环</h2>\\n<p>基本使用</p>\\n<div class=\\"language-assembly line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"assembly\\" data-title=\\"assembly\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>; 每次执行到`loop标号`时会自动将cx减1，并检测cx是否为0，不需要手动完成</span></span>\\n<span class=\\"line\\"><span>标号</span></span>\\n<span class=\\"line\\"><span>\\t...</span></span>\\n<span class=\\"line\\"><span>\\t循环体</span></span>\\n<span class=\\"line\\"><span>\\t...</span></span>\\n<span class=\\"line\\"><span>loop 标号</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/04. 控制.md","value":{"title":"04. 控制","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/04. 控制.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{d as comp,r as data};
