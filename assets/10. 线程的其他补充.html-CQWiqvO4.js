import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,a as i}from"./app-CyJMR3JQ.js";const n={},s=i(`<h1 id="线程的其他补充" tabindex="-1"><a class="header-anchor" href="#线程的其他补充"><span>线程的其他补充</span></a></h1><h1 id="condition-variable、wait、notify-one、notify-all" tabindex="-1"><a class="header-anchor" href="#condition-variable、wait、notify-one、notify-all"><span>Condition_variable、wait、notify_one、notify_all</span></a></h1><h2 id="条件变量std-condition、wdit-、notify-one" tabindex="-1"><a class="header-anchor" href="#条件变量std-condition、wdit-、notify-one"><span>条件变量std::condition、wdit()、notify_one()</span></a></h2><h2 id="上述代码深入思考" tabindex="-1"><a class="header-anchor" href="#上述代码深入思考"><span>上述代码深入思考</span></a></h2><h2 id="notify-all" tabindex="-1"><a class="header-anchor" href="#notify-all"><span>notify_all</span></a></h2><h1 id="async、future、packaged-task、promise" tabindex="-1"><a class="header-anchor" href="#async、future、packaged-task、promise"><span>async、future、packaged_task、promise</span></a></h1><h2 id="std-async、std-future创建后台任务并返回值" tabindex="-1"><a class="header-anchor" href="#std-async、std-future创建后台任务并返回值"><span>std::async、std::future创建后台任务并返回值</span></a></h2><h2 id="std-packaged-task" tabindex="-1"><a class="header-anchor" href="#std-packaged-task"><span>std::packaged_task</span></a></h2><h2 id="std-promise" tabindex="-1"><a class="header-anchor" href="#std-promise"><span>std::promise</span></a></h2><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><h1 id="future其他成员函数、shared-future、atomic" tabindex="-1"><a class="header-anchor" href="#future其他成员函数、shared-future、atomic"><span>future其他成员函数、shared_future、atomic</span></a></h1><h2 id="std-future的其他成员函数" tabindex="-1"><a class="header-anchor" href="#std-future的其他成员函数"><span>std::future的其他成员函数</span></a></h2><h2 id="std-shared-future" tabindex="-1"><a class="header-anchor" href="#std-shared-future"><span>std::shared_future</span></a></h2><h2 id="原子操作std-atomic" tabindex="-1"><a class="header-anchor" href="#原子操作std-atomic"><span>原子操作std::atomic</span></a></h2><h3 id="原子操作概念引出范例" tabindex="-1"><a class="header-anchor" href="#原子操作概念引出范例"><span>原子操作概念引出范例</span></a></h3><h3 id="基本的std-atomic用法范例" tabindex="-1"><a class="header-anchor" href="#基本的std-atomic用法范例"><span>基本的std::atomic用法范例</span></a></h3><h3 id="心得总结" tabindex="-1"><a class="header-anchor" href="#心得总结"><span>心得总结</span></a></h3><h1 id="std-atomic续谈、std-async深入谈" tabindex="-1"><a class="header-anchor" href="#std-atomic续谈、std-async深入谈"><span>std::atomic续谈、std::async深入谈</span></a></h1><h2 id="原子操作std-atomic续谈" tabindex="-1"><a class="header-anchor" href="#原子操作std-atomic续谈"><span>原子操作std::atomic续谈</span></a></h2><h2 id="深入谈std-async" tabindex="-1"><a class="header-anchor" href="#深入谈std-async"><span>深入谈std::async</span></a></h2><h3 id="std-async参数详述" tabindex="-1"><a class="header-anchor" href="#std-async参数详述"><span>std::async参数详述</span></a></h3><h3 id="std-async和std-thread的区别" tabindex="-1"><a class="header-anchor" href="#std-async和std-thread的区别"><span>std::async和std::thread的区别</span></a></h3><h3 id="std-async不确定性问题的解决" tabindex="-1"><a class="header-anchor" href="#std-async不确定性问题的解决"><span>std::async不确定性问题的解决</span></a></h3><h1 id="windows临界区、其他各种mutex互斥量" tabindex="-1"><a class="header-anchor" href="#windows临界区、其他各种mutex互斥量"><span>windows临界区、其他各种mutex互斥量</span></a></h1><h2 id="windows临界区" tabindex="-1"><a class="header-anchor" href="#windows临界区"><span>windows临界区</span></a></h2><h2 id="多次进入临界区试验" tabindex="-1"><a class="header-anchor" href="#多次进入临界区试验"><span>多次进入临界区试验</span></a></h2><h2 id="自动析构技术" tabindex="-1"><a class="header-anchor" href="#自动析构技术"><span>自动析构技术</span></a></h2><h2 id="recursive-mutex递归的独占互斥量" tabindex="-1"><a class="header-anchor" href="#recursive-mutex递归的独占互斥量"><span>recursive_mutex递归的独占互斥量</span></a></h2><h2 id="带超时的互斥量std-timed-mutex和std-recursive-timed-mutex" tabindex="-1"><a class="header-anchor" href="#带超时的互斥量std-timed-mutex和std-recursive-timed-mutex"><span>带超时的互斥量std::timed_mutex和std::recursive_timed_mutex</span></a></h2><h1 id="补充知识、线程池浅谈、数量谈、总结" tabindex="-1"><a class="header-anchor" href="#补充知识、线程池浅谈、数量谈、总结"><span>补充知识、线程池浅谈、数量谈、总结</span></a></h1><h2 id="补充知识点" tabindex="-1"><a class="header-anchor" href="#补充知识点"><span>补充知识点</span></a></h2><h3 id="虚假唤醒" tabindex="-1"><a class="header-anchor" href="#虚假唤醒"><span>虚假唤醒</span></a></h3><h3 id="atomic" tabindex="-1"><a class="header-anchor" href="#atomic"><span>atomic</span></a></h3><h2 id="浅谈线程池" tabindex="-1"><a class="header-anchor" href="#浅谈线程池"><span>浅谈线程池</span></a></h2><h3 id="场景设想" tabindex="-1"><a class="header-anchor" href="#场景设想"><span>场景设想</span></a></h3><h3 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h3><h2 id="线程创建数量谈" tabindex="-1"><a class="header-anchor" href="#线程创建数量谈"><span>线程创建数量谈</span></a></h2><h2 id="c-11多线程总结" tabindex="-1"><a class="header-anchor" href="#c-11多线程总结"><span>C++11多线程总结</span></a></h2><h1 id="多线程-线程的其他补充" tabindex="-1"><a class="header-anchor" href="#多线程-线程的其他补充"><span>多线程 - 线程的其他补充</span></a></h1><h2 id="线程操作补充" tabindex="-1"><a class="header-anchor" href="#线程操作补充"><span>线程操作补充</span></a></h2><h3 id="自带锁的数据-新版list" tabindex="-1"><a class="header-anchor" href="#自带锁的数据-新版list"><span>自带锁的数据 - 新版list</span></a></h3><h2 id="线程管理" tabindex="-1"><a class="header-anchor" href="#线程管理"><span>线程管理</span></a></h2><h3 id="线程id" tabindex="-1"><a class="header-anchor" href="#线程id"><span>线程id</span></a></h3><p>线程id</p><ul><li>线程id可以通过<code>std::this_thread::get_id();</code>来获取</li></ul><h3 id="踩坑问题" tabindex="-1"><a class="header-anchor" href="#踩坑问题"><span>踩坑问题</span></a></h3><h4 id="引用问题" tabindex="-1"><a class="header-anchor" href="#引用问题"><span>引用问题</span></a></h4><p>例程：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;iostream&gt;
#include &lt;thread&gt;			// 线程头文件

using namespace std;

class TA
{
public:    
    int &amp;m_i;				// 【新增】引用对象
    TA(int &amp;i):m_i(i) {}	// 【新增】构造函数
    void operator()()		// 线程的初始函数（类成员函数），不能带参数！！！
    { 
        cout &lt;&lt; &quot;子线程&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;m_i：&quot; &lt;&lt; m_i &lt;&lt; endl;	// 【新增】每次输出时m_i的值都不一样 
    }
}    

int main()					// main函数，主线程的初始函数
{  
    int myi = 6;			// 【新增】 
    Ta ta(myi);				// 【修改】传入引用对象 
    /* std::thread mythread(Ta()); // 这里用匿名对象也是可以的 */  
    std::thread mythread(ta);	// 函数、类、Lambda都是可调用对象 
    mythread.detach();       
    cout &lt;&lt; &quot;主线程&quot; &lt;&lt; endl; 
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Q：为什么每次输出时m_i的值都不一样</p><p>A：原因：detach后主线程执行完后，m_i的内存被回收销毁，此时m_i的内存的值不可控</p><h4 id="对象拷贝问题" tabindex="-1"><a class="header-anchor" href="#对象拷贝问题"><span>对象拷贝问题</span></a></h4><p>Q：使用detach()后，当主线程结束对象被销毁，子线程还能使用这个对象的成员函数吗</p><p>A：对象会被复制到线程中生成新对象 前面的例程从开始到结束发生了：一次构造函数、一次拷贝构造函数、两次析构函数 （这里拷贝构造函数默认是浅拷贝，对象中有引用对象的要注意重写复制构造函数来深拷贝，否则会发生前面的问题）</p><h2 id="thread源码分析" tabindex="-1"><a class="header-anchor" href="#thread源码分析"><span>Thread源码分析</span></a></h2><p>构造函数是一个右值引用的可变参数模板，接受右值参数</p><p>其他暂略</p><h1 id="_00" tabindex="-1"><a class="header-anchor" href="#_00"><span>00</span></a></h1>`,58),d=[s];function l(r,c){return a(),t("div",null,d)}const u=e(n,[["render",l],["__file","10. 线程的其他补充.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85.html","title":"线程的其他补充","lang":"zh-CN","frontmatter":{"description":"线程的其他补充 Condition_variable、wait、notify_one、notify_all 条件变量std::condition、wdit()、notify_one() 上述代码深入思考 notify_all async、future、packaged_task、promise std::async、std::future创建后台任务并...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"线程的其他补充"}],["meta",{"property":"og:description","content":"线程的其他补充 Condition_variable、wait、notify_one、notify_all 条件变量std::condition、wdit()、notify_one() 上述代码深入思考 notify_all async、future、packaged_task、promise std::async、std::future创建后台任务并..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程的其他补充\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"线程的其他补充","slug":"线程的其他补充","link":"#线程的其他补充","children":[]},{"level":1,"title":"Condition_variable、wait、notify_one、notify_all","slug":"condition-variable、wait、notify-one、notify-all","link":"#condition-variable、wait、notify-one、notify-all","children":[{"level":2,"title":"条件变量std::condition、wdit()、notify_one()","slug":"条件变量std-condition、wdit-、notify-one","link":"#条件变量std-condition、wdit-、notify-one","children":[]},{"level":2,"title":"上述代码深入思考","slug":"上述代码深入思考","link":"#上述代码深入思考","children":[]},{"level":2,"title":"notify_all","slug":"notify-all","link":"#notify-all","children":[]}]},{"level":1,"title":"async、future、packaged_task、promise","slug":"async、future、packaged-task、promise","link":"#async、future、packaged-task、promise","children":[{"level":2,"title":"std::async、std::future创建后台任务并返回值","slug":"std-async、std-future创建后台任务并返回值","link":"#std-async、std-future创建后台任务并返回值","children":[]},{"level":2,"title":"std::packaged_task","slug":"std-packaged-task","link":"#std-packaged-task","children":[]},{"level":2,"title":"std::promise","slug":"std-promise","link":"#std-promise","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":1,"title":"future其他成员函数、shared_future、atomic","slug":"future其他成员函数、shared-future、atomic","link":"#future其他成员函数、shared-future、atomic","children":[{"level":2,"title":"std::future的其他成员函数","slug":"std-future的其他成员函数","link":"#std-future的其他成员函数","children":[]},{"level":2,"title":"std::shared_future","slug":"std-shared-future","link":"#std-shared-future","children":[]},{"level":2,"title":"原子操作std::atomic","slug":"原子操作std-atomic","link":"#原子操作std-atomic","children":[{"level":3,"title":"原子操作概念引出范例","slug":"原子操作概念引出范例","link":"#原子操作概念引出范例","children":[]},{"level":3,"title":"基本的std::atomic用法范例","slug":"基本的std-atomic用法范例","link":"#基本的std-atomic用法范例","children":[]},{"level":3,"title":"心得总结","slug":"心得总结","link":"#心得总结","children":[]}]}]},{"level":1,"title":"std::atomic续谈、std::async深入谈","slug":"std-atomic续谈、std-async深入谈","link":"#std-atomic续谈、std-async深入谈","children":[{"level":2,"title":"原子操作std::atomic续谈","slug":"原子操作std-atomic续谈","link":"#原子操作std-atomic续谈","children":[]},{"level":2,"title":"深入谈std::async","slug":"深入谈std-async","link":"#深入谈std-async","children":[{"level":3,"title":"std::async参数详述","slug":"std-async参数详述","link":"#std-async参数详述","children":[]},{"level":3,"title":"std::async和std::thread的区别","slug":"std-async和std-thread的区别","link":"#std-async和std-thread的区别","children":[]},{"level":3,"title":"std::async不确定性问题的解决","slug":"std-async不确定性问题的解决","link":"#std-async不确定性问题的解决","children":[]}]}]},{"level":1,"title":"windows临界区、其他各种mutex互斥量","slug":"windows临界区、其他各种mutex互斥量","link":"#windows临界区、其他各种mutex互斥量","children":[{"level":2,"title":"windows临界区","slug":"windows临界区","link":"#windows临界区","children":[]},{"level":2,"title":"多次进入临界区试验","slug":"多次进入临界区试验","link":"#多次进入临界区试验","children":[]},{"level":2,"title":"自动析构技术","slug":"自动析构技术","link":"#自动析构技术","children":[]},{"level":2,"title":"recursive_mutex递归的独占互斥量","slug":"recursive-mutex递归的独占互斥量","link":"#recursive-mutex递归的独占互斥量","children":[]},{"level":2,"title":"带超时的互斥量std::timed_mutex和std::recursive_timed_mutex","slug":"带超时的互斥量std-timed-mutex和std-recursive-timed-mutex","link":"#带超时的互斥量std-timed-mutex和std-recursive-timed-mutex","children":[]}]},{"level":1,"title":"补充知识、线程池浅谈、数量谈、总结","slug":"补充知识、线程池浅谈、数量谈、总结","link":"#补充知识、线程池浅谈、数量谈、总结","children":[{"level":2,"title":"补充知识点","slug":"补充知识点","link":"#补充知识点","children":[{"level":3,"title":"虚假唤醒","slug":"虚假唤醒","link":"#虚假唤醒","children":[]},{"level":3,"title":"atomic","slug":"atomic","link":"#atomic","children":[]}]},{"level":2,"title":"浅谈线程池","slug":"浅谈线程池","link":"#浅谈线程池","children":[{"level":3,"title":"场景设想","slug":"场景设想","link":"#场景设想","children":[]},{"level":3,"title":"实现方式","slug":"实现方式","link":"#实现方式","children":[]}]},{"level":2,"title":"线程创建数量谈","slug":"线程创建数量谈","link":"#线程创建数量谈","children":[]},{"level":2,"title":"C++11多线程总结","slug":"c-11多线程总结","link":"#c-11多线程总结","children":[]}]},{"level":1,"title":"多线程 - 线程的其他补充","slug":"多线程-线程的其他补充","link":"#多线程-线程的其他补充","children":[{"level":2,"title":"线程操作补充","slug":"线程操作补充","link":"#线程操作补充","children":[{"level":3,"title":"自带锁的数据 - 新版list","slug":"自带锁的数据-新版list","link":"#自带锁的数据-新版list","children":[]}]},{"level":2,"title":"线程管理","slug":"线程管理","link":"#线程管理","children":[{"level":3,"title":"线程id","slug":"线程id","link":"#线程id","children":[]},{"level":3,"title":"踩坑问题","slug":"踩坑问题","link":"#踩坑问题","children":[{"level":4,"title":"引用问题","slug":"引用问题","link":"#引用问题","children":[]},{"level":4,"title":"对象拷贝问题","slug":"对象拷贝问题","link":"#对象拷贝问题","children":[]}]}]},{"level":2,"title":"Thread源码分析","slug":"thread源码分析","link":"#thread源码分析","children":[]}]},{"level":1,"title":"00","slug":"_00","link":"#_00","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.28,"words":685},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/04. 优化/多线程/10. 线程的其他补充.md","autoDesc":true}');export{u as comp,p as data};
