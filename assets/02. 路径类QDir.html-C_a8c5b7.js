import{_ as t,c as e,a as n,o as l}from"./app-DMuzqBDp.js";const r={};function d(a,i){return l(),e("div",null,i[0]||(i[0]=[n(`<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="qdir类-路径问题" tabindex="-1"><a class="header-anchor" href="#qdir类-路径问题"><span>QDir类 - 路径问题</span></a></h1><h2 id="qdir" tabindex="-1"><a class="header-anchor" href="#qdir"><span>QDir</span></a></h2><h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用"><span>基本使用</span></a></h3><p>头文件</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;QDir&gt;										// 头文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>构造函数 &amp; 返回QDir的函数</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QDir(const QDir &amp;dir)								// 复制构造函数
QDir(const QString &amp;path = QString())				// 根据路径名
QDir(const QString &amp;path, const QString &amp;nameFilter, QDir::SortFlags sort = SortFlags(Name | IgnoreCase), QDir::Filters filters = AllEntries)
QDir(qApp-&gt;applicationDirPath())					// 获取应用路径（指pro中DESTDIR的参）并构造QDir
QCoreApplication::applicationDirPath();				// 返回应用路径（同上？）
directoryOf(&quot;scripts&quot;);								// 访问应用程序的脚本子目录
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>QDir常用方法</p><p><strong>小心中文路径</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>dirName();	// 路径最后文件夹的名字，返回QString
cdUp();		// cd到上一层
cd();		
// 注意1：如果新目录不存在，则不会执行逻辑cd()操作!!!需要加判定
// 注意2：中文路径有可能导致cd失败！
QString QDir::absoluteFilePath(const QString &amp;fileName) const;	// 参数是文件名
QString QDir::absolutePath() const;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>entryList方法</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QStringList entryList(QDir::Filters filters = NoFilter, QDir::SortFlags sort = NoSort) const
// 媒体值（enum QDir::Filterflags / QDir::Filters）

QStringList entryList(const QStringList &amp;nameFilters, QDir::Filters filters = NoFilter, QDir::SortFlags sort = NoSort) const
// 名字过滤、媒体值（enum QDir::Filterflags / QDir::Filters）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常见错误" tabindex="-1"><a class="header-anchor" href="#常见错误"><span>常见错误</span></a></h3><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// 注意1：如果新目录不存在，则不会执行逻辑cd()操作!!!需要加判定
// 注意2：中文路径有可能导致cd失败！

if(!dPath.cd(QString::fromLocal8Bit(&quot;./AppData/LocalLow/miHoYo/原神&quot;)))
{
    qDebug()&lt;&lt;&quot;Failed to cd the path.&quot;
        &lt;&lt;dPath.absolutePath();
    return &quot;&quot;;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="媒体值补充" tabindex="-1"><a class="header-anchor" href="#媒体值补充"><span>媒体值补充</span></a></h3><table><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>QDir::Dirs</td><td>0x001</td><td>List directories that match the filters.</td></tr><tr><td>QDir::AllDirs</td><td>0x400</td><td>List all directories; i.e. don&#39;t apply the filters to directory names.</td></tr><tr><td>QDir::Files</td><td>0x002</td><td>List files.</td></tr><tr><td>QDir::Drives</td><td>0x004</td><td>List disk drives (ignored under Unix).</td></tr><tr><td>QDir::NoSymLinks</td><td>0x008</td><td>Do not list symbolic links (ignored by operating systems that don&#39;t support symbolic links).</td></tr><tr><td>QDir::NoDotAndDotDot</td><td>NoDot | NoDotDot</td><td>Do not list the special entries &quot;.&quot; and &quot;..&quot;.</td></tr><tr><td>QDir::NoDot</td><td>0x2000</td><td>Do not list the special entry &quot;.&quot;.</td></tr><tr><td>QDir::NoDotDot</td><td>0x4000</td><td>Do not list the special entry &quot;..&quot;.</td></tr><tr><td>QDir::AllEntries</td><td>Dirs | Files | Drives</td><td>List directories, files, drives and symlinks (this does not list broken symlinks unless you specify System).</td></tr><tr><td>QDir::Readable</td><td>0x010</td><td>List files for which the application has read access. The Readable value needs to be combined with Dirs or Files.</td></tr><tr><td>QDir::Writable</td><td>0x020</td><td>List files for which the application has write access. The Writable value needs to be combined with Dirs or Files.</td></tr><tr><td>QDir::Executable</td><td>0x040</td><td>List files for which the application has execute access. The Executable value needs to be combined with Dirs or Files.</td></tr><tr><td>QDir::Modified</td><td>0x080</td><td>Only list files that have been modified (ignored on Unix).</td></tr><tr><td>QDir::Hidden</td><td>0x100</td><td>List hidden files (on Unix, files starting with a &quot;.&quot;).</td></tr><tr><td>QDir::System</td><td>0x200</td><td>List system files (on Unix, FIFOs, sockets and device files are included; on Windows, .lnk files are included)</td></tr><tr><td>QDir::CaseSensitive</td><td>0x800</td><td>The filter should be case sensitive.</td></tr></tbody></table><p>Functions that</p><h3 id="应用举例" tabindex="-1"><a class="header-anchor" href="#应用举例"><span>应用举例</span></a></h3><p>一个应用的Demo —— 插件加载</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QDir pluginsDir = QDir(qApp-&gt;applicationDirPath());                 // 获取应用路径（指pro中DESTDIR的参）并构造QDir
if(!pluginsDir.cd(&quot;plugins&quot;)) return -1;                            // 查看是否存在plugins目录
foreach (QString fileName, pluginsDir.entryList(QDir::Files))       // 循环加载plugins目录中的插件，entryList返回QStingList
{
    qDebug()&lt;&lt;fileName;												// （调试用）
    /* 里面返回目录中文件的绝对路径名，然后加载插件（加载插件需要绝对路径）*/
    QPluginLoader pluginLoader(pluginsDir.absoluteFilePath(fileName));
    // ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一个应用的Demo —— 脚本加载</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void Calculaotr::createCustomButtons()
{
    QDir scriptsDir = directoryOf(&quot;scripts&quot;);										// 访问应用程序的脚本子目录
    QStringList fileNames = scriptsDir.entryList(QStringList(&quot;*.js&quot;),QDir::Files);	// 找.js扩展名的文件
    foreach (QString fileName, fileNames){											// 循环脚本文件
        QString text = fileName;
        // ...
        button-&gt;setProperty(&quot;scriptFileName&quot;, scriptsDir.absoluteFilePath(fileName));// 设置属性使用脚本（绝对路径）
        // ...
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="获取路径" tabindex="-1"><a class="header-anchor" href="#获取路径"><span>获取路径</span></a></h2><h3 id="c-中获取路径" tabindex="-1"><a class="header-anchor" href="#c-中获取路径"><span>C++中获取路径</span></a></h3><p>build构建路径</p><ul><li><code>#include &lt;QCoreApplication&gt;</code> + <code>QDir(qApp-&gt;applicationDirPath())</code></li><li><code>#include &lt;QCoreApplication&gt;</code> + <code>QDir(QCoreApplication::applicationDirPath())</code></li><li>两种写法一样，默认是debug/release文件夹，受.pro的<code>DESTDIR = ../App</code>影响</li><li>（win中cdUp后才是pro中的<code>./</code>路径，更不是源代码路径）</li></ul><p>exe可执行文件路径</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;QCoreAppliacation&gt;
QString strDirPath = QCoreApplication::applicationDirPath();	// 返回包含当前项目的可执行文件的路径
QString strFilePath = QCoreApplication::applicationFilePath();	// 返回可执行文件的路径
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>其他</p><ul><li><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QCoreApplication::applicationDirPth();		// 可执行文件所在目录
QcoreApplication::applicationFilePath();	// 可执行文件绝对路径
QcoreApplication::applicationName();		// 可执行文件名
QDir::currentPath();						// 当前程序运行目录
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="注意-工作路径和执行路径-可执行文件路径-的区别" tabindex="-1"><a class="header-anchor" href="#注意-工作路径和执行路径-可执行文件路径-的区别"><span>注意：工作路径和执行路径（可执行文件路径）的区别</span></a></h3><p>有时打印出来这两是相同的，但其实这两个路径不一样</p><p>双击程序，程序是由explore启动的，工作目录和exe所在目录是同一个目录， 但是你用ide的调试器启动，他的启动是继承了ide本身设定的工作路径的，虽然这个路径也可以调 所以以执行文件所在的路径为基准，准不会错</p><p>系统默认的相对路径都是以执行文件所在目录为相对路径，而不是以工作目录为相对路径的</p><p>运行目录就是你执行文件所在目录 是固定不变的, 工作目录是一个环境变量 可在程序运行后随时进行设置更改 工作路径和启动器有关的 比如说 file.open(../a.txt); 这个a.txt文件的具体位置是根据工作目录来判断的</p><p>选用：一般不要用工作路径，用执行路径也就是exe路径</p><h3 id="pro中获取路径" tabindex="-1"><a class="header-anchor" href="#pro中获取路径"><span>.pro中获取路径</span></a></h3><ul><li>路径宏 <ul><li>安装路径有关（QT_INSTALL开头） <ul><li><code>$$[QT_INSTALL_PLUGINS]</code>，插件路径，<code>D:\\Soft\\Dev\\Tools\\QT\\5.15.2\\msvc2019_64\\plugins</code></li><li><code>$$[QT_INSTALL_EXAMPLES]</code>，示例路径，<code>D:\\Soft\\Dev\\Tools\\QT\\Examples\\Qt-6.0.3</code></li></ul></li><li>源代码路径有关 <ul><li><code>$$PWD</code>，指定指向包含正在解析的当前文件的目录的完整路径</li></ul></li><li>构建路径有关 <ul><li><code>./</code>，和<code>$$PWD</code>不同，前者是build路径（debug/release的上一层），后者是源代码项目路径</li></ul></li></ul></li></ul><h2 id="根据不同系统选择编译文件夹" tabindex="-1"><a class="header-anchor" href="#根据不同系统选择编译文件夹"><span>根据不同系统选择编译文件夹</span></a></h2><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>QDir pluginsDir(QCoreApplication::applicationDirPath());
#if defined(Q_OS_WIN)
    if (pluginsDir.dirName().toLower() == &quot;debug&quot; || pluginsDir.dirName().toLower() == &quot;release&quot;)
        pluginsDir.cdUp();
#elif defined(Q_OS_MAC)
    if (pluginsDir.dirName() == &quot;MacOS&quot;) {
        pluginsDir.cdUp();
        pluginsDir.cdUp();
        pluginsDir.cdUp();
    }
#endif
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,42)]))}const c=t(r,[["render",d],["__file","02. 路径类QDir.html.vue"]]),o=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/03.%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%A3%81%E7%9B%98%E7%9B%B8%E5%85%B3/02.%20%E8%B7%AF%E5%BE%84%E7%B1%BBQDir.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 QDir类 - 路径问题 QDir 基本使用 头文件 构造函数 & 返回QDir的函数 QDir常用方法 小心中文路径 entryList方法 常见错误 媒体值补充 Functions that 应用举例 一个应用的Demo —— 插件加载 另一个应用的Demo —— 脚本加载 获取路径 C++中获取路径 build构建路径 #includ...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/03.%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%A3%81%E7%9B%98%E7%9B%B8%E5%85%B3/02.%20%E8%B7%AF%E5%BE%84%E7%B1%BBQDir.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 QDir类 - 路径问题 QDir 基本使用 头文件 构造函数 & 返回QDir的函数 QDir常用方法 小心中文路径 entryList方法 常见错误 媒体值补充 Functions that 应用举例 一个应用的Demo —— 插件加载 另一个应用的Demo —— 脚本加载 获取路径 C++中获取路径 build构建路径 #includ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"QDir类 - 路径问题","slug":"qdir类-路径问题","link":"#qdir类-路径问题","children":[{"level":2,"title":"QDir","slug":"qdir","link":"#qdir","children":[{"level":3,"title":"基本使用","slug":"基本使用","link":"#基本使用","children":[]},{"level":3,"title":"常见错误","slug":"常见错误","link":"#常见错误","children":[]},{"level":3,"title":"媒体值补充","slug":"媒体值补充","link":"#媒体值补充","children":[]},{"level":3,"title":"应用举例","slug":"应用举例","link":"#应用举例","children":[]}]},{"level":2,"title":"获取路径","slug":"获取路径","link":"#获取路径","children":[{"level":3,"title":"C++中获取路径","slug":"c-中获取路径","link":"#c-中获取路径","children":[]},{"level":3,"title":"注意：工作路径和执行路径（可执行文件路径）的区别","slug":"注意-工作路径和执行路径-可执行文件路径-的区别","link":"#注意-工作路径和执行路径-可执行文件路径-的区别","children":[]},{"level":3,"title":".pro中获取路径","slug":"pro中获取路径","link":"#pro中获取路径","children":[]}]},{"level":2,"title":"根据不同系统选择编译文件夹","slug":"根据不同系统选择编译文件夹","link":"#根据不同系统选择编译文件夹","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.57,"words":1370},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/03. Qt其他类（按功能）/03. 文件与磁盘相关/02. 路径类QDir.md","excerpt":"\\n<h1>目录</h1>\\n<h1>QDir类 - 路径问题</h1>\\n<h2>QDir</h2>\\n<h3>基本使用</h3>\\n<p>头文件</p>\\n<div class=\\"language-c++\\" data-ext=\\"c++\\" data-title=\\"c++\\"><pre class=\\"language-c++\\"><code>#include &lt;QDir&gt;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 头文件\\n</code></pre></div><p>构造函数 &amp; 返回QDir的函数</p>\\n<div class=\\"language-c++\\" data-ext=\\"c++\\" data-title=\\"c++\\"><pre class=\\"language-c++\\"><code>QDir(const QDir &amp;dir)\\t\\t\\t\\t\\t\\t\\t\\t// 复制构造函数\\nQDir(const QString &amp;path = QString())\\t\\t\\t\\t// 根据路径名\\nQDir(const QString &amp;path, const QString &amp;nameFilter, QDir::SortFlags sort = SortFlags(Name | IgnoreCase), QDir::Filters filters = AllEntries)\\nQDir(qApp-&gt;applicationDirPath())\\t\\t\\t\\t\\t// 获取应用路径（指pro中DESTDIR的参）并构造QDir\\nQCoreApplication::applicationDirPath();\\t\\t\\t\\t// 返回应用路径（同上？）\\ndirectoryOf(\\"scripts\\");\\t\\t\\t\\t\\t\\t\\t\\t// 访问应用程序的脚本子目录\\n</code></pre></div>","autoDesc":true}');export{c as comp,o as data};
