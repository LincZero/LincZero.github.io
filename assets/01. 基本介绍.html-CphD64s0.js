import{_ as i,c as e,e as t,o}from"./app-DnpufS1x.js";const p={};function n(B,l){return o(),e("div",null,l[0]||(l[0]=[t('<h1 id="《linux内核观测技术bpf》" tabindex="-1"><a class="header-anchor" href="#《linux内核观测技术bpf》"><span>《Linux内核观测技术BPF》</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="基本介绍" tabindex="-1"><a class="header-anchor" href="#基本介绍"><span>基本介绍</span></a></h1><p>进度记录：20/174 (pdf)</p><p>关于书上的代码；https :/loreil.lyllbpf-r叩0</p><p>书上的代码 github：https://github.com/bpftools/linux-observability-with-bpf/tree/master</p><p><mark><strong>【必看】【必看】【必看】笔记中很多的代码部分我都是直接根据双层pdf的文字层进行复制的，他这个版本的pdf没多余空格这点比较好，但有个非常严重的问题：<code>1l</code>不分，<code>0o</code>不分。所以程序仅供参考不能直接用，实在要用需要多注意这两个容易识别错误的地方。不过更建议重打，检查总是会检查漏</strong></mark></p><h2 id="书籍目录" tabindex="-1"><a class="header-anchor" href="#书籍目录"><span>书籍目录</span></a></h2><ol><li>引言 <ol><li>PDF的历史</li><li>架构</li><li>小结</li></ol></li><li>运行第一个BPF程序 <ol><li>编写BPF程序</li><li>BPF程序类型</li><li>BPF验证器</li><li>BPF类型格式</li><li>尾部调用</li><li>小结</li></ol></li><li>BPF映射 <ol><li>创建BPF映射</li><li>使用BPF映射</li><li>BPF映射类型</li><li>BPF虚拟文件系统</li><li>小结</li></ol></li><li>BPF跟踪 <ol><li>探针</li><li>跟踪数据可视化</li><li>小结</li></ol></li><li>BPF工具 <ol><li>BPFTool</li><li>BPFTrace</li><li>kubectl-trace</li><li>eBPF Exporter</li><li>小结</li></ol></li><li>Linux网络和BPF <ol><li>BPF和数据包过滤</li><li>基于BPF的流量控制分类器</li><li>小结</li></ol></li><li>XDP <ol><li>XDP程序概述</li><li>XPD和BCC</li><li>测试XDP程序</li><li>XDP用户案例</li><li>小结</li></ol></li><li>Linux内核安全、能力和Seccomp <ol><li>能力</li><li>Seccomp</li><li>BPF的LSM钩子</li><li>小结</li></ol></li><li>真实的用户案例 <ol><li>Sysdig eBPF上帝视角</li><li>Flowmill</li></ol></li></ol><h2 id="引言-可观测性" tabindex="-1"><a class="header-anchor" href="#引言-可观测性"><span>引言 - 可观测性</span></a></h2><p>在过去的几十年里，计算机系统变得越来越复杂。人们创建了很多办怯来了解软件的行为，试图解决对复杂系统进行洞察的挑战。</p><ul><li><p>日志</p><ul><li><p>日志是很好的信息来源，常用于获得应用程序可见性。日志为分析应用程序的行为提供了精确数据。</p><p>然而，日志分析的方桂受制于应用开发者暴露的日志内容。如果想要收集系统中日志格式以外的信息，则变得和反编译程序来查看执行流一样有挑战。</p></li></ul></li><li><p>度量</p><ul><li><p>另外一种流行的方法是使用度量来推断程序的行为。</p><p>度量与日志有所不同，日志提供的是显性数据，而度量是通过数据聚合对一个程序在特定时间点的行为进行衡量。</p></li></ul></li><li><p>可观测性</p><ul><li>可观测性是一种新兴的实践，尝试从不同角度来解决问题。可观测性被定义成一种能力，可以对给定系统提出的任意问题，寻求到复杂的答案。</li></ul></li><li><p>比较</p><ul><li><p>可观测性、日志和度量聚合三者的主要区别是<strong>收集的数据内容</strong>。</p><p>如果可观测性的实践需要随时随地回答任意问题，那么唯一可行的方式就是收集系统中生成的所有数据，在需要回答问题的时候聚合收集到的数据。</p></li></ul></li></ul><p>Nassim Nicholas Taleb 的畅销书 Antifragile: Things That Gain From Disorder ( Penguin Random Hous巳出版社) ，书中提到的广为人知的&quot;黑天鹅&quot;事件 ( &quot;黑天鹅&quot;事件指产生重大后果的意外事件) ，如果在事件发生前就进行观测，事件是可预料的。</p><p>在作者的另一本书 The Black Swan (Penguin Random House 出版社)中，他解释了在一些罕见的事件中，拥有相关数据是如何帮助降低风险的 。</p><p>&quot;黑天鹅&quot;事件在软件工程中比我们想象的更常见，而且无战避免。假设我们无法预防这类事件，唯一的选择就是在不影响业务系统的前提下，获得尽可能多的信息来解决问题。</p><p>可观测性有助于我们构建健壮的系统，减少&quot;黑天鹅&quot;事件的发生。它的前提条件是我们正在收集的任何数据都能回答未来的任何问题。所以，我们认为对于&quot;黑天鹅&quot;事件的研究和可观测性的实践，核心是从系统中收集到的数据。</p><h2 id="历史" tabindex="-1"><a class="header-anchor" href="#历史"><span>历史</span></a></h2><p><strong>1992 年</strong></p><p>Steven McCanne 和 Van Jacobson 写了一篇名为 &quot;The BSD Packet Filter: A New Architecture for User-Level Packet Capture&quot; 的论文。在文中，作者描述了他们如何在 Unix 内核实现网络数据包过滤，这种新的技术比当时最先进的数据包过滤技术快 20 倍。</p><p>数据包过滤有一个特定的目的 : 可以编写应用程序直接使用内核信息来监控系统网络。有了这些内核信息，应用程序就可以决定如何处理这些数据包。 BPF 在数据包过滤上引入了两大革新:</p><ul><li>一个新的虚拟机 (VM) 设计 ， 可以有效地工作在基于寄存器结构的 CPU 之上。</li><li>应用程序使用缓存只复制与过滤、数据包相关的数据，不会复制数据包的所有信息。这样可以最大限度地减少 BPF 处理的数据。</li></ul><p>由于这些巨大的改进，所有的 Unix 系统都选择采用 BPF 作为网络数据包过滤技术，而放弃了原有消耗大内存和低性能的实现。直到今天，许多 Unix 内核的派生系统中(包括 Linux 内核)仍使用该实现。</p><p><strong>2014 年初</strong></p><p>Alexei Starovoitov 实现了 eBPF 。新的设计针对现代硬件进行了优化，所以 eBPF 生成的指令集比旧的 BPF 解释器生成的机器码执行得更快。</p><p>扩展版本也增加了虚拟机中的寄存器数量，将原有的 2个 32 位寄存器增加到 10 个 64 位寄存器。由于寄存器数量和宽度的增加，开发人员可以使用函数 参数自由交换更多的信息，编写更复杂的程序。总之，这些改进使 eBPF 版本的速度比原来的 BPF 提高了4倍。</p><p>eBPF 实现的最初目标是优化处理网络过滤器的内部 BP F 指令集。当时， BPF仍然限于内核空间使用，只有少数用户空间程序可以编写内核处理的 BPF 过滤器，例如 Tcpdump 和 Seccomp ，在后面的章节中我们会讨论这些程序。时至今日，这些程序仍基于旧的 BPF 解释器生成字节码，但内核中会将这些指令转换为高性能的内部表示。</p><p><strong>2014 年 6 月</strong></p><p>eBPF 1幸 t主 l 扩展到用户空间。这是 B凹的转折点。正如 Alexei 在提交补丁的注释中写道：“这个补丁展示了 eBPF 的潜力。”</p><p>BPF 不再局限于网络枝，已经成为内 核顶级的子系统。 BPF 程序架构强调安全性和稳定性，看上去更像内核模块，但与内核模块不同， BPF 程序不需要重新编译内核 ， 并且可以确保 BPF 程序运行完成 ，而不会造成系统的崩溃。</p><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构"><span>架构</span></a></h2><p>BPF 是一种高级虚拟机，可以在隔离的环境执行代码指令。</p><p>执行顺序：</p><ol><li><p><strong>C代码编译成BPF字节码</strong></p><p>从某种意义上看， BPF 和 Java 虚拟机 ( JVM) 功能类似，我们可以将高级编程语言编译成机器代码， JVM 是一种运行这种机器代码的专用程序。编译器LLVM 和 GNU GCC (不久的将来) 可提供对 BPF 的支持，将 C 代码编译成 BPF 指令。</p></li><li><p><strong>BPF 验证器</strong></p><p>代码编译后， BP F 使用 BPF 验证器来确保程序在内核中安全运行。BPF 验证器能阻止可能使内核崩渍的代码。如果代码是安全的， BPF 程序将被加载到内核中。 Linux 内核也为 BPF 指令集成了即时编译器。 （即时编译又叫实时编译，是一种把字节码翻译成机器码并且缓存起来以降低性能耗损，被用来改善应拟机性能）</p></li><li><p><strong>字节码转机器码</strong></p><p>在程序被验证后， JIT 编译器会直接将 BPF 字节码转换为机器代码，从而减少运行时的时间开销。该架构具有一个非常有用的特点就是加载 BPF 程序无 须重启系统，我们不仅可以在系统启动时通过初始化脚本加载 BPF 程序，也可以按需随时加载程序。</p></li></ol><p>执行点：</p><blockquote><p>（程序执行点是由 BPF 程序类型确定，我们将在第 2 章讨论它们）</p><p>在内核运行 BPF 程序之前，我们需要知道程序附加的执行点。内核中有诸多执行点，数量也在持续增长。当选择了特定的执行点时，内核会提供一些可用的帮助函数，这些帮助函数可用于处理程序接收的数据，从而使执行点和 BPF 程序能够紧密地配合。</p></blockquote><p>BPF映射：</p><blockquote><p>（BPF 映射负责在内核和用户空间之间共享数据。我们将在第 3 章中讨论 BPF 映射）</p><p>BPF 映射提供双向的数据共享，这意味着我们可以分别从内核和用户空间写入和读取数据。 BPF 映射包括一些数据结构类型，从简单数组、哈希映射到自定义的映射，我们甚至可以将整个 BPF 程序保存在 BPF 映射中。</p></blockquote>',37)]))}const a=i(p,[["render",n],["__file","01. 基本介绍.html.vue"]]),s=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/01.%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.html","title":"《Linux内核观测技术BPF》","lang":"zh-CN","frontmatter":{"description":"《Linux内核观测技术BPF》 目录 基本介绍 进度记录：20/174 (pdf) 关于书上的代码；https :/loreil.lyllbpf-r叩0 书上的代码 github：https://github.com/bpftools/linux-observability-with-bpf/tree/master 【必看】【必看】【必看】笔记中很多...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E7%BD%91%E7%BB%9C%E5%BA%93/%E6%97%A0%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%BA%93/eBPF/%E3%80%8ALinux%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B%E6%8A%80%E6%9C%AFBPF%E3%80%8B/01.%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《Linux内核观测技术BPF》"}],["meta",{"property":"og:description","content":"《Linux内核观测技术BPF》 目录 基本介绍 进度记录：20/174 (pdf) 关于书上的代码；https :/loreil.lyllbpf-r叩0 书上的代码 github：https://github.com/bpftools/linux-observability-with-bpf/tree/master 【必看】【必看】【必看】笔记中很多..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《Linux内核观测技术BPF》\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《Linux内核观测技术BPF》","slug":"《linux内核观测技术bpf》","link":"#《linux内核观测技术bpf》","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"基本介绍","slug":"基本介绍","link":"#基本介绍","children":[{"level":2,"title":"书籍目录","slug":"书籍目录","link":"#书籍目录","children":[]},{"level":2,"title":"引言 - 可观测性","slug":"引言-可观测性","link":"#引言-可观测性","children":[]},{"level":2,"title":"历史","slug":"历史","link":"#历史","children":[]},{"level":2,"title":"架构","slug":"架构","link":"#架构","children":[]}]}],"git":{},"readingTime":{"minutes":7.97,"words":2390},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/01. 基本介绍.md","excerpt":"\\n<h1>目录</h1>\\n<h1>基本介绍</h1>\\n<p>进度记录：20/174 (pdf)</p>\\n<p>关于书上的代码；https :/loreil.lyllbpf-r叩0</p>\\n<p>书上的代码 github：https://github.com/bpftools/linux-observability-with-bpf/tree/master</p>\\n<p><mark><strong>【必看】【必看】【必看】笔记中很多的代码部分我都是直接根据双层pdf的文字层进行复制的，他这个版本的pdf没多余空格这点比较好，但有个非常严重的问题：<code>1l</code>不分，<code>0o</code>不分。所以程序仅供参考不能直接用，实在要用需要多注意这两个容易识别错误的地方。不过更建议重打，检查总是会检查漏</strong></mark></p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/01. 基本介绍.md","value":{"title":"01. 基本介绍","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/网络库/无协议栈库/eBPF/《Linux内核观测技术BPF》/01. 基本介绍.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{a as comp,s as data};
