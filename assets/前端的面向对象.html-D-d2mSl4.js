import{_ as o,e as t,g as p,o as a}from"./app-EuS-Ookm.js";const n={};function E(r,e){return a(),t("div",null,e[0]||(e[0]=[p('<h1 id="前端的面向对象" tabindex="-1"><a class="header-anchor" href="#前端的面向对象"><span>前端的面向对象</span></a></h1><h2 id="面向对象-在前端的实现" tabindex="-1"><a class="header-anchor" href="#面向对象-在前端的实现"><span>面向对象，在前端的实现</span></a></h2><p>不同的组件看作不同的类</p><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h3><h3 id="指针引用" tabindex="-1"><a class="header-anchor" href="#指针引用"><span>指针引用</span></a></h3><p>这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。</p><p>比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。</p><p>例如 vue-flow，通常还要更新完之后执行一下 <code>updateNodesData</code> 方法。基于数据驱动的东西才能捕获到这种变化</p>',8)]))}const s=o(n,[["render",E],["__file","前端的面向对象.html.vue"]]),i=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B7%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%89%8D%E7%AB%AF%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html","title":"前端的面向对象","lang":"zh-CN","frontmatter":{"description":"前端的面向对象 面向对象，在前端的实现 不同的组件看作不同的类 继承 指针引用 这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。 比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。 例如 vue-flow，通...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B7%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%89%8D%E7%AB%AF%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"前端的面向对象"}],["meta",{"property":"og:description","content":"前端的面向对象 面向对象，在前端的实现 不同的组件看作不同的类 继承 指针引用 这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。 比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。 例如 vue-flow，通..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"前端的面向对象\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"git":{},"readingTime":{"minutes":0.58,"words":173},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/跨技术栈设计模式/前端的面向对象.md","excerpt":"\\n<h2>面向对象，在前端的实现</h2>\\n<p>不同的组件看作不同的类</p>\\n<h3>继承</h3>\\n<h3>指针引用</h3>\\n<p>这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。</p>\\n<p>比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。</p>\\n<p>例如 vue-flow，通常还要更新完之后执行一下 <code>updateNodesData</code> 方法。基于数据驱动的东西才能捕获到这种变化</p>\\n","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/跨技术栈设计模式/前端的面向对象.md","value":{"title":"前端的面向对象","path":"MdNote_Public/01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/跨技术栈设计模式/前端的面向对象.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{s as comp,i as data};
