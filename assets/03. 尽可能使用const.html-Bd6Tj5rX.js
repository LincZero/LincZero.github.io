import{_ as s,c as t,b as a,o as e}from"./app-CxAoBuKS.js";const i={};function o(c,n){return e(),t("div",null,n[0]||(n[0]=[a(`<h3 id="const变量" tabindex="-1"><a class="header-anchor" href="#const变量"><span>const变量</span></a></h3><ul><li>如果关键字const出现在星号左边,表示被指物是常量</li><li>如果出现在星号右边,表示指针自身是常量;</li><li>如果出现在星号两边,表示被指物和指针两者都是常量。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>char greeting<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
char<span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span> 			<span class="token comment">// non-const pointer, 	non-const data</span>
<span class="token keyword">const</span> char<span class="token operator">*</span> <span class="token constant">P</span> <span class="token operator">=</span> greeting<span class="token punctuation">;</span> 		<span class="token comment">// non-const pointer, 	const data</span>
char<span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span> 		<span class="token comment">// const pointer, 		non-const data</span>
<span class="token keyword">const</span> char<span class="token operator">*</span> <span class="token keyword">const</span> <span class="token constant">P</span> <span class="token operator">=</span> greeting<span class="token punctuation">;</span> <span class="token comment">// const pointer, 		const data</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果被指物是常量，有些程序员会将关键字const写在类型之前，有些人会把它写在类型之后、星号之前。两种写法的意义相同，所以下列两个函数接受的参数类型是一样的：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void f1 (const Widget* pw); 	// E1获得一个指针,指向一个常量的(不变的)Widget对象.
void f2 (Widget const * pw); 	// f2 也是
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="const与函数声明式-函数返回值、各参数、函数自身-如果是成员函数" tabindex="-1"><a class="header-anchor" href="#const与函数声明式-函数返回值、各参数、函数自身-如果是成员函数"><span>const与函数声明式（函数返回值、各参数、函数自身（如果是成员函数））</span></a></h3><p>在一个函数声明式内，const可以和这些产生关联：</p><ul><li>函数返回值</li><li>各参数</li><li>函数自身（如果是成员函数）</li></ul><h4 id="函数返回值与参数" tabindex="-1"><a class="header-anchor" href="#函数返回值与参数"><span>函数返回值与参数</span></a></h4><p>令函数返回一个常量值,往往可以降低因客户错误而造成的意外,而又不至于放弃安全性和高效性。</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class Rational { ... };
const Rational operator* (const Rational&amp; lhs, const Rational&amp; rhs):

Rational a,b,c;
(a*b)=c;	// 在a*b的成果上调用operator=
			// 不加const会导致非报错的错误
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="const成员函数" tabindex="-1"><a class="header-anchor" href="#const成员函数"><span>const成员函数</span></a></h4><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员**（准确地说是非静态数据成员）**作任何改变</p><p>真实程序中const对参大多用于 <strong>passed by pointer-to-const</strong> 或 <strong>passed by reference-to-const</strong> 的传递结果</p><p>两个流行概念</p><ul><li>bitwise constness <ul><li>概念：成员函数只有在不吊改对象之任何成员变量（static除外）时才可以说是const。也就是说它不更改对县内的任何-个bit。</li><li>优点：容易侦测违反点，也是C+对常量性(constness)的定义</li><li>缺点：是许多成员函数蛛然不十足具备const性质却能通过bitwise测试，例如一个更改了“指针所指物“的成员函数虽然不能算是const</li></ul></li><li>logical constness <ul><li>概念：一个const成员函数可以修改它所处理的对象内的某些bits,但只有在客户端侦测不出的情况下才得如此。</li><li>举例：例如你的cTextBlockclass有可能高速缓存Ccache 文本区块的长度以便应付询问 length的实现当然不是bitwise const。 如果编译器用的是bitwise constness怎么办？答：使用mutable(可变的)释放掉non-static成员变量的bitwiseconstness约柬:</li></ul></li></ul><h3 id="在const和non-const成员函数中避免重复" tabindex="-1"><a class="header-anchor" href="#在const和non-const成员函数中避免重复"><span>在const和non-const成员函数中避免重复</span></a></h3><p>对于“bitwise-constness非我所欲“的问题,mutable是个解决办法,但它不能解决所有的const相关难题</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class TextBlock {
public:
    const char&amp; cperator[] (std::sizet position) const
    {
        // 边 界 检 验 (bounds checking)
        // 志 记 数 据 访 问 (log access data)
        // 检 验 数 据 完 整 性 (verify data integrity)
        return text [position];
    }
    char&amp; operator(] (std::size_t position)
    {
        // 边 界 检 验 (bounds checking)
        // 志 记 数 据 访 问 (log access data)
        // 检 验 数 据 完 整 性 (verify data integrity)
        return text [position];
    }
Private:
	std::string text;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如这里会重复一些东西。这促使我们将常量性转除《easting away constuess》。</p><p>更安全的做法是：（如你所见,这份代码有两个转型动作,而不是一个）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>class TextBlock {
public:
    const char&amp; operator[] (std::size_t position) const // 一 如 既 往
    {
        // 边 界 检 验 (bounds checking)
        // 志 记 数 据 访 问 (log access data)
        // 检 验 数 据 完 整 性 (verify data integrity)
        return text[Position]
    }
    char&amp; operator[] (std::size_t position) 			// 现 在 只 调 用 const op []
    {
		return const_cast&lt;char&amp;&gt;( 							// 将 op [] 返 回 值 的 const 转 除
			static_ cast&lt;const TextBlock&amp;&gt;(*this)[position] // 为 *this 加 上 const，并调用 const op[]
		);
    }
    ...
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><mark>总结</mark></span></a></h3><p>请记住：</p><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法。 const可被施加于 <ol><li>任何作用域内的对象</li><li>函数参数</li><li>函数返回类型</li><li>成员函数本体</li></ol></li><li>编译器强制实施bitwise constness，但你编写程序时应该使用 “概念上的常量性“ (conceptual constness)。</li><li>当const和non-const成员函数有着实质等价的实现时，<strong>令non-const版本调用const版本可避免代码重复</strong>。</li></ul>`,25)]))}const r=s(i,[["render",o],["__file","03. 尽可能使用const.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/08.%20C__%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E3%80%8AEffective%20C__%20%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E3%80%8B/01.%20%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC__/03.%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const.html","title":"","lang":"zh-CN","frontmatter":{"description":"const变量 如果关键字const出现在星号左边,表示被指物是常量 如果出现在星号右边,表示指针自身是常量; 如果出现在星号两边,表示被指物和指针两者都是常量。 如果被指物是常量，有些程序员会将关键字const写在类型之前，有些人会把它写在类型之后、星号之前。两种写法的意义相同，所以下列两个函数接受的参数类型是一样的： const与函数声明式（函数返...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/08.%20C__%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E3%80%8AEffective%20C__%20%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E3%80%8B/01.%20%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC__/03.%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:description","content":"const变量 如果关键字const出现在星号左边,表示被指物是常量 如果出现在星号右边,表示指针自身是常量; 如果出现在星号两边,表示被指物和指针两者都是常量。 如果被指物是常量，有些程序员会将关键字const写在类型之前，有些人会把它写在类型之后、星号之前。两种写法的意义相同，所以下列两个函数接受的参数类型是一样的： const与函数声明式（函数返..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":3,"title":"const变量","slug":"const变量","link":"#const变量","children":[]},{"level":3,"title":"const与函数声明式（函数返回值、各参数、函数自身（如果是成员函数））","slug":"const与函数声明式-函数返回值、各参数、函数自身-如果是成员函数","link":"#const与函数声明式-函数返回值、各参数、函数自身-如果是成员函数","children":[{"level":4,"title":"函数返回值与参数","slug":"函数返回值与参数","link":"#函数返回值与参数","children":[]},{"level":4,"title":"const成员函数","slug":"const成员函数","link":"#const成员函数","children":[]}]},{"level":3,"title":"在const和non-const成员函数中避免重复","slug":"在const和non-const成员函数中避免重复","link":"#在const和non-const成员函数中避免重复","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.64,"words":1091},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/08. C++高级编程/《Effective C++ 改善程序与设计的55个具体做法》/01. 让自己习惯C++/03. 尽可能使用const.md","excerpt":"<h3>const变量</h3>\\n<ul>\\n<li>如果关键字const出现在星号左边,表示被指物是常量</li>\\n<li>如果出现在星号右边,表示指针自身是常量;</li>\\n<li>如果出现在星号两边,表示被指物和指针两者都是常量。</li>\\n</ul>\\n<div class=\\"language-javascript\\" data-ext=\\"js\\" data-title=\\"js\\"><pre class=\\"language-javascript\\"><code>char greeting<span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"Hello\\"</span><span class=\\"token punctuation\\">;</span>\\nchar<span class=\\"token operator\\">*</span> p <span class=\\"token operator\\">=</span> greeting<span class=\\"token punctuation\\">;</span> \\t\\t\\t<span class=\\"token comment\\">// non-const pointer, \\tnon-const data</span>\\n<span class=\\"token keyword\\">const</span> char<span class=\\"token operator\\">*</span> <span class=\\"token constant\\">P</span> <span class=\\"token operator\\">=</span> greeting<span class=\\"token punctuation\\">;</span> \\t\\t<span class=\\"token comment\\">// non-const pointer, \\tconst data</span>\\nchar<span class=\\"token operator\\">*</span> <span class=\\"token keyword\\">const</span> p <span class=\\"token operator\\">=</span> greeting<span class=\\"token punctuation\\">;</span> \\t\\t<span class=\\"token comment\\">// const pointer, \\t\\tnon-const data</span>\\n<span class=\\"token keyword\\">const</span> char<span class=\\"token operator\\">*</span> <span class=\\"token keyword\\">const</span> <span class=\\"token constant\\">P</span> <span class=\\"token operator\\">=</span> greeting<span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// const pointer, \\t\\tconst data</span>\\n</code></pre></div>","autoDesc":true}');export{r as comp,p as data};
