import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as d,o as r,c as i,a as t,b as e,d as s,e as a}from"./app-yixEWCFr.js";const c={},p=a(`<h1 id="overlay" tabindex="-1"><a class="header-anchor" href="#overlay"><span>Overlay</span></a></h1><table><thead><tr><th style="text-align:center;">技术名称</th><th style="text-align:center;">支持者</th><th style="text-align:center;">支持方式</th><th style="text-align:center;">网络虚拟化方式</th><th style="text-align:center;">数据新增报文长度</th><th style="text-align:center;">链路HASH能力</th></tr></thead><tbody><tr><td style="text-align:center;">VXLAN</td><td style="text-align:center;">Cisco/VMWARE/Citrix/Red Hat/Broadcom</td><td style="text-align:center;">L2 over UDP</td><td style="text-align:center;">VXLAN报头 24 bit VNI</td><td style="text-align:center;">50Byte(+原数据)</td><td style="text-align:center;">现有网络可进行L2 ~ L4 HASH</td></tr><tr><td style="text-align:center;">NVGRE</td><td style="text-align:center;">HP/Microsoft/Broadcom/Dell/Intel</td><td style="text-align:center;">L2 over GRE</td><td style="text-align:center;">NVGRE 报头 24 bit VSI</td><td style="text-align:center;">42Byte(+原数据)</td><td style="text-align:center;">GRE头的HASH 需要网络升级</td></tr><tr><td style="text-align:center;">STT</td><td style="text-align:center;">VMWare</td><td style="text-align:center;">无状态TCP，即L2在类似TCP的传输层</td><td style="text-align:center;">STT报头 64 bit Context ID</td><td style="text-align:center;">58 ~ 76Byte(+原数据)</td><td style="text-align:center;">现有网络可进行 L2 ~ L4 HASH</td></tr></tbody></table><h2 id="generic-routing-encapsulation-gre" tabindex="-1"><a class="header-anchor" href="#generic-routing-encapsulation-gre"><span>Generic Routing Encapsulation (GRE)</span></a></h2><p>GRE提供了IP in IP的封装技术:</p><p>![GRE Tunnel Encapsulation - RFC2784](10. Overlay.assets/GRE-Tunnel-Encapsulation-RFC2784.jpg)</p><table><thead><tr><th>步骤</th><th>操作/封包</th><th>协议</th><th>长度</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>ping -s 1448</td><td>ICMP</td><td>1456 = 1448 + 8 （ICMP header）</td><td>ICMP MSS</td></tr><tr><td>2</td><td>L3</td><td>IP</td><td>1476 = 1456 + 20 （IP header）</td><td>GRE Tunnel MTU</td></tr><tr><td>3</td><td>L2</td><td>Ethernet</td><td>1490 = 1476 + 14 （Ethernet header）</td><td>经过 bridge 到达 GRE</td></tr><tr><td>4</td><td>GRE</td><td>IP</td><td>1500 = 1476 + 4 （GRE header）+ 20 （IP header）</td><td>物理网卡 （IP）MTU</td></tr><tr><td>5</td><td>L2</td><td>Ethernet</td><td>1514 = 1500 + 14 （Ethernet header）</td><td>最大可传输帧大小</td></tr></tbody></table><p>因此，GRE 的 overhead 是 1514 - 1490 = 24 byte。</p><p>可见，使用 GRE 可以比使用 VxLAN 每次可以多传输 1448 - 1422 = 26 byte 的数据。</p><p>![GRE vs VxLAN](10. Overlay.assets/GRE-vs-VxLAN.png)</p><p>由于GRE没有提供加密和防止窃听的技术，故而经常跟IPSEC一起配合实现对数据的加密传输。</p><h2 id="vxlan" tabindex="-1"><a class="header-anchor" href="#vxlan"><span>VXLAN</span></a></h2><p>Virtual eXtensible Local Area Network (VXLAN) 是一种将2层报文封装到UDP包(Mac in UDP)中进行传输的一种封装协议。VXLAN主要是由Cisco推出的，VXLAN的包头有一个24bit的ID段，即意味着1600万个独一无二的虚拟网段，这个ID通常是对UDP端口采取伪随机算法而生成的（UDP端口是由该帧中的原始MAC Hash生成的）。这样做的好处是可以保证基于5元组的负载均衡，保存VM之间数据包的顺序，具体做法是将数据包内部的MAC组映射到唯一的UDP端口组。将二层广播被转换成IP组播,VXLAN使用IP组播在虚拟网段中泛洪而且依赖于动态MAC学习。在VXLAN中，封装和解封的组件有个专有的名字叫做VTEP，VTEP之间通过组播发现对方。</p><p>![VxLAN](10. Overlay.assets/VxLAN.png)</p><table><thead><tr><th>步骤</th><th>操作/封包</th><th>协议</th><th>长度</th><th>MTU</th></tr></thead><tbody><tr><td>1</td><td>ping -s 1422</td><td>ICMP</td><td>1430 = 1422 + 8 （ICMP header）</td><td></td></tr><tr><td>2</td><td>L3</td><td>IP</td><td>1450 = 1430 + 20 （IP header）</td><td>VxLAN Interface 的 MTU</td></tr><tr><td>3</td><td>L2</td><td>Ethernet</td><td>1464 = 1450 + 14 （Ethernet header）</td><td></td></tr><tr><td>4</td><td>VxLAN</td><td>UDP</td><td>1480 = 1464 + 8 （VxLAN header） + 8 （UDP header）</td><td></td></tr><tr><td>5</td><td>L3</td><td>IP</td><td>1500 = 1480 + 20 （IP header）</td><td>物理网卡的（IP）MTU，它不包括 Ethernet header 的长度</td></tr><tr><td>6</td><td>L2</td><td>Ethernet</td><td>1514 = 1500 + 14 （Ethernet header）</td><td>最大可传输帧大小</td></tr></tbody></table><p>因此，VxLAN 的 overhead 是1514- 1464 = 50 byte。</p><p>![VxLAN Head End Replication](10. Overlay.assets/VxLAN-Head-End-Replication.png)</p><p>基于组播的 VXLAN 网络其实是没有控制平面的，依赖于数据平面的 flood-and-learn，如果交换机不支持组播的话，将会退化到广播，目前这类的应用已经很少了。为了解决组播的依赖，一种方法是通过 HER 的方法复制报文成单播，这样组播报文或者广播报文可以通过单播复制的形式发送，这种方式被称为 Head-End Replication。Open vSwitch Driver 实现的 VXLAN 即使用类似这种方式避免组播的依赖。HER 在即使有控制平面的情况下依然具备价值，因为有可能有静默主机、MAC 表项老化、虚拟机需要使用组播或广播达成业务的需求。</p><h3 id="vxlan-offload" tabindex="-1"><a class="header-anchor" href="#vxlan-offload"><span>VXLAN Offload</span></a></h3><p>一些新型号的网卡(Intel X540 or X710)，具备VXLAN硬件封包／解包能力。开启硬件VXLAN offload，并使用较大的MTU（如9000），可以明显提升虚拟网络的性能。</p><h3 id="开启或关闭vxlan-offload的方法" tabindex="-1"><a class="header-anchor" href="#开启或关闭vxlan-offload的方法"><span>开启或关闭vxlan offload的方法</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>ethtool -k &lt;eth0/eth1&gt; tx-udp_tnl-segmentation &lt;on/off&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="vxlan转发过程" tabindex="-1"><a class="header-anchor" href="#vxlan转发过程"><span>VXLAN转发过程</span></a></h3><h4 id="同vxlan-id内转发" tabindex="-1"><a class="header-anchor" href="#同vxlan-id内转发"><span>同VXLAN ID内转发</span></a></h4><p>VXLAN最早依靠组播泛洪的方式来转发，但这会导致产生大量的组播流量。所以，在实际生产中，通常使用SDN控制器结合南向协议来避免组播问题。</p><p>![VxLAN Forward](10. Overlay.assets/VxLAN-forward.png)</p>`,25),o={href:"http://blog.csdn.net/sinat_31828101/article/details/50504656",target:"_blank",rel:"noopener noreferrer"},h=a(`<h4 id="不同vxlan-id转发" tabindex="-1"><a class="header-anchor" href="#不同vxlan-id转发"><span>不同VXLAN ID转发</span></a></h4><p>大致转发过程与上面类似，所不同的是需要报文在所属vtep或者vxlan gateway处来转换vxlan id（源和目的处都需要做这个转换）。</p><h4 id="vxlan与非vxlan-如vlan-转发" tabindex="-1"><a class="header-anchor" href="#vxlan与非vxlan-如vlan-转发"><span>VXLAN与非VXLAN（如VLAN）转发</span></a></h4><p>需要VXLAN Gateway来转换vxlan vni和vlan id：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>   +---+-----+---+                                    +---+-----+---+
   |    Server 1 |                                    |  Non-VXLAN  |
   (VXLAN enabled)&lt;-----+                       +----&gt;|  server     |
   +-------------+      |                       |     +-------------+
                        |                       |
   +---+-----+---+      |                       |     +---+-----+---+
   |Server 2     |      |                       |     |  Non-VXLAN  |
   (VXLAN enabled)&lt;-----+   +---+-----+---+     +----&gt;|    server   |
   +-------------+      |   |Switch acting|     |     +-------------+
                        |---|  as VXLAN   |-----|
   +---+-----+---+      |   |   Gateway   |
   | Server 3    |      |   +-------------+
   (VXLAN enabled)&lt;-----+
   +-------------+      |
                        |
   +---+-----+---+      |
   | Server 4    |      |
   (VXLAN enabled)&lt;-----+
   +-------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mpbgp-evpn-vxlan" tabindex="-1"><a class="header-anchor" href="#mpbgp-evpn-vxlan"><span>MPBGP EVPN VXLAN</span></a></h3><p>![MPBGP EVPN VxLAN](10. Overlay.assets/MPBGP-EVPN-VxLAN.jpg)</p><p>每一个 VTEP 将作为一个 BGP Speaker，向其他 VTEP 通过 EVPN 发送本地的 MAC、IP 信息，BGP RR 可以避免 BGP 的 Full-Mesh，提高通信效率。得益于控制平面，每个 VTEP 将可作为分布式网关、可以抑制 ARP 广播、可以将广播或组播通过单播复制来提升效率、可以对 VTEP 进行认证。</p><p>具体到 BGP 租网上，有几种选择，包括 iBGP、eBGP 的选择和外部网络通信。</p><p>![VETP Leaf](10. Overlay.assets/VETP-leaf.jpg)</p><p>这种模型下 VTEP 只在 Leaf 上，Spine 中选取两个作为 iBGP RR，Spine 不需要作为 VTEP。此外 RR 也可以有多种放置方法，例如在 Leaf 上，这样 Spine 不需要运行 MPBGP EVPN，或者在额外的专门网络设备。</p><p>如果是 eBGP，典型的部署方法如下图，好处是 Spine 作为 eBGP Peer，而不是 iBGP RR，Spine，Spine上 的 BGP 需要有对 address-family l2vpn evpn 的转发能力，但不需要支持 VXLAN。所有 Leaf 可以设置各自的 AS，也可以设置为同一 AS，eBGP 运维难度较高，参考设计见 draft-ietf-rtgwg-bgp-routing-large-dc，目前一般较少采用。</p><p>![eBGP](10. Overlay.assets/eBGP.jpg)</p><h3 id="distributed-anycast-gateway" tabindex="-1"><a class="header-anchor" href="#distributed-anycast-gateway"><span>Distributed Anycast Gateway</span></a></h3><p>IETF 在 draft-ietf-bess-evpn-inter-subnet-forwarding中对在 EVPN 中属于不同的 VxLan 下如何通过 Integrated Routing and Bridging（以下简称 IRB）处理跨子网通信做了说明，换句话说，EVPN VxLan 提供了原生的基于 IRB 的分布式三层网关参考。</p><p>然而 EVPN VxLan 的实际路由过程可以分成两步来谈，第一部分是虚拟机的 First-hop 的地址，即网关地址，第二部分是如何在不同 VxLan 间路由（IRB），本节会先谈网关地址的问题。</p><p>目前一种实践是使用 Anycast Gateway 技术，每个 VTEP 上均配置相同的 vIP 和 vMAC，如图：</p><p>![Anycast Gateway](10. Overlay.assets/anycast-gateway.jpg)</p><p>这样首先每个虚拟机的网关都在最近的 VTEP 上，可以优化网络路径，其次当虚拟机发生迁移时，不会需要重新获取默认网关的 ARP。在一些厂商中，这项技术被称为 Static Anycast Gateway。</p><h3 id="integrated-routing-and-bridging" tabindex="-1"><a class="header-anchor" href="#integrated-routing-and-bridging"><span>Integrated Routing and Bridging</span></a></h3><p>IRB 即 VTEP 提供三层和二层功能，但是对于具体如何路由，目前存在两种方法，分别为 Asymmetric IRB mode 和 Symmetric IRB mode。前者是非对称模式，后者是对称模式，对于 Asymmetric，结合 Anycast Gateway 后路径是这样的：</p><p>![IRB asymmetric](10. Overlay.assets/IRB-asymmetric.jpg)</p><p>报文由虚拟机发出时，目的 MAC 是网关的虚拟 MAC，VTEP-1 收到报文后查询路由找到 IP-2 对应的虚拟机，查询到对应的 VTEP 为 VTEP-2 后，封上 VxLan 的头部发到 VTEP-2，并将 VNI 设置为对方的 VNI-B，VTEP-2 收到报文后，将 VxLan 头部剥掉换成 Vlan 并发往 VM-2。</p><p>当虚拟机需要回复时，路径完全反过来，即在 VTEP-2 上完成 VXLAN 封包和设置 VNI 为 VNI-A。所以这个过程是非对称的。</p><p>这种实现存在一些显而易见的问题：</p><ul><li>所有的 VTEP 必须配置上所有的 VXALN VNI，否则不同 VNI 通信会存在问题；</li><li>所有的 VTEP 必须获整个 Fabric 完整的 Host tables 信息，否则无法完成完路由。</li></ul><p>另一种实现方法是 Symmetric IRB，其实现与 Asymmetric IRB 最显著的不同是源 VTEP 和目标 VTEP 都会承担三层和二层功能，而不像 Symmetric IRB 只在源 VTEP 做路由。这样最终实现是对称的，但前提是必须引入一个新的概念即 L3 VNI。</p><p>在 Symmetric IRB 中，每个租户的 VRF 会分配一个 L3 VNI，可达信息（NLDR）会在同一个 L3 VNI 下同步，这样每次路由需要将外层 VXLAN 目的地址设置为目的 VTEP 的地址，将 VNI 设置为 L3 VNI。</p><p>![symmetric IRB](10. Overlay.assets/symmetric-IRB.jpg)</p><p>从上面的分析可以得知，Symmetric IRB 最大的好处一是不需要所有 VTEP 均配置所有 VNI，二是不需要所有的 VTEP 知道整个 Fabric 的完整 Host tables 信息。但是，这是建立在不是最差情况的前提，如果说恰好每个租户都在每个 VTEP 下具有虚拟机，或着整个网络只有一个租户，那么网络可能产生退化。Symmetric IRB 的主要优化场景是针对多租户的。</p><p>![symmetric IRB multi tenant](10. Overlay.assets/symmetric-IRB-multi-tenant.jpg)</p><h2 id="nvgre" tabindex="-1"><a class="header-anchor" href="#nvgre"><span>NVGRE</span></a></h2><p>NVGRE主要支持者是Microsoft。与VXLAN不同的是，NVGRE没有采用标准传输协议（TCP/UDP），而是借助通用路由封装协议（GRE）。NVGRE使用GRE头部的低24位作为租户网络标识符（TNI），与VXLAN一样可以支持1600个虚拟网络。为了提供描述带宽利用率粒度的流，传输网络需要使用GRE头，但是这导致NVGRE不能兼容传统负载均衡，这是NVGRE与VXLAN相比最大的区别也是最大的不足。为了提高负载均衡能力建议每个NVGRE主机使用多个IP地址，确保更多流量能够被负载均衡。</p><p>NVGRE不需要依赖泛洪和IP组播进行学习，而是以一种更灵活的方式进行广播，但是这需要依赖硬件/供应商。最后一个区别关于分片，NVGRE支持减小数据包最大传输单元以减小内部虚拟网络数据包大小，不需要要求传输网络支持传输大型帧。</p><p>![NVGRE](10. Overlay.assets/NVGRE.png)</p><h2 id="stt" tabindex="-1"><a class="header-anchor" href="#stt"><span>STT</span></a></h2><p>STT（Stateless Transport Tunneling Protocol）是Nicira提交的隧道协议，类似于VXLAN和VGGRE，它也是把二层的帧封装在一个ip报文的payload中，并在前面增加了tcp头和STT头。注意，STT的tcp头是精心构造出来的，以便利用TSO、LRO、GRO等网卡特性。</p><h2 id="geneve" tabindex="-1"><a class="header-anchor" href="#geneve"><span>Geneve</span></a></h2><p>Geneve（Generic Network Virtualization Encapsulation）旨在统一VXLAN、NVGRE等各种方案，提供更灵活且适用各种虚拟化场景的通用封装协议。</p><p>Geneve使用UDP封包，端口号为6081。</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><ul><li>https://docs.ustack.com/unp/src/architecture/vxlan.html</li><li>http://www.cisco.com/c/en/us/products/collateral/switches/nexus-9000-series-switches/guide-c07-734107.html</li></ul>`,42);function E(v,g){const n=d("ExternalLinkIcon");return r(),i("div",null,[p,t("p",null,[e("(图片来自"),t("a",o,[e("csdn"),s(n)]),e(")")]),h])}const A=l(c,[["render",E],["__file","10. Overlay.html.vue"]]),x=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8B/02.%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/10.%20Overlay.html","title":"Overlay","lang":"zh-CN","frontmatter":{"description":"Overlay Generic Routing Encapsulation (GRE) GRE提供了IP in IP的封装技术: ![GRE Tunnel Encapsulation - RFC2784](10. Overlay.assets/GRE-Tunnel-Encapsulation-RFC2784.jpg) 因此，GRE 的 overhead...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8B/02.%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/10.%20Overlay.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Overlay"}],["meta",{"property":"og:description","content":"Overlay Generic Routing Encapsulation (GRE) GRE提供了IP in IP的封装技术: ![GRE Tunnel Encapsulation - RFC2784](10. Overlay.assets/GRE-Tunnel-Encapsulation-RFC2784.jpg) 因此，GRE 的 overhead..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Overlay\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Overlay","slug":"overlay","link":"#overlay","children":[{"level":2,"title":"Generic Routing Encapsulation (GRE)","slug":"generic-routing-encapsulation-gre","link":"#generic-routing-encapsulation-gre","children":[]},{"level":2,"title":"VXLAN","slug":"vxlan","link":"#vxlan","children":[{"level":3,"title":"VXLAN Offload","slug":"vxlan-offload","link":"#vxlan-offload","children":[]},{"level":3,"title":"开启或关闭vxlan offload的方法","slug":"开启或关闭vxlan-offload的方法","link":"#开启或关闭vxlan-offload的方法","children":[]},{"level":3,"title":"VXLAN转发过程","slug":"vxlan转发过程","link":"#vxlan转发过程","children":[{"level":4,"title":"同VXLAN ID内转发","slug":"同vxlan-id内转发","link":"#同vxlan-id内转发","children":[]},{"level":4,"title":"不同VXLAN ID转发","slug":"不同vxlan-id转发","link":"#不同vxlan-id转发","children":[]},{"level":4,"title":"VXLAN与非VXLAN（如VLAN）转发","slug":"vxlan与非vxlan-如vlan-转发","link":"#vxlan与非vxlan-如vlan-转发","children":[]}]},{"level":3,"title":"MPBGP EVPN VXLAN","slug":"mpbgp-evpn-vxlan","link":"#mpbgp-evpn-vxlan","children":[]},{"level":3,"title":"Distributed Anycast Gateway","slug":"distributed-anycast-gateway","link":"#distributed-anycast-gateway","children":[]},{"level":3,"title":"Integrated Routing and Bridging","slug":"integrated-routing-and-bridging","link":"#integrated-routing-and-bridging","children":[]}]},{"level":2,"title":"NVGRE","slug":"nvgre","link":"#nvgre","children":[]},{"level":2,"title":"STT","slug":"stt","link":"#stt","children":[]},{"level":2,"title":"Geneve","slug":"geneve","link":"#geneve","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.76,"words":2627},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》/02. 网络基础理论/10. Overlay.md","autoDesc":true}');export{A as comp,x as data};
