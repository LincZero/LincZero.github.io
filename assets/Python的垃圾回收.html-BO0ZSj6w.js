import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o,c,a as n,d as s,b as e,e as a}from"./app-DtBZtuIa.js";const i={},u=a('<h1 id="gc-垃圾回收" tabindex="-1"><a class="header-anchor" href="#gc-垃圾回收"><span>GC 垃圾回收</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="python的垃圾回收" tabindex="-1"><a class="header-anchor" href="#python的垃圾回收"><span>Python的垃圾回收</span></a></h1><p>参考：</p>',4),d={href:"https://www.cnblogs.com/chickenwrap/p/10473124.html",target:"_blank",rel:"noopener noreferrer"},r=a(`<h2 id="简概-garbage-collection-gc" tabindex="-1"><a class="header-anchor" href="#简概-garbage-collection-gc"><span>简概 Garbage collection(GC)</span></a></h2><p>现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。 自己管理内存极其自由，可以任意申请内存，但如同一把<strong>双刃剑</strong>，为大量<strong>内存泄露，悬空指针</strong>等bug埋下隐患。</p><p>对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。</p><p>python里也同java一样采用了垃圾收集机制，不过不一样的是: python采用的是<code>引用计数</code>机制为主，<code>标记-清除</code>和<code>分代收集</code>两种机制为辅的策略</p><h2 id="引用计数机制" tabindex="-1"><a class="header-anchor" href="#引用计数机制"><span>引用计数机制</span></a></h2><p>python里每一个东西都是对象，它们的核心就是一个结构体：<code>PyObject</code></p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>typedef struct_object <span class="token punctuation">{</span>
	<span class="token builtin">int</span> ob_refcnt<span class="token punctuation">;</span>				<span class="token comment"># 引用计数。当一个对象有新的引用时。它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少</span>
	struct_typeobject <span class="token operator">*</span>ob_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span> PyObject<span class="token punctuation">;</span>  					<span class="token comment"># PyObject是每个对象必有的内容</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#define Py_INCREF(op)						// 增加计数
	((op)-&gt;ob_refcnt++)
#define Py_DECREF(op)  						// 减少计数
    if (--(op)-&gt;ob_refcnt != 0) \\
    	; \\
    else \\
    	__Py_Dealloc((PyObject *)(op))		// 引用计数为0时删除对象，对象生命就结束了
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="引用计数机制的优点" tabindex="-1"><a class="header-anchor" href="#引用计数机制的优点"><span>引用计数机制的优点</span></a></h3><ol><li>简单</li><li>实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li></ol><h3 id="引用计数机制的缺点" tabindex="-1"><a class="header-anchor" href="#引用计数机制的缺点"><span>引用计数机制的缺点</span></a></h3><ol><li><p>维护引用计数消耗资源</p></li><li><p>循环引用</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
list2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
list1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list2<span class="token punctuation">)</span>
list2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>list1与list2相互引用，即便不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，<strong>所占用的内存永远无法被回收</strong>，这将是致命的。</p><p>对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(标记清除和分代收集)</p></li></ol><h2 id="画说-ruby-与-python-垃圾回收" tabindex="-1"><a class="header-anchor" href="#画说-ruby-与-python-垃圾回收"><span>画说 Ruby 与 Python 垃圾回收</span></a></h2><h2 id="使用gc模块" tabindex="-1"><a class="header-anchor" href="#使用gc模块"><span>使用GC模块</span></a></h2><h3 id="打印类的实例" tabindex="-1"><a class="header-anchor" href="#打印类的实例"><span>打印类的实例</span></a></h3>`,16),k={href:"https://blog.csdn.net/weixin_39951419/article/details/113991530",target:"_blank",rel:"noopener noreferrer"},v=a(`<h4 id="方法一-利用静态成员手动计数" tabindex="-1"><a class="header-anchor" href="#方法一-利用静态成员手动计数"><span>方法一，利用静态成员手动计数</span></a></h4><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>count <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">type</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">type</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>count <span class="token operator">-=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="方法二-使用gc类" tabindex="-1"><a class="header-anchor" href="#方法二-使用gc类"><span>方法二，使用GC类</span></a></h4><p>常用方法（参考官网文档：https://docs.python.org/zh-cn/3/library/gc.html?highlight=gc#module-gc）</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>gc<span class="token punctuation">.</span>enable<span class="token punctuation">(</span><span class="token punctuation">)</span>			<span class="token comment"># 启用自动垃圾回收</span>
gc<span class="token punctuation">.</span>disable<span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token comment"># 停用自动垃圾回收</span>
gc<span class="token punctuation">.</span>isenabled<span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token comment"># 返回是否启用了自动回收</span>

gc<span class="token punctuation">.</span>get_objects<span class="token punctuation">(</span>generation<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>		<span class="token comment"># 返回一个收集器所跟踪的所有对象的列表</span>
gc<span class="token punctuation">.</span>get_count<span class="token punctuation">(</span><span class="token punctuation">)</span>						<span class="token comment"># 将当前回收计数以形为(count0, count1, count2)的元组返回</span>

gc<span class="token punctuation">.</span>is_tracked<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>	<span class="token comment"># 当对象正在被垃圾回收器监控时返回 True。一般来说，原子类的实例不会被监控，原子类（如容器、用户自定义的对象）会被监控</span>
gc<span class="token punctuation">.</span>is_finalized<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment"># 如果给定对象已被垃圾回收器终结则返回 True，否则返回 False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用</p><ul><li>用来检查漏析构对象很方便</li><li>发现漏析构对象用，可以通过<code>print(gc.get_referents(obj))</code>发现循环引用、remove属性不彻底的问题</li></ul><p>举例</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> gc

<span class="token keyword">for</span> obj <span class="token keyword">in</span> gc<span class="token punctuation">.</span>get_objects<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> Node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;GC_Node&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">,</span> gc<span class="token punctuation">.</span>isenabled<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gc<span class="token punctuation">.</span>get_referents<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> Edge<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;GC_Edge&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> Socket<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;GC_Socket&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="手动析构问题-与c-不同" tabindex="-1"><a class="header-anchor" href="#手动析构问题-与c-不同"><span>手动析构问题（与C++不同）</span></a></h2><p>参考：http://c.biancheng.net/view/2371.html</p><ul><li><p>Python中</p><ul><li>不要误认为，只要为该实例对象调用 <code>__del__()</code> 方法，该对象所占用的内存空间就会被释放。</li><li>举个例子：</li></ul><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">CLanguage</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;调用 __init__() 方法构造对象&quot;</span><span class="token punctuation">)</span>
        
    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;调用__del__() 销毁对象，释放其空间&quot;</span><span class="token punctuation">)</span>
        
clangs <span class="token operator">=</span> CLanguage<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#添加一个引用clangs对象的实例对象</span>
cl <span class="token operator">=</span> clangs
<span class="token keyword">del</span> clangs  <span class="token comment"># 手动析构失败。对象没被析构，cl也不会变成空悬指针</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;***********&quot;</span><span class="token punctuation">)</span>

<span class="token triple-quoted-string string">&quot;&quot;&quot; 程序运行结果为：
调用 __init__() 方法构造对象
***********
调用__del__() 销毁对象，释放其空间
&quot;&quot;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++中</p><ul><li>调用析构函数、对象所占用的内存空间必然会被释放。上面的例子中，cl会变成 <code>空悬指针</code></li></ul></li></ul>`,12);function h(b,m){const t=l("ExternalLinkIcon");return o(),c("div",null,[u,n("ul",null,[n("li",null,[n("a",d,[s("【博客园】Python垃圾回收机制（转）"),e(t)])])]),r,n("p",null,[s("参考："),n("a",k,[s("【CSDN】python输出类的实例_打印类的所有实例"),e(t)])]),v])}const _=p(i,[["render",h],["__file","Python的垃圾回收.html.vue"]]),E=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/03.%20Tools/04.%20%E4%BC%98%E5%8C%96%E5%B1%82/GC%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html","title":"GC 垃圾回收","lang":"zh-CN","frontmatter":{"description":"GC 垃圾回收 目录 Python的垃圾回收 参考： 【博客园】Python垃圾回收机制（转） 简概 Garbage collection(GC) 现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。 自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/03.%20Tools/04.%20%E4%BC%98%E5%8C%96%E5%B1%82/GC%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"GC 垃圾回收"}],["meta",{"property":"og:description","content":"GC 垃圾回收 目录 Python的垃圾回收 参考： 【博客园】Python垃圾回收机制（转） 简概 Garbage collection(GC) 现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。 自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GC 垃圾回收\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"GC 垃圾回收","slug":"gc-垃圾回收","link":"#gc-垃圾回收","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"Python的垃圾回收","slug":"python的垃圾回收","link":"#python的垃圾回收","children":[{"level":2,"title":"简概 Garbage collection(GC)","slug":"简概-garbage-collection-gc","link":"#简概-garbage-collection-gc","children":[]},{"level":2,"title":"引用计数机制","slug":"引用计数机制","link":"#引用计数机制","children":[{"level":3,"title":"引用计数机制的优点","slug":"引用计数机制的优点","link":"#引用计数机制的优点","children":[]},{"level":3,"title":"引用计数机制的缺点","slug":"引用计数机制的缺点","link":"#引用计数机制的缺点","children":[]}]},{"level":2,"title":"画说 Ruby 与 Python 垃圾回收","slug":"画说-ruby-与-python-垃圾回收","link":"#画说-ruby-与-python-垃圾回收","children":[]},{"level":2,"title":"使用GC模块","slug":"使用gc模块","link":"#使用gc模块","children":[{"level":3,"title":"打印类的实例","slug":"打印类的实例","link":"#打印类的实例","children":[{"level":4,"title":"方法一，利用静态成员手动计数","slug":"方法一-利用静态成员手动计数","link":"#方法一-利用静态成员手动计数","children":[]},{"level":4,"title":"方法二，使用GC类","slug":"方法二-使用gc类","link":"#方法二-使用gc类","children":[]}]}]},{"level":2,"title":"手动析构问题（与C++不同）","slug":"手动析构问题-与c-不同","link":"#手动析构问题-与c-不同","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.59,"words":1076},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/03. Tools/04. 优化层/GC 垃圾回收/Python的垃圾回收.md","autoDesc":true}');export{_ as comp,E as data};
