import{_ as a,c as l,e as n,o as t}from"./app-DEUP2Tjk.js";const i={};function e(p,s){return t(),l("div",null,s[0]||(s[0]=[n('<h1 id="《数据结构与算法分析》c语言描述" tabindex="-1"><a class="header-anchor" href="#《数据结构与算法分析》c语言描述"><span>《数据结构与算法分析》C语言描述</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="表、栈、队列" tabindex="-1"><a class="header-anchor" href="#表、栈、队列"><span>表、栈、队列</span></a></h1><p>本章讨论最简单和最基本三种数据结构——表、栈、队列</p><p>本章内容</p><ul><li>介绍<code>抽象数据类型</code>（ADT）的概念</li><li>阐述如何对<code>表</code>进行有效的操作</li><li>介绍<code>栈ADT</code>及其实现递归方面的应用</li><li>介绍<code>队列ADT</code>及其在操作系统和算法设计中的应用</li></ul><h2 id="抽象数据类型" tabindex="-1"><a class="header-anchor" href="#抽象数据类型"><span>抽象数据类型</span></a></h2><p>模块化</p><ul><li>描述 <ul><li>程序设计的基本法则之一是例程不应超过一页，这可以通过分割模块（<em>module</em>）来实现</li></ul></li><li>优点 <ul><li>调试小程序比调试大程序容易得多</li><li>多个人同时对一个模块化程序编程要更容易</li><li>一个写得好的模块化程序把某些依赖关系只局限在一个例程中，修改起来更容易</li></ul></li></ul><p>抽象数据类型（<em>Abstract Data Type</em>，ADT）</p><ul><li>描述 <ul><li>是一些操作的集合，是数学的抽象</li></ul></li></ul><h2 id="表adt" tabindex="-1"><a class="header-anchor" href="#表adt"><span>表ADT</span></a></h2><h3 id="表模型" tabindex="-1"><a class="header-anchor" href="#表模型"><span>表模型</span></a></h3><p>概念</p><ul><li>空表（<em>empty list</em>）：大小为0的表</li><li>除空表以外的任何表 <ul><li>表中第一个元素是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，最后一个元素是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>后续<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，或说<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>续<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后，并称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>前驱<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>没有前驱元，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>没有后驱元</li></ul></li></ul><p>表ADT常用的操作集合</p><ul><li><code>MakeEmpty</code></li><li><code>PrintList</code>，打印表</li><li><code>Find</code>，返回关键字首次出现的位置</li><li><code>FindKth</code>，返回某个位置上的元素</li><li><code>Insert</code>，从表的某个位置插入某个关键字</li><li><code>Delete</code>，从表的某个位置删除某个关键字</li></ul><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h3><h4 id="数组实现-表的简单实现" tabindex="-1"><a class="header-anchor" href="#数组实现-表的简单实现"><span>数组实现（表的简单实现）</span></a></h4><p>数组</p><ul><li>对表的所有操作都可以使用数组实现</li></ul><p>性能</p><ul><li><code>PrintList</code>，线性时间</li><li><code>Find</code>，线性时间</li><li><code>FindKth</code>，常数时间</li><li><code>Insert</code>，线性时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><code>Delete</code>，线性时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><p>不足</p><ul><li>可以看到插入和删除需要线性时间，当N次相继插入/删除时需要二次时间（如删除所有元素a），运行会非常慢</li><li>且表的大小必须事先已知</li><li>所以简单数组一般不用来实现表这种结构</li></ul><h4 id="链表实现-linked-list" tabindex="-1"><a class="header-anchor" href="#链表实现-linked-list"><span>链表实现（<em>linked list</em>）</span></a></h4><p>链表与原理</p><ul><li>为了避免插入和删除的线性开销，可以允许表不连续存储。用链表来实现</li><li>每一个结构有表元素和指向后续元的结构的指针（称为Next指针），其中最后一个单元的Next指向NULL</li></ul><p>性能</p><ul><li><code>PrintList</code>，线性时间，（比数组实现稍慢）</li><li><code>Find</code>，线性时间，（比数组实现稍慢）</li><li><code>FindKth</code>，线性时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，（不如数组实现）</li><li><code>Insert</code>，（寻址过程还是线性，但连续插入/删除时仍是线性时间）</li><li><code>Delete</code>，（寻址过程还是线性，但连续插入/删除时仍是线性时间）</li></ul><p>程序实现细节</p><ul><li>起始端插入和删除是特殊情况，需要注意</li><li>除了重载特殊情况外还有个解决方法：留出一个标志节点，称为表头（<em>header</em>）或哑节点（<em>dummy node</em>）</li><li>删除算法需要记住被删除元素前面的表元</li></ul><p>程序</p><ul><li>略，学C++时写过一次了，懒得再写一次</li></ul><blockquote><h5 id="单链表-singly-linked-list" tabindex="-1"><a class="header-anchor" href="#单链表-singly-linked-list"><span>单链表（<em>singly linked list</em>）</span></a></h5></blockquote><p>略，就是普通链表</p><blockquote><h5 id="双链表-doubly-linked-list" tabindex="-1"><a class="header-anchor" href="#双链表-doubly-linked-list"><span>双链表（<em>doubly linked list</em>）</span></a></h5></blockquote><p>有时需要倒序扫描链表，解决方法是在数据结构上增加一个指向前一个单元的指针</p><p>但该方法有额外的空间和性能开销</p><blockquote><h5 id="循环链表" tabindex="-1"><a class="header-anchor" href="#循环链表"><span>循环链表</span></a></h5></blockquote><p>让最后的单元反过来直指第一个单元。这种结构可以有表头也可以没有表头，并且还可以是双向链表</p><p>这种结构在某些应用程序中很流行</p><h4 id="游标实现" tabindex="-1"><a class="header-anchor" href="#游标实现"><span>游标实现</span></a></h4><p>BASIC和FORTRAN等许多语言都不支持指针，若需要链表又不能使用指针，则需要使用其他实现方法——<code>游标实现法</code>（<em>cursor ...</em>）</p><p>思路</p><ul><li>在链表中指针实现中有两个重要特性，游标法需要模仿实现这两套特性 <ul><li>数据存储在一组结构体中。每个结构体包含数据以及指向下一个结构体的指针</li><li>一个新的结构体可以通过调用malloc而从系统全局内存（<em>golbal memory</em>）中得到，并可通过调用free而释放</li></ul></li></ul><p>具体思路</p><ul><li>略</li></ul><p>实现</p><ul><li>略</li></ul><h3 id="应用" tabindex="-1"><a class="header-anchor" href="#应用"><span>应用</span></a></h3><h4 id="表示一元多项式" tabindex="-1"><a class="header-anchor" href="#表示一元多项式"><span>表示一元多项式</span></a></h4><ul><li>这个例子是说对于非稠密多项式，单链表比数组实现更优</li><li>个人感觉这个例子不好，他数组的实现本来就很差，弄结构体列表应该性能差不多吧，又不需要删除和添加多项式中的元素</li><li>反正挺迷惑的？？？</li></ul><h4 id="基数排序-radix-sort" tabindex="-1"><a class="header-anchor" href="#基数排序-radix-sort"><span>基数排序（<em>radix sort</em>）</span></a></h4><p>桶式排序（<em>bucket sort</em>）</p><ul><li>说明 <ul><li>有N个整数，范围从1到M（或从0到M-1），利用该前提可以得到一种快速的排序——桶式排序</li></ul></li><li>思路 <ul><li>留置一个大小为M的数组，称为Count，初始化为0</li><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>被读入时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Count[A_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>增1，读入所有输入后</li><li>扫描数组Count，打印输出排好序的表</li></ul></li><li>性能：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M+N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M=\\Theta(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，则为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><p>基数排序（<em>radix sort</em>）</p><ul><li>说明 <ul><li>也称卡式排序（<em>card sort</em>），因为以前用于老式穿孔卡的排序</li><li>是桶式排序的的推广</li></ul></li><li>思路 <ul><li>排序10个数，范围在0到999之间</li><li>这时不能用桶式排序了，桶会太大。策略是使用多趟桶式排序</li><li>依次对最低（有效）“位”优先的方式进程桶式排序（不能从高位到低位，排序一次就知道为什么了）</li></ul></li><li>性能 <ul><li>时间线性，空间需求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\Theta(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li></ul><h4 id="多重表-大学课程注册例子" tabindex="-1"><a class="header-anchor" href="#多重表-大学课程注册例子"><span>多重表（大学课程注册例子）</span></a></h4><p>多重表（大学课程注册例子）</p><ul><li>应用 <ul><li>大学的课程注册，40000个学生和2500门课程</li><li>要生成两种报告：每个班的注册者、每个学生注册的班级</li></ul></li><li>二维数组实现 <ul><li>常用的实现是二维数组，但这样的数组会有1亿项，空间需求太大</li><li>若一个学生注册3门课程，则有意义的数据有120000项，仅占0.1%，空间利用率低</li></ul></li><li>多重表实现 <ul><li>每个项既在学生链表中又在课程链表中（每个项两个链表指针）</li></ul></li><li>性能 <ul><li>循环表节省空间但花费时间</li></ul></li></ul><h2 id="栈adt" tabindex="-1"><a class="header-anchor" href="#栈adt"><span>栈ADT</span></a></h2><h3 id="栈模型" tabindex="-1"><a class="header-anchor" href="#栈模型"><span>栈模型</span></a></h3><p>概念</p><ul><li>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶（<em>top</em>）</li><li>有时也叫LIFO（后进先出）表</li></ul><p>操作集合</p><ul><li>Push，进栈</li><li>Pop，出栈</li><li>Top，检查最后插入的元素</li><li>对空栈进行Pop或Top被认为是栈ADT的错误</li><li>Push时空间用尽是实现错误，但不是ADT错误</li></ul><h3 id="实现-1" tabindex="-1"><a class="header-anchor" href="#实现-1"><span>实现</span></a></h3><h4 id="链表实现" tabindex="-1"><a class="header-anchor" href="#链表实现"><span>链表实现</span></a></h4><p>链表实现</p><ul><li>程序：略</li><li>性能：较差，对于malloc和free的调用的开销是昂贵的</li></ul><h4 id="数组实现" tabindex="-1"><a class="header-anchor" href="#数组实现"><span>数组实现</span></a></h4><p>（更流行，一般应用程序中栈元素的实际个数不会太大）</p><ul><li>程序：略</li><li>性能：较好</li></ul><h3 id="应用-1" tabindex="-1"><a class="header-anchor" href="#应用-1"><span>应用</span></a></h3><h4 id="平衡符号" tabindex="-1"><a class="header-anchor" href="#平衡符号"><span>平衡符号</span></a></h4><ul><li>说明：编译器检查程序语法时，可以检验每个符号是否都成对出现</li><li>例如：<code>[()]</code>合法，<code>[(])</code>错误</li><li>实现：这个很容易就能想明白了，略</li><li>性能：线性，且是“在线”的（联机算法）</li></ul><h4 id="后缀表达式" tabindex="-1"><a class="header-anchor" href="#后缀表达式"><span>后缀表达式</span></a></h4><ul><li>说明 <ul><li>科学计算器需要先算乘除再算加减，如<code>4.99*1.06 + 5.99 + 6.99*1.06</code></li></ul></li><li>实现 <ul><li>后缀记法 <ul><li>可以将上面的操作顺序书写为：<code>4.99 1.06 * 5.99 + 6.99 1.06 * +</code></li><li>这种记法叫做<code>后缀</code>（<em>postfix</em>）或<code>逆波兰</code>（<em>reverse Polish</em>）记法</li><li>可以用栈来实现后缀记法的计算</li><li>当遇到数就推入栈，遇到符号就弹出两个数运算并将结果推回栈</li></ul></li><li>中缀到后缀的转换 <ul><li>标准形式的表达式（也叫作中缀式（<em>infix</em>））转换成后缀式</li><li>可以用栈来实现中缀到后缀的转换，规则多且繁琐。此处略，详见书</li></ul></li></ul></li><li>性能 <ul><li>后缀计算：线性</li><li>转换到后缀：线性</li></ul></li></ul><h4 id="函数调用" tabindex="-1"><a class="header-anchor" href="#函数调用"><span>函数调用</span></a></h4><p>这个就很经典了</p><p>尾递归（<em>tail recursion</em>）应当被优化以消除，可使用goto语句进行消除，而有些编译器还能自动完成尾调用优化</p><h2 id="队列adt-queue" tabindex="-1"><a class="header-anchor" href="#队列adt-queue"><span>队列ADT（<em>queue</em>）</span></a></h2><h3 id="队列模型" tabindex="-1"><a class="header-anchor" href="#队列模型"><span>队列模型</span></a></h3><p>操作集合</p><ul><li>Enqueue，入队，表末端（也叫队尾，<em>rear</em> ）插入元素</li><li>Dequeue，出队，表开头（也叫队头，<em>front</em>）删除元素</li></ul><h3 id="实现-数组实现" tabindex="-1"><a class="header-anchor" href="#实现-数组实现"><span>实现（数组实现）</span></a></h3><p>数组实现</p><ul><li>一般是使用<code>循环数组</code>（<em>circular array</em>）实现</li></ul><p>注意点</p><ul><li>检验队列是否为空很重要。队列为空时出队操作会返回一个不确定的值</li><li>某些程序设计人员使用不同的方式来表示队列的队头和队尾</li></ul><p>程序</p><ul><li>略</li></ul><h3 id="应用-2" tabindex="-1"><a class="header-anchor" href="#应用-2"><span>应用</span></a></h3><p>应用</p><ul><li>送往行式打印机的作业</li><li>实际生活中的排队</li><li>计算机网络中的文件服务器</li><li>接线员较忙时对大公司的传呼</li><li>大学时学生等待使用终端</li><li>餐馆拿票排队</li></ul><p>其他</p><ul><li>有一个叫<code>排队论</code>（<em>queueing theory</em>）的完整数学分支</li><li>处理用概率的方法计算用户排队预计等待时间、等待服务的队列能排多长，以及其他一些诸如此类的问题</li></ul>',98)]))}const c=a(i,[["render",e],["__file","03. 表、栈、队列.html.vue"]]),r=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Program_Algorithm/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8BC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/03.%20%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97.html","title":"《数据结构与算法分析》C语言描述","lang":"zh-CN","frontmatter":{"description":"《数据结构与算法分析》C语言描述 目录 表、栈、队列 本章讨论最简单和最基本三种数据结构——表、栈、队列 本章内容 介绍抽象数据类型（ADT）的概念 阐述如何对表进行有效的操作 介绍栈ADT及其实现递归方面的应用 介绍队列ADT及其在操作系统和算法设计中的应用 抽象数据类型 模块化 描述 程序设计的基本法则之一是例程不应超过一页，这可以通过分割模块（m...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Program_Algorithm/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8BC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/03.%20%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"《数据结构与算法分析》C语言描述"}],["meta",{"property":"og:description","content":"《数据结构与算法分析》C语言描述 目录 表、栈、队列 本章讨论最简单和最基本三种数据结构——表、栈、队列 本章内容 介绍抽象数据类型（ADT）的概念 阐述如何对表进行有效的操作 介绍栈ADT及其实现递归方面的应用 介绍队列ADT及其在操作系统和算法设计中的应用 抽象数据类型 模块化 描述 程序设计的基本法则之一是例程不应超过一页，这可以通过分割模块（m..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《数据结构与算法分析》C语言描述\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"《数据结构与算法分析》C语言描述","slug":"《数据结构与算法分析》c语言描述","link":"#《数据结构与算法分析》c语言描述","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"表、栈、队列","slug":"表、栈、队列","link":"#表、栈、队列","children":[{"level":2,"title":"抽象数据类型","slug":"抽象数据类型","link":"#抽象数据类型","children":[]},{"level":2,"title":"表ADT","slug":"表adt","link":"#表adt","children":[{"level":3,"title":"表模型","slug":"表模型","link":"#表模型","children":[]},{"level":3,"title":"实现","slug":"实现","link":"#实现","children":[{"level":4,"title":"数组实现（表的简单实现）","slug":"数组实现-表的简单实现","link":"#数组实现-表的简单实现","children":[]},{"level":4,"title":"链表实现（linked list）","slug":"链表实现-linked-list","link":"#链表实现-linked-list","children":[]},{"level":4,"title":"游标实现","slug":"游标实现","link":"#游标实现","children":[]}]},{"level":3,"title":"应用","slug":"应用","link":"#应用","children":[{"level":4,"title":"表示一元多项式","slug":"表示一元多项式","link":"#表示一元多项式","children":[]},{"level":4,"title":"基数排序（radix sort）","slug":"基数排序-radix-sort","link":"#基数排序-radix-sort","children":[]},{"level":4,"title":"多重表（大学课程注册例子）","slug":"多重表-大学课程注册例子","link":"#多重表-大学课程注册例子","children":[]}]}]},{"level":2,"title":"栈ADT","slug":"栈adt","link":"#栈adt","children":[{"level":3,"title":"栈模型","slug":"栈模型","link":"#栈模型","children":[]},{"level":3,"title":"实现","slug":"实现-1","link":"#实现-1","children":[{"level":4,"title":"链表实现","slug":"链表实现","link":"#链表实现","children":[]},{"level":4,"title":"数组实现","slug":"数组实现","link":"#数组实现","children":[]}]},{"level":3,"title":"应用","slug":"应用-1","link":"#应用-1","children":[{"level":4,"title":"平衡符号","slug":"平衡符号","link":"#平衡符号","children":[]},{"level":4,"title":"后缀表达式","slug":"后缀表达式","link":"#后缀表达式","children":[]},{"level":4,"title":"函数调用","slug":"函数调用","link":"#函数调用","children":[]}]}]},{"level":2,"title":"队列ADT（queue）","slug":"队列adt-queue","link":"#队列adt-queue","children":[{"level":3,"title":"队列模型","slug":"队列模型","link":"#队列模型","children":[]},{"level":3,"title":"实现（数组实现）","slug":"实现-数组实现","link":"#实现-数组实现","children":[]},{"level":3,"title":"应用","slug":"应用-2","link":"#应用-2","children":[]}]}]}],"git":{},"readingTime":{"minutes":7.69,"words":2308},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Program_Algorithm/《数据结构与算法分析》C语言描述/03. 表、栈、队列.md","excerpt":"\\n<h1>目录</h1>\\n<h1>表、栈、队列</h1>\\n<p>本章讨论最简单和最基本三种数据结构——表、栈、队列</p>\\n<p>本章内容</p>\\n<ul>\\n<li>介绍<code>抽象数据类型</code>（ADT）的概念</li>\\n<li>阐述如何对<code>表</code>进行有效的操作</li>\\n<li>介绍<code>栈ADT</code>及其实现递归方面的应用</li>\\n<li>介绍<code>队列ADT</code>及其在操作系统和算法设计中的应用</li>\\n</ul>\\n<h2>抽象数据类型</h2>\\n<p>模块化</p>\\n<ul>\\n<li>描述\\n<ul>\\n<li>程序设计的基本法则之一是例程不应超过一页，这可以通过分割模块（<em>module</em>）来实现</li>\\n</ul>\\n</li>\\n<li>优点\\n<ul>\\n<li>调试小程序比调试大程序容易得多</li>\\n<li>多个人同时对一个模块化程序编程要更容易</li>\\n<li>一个写得好的模块化程序把某些依赖关系只局限在一个例程中，修改起来更容易</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Program_Algorithm/《数据结构与算法分析》C语言描述/03. 表、栈、队列.md","value":{"title":"03. 表、栈、队列","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Program_Algorithm/《数据结构与算法分析》C语言描述/03. 表、栈、队列.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{c as comp,r as data};
