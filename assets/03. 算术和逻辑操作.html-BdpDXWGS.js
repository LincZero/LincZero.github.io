import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as e,e as a}from"./app-DtBZtuIa.js";const l={},i=a(`<h1 id="computersystems" tabindex="-1"><a class="header-anchor" href="#computersystems"><span>ComputerSystems</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="算术和逻辑操作" tabindex="-1"><a class="header-anchor" href="#算术和逻辑操作"><span>算术和逻辑操作</span></a></h1><p>整数算术操作（分为<strong>4组</strong>：加载有效地址、一元操作、二元操作、移位）</p><table><thead><tr><th>指令</th><th>单词</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>leaq</td><td></td><td>S、D</td><td>D &lt; &amp;S</td><td>加载有效地址</td></tr><tr><td>——————</td><td></td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td>INC</td><td>increase</td><td>D</td><td>D &lt; D+1</td><td>加1</td></tr><tr><td>EDC</td><td>decrease</td><td>D</td><td>D &lt; D-1</td><td>减1</td></tr><tr><td>NEG</td><td>negative</td><td>D</td><td>D &lt; -D</td><td>取负（-D=~D+1）</td></tr><tr><td>NOT</td><td>not</td><td>D</td><td>D &lt; ~D</td><td>取补（D+~D=-1）</td></tr><tr><td>——————</td><td></td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td>ADD</td><td>add</td><td>S、D</td><td>D &lt; D+S</td><td>加</td></tr><tr><td>SUB</td><td>subtraction</td><td>S、D</td><td>D &lt; D-S</td><td>减</td></tr><tr><td>IMUL</td><td>multiply</td><td>S、D</td><td>D &lt; D*S</td><td>乘</td></tr><tr><td>XOR</td><td>exclusive or</td><td>S、D</td><td>D &lt; D^S</td><td>异或</td></tr><tr><td>OR</td><td>or</td><td>S、D</td><td>D &lt; D|S</td><td>或</td></tr><tr><td>AND</td><td>and</td><td>S、D</td><td>D &lt; D&amp;S</td><td>与</td></tr><tr><td>——————</td><td></td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td>SAL</td><td></td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移</td></tr><tr><td>SHL</td><td></td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移（等同SAL）</td></tr><tr><td>SAR</td><td></td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>A</sub>k</td><td>算术右移</td></tr><tr><td>SHR</td><td></td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>L</sub>k</td><td>逻辑右移</td></tr></tbody></table><p>具体还可细分指令类，如：指令类ADD由四条加法指令组成：addb、addw、addl、addq</p><h2 id="加载有效地址" tabindex="-1"><a class="header-anchor" href="#加载有效地址"><span>加载有效地址</span></a></h2><table><thead><tr><th>指令</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>leaq</td><td>S、D</td><td>D &lt; &amp;S</td><td>加载有效地址</td></tr></tbody></table><ul><li>加载有效地址（load effective address）<code>leaq</code>： <ul><li>是<code>movq</code>指令（传送四字（8字节））的变形，<code>leaq S,D</code>相当于C语言中的<code>D = &amp;S</code> 即<code>leaq S,D</code>等同于<code>movq S的地址,D</code></li><li>妙用：能执行有限形式的2加法&amp;1乘法，如<code>leaq (%rdi,%rsi,4), %rax</code>，十分方便</li></ul></li></ul><h2 id="一元操作" tabindex="-1"><a class="header-anchor" href="#一元操作"><span>一元操作</span></a></h2><table><thead><tr><th>指令</th><th>单词</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>INC</td><td>increase</td><td>D</td><td>D &lt; D+1</td><td>加1</td></tr><tr><td>EDC</td><td>decrease</td><td>D</td><td>D &lt; D-1</td><td>减1</td></tr><tr><td>NEG</td><td>negative</td><td>D</td><td>D &lt; -D</td><td>取负（-D=~D+1）</td></tr><tr><td>NOT</td><td>not</td><td>D</td><td>D &lt; ~D</td><td>取补（D+~D=-1）</td></tr></tbody></table><ul><li><p>一元：inc和dec类似于C语言中的加1运算符和减1运算符</p><ul><li>操作数为寄存器或内存地址</li></ul></li><li><p>地址+1也是加长度而非1，如：<code>incq (%rsp)</code></p></li></ul><h3 id="inc-dec" tabindex="-1"><a class="header-anchor" href="#inc-dec"><span>inc/dec</span></a></h3><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>inc reg/mem		; = add ax 1
dec reg/mem		; = sub ax 1
; 注意：他们不影响eflags的CF符号位
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mul-div" tabindex="-1"><a class="header-anchor" href="#mul-div"><span>mul/div</span></a></h3><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>mul reg/mem		; 操作数应是8/16位
div reg/mem		; 操作数应是8/16位
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>mul/div</p><ul><li>只有一个操作数，所以会有一些指定的寄存器，要预先将数放进去</li><li>mul/div操作数都是无符号的 (不能处理负数)，而add/sub/adc/sbb这些都可以处理有符号数</li></ul><p>mul，注意结果会影响标志位</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>reg/mem8</td><td>al</td><td>ah:al</td></tr><tr><td>reg/mem16</td><td>dx</td><td>dx:ax</td></tr></tbody></table><p>div，注意结果不会影响标志位</p><table><thead><tr><th>被除数</th><th>除数</th><th>余数</th><th>商</th></tr></thead><tbody><tr><td>ax</td><td>reg8/mrm8</td><td>ah</td><td>al</td></tr><tr><td>dx:ax</td><td>reg16/mem16</td><td>dx</td><td>ax</td></tr></tbody></table><p>实战：</p><p>如果需要做一些高位除法，例如32位除以16位的除法，则需要自己写汇编代码</p><p>例如：0x00090006除以2 = 0x00048003余0</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>; 准备
mov dx, 0x0009	; 高16位
mov ax, 0x0006	; 低16位
mov cx, 0x0002	; 
push ax			; 低16位入栈
mov ax, dx		; 高16位放到ax
mov dx, 0		; dx置为0
; ax=0x0009, bx=0x????, cx=0x0002, dx=0x0000, 栈=[0x0006]

; 高位除法
div cx			; 先做高位除法
mov bx, ax		; 商保存至bx
pop ax
; ax=0x0006, bx=0x0004, cx=0x0002, dx=0x0001, 栈=[]
; 注意一下这里的dx是参与在被除数中的，即被除数是0x00010006，结果是不溢出的16位

; 低位除法
div cx			;
; ax=0x8003, bx=0x0004, cx=0x0002, dx=0x0000, 栈=[]
; 最终计算结果 = bx:ax余dx = 0x00048003余0，符合
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二元操作" tabindex="-1"><a class="header-anchor" href="#二元操作"><span>二元操作</span></a></h2><table><thead><tr><th>指令</th><th>单词</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>ADD</td><td>add</td><td>S、D</td><td>D &lt; D+S</td><td>加</td></tr><tr><td>SUB</td><td>subtraction</td><td>S、D</td><td>D &lt; D-S</td><td>减</td></tr><tr><td>IMUL</td><td>multiply</td><td>S、D</td><td>D &lt; D*S</td><td>乘</td></tr><tr><td>XOR</td><td>exclusive or</td><td>S、D</td><td>D &lt; D^S</td><td>异或</td></tr><tr><td>OR</td><td>or</td><td>S、D</td><td>D &lt; D|S</td><td>或</td></tr><tr><td>AND</td><td>and</td><td>S、D</td><td>D &lt; D&amp;S</td><td>与</td></tr></tbody></table><ul><li><p>二元：add和sub类似于C语言中的x+=a和x-=a</p></li><li><p>第一个操作数为立即数、寄存器或内存地址</p><ul><li>第二个操作数为寄存器或内存地址。为内存时：处理器会先读出值、执行操作、再把结果写回内存</li></ul></li></ul><h3 id="add-sub" tabindex="-1"><a class="header-anchor" href="#add-sub"><span>add/sub</span></a></h3><p>基本使用</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>add reg/men reg/mem/imm		;加法，两操作数分别应是8/16位
sub	reg/men reg/mem/imm		;减法，两操作数分别应是8/16位

; 注意add或sub会产生借位或进位，必须将借位或进位保存下来
; CPU内部有一个标志寄存器(eflags)，第0位是CF位，用来保存进位和借位
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证：addsub.asm</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>;不产生进位的加法
mov ax, 0x0001
mov bx, 0x0002
add ax, bx
;产生进位的加法
mov ax, 0xf000
mov bx, 0x1000
add ax, bx
;不产生进位的减法
mov cx, 0x0003
mov dx, 0x0001
sub cx, dx
;产生进位的减法
mov cx, 0x0001
mov dx, 0x0002
sub cx, dx

xh: jmp xh	; xh是自定义命名
times 510($-$$) db 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="add-sub衍生指令-adc-sbb" tabindex="-1"><a class="header-anchor" href="#add-sub衍生指令-adc-sbb"><span>add/sub衍生指令 adc/sbb</span></a></h3><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>adc = add with carry = 被加数+加数+CF
sbb = sub with carry = 被减数-减数-CF
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>应用场景：处理高位的加减法</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>; 例如计算0x0001f000 + 0x000101000，但只有4位寄存器

; bx:ax=0x0001f000
mov bx, 0x0001
mov ax, 0xf000
; dx:cx=0x00101000
mov dx, 0x0010
mov cx, 0x1000
; 低位相加。此时CF=0，可不用adc
add ax, cx
; 高位相加。此时使用adc，若CF=1则会加上CF
adc bx, dx

jmp $
times 510($-$$) db 0

; 结果为bx:ax=0x00120000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="and" tabindex="-1"><a class="header-anchor" href="#and"><span>and/</span></a></h3><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>and dest目的(reg/mem) source源(reg/mem/imm)
or dest目的(reg/mem) source源(reg/mem/imm)
not reg/mem
xor dest目的(reg/mem) source源(reg/mem/imm)	; 会影响标志位
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>骚操作</p><ul><li>当仅取某一位时，用一个数 (如1100) 来与其进行and运算，有1的部分才会保留</li><li>当想将某一位强制变1，用一个数 (如0010) 来与其进行or运算，有1的部分强制变1</li><li>可以用来匹配两个数是否相同，若是则结果全0。可以用来置零</li></ul><h2 id="移位操作" tabindex="-1"><a class="header-anchor" href="#移位操作"><span>移位操作</span></a></h2><table><thead><tr><th>指令</th><th>操作数</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>SAL</td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移</td></tr><tr><td>SHL</td><td>k、D</td><td>D &lt; D&lt;&lt;k</td><td>左移（等同SAL）</td></tr><tr><td>SAR</td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>A</sub>k</td><td>算术右移</td></tr><tr><td>SHR</td><td>k、D</td><td>D &lt; D&gt;&gt;<sub>L</sub>k</td><td>逻辑右移</td></tr></tbody></table><p>骚操作</p><ul><li>当乘或除以一个2^n数时，直接左移或右移</li></ul><h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h1><h2 id="讨论" tabindex="-1"><a class="header-anchor" href="#讨论"><span>讨论</span></a></h2><h2 id="cmp-比较指令" tabindex="-1"><a class="header-anchor" href="#cmp-比较指令"><span>cmp 比较指令</span></a></h2><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>cmp dest(reg/mem) source(reg/mem/imm)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="特殊的算术操作" tabindex="-1"><a class="header-anchor" href="#特殊的算术操作"><span>特殊的算术操作</span></a></h2>`,51),s=[i];function n(r,c){return t(),e("div",null,s)}const b=d(l,[["render",n],["__file","03. 算术和逻辑操作.html.vue"]]),u=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/03.%20%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.html","title":"ComputerSystems","lang":"zh-CN","frontmatter":{"description":"ComputerSystems 目录 算术和逻辑操作 整数算术操作（分为4组：加载有效地址、一元操作、二元操作、移位） 具体还可细分指令类，如：指令类ADD由四条加法指令组成：addb、addw、addl、addq 加载有效地址 加载有效地址（load effective address）leaq： 是movq指令（传送四字（8字节））的变形，leaq...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/03.%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/03.%20%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"ComputerSystems"}],["meta",{"property":"og:description","content":"ComputerSystems 目录 算术和逻辑操作 整数算术操作（分为4组：加载有效地址、一元操作、二元操作、移位） 具体还可细分指令类，如：指令类ADD由四条加法指令组成：addb、addw、addl、addq 加载有效地址 加载有效地址（load effective address）leaq： 是movq指令（传送四字（8字节））的变形，leaq..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ComputerSystems\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"ComputerSystems","slug":"computersystems","link":"#computersystems","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"算术和逻辑操作","slug":"算术和逻辑操作","link":"#算术和逻辑操作","children":[{"level":2,"title":"加载有效地址","slug":"加载有效地址","link":"#加载有效地址","children":[]},{"level":2,"title":"一元操作","slug":"一元操作","link":"#一元操作","children":[{"level":3,"title":"inc/dec","slug":"inc-dec","link":"#inc-dec","children":[]},{"level":3,"title":"mul/div","slug":"mul-div","link":"#mul-div","children":[]}]},{"level":2,"title":"二元操作","slug":"二元操作","link":"#二元操作","children":[{"level":3,"title":"add/sub","slug":"add-sub","link":"#add-sub","children":[]},{"level":3,"title":"add/sub衍生指令 adc/sbb","slug":"add-sub衍生指令-adc-sbb","link":"#add-sub衍生指令-adc-sbb","children":[]},{"level":3,"title":"and/","slug":"and","link":"#and","children":[]}]},{"level":2,"title":"移位操作","slug":"移位操作","link":"#移位操作","children":[]}]},{"level":1,"title":"其他","slug":"其他","link":"#其他","children":[{"level":2,"title":"讨论","slug":"讨论","link":"#讨论","children":[]},{"level":2,"title":"cmp 比较指令","slug":"cmp-比较指令","link":"#cmp-比较指令","children":[]},{"level":2,"title":"特殊的算术操作","slug":"特殊的算术操作","link":"#特殊的算术操作","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.71,"words":1412},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/02. 计算机指令/03. 汇编指令/03. 算术和逻辑操作.md","autoDesc":true}');export{b as comp,u as data};
