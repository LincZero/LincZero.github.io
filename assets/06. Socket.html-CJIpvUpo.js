import{_ as t,c as n,a as o,o as s}from"./app-DxUtpnUG.js";const c="/assets/12-TCP编程模型-CRdzl9Le.jpg",a="/assets/13-UDP编程模型-pI3SkzW6.jpg",l={};function i(p,e){return s(),n("div",null,e[0]||(e[0]=[o(`<h1 id="socket" tabindex="-1"><a class="header-anchor" href="#socket"><span>Socket</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想 <strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><h3 id="系统调用使用" tabindex="-1"><a class="header-anchor" href="#系统调用使用"><span>系统调用使用</span></a></h3><p>我们来看看创建 socket 的系统调用：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/**
 * @param domain 用来指定协议族。比如：
 *   - AF_INET 用于 IPV4
 *   - AF_INET6 用于 IPV6
 *   - AF_LOCAL/AF_UNIX 用于本机；
 *
 * @param type 用来指定通信特性。比如：
 *   - SOCK_STREAM 表示的是字节流，对应 TCP、
 *   - SOCK_DGRAM  表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；
 *
 * @param protocal 原本是用来指定通信协议的，但现在基本废弃。
 *     因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；
 */</span>
<span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocal<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="socket-类型" tabindex="-1"><a class="header-anchor" href="#socket-类型"><span>Socket 类型</span></a></h3><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信： <ul><li>「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM</li><li>「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM</li><li>另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul></li></ul><h2 id="三种socket类型" tabindex="-1"><a class="header-anchor" href="#三种socket类型"><span>三种Socket类型</span></a></h2><p>接下来，简单说一下这三种通信的编程模式。</p><h3 id="针对-tcp-协议通信的-socket-编程模型" tabindex="-1"><a class="header-anchor" href="#针对-tcp-协议通信的-socket-编程模型"><span>针对 TCP 协议通信的 socket 编程模型</span></a></h3><p><img src="`+c+'" alt="img" loading="lazy"></p><p>流程：</p><ol><li>准备及连接阶段 <ol><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li></ol></li><li>通信阶段 <ol><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li></ol></li><li>断开阶段 <ol><li>客户端断开连接时，会调用 <code>close</code>。那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ol></li></ol><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket：</p><ul><li>一个叫作 <strong>监听 socket</strong>；</li><li>一个叫作 <strong>已完成连接 socket</strong>。</li></ul><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h3 id="针对-udp-协议通信的-socket-编程模型" tabindex="-1"><a class="header-anchor" href="#针对-udp-协议通信的-socket-编程模型"><span>针对 UDP 协议通信的 socket 编程模型</span></a></h3><p><img src="'+a+'" alt="img" loading="lazy"></p><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p><h3 id="针对本地进程间通信的-socket-编程模型" tabindex="-1"><a class="header-anchor" href="#针对本地进程间通信的-socket-编程模型"><span>针对本地进程间通信的 socket 编程模型</span></a></h3><p>本地 socket 被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>区别：本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p>',32)]))}const r=t(l,[["render",i],["__file","06. Socket.html.vue"]]),k=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/02.%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/06.%20Socket.html","title":"Socket","lang":"zh-CN","frontmatter":{"description":"Socket 介绍 前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想 跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。 实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。 系统调用使用 我们来看看创建 socket 的系统调用： Socket 类型 根据创...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/02.%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/06.%20Socket.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"Socket"}],["meta",{"property":"og:description","content":"Socket 介绍 前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想 跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。 实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。 系统调用使用 我们来看看创建 socket 的系统调用： Socket 类型 根据创..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Socket\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"Socket","slug":"socket","link":"#socket","children":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[{"level":3,"title":"系统调用使用","slug":"系统调用使用","link":"#系统调用使用","children":[]},{"level":3,"title":"Socket 类型","slug":"socket-类型","link":"#socket-类型","children":[]}]},{"level":2,"title":"三种Socket类型","slug":"三种socket类型","link":"#三种socket类型","children":[{"level":3,"title":"针对 TCP 协议通信的 socket 编程模型","slug":"针对-tcp-协议通信的-socket-编程模型","link":"#针对-tcp-协议通信的-socket-编程模型","children":[]},{"level":3,"title":"针对 UDP 协议通信的 socket 编程模型","slug":"针对-udp-协议通信的-socket-编程模型","link":"#针对-udp-协议通信的-socket-编程模型","children":[]},{"level":3,"title":"针对本地进程间通信的 socket 编程模型","slug":"针对本地进程间通信的-socket-编程模型","link":"#针对本地进程间通信的-socket-编程模型","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.58,"words":1075},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/02. 通信方式/06. Socket.md","excerpt":"\\n<h2>介绍</h2>\\n<p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想 <strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p>\\n<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p>\\n<h3>系统调用使用</h3>\\n<p>我们来看看创建 socket 的系统调用：</p>\\n<div class=\\"language-c\\" data-ext=\\"c\\" data-title=\\"c\\"><pre class=\\"language-c\\"><code><span class=\\"token comment\\">/**\\n * @param domain 用来指定协议族。比如：\\n *   - AF_INET 用于 IPV4\\n *   - AF_INET6 用于 IPV6\\n *   - AF_LOCAL/AF_UNIX 用于本机；\\n *\\n * @param type 用来指定通信特性。比如：\\n *   - SOCK_STREAM 表示的是字节流，对应 TCP、\\n *   - SOCK_DGRAM  表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；\\n *\\n * @param protocal 原本是用来指定通信协议的，但现在基本废弃。\\n *     因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；\\n */</span>\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">socket</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> domain<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">int</span> type<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">int</span> protocal<span class=\\"token punctuation\\">)</span>\\n</code></pre></div>","autoDesc":true}');export{r as comp,k as data};
