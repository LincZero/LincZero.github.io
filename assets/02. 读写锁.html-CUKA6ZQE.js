import{_ as t,c as n,e as l,o}from"./app-_6RECMRt.js";const i="/assets/%E8%AF%BB%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-Dtd_sGMc.png",a="/assets/%E5%86%99%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-Bd7b-d3R.png",p={};function r(E,e){return o(),n("div",null,e[0]||(e[0]=[l('<h1 id="读写锁" tabindex="-1"><a class="header-anchor" href="#读写锁"><span>读写锁</span></a></h1><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p><p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p><h2 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h2><p>读写锁的工作原理是：</p><ul><li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li><li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p>所以说，写锁是<strong>独占锁</strong>，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是<strong>共享锁</strong>，因为读锁可以被多个线程同时持有。</p><p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</p><h2 id="读写锁类别" tabindex="-1"><a class="header-anchor" href="#读写锁类别"><span>读写锁类别</span></a></h2><h3 id="读优先锁" tabindex="-1"><a class="header-anchor" href="#读优先锁"><span>读优先锁</span></a></h3><p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p><p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</p><p><img src="'+i+'" alt="img" loading="lazy"></p><h3 id="写优先锁" tabindex="-1"><a class="header-anchor" href="#写优先锁"><span>写优先锁</span></a></h3><p>而「写优先锁」是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。如下图：</p><p><img src="'+a+'" alt="img" loading="lazy"></p><p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p><p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p><h3 id="公平读写锁" tabindex="-1"><a class="header-anchor" href="#公平读写锁"><span>公平读写锁</span></a></h3><p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p><p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>',22)]))}const B=t(p,[["render",r],["__file","02. 读写锁.html.vue"]]),c=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/05.%20%E6%9B%B4%E5%A4%9A%E9%94%81/02.%20%E8%AF%BB%E5%86%99%E9%94%81.html","title":"读写锁","lang":"zh-CN","frontmatter":{"description":"读写锁 读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。 所以，读写锁适用于能明确区分读操作和写操作的场景。 实现原理 读写锁的工作原理是： 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/05.%20%E6%9B%B4%E5%A4%9A%E9%94%81/02.%20%E8%AF%BB%E5%86%99%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"读写锁"}],["meta",{"property":"og:description","content":"读写锁 读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。 所以，读写锁适用于能明确区分读操作和写操作的场景。 实现原理 读写锁的工作原理是： 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"读写锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"读写锁","slug":"读写锁","link":"#读写锁","children":[{"level":2,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]},{"level":2,"title":"读写锁类别","slug":"读写锁类别","link":"#读写锁类别","children":[{"level":3,"title":"读优先锁","slug":"读优先锁","link":"#读优先锁","children":[]},{"level":3,"title":"写优先锁","slug":"写优先锁","link":"#写优先锁","children":[]},{"level":3,"title":"公平读写锁","slug":"公平读写锁","link":"#公平读写锁","children":[]}]}]}],"git":{},"readingTime":{"minutes":2.95,"words":884},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/05. 更多锁/02. 读写锁.md","excerpt":"\\n<p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p>\\n<p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p>\\n<h2>实现原理</h2>\\n<p>读写锁的工作原理是：</p>\\n<ul>\\n<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li>\\n<li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/05. 更多锁/02. 读写锁.md","value":{"title":"02. 读写锁","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/05. 更多锁/02. 读写锁.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{B as comp,c as data};
