import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as n}from"./app-yixEWCFr.js";const i="/assets/20210319000028665-BTc30K0m.png",l={},r=n(`<h1 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C++</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="oop-vs-gp" tabindex="-1"><a class="header-anchor" href="#oop-vs-gp"><span>OOP vs GP</span></a></h1><h2 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较</span></a></h2><h3 id="数据和方法的区别" tabindex="-1"><a class="header-anchor" href="#数据和方法的区别"><span>数据和方法的区别</span></a></h3><ul><li><p>OOP的目的是将<strong>数据</strong>和<strong>方法</strong>绑定在一起</p><ul><li>例如对<code>std::list</code>容器进行排序要调用<code>std::list::sort</code>方法</li></ul></li><li><p>GP的目的是将<strong>数据</strong>和<strong>方法</strong>分离开来</p><ul><li>例如对<code>std::vector</code>容器进行排序要调用<code>std::sort</code>方法</li></ul></li></ul><h3 id="oop-object-oriented-programming" tabindex="-1"><a class="header-anchor" href="#oop-object-oriented-programming"><span>OOP（Object-Oriented Programming）</span></a></h3><p><mark>OOP企图将 datas 和 methods 关联在一起</mark></p><p>类定义</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>/* list类 */
template &lt;class T, class Alloc=alloc&gt;
class list {
    //...
    void sort();
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Q：引申问题：为什么list不能用<code>::sort</code>排序</li><li>A：<code>std::sort</code>的实现使用了随机访问，而list不能随机访问，不能用<code>::sort</code>排序</li></ul><h3 id="gp-generic-programming" tabindex="-1"><a class="header-anchor" href="#gp-generic-programming"><span>GP（Generic Programming）</span></a></h3><p>标准库使用GP编程</p><p><mark>GP却是将 datas 和 methods 分开来</mark></p><p>类定义（这两个容器都提供 RandomAccessIterator 随机遍历器）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>/* vector类 */
template &lt;class T, class Alloc=alloc&gt;
class vector {
    //...
    //（没有sort方法）
};

/* deque类 */
template &lt;class T, class Alloc=alloc, size_t BufSiz=0&gt;
class deque {
    //...
    //（没有sort方法）
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>算法 Algorithms（排序）</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>template&lt;typename _RandomAccessIterator&gt;
inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
    // std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
}

template&lt;typename _RandomAccessIterator, typename _Compare&gt;
inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
    if (__first != __last) {
        std::__introsort_loop(__first, __last,
                              std::__lg(__last - __first) * 2,		// 对iterator进行减运算,std::list的iterator没有实现该运算
                              __comp);
        std::__final_insertion_sort(__first, __last, __comp);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="gp-补充" tabindex="-1"><a class="header-anchor" href="#gp-补充"><span>GP 补充</span></a></h2><h3 id="好处" tabindex="-1"><a class="header-anchor" href="#好处"><span>好处</span></a></h3><ul><li>Containers 和 Algorithms 团队可以各自开发，其间以Iterator沟通即可</li><li>Algorithms 通过 Iterator 确定操作范围，并通过Iterator取用Container元素</li></ul><h3 id="组件结构" tabindex="-1"><a class="header-anchor" href="#组件结构"><span>组件结构</span></a></h3><ul><li><p>图示</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
仿函数_Functors_例comp仿函数<span class="token arrow operator">--&gt;</span>
算法_Algorithms_例sort方法<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">-.</span><span class="token label property">迭代器_Iterators</span><span class="token arrow operator">..-&gt;</span></span>
容器_Containers_例vector或deque容器
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>复习下六组件结构</p><div class="language-mermaid line-numbers-mode" data-ext="mermaid" data-title="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> LR
<span class="token keyword">subgraph</span> 迭代器适配器
	迭代器
<span class="token keyword">end</span>
<span class="token keyword">subgraph</span> 容器适配器
	容器
<span class="token keyword">end</span>
<span class="token keyword">subgraph</span> 仿函数适配器
	仿函数
<span class="token keyword">end</span>
分配器<span class="token arrow operator">--&gt;</span>容器
仿函数<span class="token arrow operator">--&gt;</span>算法<span class="token arrow operator">-.-&gt;</span>迭代器<span class="token arrow operator">-.-&gt;</span>容器
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="操作符重载-vs-模板-泛化、全特化、偏特化" tabindex="-1"><a class="header-anchor" href="#操作符重载-vs-模板-泛化、全特化、偏特化"><span>操作符重载 vs 模板（泛化、全特化、偏特化）</span></a></h2><figure><img src="`+i+'" alt="请添加图片描述" tabindex="0" loading="lazy"><figcaption>请添加图片描述</figcaption></figure><h3 id="operator-overloading-操作符重载" tabindex="-1"><a class="header-anchor" href="#operator-overloading-操作符重载"><span>Operator Overloading 操作符重载</span></a></h3><p>略</p><h3 id="templates-模板" tabindex="-1"><a class="header-anchor" href="#templates-模板"><span>Templates 模板</span></a></h3><p>略</p>',29),t=[r];function d(o,c){return s(),a("div",null,t)}const v=e(l,[["render",d],["__file","08. OOP vs GP.html.vue"]]),g=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/STL/08.%20OOP%20vs%20GP.html","title":"C++","lang":"zh-CN","frontmatter":{"description":"C++ 目录 OOP vs GP 比较 数据和方法的区别 OOP的目的是将数据和方法绑定在一起 例如对std::list容器进行排序要调用std::list::sort方法 GP的目的是将数据和方法分离开来 例如对std::vector容器进行排序要调用std::sort方法 OOP（Object-Oriented Programming） OOP企图...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/STL/08.%20OOP%20vs%20GP.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"C++"}],["meta",{"property":"og:description","content":"C++ 目录 OOP vs GP 比较 数据和方法的区别 OOP的目的是将数据和方法绑定在一起 例如对std::list容器进行排序要调用std::list::sort方法 GP的目的是将数据和方法分离开来 例如对std::vector容器进行排序要调用std::sort方法 OOP（Object-Oriented Programming） OOP企图..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"C++","slug":"c","link":"#c","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"OOP vs GP","slug":"oop-vs-gp","link":"#oop-vs-gp","children":[{"level":2,"title":"比较","slug":"比较","link":"#比较","children":[{"level":3,"title":"数据和方法的区别","slug":"数据和方法的区别","link":"#数据和方法的区别","children":[]},{"level":3,"title":"OOP（Object-Oriented Programming）","slug":"oop-object-oriented-programming","link":"#oop-object-oriented-programming","children":[]},{"level":3,"title":"GP（Generic Programming）","slug":"gp-generic-programming","link":"#gp-generic-programming","children":[]}]},{"level":2,"title":"GP 补充","slug":"gp-补充","link":"#gp-补充","children":[{"level":3,"title":"好处","slug":"好处","link":"#好处","children":[]},{"level":3,"title":"组件结构","slug":"组件结构","link":"#组件结构","children":[]}]},{"level":2,"title":"操作符重载 vs 模板（泛化、全特化、偏特化）","slug":"操作符重载-vs-模板-泛化、全特化、偏特化","link":"#操作符重载-vs-模板-泛化、全特化、偏特化","children":[{"level":3,"title":"Operator Overloading 操作符重载","slug":"operator-overloading-操作符重载","link":"#operator-overloading-操作符重载","children":[]},{"level":3,"title":"Templates 模板","slug":"templates-模板","link":"#templates-模板","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.65,"words":496},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/07. 模块库/STL/08. OOP vs GP.md","autoDesc":true}');export{v as comp,g as data};
