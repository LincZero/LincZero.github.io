import{_ as r,c as o,e as n,a as t,f as e,o as s}from"./app-CcegWvWz.js";const i={};function a(d,l){return s(),o("div",null,l[0]||(l[0]=[n('<h1 id="【材质】贴图网站-材质贴图后缀" tabindex="-1"><a class="header-anchor" href="#【材质】贴图网站-材质贴图后缀"><span>【材质】贴图网站&amp;材质贴图后缀</span></a></h1><p>材质贴图怎么用</p><p>​ 各种材质贴图网站</p><p>​ Vizpark,cgtrader,artstation,cgAxis,</p><p>​ 【textures.com】,【texturesHaven.com】,arroway,</p><p>​ Quixel Mwgascans,gumroad,substance,【poliiGon.com】</p><p>​</p><p>​ 3dtexture,cco texture</p><p>​ PBR材质</p><p>​常见通道贴图：</p>',10),t("div",{class:"ab-note drop-shadow"},[t("table",{class:"ab-table ab-list-table ab-listtable-likelist"},[t("tbody",null,[t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"true",type:"漫反射",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 0
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"漫反射")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Diffuse/Albedo/Basecolor")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"1",is_fold:"false",able_fold:"false",type:"漫反射1",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 1
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"漫反射1")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"detail1")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"1",is_fold:"false",able_fold:"false",type:"漫反射2",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 2
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"漫反射2")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"detail2")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"反射",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 3
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"反射")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Reflection/Specular")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"金属度",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 4
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"金属度")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Metalness(对应IOR理解？)")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"​光泽度",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 5
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"​光泽度")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Glossiness")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"粗糙度",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 6
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"粗糙度")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Roughness")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"法线",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 7
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"法线")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,[e("Normal"),t("br"),e(" OpenGL和DirectX两种模式的rgb分别对应(x,y,z),(x,-y,z)")])])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"置换",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 8
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"置换")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Displacement/Height")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"凹凸",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 9
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"凹凸")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Bump")])])])]),t("tr",{class:"ab-foldable-tr",tr_level:"0",is_fold:"false",able_fold:"false",type:"环境光遮蔽",onclick:`
         const tr = this
         const l_tr = tr.parentNode.querySelectorAll("tr")
         const i = 10
         const tr_level = Number(tr.getAttribute("tr_level"))
         if (isNaN(tr_level)) return
         const tr_isfold = tr.getAttribute("is_fold")
         if (!tr_isfold) return
         let flag_do_fold = false  // 防止折叠最小层
         for (let j=i+1; j<l_tr.length; j++){
           const tr2 = l_tr[j]
           const tr_level2 = Number(tr2.getAttribute("tr_level"))
           if (isNaN(tr_level2)) break
           if (tr_level2<=tr_level) break
           (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
           flag_do_fold = true
         }
         if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
        `},[t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"环境光遮蔽")])])]),t("td",{rowspan:"1"},[t("div",{class:"ab-list-table-witharrow markdown-rendered"},[t("div",null,[t("p",null,"Ambient Occlusion(AO)")])])])])]),t("button",{class:"ab-table-fold",is_fold:"false"},"全部折叠/展开")])],-1),t("p",null,"​AO的常用两种做法",-1),t("p",null,[e("​1. 与漫反射贴图正片叠底，丰富暗部细节"),t("br"),e(" ​2. 与置换贴图正片叠底，增强凹凸效果对比"),t("br"),e(" ​ 光泽度，IOR，法线图不要de-gamma"),t("br"),e(" ​ 金属度，粗糙度，置换，凹凸似乎也不要de-gamma")],-1)]))}const _=r(i,[["render",a],["__file","【材质】贴图网站_材质贴图后缀.html.vue"]]),f=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/3D/Render/%E6%B8%B2%E6%9F%93%E5%99%A8/02.%20VRay/%E3%80%90%E6%9D%90%E8%B4%A8%E3%80%91%E8%B4%B4%E5%9B%BE%E7%BD%91%E7%AB%99_%E6%9D%90%E8%B4%A8%E8%B4%B4%E5%9B%BE%E5%90%8E%E7%BC%80.html","title":"【材质】贴图网站&材质贴图后缀","lang":"zh-CN","frontmatter":{"last_time":"2020.02.26","tag":"有道云","description":"【材质】贴图网站&材质贴图后缀 材质贴图怎么用 ​ 各种材质贴图网站 ​ Vizpark,cgtrader,artstation,cgAxis, ​ 【textures.com】,【texturesHaven.com】,arroway, ​ Quixel Mwgascans,gumroad,substance,【poliiGon.com】 ​ ​ 3d...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/3D/Render/%E6%B8%B2%E6%9F%93%E5%99%A8/02.%20VRay/%E3%80%90%E6%9D%90%E8%B4%A8%E3%80%91%E8%B4%B4%E5%9B%BE%E7%BD%91%E7%AB%99_%E6%9D%90%E8%B4%A8%E8%B4%B4%E5%9B%BE%E5%90%8E%E7%BC%80.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"【材质】贴图网站&材质贴图后缀"}],["meta",{"property":"og:description","content":"【材质】贴图网站&材质贴图后缀 材质贴图怎么用 ​ 各种材质贴图网站 ​ Vizpark,cgtrader,artstation,cgAxis, ​ 【textures.com】,【texturesHaven.com】,arroway, ​ Quixel Mwgascans,gumroad,substance,【poliiGon.com】 ​ ​ 3d..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"有道云"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【材质】贴图网站&材质贴图后缀\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"【材质】贴图网站&材质贴图后缀","slug":"【材质】贴图网站-材质贴图后缀","link":"#【材质】贴图网站-材质贴图后缀","children":[]}],"git":{},"readingTime":{"minutes":0.67,"words":200},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/3D/Render/渲染器/02. VRay/【材质】贴图网站&材质贴图后缀.md","excerpt":"\\n<p>材质贴图怎么用</p>\\n<p>​\\t各种材质贴图网站</p>\\n<p>​\\t\\tVizpark,cgtrader,artstation,cgAxis,</p>\\n<p>​\\t\\t【textures.com】,【texturesHaven.com】,arroway,</p>\\n<p>​\\t\\tQuixel Mwgascans,gumroad,substance,【poliiGon.com】</p>\\n<p>​</p>\\n<p>​\\t\\t3dtexture,cco texture</p>\\n<p>​\\tPBR材质</p>\\n<p>​常见通道贴图：</p>\\n<div class=\\"ab-note drop-shadow\\"><button class=\\"ab-table-fold\\" is_fold=\\"false\\">全部折叠/展开</button><table class=\\"ab-table ab-list-table ab-listtable-likelist\\"><tbody><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"true\\" type=\\"漫反射\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 0\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>漫反射</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Diffuse/Albedo/Basecolor</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"1\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"漫反射1\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 1\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>漫反射1</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>detail1</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"1\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"漫反射2\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 2\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>漫反射2</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>detail2</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"反射\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 3\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>反射</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Reflection/Specular</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"金属度\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 4\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>金属度</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Metalness(对应IOR理解？)</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"​光泽度\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 5\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>​光泽度</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Glossiness</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"粗糙度\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 6\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>粗糙度</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Roughness</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"法线\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 7\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>法线</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Normal<br>\\nOpenGL和DirectX两种模式的rgb分别对应(x,y,z),(x,-y,z)</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"置换\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 8\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>置换</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Displacement/Height</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"凹凸\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 9\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>凹凸</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Bump</p>\\n</div></div></td></tr><tr class=\\"ab-foldable-tr\\" tr_level=\\"0\\" is_fold=\\"false\\" able_fold=\\"false\\" type=\\"环境光遮蔽\\" onclick=\\"\\n         const tr = this\\n         const l_tr = tr.parentNode.querySelectorAll(&quot;tr&quot;)\\n         const i = 10\\n         const tr_level = Number(tr.getAttribute(&quot;tr_level&quot;))\\n         if (isNaN(tr_level)) return\\n         const tr_isfold = tr.getAttribute(&quot;is_fold&quot;)\\n         if (!tr_isfold) return\\n         let flag_do_fold = false  // 防止折叠最小层\\n         for (let j=i+1; j<l_tr.length; j++){\\n           const tr2 = l_tr[j]\\n           const tr_level2 = Number(tr2.getAttribute(&quot;tr_level&quot;))\\n           if (isNaN(tr_level2)) break\\n           if (tr_level2<=tr_level) break\\n           (tr_isfold == &quot;true&quot;) ? tr2.style.display = &quot;&quot; : tr2.style.display = &quot;none&quot;\\n           flag_do_fold = true\\n         }\\n         if (flag_do_fold) tr.setAttribute(&quot;is_fold&quot;, tr_isfold==&quot;true&quot;?&quot;false&quot;:&quot;true&quot;)\\n        \\"><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>环境光遮蔽</p>\\n</div></div></td><td rowspan=\\"1\\"><div class=\\"ab-list-table-witharrow markdown-rendered\\"><div><p>Ambient Occlusion(AO)</p>\\n</div></div></td></tr></tbody></table></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/3D/Render/渲染器/02. VRay/【材质】贴图网站&材质贴图后缀.md","value":{"title":"【材质】贴图网站&材质贴图后缀","path":"MdNote_Public/01. DesignAndDevelop/3D/Render/渲染器/02. VRay/【材质】贴图网站&材质贴图后缀.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{_ as comp,f as data};
