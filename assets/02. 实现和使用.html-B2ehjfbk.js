import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-D9NcyM5y.js";const t="/assets/12-互斥锁-D2N0D2Qi.jpg",p="/assets/16-火车PV操作-Dw3AWuqj.jpg",o="/assets/18-互斥信号量-DTAXQ564.jpg",c="/assets/20-生产者消费者-CUwn8Doc.jpg",l={},i=e('<h1 id="互斥与同步的实现和使用" tabindex="-1"><a class="header-anchor" href="#互斥与同步的实现和使用"><span>互斥与同步的实现和使用</span></a></h1><p>在进程/线程并发执行的过程中，进程/线程之间存在协作的关系，例如有互斥、同步的关系。</p><p>为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：</p><ul><li><em>锁</em>：加锁、解锁操作；</li><li><em>信号量</em>：P、V 操作；</li></ul><p>这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。</p><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span>锁</span></a></h2><p>使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。</p><p>任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。</p><figure><img src="'+t+`" alt="加锁-解锁" tabindex="0" loading="lazy"><figcaption>加锁-解锁</figcaption></figure><p>根据锁的实现不同，可以分为「忙等待锁」和「无忙等待锁」。</p><h3 id="原子操作、测试和置位" tabindex="-1"><a class="header-anchor" href="#原子操作、测试和置位"><span>原子操作、测试和置位</span></a></h3><p>我们先来看看「忙等待锁」的实现</p><p>在说明「忙等待锁」的实现之前，先介绍现代 CPU 体系结构提供的特殊 <strong>原子操作指令 —— 测试和置位（<em>Test-and-Set</em>）指令</strong>。</p><p>如果用 C 代码表示 Test-and-Set 指令，形式如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/**
 *  (原子性) 测试和置位
 *
 * 函数作用：
 * - 把 \`old_ptr\` 更新为 \`new\` 的新值
 * - 返回 \`old_ptr\` 的旧值；
 */</span>
<span class="token keyword">int</span> <span class="token function">TestAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> old_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> new<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token operator">*</span>old_ptr<span class="token punctuation">;</span>
    <span class="token operator">*</span>old_ptr <span class="token operator">=</span> new<span class="token punctuation">;</span>
    <span class="token keyword">return</span> old<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，<strong>关键是这些代码是原子执行</strong>。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作「测试并设置」。</p><p>那什么是原子操作呢？<strong>原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态</strong></p><h3 id="_1-忙等待锁-也叫-自旋锁" tabindex="-1"><a class="header-anchor" href="#_1-忙等待锁-也叫-自旋锁"><span>(1) 忙等待锁 (也叫 自旋锁)</span></a></h3><p>我们可以运用 Test-and-Set 指令来实现「忙等待锁」，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">lock_t</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> flag<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">lock_t</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>lock t <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
	lock<span class="token operator">-&gt;</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">TestAndset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>flag<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">;</span><span class="token comment">// do noting</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
	lock<span class="token operator">-&gt;</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来确保理解为什么这个锁能工作：</p><ol><li>第一个场景是，首先假设一个线程在运行，调用 <code>lock()</code>，没有其他线程持有锁，所以 <code>flag</code> 是 0。当调用 <code>TestAndSet(flag, 1)</code> 方法，返回 0，线程会跳出 while 循环，获取锁。同时也会原子的设置 flag 为1，标志锁已经被持有。当线程离开临界区，调用 <code>unlock()</code> 将 <code>flag</code> 清理为 0。</li><li>第二种场景是，当某一个线程已经持有锁（即 <code>flag</code> 为1）。本线程调用 <code>lock()</code>，然后调用 <code>TestAndSet(flag, 1)</code>，这一次返回 1。只要另一个线程一直持有锁，<code>TestAndSet()</code> 会重复返回 1，本线程会一直<strong>忙等</strong>。当 <code>flag</code> 终于被改为 0，本线程会调用 <code>TestAndSet()</code>，返回 0 并且原子地设置为 1，从而获得锁，进入临界区。</li></ol><p>很明显，当获取不到锁时，线程就会一直 while 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为 <strong>自旋锁（<em>spin lock</em>）</strong>。</p><p>这是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</p><h3 id="_2-无等待锁" tabindex="-1"><a class="header-anchor" href="#_2-无等待锁"><span>(2) 无等待锁</span></a></h3><p>无等待锁顾明思议就是获取不到锁的时候，不用自旋。</p><p>既然不想自旋，那当没获取到锁的时候，就把当前线程放入到 <strong>锁的等待队列</strong>，然后执行调度程序，把 CPU 让给其他线程执行。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>type <span class="token keyword">struct</span> <span class="token class-name">lock</span> t<span class="token punctuation">{</span>
    <span class="token keyword">int</span> flag<span class="token punctuation">;</span>
    <span class="token class-name">queue_t</span> <span class="token operator">*</span>q<span class="token punctuation">;</span> <span class="token comment">// 等待队列</span>
<span class="token punctuation">}</span> <span class="token class-name">lock_t</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>lock t <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock<span class="token operator">-&gt;</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">queue_init</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">TestAndSet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>flag<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		保存现在运行线程 TCB<span class="token punctuation">;</span>
		将现在运行的线程 TCB 插入到等待队列<span class="token punctuation">;</span>
		设置该线程为等待状态<span class="token punctuation">;</span>
		调度程序<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        移出等待队列的队头元素<span class="token punctuation">;</span>
        将该线程的 TCB 插入到就绪队列<span class="token punctuation">;</span>
        设置该线程为就绪状态<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	lock<span class="token operator">-&gt;</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本次只是提出了两种简单锁的实现方式。当然，在具体操作系统实现中，会更复杂，但也离不开本例子两个基本元素。</p><p>如果你想要对锁的更进一步理解，推荐大家可以看《操作系统导论》第 28 章锁的内容，这本书在「微信读书」就可以免费看。</p><h2 id="信号量" tabindex="-1"><a class="header-anchor" href="#信号量"><span>信号量</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><p>信号量是操作系统提供的一种协调共享资源访问的方法。</p><p>通常<strong>信号量表示资源的数量</strong>，对应的变量是一个整型（<code>sem</code>）变量。</p><p>另外，还有<strong>两个原子操作的系统调用函数来控制信号量的</strong>，分别是：</p><ul><li><em>P 操作</em>：将 <code>sem</code> 减 <code>1</code>，相减后，如果 <code>sem &lt; 0</code>，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</li><li><em>V 操作</em>：将 <code>sem</code> 加 <code>1</code>，相加后，如果 <code>sem &lt;= 0</code>，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；</li></ul><blockquote><p>TIP</p><p>很多人问，V 操作 中 sem &lt;= 0 的判断是不是写反了？</p><p>没写反，我举个例子，如果 sem = 1，有三个线程进行了 P 操作：</p><ul><li>第一个线程 P 操作后，sem = 0；</li><li>第二个线程 P 操作后，sem = -1；</li><li>第三个线程 P 操作后，sem = -2；</li></ul><p>这时，第一个线程执行 V 操作后， sem 是 -1，因为 sem &lt;= 0，所以要唤醒第二或第三个线程。</p></blockquote><p>P 操作是用在进入临界区之前，V 操作是用在离开临界区之后，这两个操作是必须成对出现的。</p><h3 id="信号量初值2-奇怪情况" tabindex="-1"><a class="header-anchor" href="#信号量初值2-奇怪情况"><span>信号量初值2，奇怪情况</span></a></h3><p>举个类比，2 个资源的信号量，相当于 2 条火车轨道，PV 操作如下图过程：</p><figure><img src="`+p+`" alt="信号量与火车轨道" tabindex="0" loading="lazy"><figcaption>信号量与火车轨道</figcaption></figure><h3 id="pv-操作的系统实现" tabindex="-1"><a class="header-anchor" href="#pv-操作的系统实现"><span>PV 操作的系统实现</span></a></h3><p>信号量数据结构与 PV 操作的算法描述如下图：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// 信号量数据结构</span>
type <span class="token keyword">struct</span> <span class="token class-name">sem_t</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> sem<span class="token punctuation">;</span>	<span class="token comment">// 资源个数</span>
	<span class="token class-name">queue_t</span> <span class="token operator">*</span>q<span class="token punctuation">;</span> <span class="token comment">// 等待队列</span>
<span class="token punctuation">}</span> <span class="token class-name">sem_t</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化信号量</span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>sem t <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s<span class="token operator">-&gt;</span>sem <span class="token operator">=</span> sem<span class="token punctuation">;</span>
    queue <span class="token function">init</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// P 操作 (原子性)</span>
<span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s<span class="token operator">-&gt;</span>sem<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>sem <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token number">1.</span> 保留调用线程 CPU 现场<span class="token punctuation">;</span>
        <span class="token number">2.</span> 将该线程的 TCB 插入到s的等待队列<span class="token punctuation">;</span>
        <span class="token number">3.</span> 设置该线程为等待状态<span class="token punctuation">;</span>
        <span class="token number">4.</span> 执行调度程序<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// V 操作 (原子性)</span>
<span class="token keyword">void</span> <span class="token function">V</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	s<span class="token operator">-&gt;</span>sem<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>sem <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token number">1.</span>移出s等待队列首元素<span class="token punctuation">;</span>
        <span class="token number">2.</span>将该线程的 TCB 插入就绪队列<span class="token punctuation">;</span>
        <span class="token number">3.</span>设置该线程为「就绪」状态<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PV 操作的函数是由操作系统管理和实现的，所以操作系统已经使得执行 PV 函数时是具有原子性的。</p><h3 id="pv-操作的使用" tabindex="-1"><a class="header-anchor" href="#pv-操作的使用"><span>PV 操作的使用</span></a></h3><p>信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。</p><p>我们先来说说如何使用<strong>信号量实现临界区的互斥访问</strong>。</p><p>为每类共享资源设置一个信号量 <code>s</code>，其初值为 <code>1</code>，表示该临界资源未被占用。</p><p>只要把进入临界区的操作置于 <code>P(s)</code> 和 <code>V(s)</code> 之间，即可实现进程/线程互斥：</p><figure><img src="`+o+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>此时，任何想进入临界区的线程，必先在互斥信号量上执行 P 操作，在完成对临界资源的访问后再执行 V 操作。由于互斥信号量的初始值为 1，故在第一个线程执行 P 操作后 s 值变为 0，表示临界资源为空闲，可分配给该线程，使之进入临界区。</p><p>若此时又有第二个线程想进入临界区，也应先执行 P 操作，结果使 s 变为负值，这就意味着临界资源已被占用，因此，第二个线程被阻塞。</p><p>并且，直到第一个线程执行 V 操作，释放临界资源而恢复 s 值为 0 后，才唤醒第二个线程，使之进入临界区，待它完成临界资源的访问后，又执行 V 操作，使 s 恢复到初始值 1。</p><p>对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值，分别表示：</p><ul><li>如果互斥信号量为 1，表示没有线程进入临界区；</li><li>如果互斥信号量为 0，表示有一个线程进入临界区；</li><li>如果互斥信号量为 -1，表示一个线程进入临界区，另一个线程等待进入。</li></ul><p>通过互斥信号量的方式，就能保证临界区任何时刻只有一个线程在执行，就达到了互斥的效果。</p><h3 id="信号量初值0-实现事件同步" tabindex="-1"><a class="header-anchor" href="#信号量初值0-实现事件同步"><span>信号量初值0，实现事件同步</span></a></h3><p>再来，我们说说如何使用 <strong>信号量实现事件同步</strong>。</p><p>同步的方式是设置一个信号量，其初值为 <code>0</code>。</p><p>我们把前面的「吃饭-做饭」同步的例子，用代码的方式实现一下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>semaphore sl <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// 表示不需要吃饭</span>
semaphore s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// 表示饭还没做完</span>

<span class="token comment">// 儿子线程函数</span>
<span class="token keyword">void</span> <span class="token function">son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		肚子饿<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 叫妈妈做饭</span>
        <span class="token function">P</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 等待妈妈做完饭</span>
        吃饭<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 妈妈线程函数</span>
<span class="token keyword">void</span> <span class="token function">mon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 询问需不需要做饭</span>
        做饭<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 做完饭，通知儿子吃饭</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>妈妈一开始询问儿子要不要做饭时，执行的是 <code>P(s1)</code> ，相当于询问儿子需不需要吃饭，由于 <code>s1</code> 初始值为 0，此时 <code>s1</code> 变成 -1，表明儿子不需要吃饭，所以妈妈线程就进入等待状态。</p><p>当儿子肚子饿时，执行了 <code>V(s1)</code>，使得 <code>s1</code> 信号量从 -1 变成 0，表明此时儿子需要吃饭了，于是就唤醒了阻塞中的妈妈线程，妈妈线程就开始做饭。</p><p>接着，儿子线程执行了 <code>P(s2)</code>，相当于询问妈妈饭做完了吗，由于 <code>s2</code> 初始值是 0，则此时 <code>s2</code> 变成 -1，说明妈妈还没做完饭，儿子线程就等待状态。</p><p>最后，妈妈终于做完饭了，于是执行 <code>V(s2)</code>，<code>s2</code> 信号量从 -1 变回了 0，于是就唤醒等待中的儿子线程，唤醒后，儿子线程就可以进行吃饭了。</p><h2 id="生产者-消费者问题" tabindex="-1"><a class="header-anchor" href="#生产者-消费者问题"><span>生产者-消费者问题</span></a></h2><h3 id="问题描述与分析-——-需要互斥与同步" tabindex="-1"><a class="header-anchor" href="#问题描述与分析-——-需要互斥与同步"><span>问题描述与分析 —— 需要互斥与同步</span></a></h3><figure><img src="`+c+`" alt="生产者-消费者模型" tabindex="0" loading="lazy"><figcaption>生产者-消费者模型</figcaption></figure><p>生产者-消费者问题描述：</p><ul><li><strong>生产者</strong>在生成数据后，放在一个缓冲区中；</li><li><strong>消费者</strong>从缓冲区取出数据处理；</li><li>任何时刻，<strong>只能有一个</strong>生产者或消费者可以访问缓冲区；</li></ul><p>我们对问题分析可以得出：</p><ul><li>任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，<strong>需要互斥</strong>；</li><li>缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者<strong>需要同步</strong>。</li></ul><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><p>那么我们需要三个信号量，分别是：</p><ul><li>互斥信号量 <code>mutex</code>：用于<strong>互斥访问缓冲区</strong>，初始化值为 1；</li><li>资源信号量 <code>fullBuffers</code>：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；</li><li>资源信号量 <code>emptyBuffers</code>：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；</li></ul><p>具体的实现代码：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">100</span></span></span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">// 互斥信号量，用于临界区的互斥访问</span>
semaphore emptyBuffers <span class="token operator">=</span> N<span class="token punctuation">;</span>	<span class="token comment">// 表示缓冲区「空槽」的个数</span>
semaphore fullBuffers <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// 表示缓冲区「满槽」的个数</span>

<span class="token comment">// 生产者线程函数</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>emptyBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将空槽的个数- 1</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 进入临界区</span>
        将生成的数据放到缓冲区中<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 离开临界区</span>
        <span class="token function">V</span><span class="token punctuation">(</span>fullBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 将满槽的个数 + 1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
    
<span class="token comment">// 消费者线程函数</span>
<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>fullBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将满槽的个数- 1</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 进入临界区</span>
        从缓冲区里读取数据<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 离开临界区</span>
        <span class="token function">V</span><span class="token punctuation">(</span>emptyBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 将空槽的个数 + 1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果消费者线程一开始执行 <code>P(fullBuffers)</code>，由于信号量 <code>fullBuffers</code> 初始值为 0，则此时 <code>fullBuffers</code> 的值从 0 变为 -1，说明缓冲区里没有数据，消费者只能等待。</p><p>接着，轮到生产者执行 <code>P(emptyBuffers)</code>，表示减少 1 个空槽，如果当前没有其他生产者线程在临界区执行代码，那么该生产者线程就可以把数据放到缓冲区，放完后，执行 <code>V(fullBuffers)</code> ，信号量 <code>fullBuffers</code> 从 -1 变成 0，表明有「消费者」线程正在阻塞等待数据，于是阻塞等待的消费者线程会被唤醒。</p><p>消费者线程被唤醒后，如果此时没有其他消费者线程在读数据，那么就可以直接进入临界区，从缓冲区读取数据。最后，离开临界区后，把空槽的个数 + 1。</p>`,81),u=[i];function d(r,k){return s(),a("div",null,u)}const b=n(l,[["render",d],["__file","02. 实现和使用.html.vue"]]),g=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/02.%20%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8.html","title":"互斥与同步的实现和使用","lang":"zh-CN","frontmatter":{"description":"互斥与同步的实现和使用 在进程/线程并发执行的过程中，进程/线程之间存在协作的关系，例如有互斥、同步的关系。 为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种： 锁：加锁、解锁操作； 信号量：P、V 操作； 这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。 锁...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/05.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/02.%20%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"互斥与同步的实现和使用"}],["meta",{"property":"og:description","content":"互斥与同步的实现和使用 在进程/线程并发执行的过程中，进程/线程之间存在协作的关系，例如有互斥、同步的关系。 为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种： 锁：加锁、解锁操作； 信号量：P、V 操作； 这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。 锁..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"互斥与同步的实现和使用\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"互斥与同步的实现和使用","slug":"互斥与同步的实现和使用","link":"#互斥与同步的实现和使用","children":[{"level":2,"title":"锁","slug":"锁","link":"#锁","children":[{"level":3,"title":"原子操作、测试和置位","slug":"原子操作、测试和置位","link":"#原子操作、测试和置位","children":[]},{"level":3,"title":"(1) 忙等待锁 (也叫 自旋锁)","slug":"_1-忙等待锁-也叫-自旋锁","link":"#_1-忙等待锁-也叫-自旋锁","children":[]},{"level":3,"title":"(2) 无等待锁","slug":"_2-无等待锁","link":"#_2-无等待锁","children":[]}]},{"level":2,"title":"信号量","slug":"信号量","link":"#信号量","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"信号量初值2，奇怪情况","slug":"信号量初值2-奇怪情况","link":"#信号量初值2-奇怪情况","children":[]},{"level":3,"title":"PV 操作的系统实现","slug":"pv-操作的系统实现","link":"#pv-操作的系统实现","children":[]},{"level":3,"title":"PV 操作的使用","slug":"pv-操作的使用","link":"#pv-操作的使用","children":[]},{"level":3,"title":"信号量初值0，实现事件同步","slug":"信号量初值0-实现事件同步","link":"#信号量初值0-实现事件同步","children":[]}]},{"level":2,"title":"生产者-消费者问题","slug":"生产者-消费者问题","link":"#生产者-消费者问题","children":[{"level":3,"title":"问题描述与分析 —— 需要互斥与同步","slug":"问题描述与分析-——-需要互斥与同步","link":"#问题描述与分析-——-需要互斥与同步","children":[]},{"level":3,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":11.39,"words":3417},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/05. 进程管理/03. 线程冲突/02. 实现和使用.md","autoDesc":true}');export{b as comp,g as data};
