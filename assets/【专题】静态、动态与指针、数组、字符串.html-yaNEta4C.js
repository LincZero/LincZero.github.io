import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as d,c as l,e as n}from"./app-DErOheJD.js";const e={},r=n(`<h1 id="【专题】静态、动态与指针、数组、字符串" tabindex="-1"><a class="header-anchor" href="#【专题】静态、动态与指针、数组、字符串"><span>【专题】静态、动态与指针、数组、字符串</span></a></h1><h2 id="【字符串比较】c-风格、string类、cstring类" tabindex="-1"><a class="header-anchor" href="#【字符串比较】c-风格、string类、cstring类"><span>【字符串比较】C-风格、string类、cstring类</span></a></h2><ul><li>C-风格字符串 <ul><li>提供新特性：使用字符串方式快速<code>初始化</code>变量，而无需数组</li></ul></li><li>C++ String类（比起cstring库更加方便） <ul><li>头文件<code>string</code>，位于名称空间<code>std</code>中</li><li>提供新特性：简单变量的<code>声明</code>、<code>赋值</code>方式，字符串的简便<code>拼接</code>、<code>附加</code>功能</li></ul></li><li>C语言cstring库（旧） <ul><li>头文件<code>cstring</code>或 <code>string.h</code></li><li>提供新特性：<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>方法</li></ul></li></ul><h2 id="【数组比较】数组、vector、array" tabindex="-1"><a class="header-anchor" href="#【数组比较】数组、vector、array"><span>【数组比较】数组、vector、array</span></a></h2><table><thead><tr><th>比较类型</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数组</td><td>长度固定，使用栈</td><td>性能好</td><td>不安全、不方便</td></tr><tr><td>模板类 array（C++11）</td><td>长度固定，使用栈，可使用成员函数<code>at()</code>、<code>begin()</code>、<code>end()</code></td><td><strong>更安全</strong></td><td></td></tr><tr><td>动态数组</td><td>长度可变，使用堆</td><td>更方便</td><td>不安全</td></tr><tr><td>模板类 vector</td><td>长度可变，使用堆，可使用成员函数<code>at()</code>、<code>begin()</code>、<code>end()</code></td><td>更方便、<strong>更安全</strong></td><td>效率稍低</td></tr></tbody></table><p>注意：</p><ul><li>array类和vector类的成员函数<code>at()</code>与中括号表示法类似，但会在<code>运行期间</code>捕获非法索引，中断程序</li><li>array类和vector类的成员函数<code>begin()</code>、<code>end()</code> 则可以检查边界，以免无意间越界。而==<strong>C/C++不检查数组越界错误</strong>==（<mark>安全性的体现</mark>）</li><li>额外检查的代价是运行时间更长</li></ul><h2 id="【比较】字符串、数组" tabindex="-1"><a class="header-anchor" href="#【比较】字符串、数组"><span>【比较】字符串、数组</span></a></h2><table><thead><tr><th>参数</th><th>数组</th><th>字符串</th><th>区别</th></tr></thead><tbody><tr><td>变量名</td><td>C/C++将数组名解释为第一个元素的地址</td><td>C/C++将字符串名解释为第一个字符的地址</td><td>无区别</td></tr><tr><td>定义方式</td><td>不可以使用<code>C-风格字符串</code>方式</td><td>可以使用<code>C-风格字符串</code>方式</td><td><strong>有区别</strong></td></tr><tr><td>输出方式</td><td>当给<code>cout</code>提供一个元素的地址时<br>则它只打印地址本身</td><td>当给<code>cout</code>提供一个字符的地址时<br>则它将从该字符开始打印，直到遇到空字符为止</td><td><strong>有区别</strong></td></tr></tbody></table><h2 id="【比较】指针、数组-字符串" tabindex="-1"><a class="header-anchor" href="#【比较】指针、数组-字符串"><span>【比较】指针、数组/字符串</span></a></h2><h3 id="指针、数组-符号操作-指针算术" tabindex="-1"><a class="header-anchor" href="#指针、数组-符号操作-指针算术"><span>指针、数组（符号操作：指针算术）</span></a></h3><ul><li><p>原理概述</p><ul><li>指针和数组基本等价的原因在于指针算术（<em>pointer arithmetic</em>），指针变量加1后，增加的量等于它指向的类型的字节数</li></ul></li><li><p>数组名</p><ul><li>C/C++将<code>数组名</code>解释为第一个元素的地址（长度为元素类型长度，地址+1只增加元素类型长度个地址）</li><li>注意：<code>对数组名取的地址</code>则被解释为整个数组的地址（长度为数组长度，地址+1增加整个数组长度个地址）</li></ul></li><li><p>数组指针等价性</p><ul><li><code>arrayname[i] == *(arrayname+i)</code>~~（becomes是“变成”的意思）~~前者是数组表示法，后者是指针表示法</li><li><code>arrayname[r][c] == *(*(arrayname+r)+c)</code></li></ul></li></ul><h3 id="指针、字符串" tabindex="-1"><a class="header-anchor" href="#指针、字符串"><span>指针、字符串</span></a></h3><p>字符串与数组类似，但有一点不同：</p><ul><li><mark><strong>当给<code>cout</code>提供一个字符的地址时，则它将从该字符开始打印，直到遇到空字符为止</strong></mark></li><li>用引号括起的字符串也会像数组名一样处理，也是第一个元素的地址（但不建议用这种方式处理，不安全） <ul><li>C++中字符串字面值被视为常量，修改会导致<u>运行阶段</u>错误</li><li>C++不能保证字符串字面值被唯一地存储</li></ul></li></ul><p>这种设计的好处：不需要逐个传递字符串中所有字符，工作量减少</p><h2 id="【比较】静态数组、动态数组" tabindex="-1"><a class="header-anchor" href="#【比较】静态数组、动态数组"><span>【比较】静态数组、动态数组</span></a></h2><ul><li><p>动态数组、静态数组</p><ul><li>静态数组：编译时给数组分配内存，称为静态联编（<em>static binding</em>）</li><li>动态数组：运行时给数组分配内存，称为动态联编（<em>dynamic binding</em>），这种数组叫动态数组（<em>dynamic array</em>）</li></ul></li><li><p>内存块</p><ul><li>需要注意的是new分配的内存块通常与常规变量声明分配的内存块不同</li><li>常规变量声明的值存储在：栈（stack）的内存区域中</li><li>new方式分配的内存在：堆（heap）或自由存储区（free store）的内存区域</li></ul></li></ul><h2 id="【比较】大杂烩-实验与底层原理总结" tabindex="-1"><a class="header-anchor" href="#【比较】大杂烩-实验与底层原理总结"><span>【比较】大杂烩（实验与底层原理总结）</span></a></h2><h3 id="指针、动态数组、静态数组、字符串" tabindex="-1"><a class="header-anchor" href="#指针、动态数组、静态数组、字符串"><span>指针、动态数组、静态数组、字符串</span></a></h3><p>变量在内存中的情况（Release x86）</p><p>以<code>int * pn = new int [3]; pn[0] = 12345; arn[1] = 67890;</code>为例</p><table><thead><tr><th>参数</th><th>指针名</th><th>内存1</th><th>内存2</th><th>内存3</th><th>内存4</th><th>解释说明</th></tr></thead><tbody><tr><td>值（真实内存）</td><td>——</td><td>12345</td><td>67890</td><td>19819192</td><td>19819192</td><td>存储的是变量中的值</td></tr><tr><td>值（打印值）</td><td><mark><strong>00EFFB60</strong></mark></td><td>12345</td><td>67890</td><td>（任意值）</td><td>（任意值）</td><td></td></tr><tr><td>变量状态</td><td>有值不存储</td><td>已赋值</td><td>已赋值</td><td>定义未赋值</td><td>越界</td><td></td></tr><tr><td><strong>地址（真实值）</strong></td><td>012E6D08</td><td><mark>012E6D08</mark></td><td>012E6D0C</td><td>012E6D10</td><td>012E6D14</td><td>这里的地址是虚拟地址，汇编代码是寄存器地址?</td></tr><tr><td><strong>地址（打印值）</strong></td><td><mark><strong>00EFFB60</strong></mark></td><td><mark>012E6D08</mark></td><td>012E6D0C</td><td>012E6D10</td><td>012E6D14</td><td>编译器只把输出字符数组的地址解释为打印字符串</td></tr><tr><td>变量名</td><td>pn</td><td>pn[0]</td><td>pn[1]</td><td>pn[2]</td><td>pn[3]</td><td><strong>汇编代码不存在变量名</strong>，编译时会检查以防止出错</td></tr><tr><td><strong>变量类型</strong></td><td><mark>int_pointer</mark></td><td><mark>int</mark></td><td>int</td><td>int</td><td>int</td><td><strong>汇编代码不存在变量类型</strong></td></tr><tr><td>变量名解释</td><td>首值的地址</td><td>值</td><td>值</td><td>值</td><td>值</td><td><code>指针名 == &amp;指针名[0]</code></td></tr><tr><td>变量打印解释</td><td>打印值（地址）</td><td>打印值</td><td>打印值</td><td>打印值</td><td>打印值</td><td>当打印的值为地址时，会输出</td></tr><tr><td>变量地址打印解释</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>程序跟踪量</td><td></td><td></td><td></td><td></td><td></td><td>new分配的内存大小</td></tr></tbody></table><p>以<code>int [3] arn; arn[0] = 12345; arn[1] = 67890;</code>为例</p><p>指针和数组具有等价性</p><table><thead><tr><th>参数</th><th>数组名</th><th>内存1</th><th>内存2</th><th>内存3</th><th>内存4</th><th>解释说明</th></tr></thead><tbody><tr><td>值（真实内存）</td><td>——</td><td>12345</td><td>67890</td><td>1986557911</td><td>14008320</td><td>存储的是变量中的值</td></tr><tr><td>值（打印值）</td><td><mark>00EFFAA4</mark></td><td>12345</td><td>67890</td><td>（任意值）</td><td>（任意值）</td><td>汇编代码中：数组变量名被解释为地址</td></tr><tr><td>变量状态</td><td>有值不存储</td><td>已赋值</td><td>已赋值</td><td>定义未赋值</td><td>越界</td><td></td></tr><tr><td><strong>地址（真实值）</strong></td><td>(&amp;arn不是)</td><td><mark>00EFFB6C</mark></td><td>00EFFB70</td><td>00EFFB74</td><td>00EFFB78</td><td>这里的地址是虚拟地址，汇编代码是寄存器地址?</td></tr><tr><td><strong>地址（打印值）</strong></td><td><mark><strong>00EFFB6C</strong></mark></td><td><mark>00EFFB6C</mark></td><td>00EFFB70</td><td>00EFFB74</td><td>00EFFB78</td><td>编译器只把输出字符数组的地址解释为打印字符串</td></tr><tr><td>变量名</td><td>arn</td><td>arn[0]</td><td>arn[1]</td><td>arn[2]</td><td>arn[3]</td><td><strong>汇编代码不存在变量名</strong>，编译时会检查以防止出错</td></tr><tr><td><strong>变量类型</strong></td><td><mark>int_array</mark></td><td><mark>int</mark></td><td>int</td><td>int</td><td>int</td><td><strong>汇编代码不存在变量类型</strong></td></tr><tr><td>变量名解释</td><td>首值的地址</td><td>值</td><td>值</td><td>值</td><td>值</td><td><code>数组名 == &amp;数组名[0]</code></td></tr><tr><td>变量打印解释</td><td>打印值（地址）</td><td>打印值</td><td>打印值</td><td>打印值</td><td>打印值</td><td></td></tr><tr><td>变量地址打印解释</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>程序跟踪量</td><td></td><td></td><td></td><td></td><td></td><td>数组长度</td></tr></tbody></table><p>以<code> char arc[3] = { &#39;a&#39;, &#39;r&#39; };</code>为例</p><p><strong>地址打印纸和强制转换打印值的分析</strong>：同一个地址，相同的值，即可以用字符来解释他也能用字符数组来解释他，两种解释的结果不同。这也表明了内存中并不会存储变量值的变量类型、汇编代码中不存在变量名和变量类型的概念，只会麻木地进行各种运算</p><p>注意：</p><ul><li><p><code>数组名</code>被解释为第一个元素的地址（长度为元素类型长度，地址+1只增加元素类型长度个地址）</p></li><li><p><code>对数组名取的地址</code>则被解释为整个数组的地址（长度为数组长度，地址+1增加整个数组长度个地址）</p><p>可以理解为<strong>被解释为多维数组</strong>，取地址后该数组被视作上一层数组的元素（这个元素是数组，而第一个元素就是当前数组）</p><p><code>a[0][0]</code>中，<code>a[0] == &amp;a[0][0]</code>，<code>a == &amp;a[0]</code></p></li></ul><p>（下面的&quot;烫&quot;是Debug下运行的结果，而不是Release）</p><table><thead><tr><th>参数</th><th>数组名</th><th>内存1</th><th>内存2</th><th>内存3</th><th>内存4</th><th>解释说明</th></tr></thead><tbody><tr><td>值（真实内存）</td><td>——</td><td>97</td><td>114</td><td>0</td><td>？？？</td><td>存储的是变量中的值</td></tr><tr><td>值（打印值）</td><td><mark>00EFFB64</mark></td><td>a</td><td>r</td><td>\\0</td><td>（任意值）</td><td>汇编代码中：数组变量名被解释为地址</td></tr><tr><td>变量状态</td><td>有值不存储</td><td>已赋值</td><td>已赋值</td><td>定义未赋值</td><td>越界</td><td></td></tr><tr><td><strong>地址（真实值）</strong></td><td>(&amp;arc不是)</td><td><mark>00EFFB64</mark></td><td>00EFFB65</td><td>00EFFB66</td><td>00EFFB67</td><td>这里的地址是虚拟地址，汇编代码是寄存器地址?</td></tr><tr><td><strong>地址（打印值）</strong></td><td>ar</td><td>a</td><td>r</td><td>（空字符）</td><td>烫烫烫烫?0</td><td>编译器只把输出字符数组的地址解释为打印字符串</td></tr><tr><td><strong>（强制转换打印）</strong></td><td><mark>00EFFB64</mark></td><td><mark>00EFFB64</mark></td><td>00EFFB65</td><td>00EFFB66</td><td>00EFFB67</td><td></td></tr><tr><td>变量名</td><td>arc</td><td>arc[0]</td><td>arc[1]</td><td>arc[2]</td><td>arc[3]</td><td><strong>汇编代码不存在变量名</strong>，编译时会检查以防止出错</td></tr><tr><td><strong>变量类型</strong></td><td><mark>char_array</mark></td><td><mark>char</mark></td><td>char</td><td>char</td><td>char</td><td><strong>汇编代码不存在变量类型</strong></td></tr><tr><td>变量名解释</td><td>首值的地址</td><td>值</td><td>值</td><td>值</td><td>值</td><td><code>数组名 == &amp;数组名[0]</code></td></tr><tr><td>变量打印解释</td><td>打印值（地址）</td><td>打印值</td><td>打印值</td><td>打印值</td><td>打印值</td><td></td></tr><tr><td>变量地址打印解释</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>程序跟踪量</td><td></td><td></td><td></td><td></td><td></td><td>字符数组长度</td></tr></tbody></table><p>连续定义下的地址总结</p><p>00EFFB60~00EFFB63：栈，指针，占4字节</p><p>00EFFB64~00EFFB67：栈，字符串，占1*4字节</p><p>00EFFB68~00EFFB6B：空白，占4字节</p><p>00EFFB6C~00EFFB7B：栈，数组，占4*4字节</p><p>012E6D08~012E6D17：堆，数组，占4*4字节</p><h3 id="实验代码" tabindex="-1"><a class="header-anchor" href="#实验代码"><span>实验代码</span></a></h3><div class="language-C++ line-numbers-mode" data-ext="C++" data-title="C++"><pre class="language-C++"><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    /*内存情况*/
    int* pn = new int[3];
    pn[0] = 12345;
    pn[1] = 67890;
    cout &lt;&lt; pn &lt;&lt; endl;
    cout &lt;&lt; pn[0] &lt;&lt; endl;
    cout &lt;&lt; pn[1] &lt;&lt; endl;
    cout &lt;&lt; pn[2] &lt;&lt; endl;
    cout &lt;&lt; pn[3] &lt;&lt; endl;
    cout &lt;&lt; &amp;pn &lt;&lt; endl;
    cout &lt;&lt; &amp;pn[0] &lt;&lt; endl;
    cout &lt;&lt; &amp;pn[1] &lt;&lt; endl;
    cout &lt;&lt; &amp;pn[2] &lt;&lt; endl;
    cout &lt;&lt; &amp;pn[3] &lt;&lt; endl;

    cout &lt;&lt; &quot;————————&quot; &lt;&lt; endl;

    int arn[3];
    arn[0] = 12345;
    arn[1] = 67890;
    cout &lt;&lt; arn &lt;&lt; endl;
    cout &lt;&lt; arn[0] &lt;&lt; endl;
    cout &lt;&lt; arn[1] &lt;&lt; endl;
    cout &lt;&lt; arn[2] &lt;&lt; endl;
    cout &lt;&lt; arn[3] &lt;&lt; endl;
    cout &lt;&lt; &amp;arn &lt;&lt; endl;
    cout &lt;&lt; &amp;arn[0] &lt;&lt; endl;
    cout &lt;&lt; &amp;arn[1] &lt;&lt; endl;
    cout &lt;&lt; &amp;arn[2] &lt;&lt; endl;
    cout &lt;&lt; &amp;arn[3] &lt;&lt; endl;

    cout &lt;&lt; &quot;————————&quot; &lt;&lt; endl;

    char arc[3] = { &#39;a&#39;, &#39;r&#39; };
    cout &lt;&lt; arc &lt;&lt; endl;
    cout &lt;&lt; arc[0] &lt;&lt; endl;
    cout &lt;&lt; arc[1] &lt;&lt; endl;
    cout &lt;&lt; arc[2] &lt;&lt; endl;
    cout &lt;&lt; arc[3] &lt;&lt; endl;
    cout &lt;&lt; &amp;arc[0] &lt;&lt; endl;
    cout &lt;&lt; &amp;arc[1] &lt;&lt; endl;
    cout &lt;&lt; &amp;arc[2] &lt;&lt; endl;
    cout &lt;&lt; &amp;arc[3] &lt;&lt; endl;
    cout &lt;&lt; (int*)&amp;arc[0] &lt;&lt; endl; // 转指针类型技巧
    cout &lt;&lt; (int*)&amp;arc[1] &lt;&lt; endl;
    cout &lt;&lt; (int*)&amp;arc[2] &lt;&lt; endl;
    cout &lt;&lt; (int*)&amp;arc[3] &lt;&lt; endl;
    // 旧方法cout &lt;&lt; (long)&amp;arc &lt;&lt; endl; // 但会忽略前面的零而且不是16进制

    cout &lt;&lt; &quot;————————&quot; &lt;&lt; endl;

    char arc2[4] = { &#39;a&#39;, &#39;r&#39;,&#39;c&#39;};
    cout &lt;&lt; (arc2 == &amp;arc2[0]) &lt;&lt; endl;
    cout &lt;&lt; arc2 &lt;&lt; endl;
    cout &lt;&lt; &amp;arc2[0] &lt;&lt; endl;
    cout &lt;&lt; &amp;arc2[1] &lt;&lt; endl;
    cout &lt;&lt; &amp;arc2[2] &lt;&lt; endl;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,40),i=[r];function a(c,s){return d(),l("div",null,i)}const m=t(e,[["render",a],["__file","【专题】静态、动态与指针、数组、字符串.html.vue"]]),p=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/02.%20%E6%95%B0%E6%8D%AE_%E7%AE%97%E6%B3%95/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E4%B8%8E%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.html","title":"【专题】静态、动态与指针、数组、字符串","lang":"zh-CN","frontmatter":{"description":"【专题】静态、动态与指针、数组、字符串 【字符串比较】C-风格、string类、cstring类 C-风格字符串 提供新特性：使用字符串方式快速初始化变量，而无需数组 C++ String类（比起cstring库更加方便） 头文件string，位于名称空间std中 提供新特性：简单变量的声明、赋值方式，字符串的简便拼接、附加功能 C语言cstring库...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/02.%20%E6%95%B0%E6%8D%AE_%E7%AE%97%E6%B3%95/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E4%B8%8E%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"【专题】静态、动态与指针、数组、字符串"}],["meta",{"property":"og:description","content":"【专题】静态、动态与指针、数组、字符串 【字符串比较】C-风格、string类、cstring类 C-风格字符串 提供新特性：使用字符串方式快速初始化变量，而无需数组 C++ String类（比起cstring库更加方便） 头文件string，位于名称空间std中 提供新特性：简单变量的声明、赋值方式，字符串的简便拼接、附加功能 C语言cstring库..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【专题】静态、动态与指针、数组、字符串\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"【专题】静态、动态与指针、数组、字符串","slug":"【专题】静态、动态与指针、数组、字符串","link":"#【专题】静态、动态与指针、数组、字符串","children":[{"level":2,"title":"【字符串比较】C-风格、string类、cstring类","slug":"【字符串比较】c-风格、string类、cstring类","link":"#【字符串比较】c-风格、string类、cstring类","children":[]},{"level":2,"title":"【数组比较】数组、vector、array","slug":"【数组比较】数组、vector、array","link":"#【数组比较】数组、vector、array","children":[]},{"level":2,"title":"【比较】字符串、数组","slug":"【比较】字符串、数组","link":"#【比较】字符串、数组","children":[]},{"level":2,"title":"【比较】指针、数组/字符串","slug":"【比较】指针、数组-字符串","link":"#【比较】指针、数组-字符串","children":[{"level":3,"title":"指针、数组（符号操作：指针算术）","slug":"指针、数组-符号操作-指针算术","link":"#指针、数组-符号操作-指针算术","children":[]},{"level":3,"title":"指针、字符串","slug":"指针、字符串","link":"#指针、字符串","children":[]}]},{"level":2,"title":"【比较】静态数组、动态数组","slug":"【比较】静态数组、动态数组","link":"#【比较】静态数组、动态数组","children":[]},{"level":2,"title":"【比较】大杂烩（实验与底层原理总结）","slug":"【比较】大杂烩-实验与底层原理总结","link":"#【比较】大杂烩-实验与底层原理总结","children":[{"level":3,"title":"指针、动态数组、静态数组、字符串","slug":"指针、动态数组、静态数组、字符串","link":"#指针、动态数组、静态数组、字符串","children":[]},{"level":3,"title":"实验代码","slug":"实验代码","link":"#实验代码","children":[]}]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.2,"words":2460},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/02. 数据+算法/【专题】静态、动态与指针、数组、字符串.md","excerpt":"\\n<h2>【字符串比较】C-风格、string类、cstring类</h2>\\n<ul>\\n<li>C-风格字符串\\n<ul>\\n<li>提供新特性：使用字符串方式快速<code>初始化</code>变量，而无需数组</li>\\n</ul>\\n</li>\\n<li>C++ String类（比起cstring库更加方便）\\n<ul>\\n<li>头文件<code>string</code>，位于名称空间<code>std</code>中</li>\\n<li>提供新特性：简单变量的<code>声明</code>、<code>赋值</code>方式，字符串的简便<code>拼接</code>、<code>附加</code>功能</li>\\n</ul>\\n</li>\\n<li>C语言cstring库（旧）\\n<ul>\\n<li>头文件<code>cstring</code>或 <code>string.h</code></li>\\n<li>提供新特性：<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>方法</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{m as comp,p as data};
