import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as l,a as t}from"./app-CMEFroyS.js";const n={},a=t('<h1 id="联编" tabindex="-1"><a class="header-anchor" href="#联编"><span>联编</span></a></h1><h2 id="联编-1" tabindex="-1"><a class="header-anchor" href="#联编-1"><span>联编</span></a></h2><h3 id="函数名联编-binding" tabindex="-1"><a class="header-anchor" href="#函数名联编-binding"><span>函数名联编（<em>binding</em>）</span></a></h3><ul><li>行为 <ul><li>将源代码中的函数调用解释为执行特定的函数代码块</li></ul></li><li>实现机理 <ul><li>C：每个函数名都对应一个不同的函数，实现非常简单</li><li>C++：由于重载，实现变得复杂。但还是能在编译过程完成这种联编。但涉及到虚函数时，静态联编无法实现，需要动态联编</li></ul></li></ul><h2 id="静态联编" tabindex="-1"><a class="header-anchor" href="#静态联编"><span>静态联编</span></a></h2><p>静态联编（<em>static binding</em>），又称早期联编（<em>early binding</em>）</p><h2 id="动态联编" tabindex="-1"><a class="header-anchor" href="#动态联编"><span>动态联编</span></a></h2><p>动态联编（<em>dynamic binding</em>），又称晚期联编（<em>late binding</em>）</p><ul><li>举例 <ul><li>动态内存</li><li>虚函数/纯虚函数</li></ul></li></ul><h2 id="一些动态的操作" tabindex="-1"><a class="header-anchor" href="#一些动态的操作"><span>一些动态的操作</span></a></h2><ul><li>动态指定编程代码：函数模板的底层原理就是</li><li>动态指定变量地址：动态内存new</li><li>动态指定变量值：普通赋值，css3的calc属性</li><li>动态指定变量类型：（模板提供参数化类型）函数模板、类模板</li><li>动态指定变量名：一般是字典，key属于变量也属于变量名</li></ul>',11),r=[a];function c(o,s){return i(),l("div",null,r)}const p=e(n,[["render",c],["__file","03. 联编.html.vue"]]),u=JSON.parse('{"path":"/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/03.%20%E8%81%94%E7%BC%96.html","title":"联编","lang":"zh-CN","frontmatter":{"description":"联编 联编 函数名联编（binding） 行为 将源代码中的函数调用解释为执行特定的函数代码块 实现机理 C：每个函数名都对应一个不同的函数，实现非常简单 C++：由于重载，实现变得复杂。但还是能在编译过程完成这种联编。但涉及到虚函数时，静态联编无法实现，需要动态联编 静态联编 静态联编（static binding），又称早期联编（early bin...","head":[["meta",{"property":"og:url","content":"http://192.168.0.101:8080/MdNote_Public/01.%20%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/03.%20%E8%81%94%E7%BC%96.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"联编"}],["meta",{"property":"og:description","content":"联编 联编 函数名联编（binding） 行为 将源代码中的函数调用解释为执行特定的函数代码块 实现机理 C：每个函数名都对应一个不同的函数，实现非常简单 C++：由于重载，实现变得复杂。但还是能在编译过程完成这种联编。但涉及到虚函数时，静态联编无法实现，需要动态联编 静态联编 静态联编（static binding），又称早期联编（early bin..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"联编\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"联编","slug":"联编","link":"#联编","children":[{"level":2,"title":"联编","slug":"联编-1","link":"#联编-1","children":[{"level":3,"title":"函数名联编（binding）","slug":"函数名联编-binding","link":"#函数名联编-binding","children":[]}]},{"level":2,"title":"静态联编","slug":"静态联编","link":"#静态联编","children":[]},{"level":2,"title":"动态联编","slug":"动态联编","link":"#动态联编","children":[]},{"level":2,"title":"一些动态的操作","slug":"一些动态的操作","link":"#一些动态的操作","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.87,"words":261},"filePathRelative":"MdNote_Public/01. 设计开发与数据生产/Develop/01. Language/C++/04. 优化/03. 联编.md","autoDesc":true}');export{p as comp,u as data};
