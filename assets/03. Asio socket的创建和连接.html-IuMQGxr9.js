import{_ as o,c as e,a,b as s,d as t,e as c,o as l,r as i}from"./app-CQm44bc7.js";const u={},d={href:"https://llfc.club/articlepage?id=2LXIKWJtKGblnWtHT7TplLKK6ze",target:"_blank",rel:"noopener noreferrer"};function r(k,n){const p=i("ExternalLinkIcon");return l(),e("div",null,[n[3]||(n[3]=a('<p>视频：https://www.bilibili.com/video/BV1jm4y1r7AY 作者文档：https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS</p><h2 id="传统的阻塞模型" tabindex="-1"><a class="header-anchor" href="#传统的阻塞模型"><span>传统的阻塞模型</span></a></h2><p>网络编程的基本流程对于服务端是这样的</p><p>服务端</p><ol><li>socket——创建socket对象。</li><li>bind——绑定本机ip+port。</li><li>listen——监听来电，若在监听到来电，则建立起连接。</li><li>accept——再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。</li><li>read、write——就是收发消息了。</li></ol><p>客户端</p><ol><li>socket——创建socket对象。</li><li>connect——根据服务端ip+port，发起连接请求。</li><li>write、read——建立连接后，就可发收消息了。</li></ol><p>图示如下</p><blockquote><p><img src="https://cdn.llfc.club/1540562-20190417002428451-62583604.jpg" alt="https://cdn.llfc.club/1540562-20190417002428451-62583604.jpg" loading="lazy"></p></blockquote>',9)),s("p",null,[n[1]||(n[1]=t("相关的网络编程技术可以看看我之前写的文章")),n[2]||(n[2]=s("br",null,null,-1)),s("a",d,[n[0]||(n[0]=t("https://llfc.club/articlepage?id=2LXIKWJtKGblnWtHT7TplLKK6ze")),c(p)])]),n[4]||(n[4]=a(`<h2 id="现代化模型" tabindex="-1"><a class="header-anchor" href="#现代化模型"><span>现代化模型</span></a></h2><p>当然，现在的都是<strong>Proactor模式</strong>、<strong>Reactor模式</strong>这种，使用epoll等<strong>多路复用</strong>技术，而且是<strong>异步</strong>的</p><ul><li>Reactor模式，是同步模型</li><li>Proactor模式，是异步模型</li></ul><p>接下来按照上述流程，我们用boost::asio逐步介绍。这里会有本书：《Boost.Asio C++ Network Programming Cookbook》，博客很多地方也按这本书写的</p><h2 id="终端节点的创建" tabindex="-1"><a class="header-anchor" href="#终端节点的创建"><span>终端节点的创建</span></a></h2><p>所谓 <code>终端节点</code> 就是用来通信的端对端的节点，可以通过ip地址和端口构造，其的节点可以连接这个终端节点做通信.<br> 如果我们是客户端，我们可以通过对端的ip和端口构造一个endpoint，用这个endpoint和其通信。</p><p>客户端</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span>  <span class="token function">client_end_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Step 1. 假设客户端应用程序已经获得了ip地址和协议端口号。</span>
	std<span class="token double-colon punctuation">::</span>string raw_ip_address <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> port_num <span class="token operator">=</span> <span class="token number">3333</span><span class="token punctuation">;</span>
	<span class="token comment">// 用于存储解析原始ip地址时发生的错误信息。</span>
	boost<span class="token double-colon punctuation">::</span>system<span class="token double-colon punctuation">::</span>error_code ec<span class="token punctuation">;</span>
	<span class="token comment">// Step 2. 使用独立于IP协议版本的地址表示。</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>address ip_address <span class="token operator">=</span> asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>address<span class="token double-colon punctuation">::</span><span class="token function">from_string</span><span class="token punctuation">(</span>raw_ip_address<span class="token punctuation">,</span> ec<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 提供的IP地址无效。打破执行</span>
		std<span class="token double-colon punctuation">::</span>cout
			<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Failed to parse the IP address. Error code = &quot;</span>
			<span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;. Message: &quot;</span> <span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Step 3. 准备端点</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span>ip_address<span class="token punctuation">,</span> port_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 4. 端点已经准备好，可以用来指定客户机想要与之通信的网络中的特定服务器。</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端，如果是服务端，则只需根据本地地址绑定就可以生成endpoint</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span>  <span class="token function">server_end_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// Step 1. 这里我们假设服务器应用程序已经获得了协议端口号。</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> port_num <span class="token operator">=</span> <span class="token number">3333</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 2. 创建asio::ip::address类的特殊对象，指定主机上所有可用的ip地址。注意，这里我们假设服务器工作在IPv6协议上。</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>address ip_address <span class="token operator">=</span> asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>address_v6<span class="token double-colon punctuation">::</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 3. 创建端点</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span>ip_address<span class="token punctuation">,</span> port_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 4. 端点被创建后，并可用于指定IP地址和端口号，服务器应用程序希望在这些地址和端口号上侦听传入的连接。</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结</p><ul><li>创建ip地址类，<code>asio::ip::address</code></li><li>创建端点类，<code>asio::ip::tcp::endpoint</code></li></ul><h2 id="创建socket" tabindex="-1"><a class="header-anchor" href="#创建socket"><span>创建socket</span></a></h2><p>创建socket分为4步</p><ol><li>创建上下文iocontext</li><li>选择协议</li><li>生成socket</li><li>打开socket</li></ol><p>具体点来讲是：</p><ul><li>创建IO服务类，<code>asio::io_service</code></li><li>创建tcp类，<code>asio::ip::tcp</code></li><li>创建socket类 <ul><li>客户端：普通 socket类，<code>asio::ip::tcp::socket</code></li><li>服务端：accept socket类，<code>asio::ip::tcp::acceptor</code></li></ul></li><li>打开socket类，open</li></ul><p>客户端</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">// 创建TCP套接字</span>
<span class="token keyword">int</span> <span class="token function">create_tcp_socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Step 1. 套接字构造函数需要&#39;io_service&#39;类的实例 </span>
	asio<span class="token double-colon punctuation">::</span>io_context  ios<span class="token punctuation">;</span>
	<span class="token comment">// Step 2. 创建一个tcp类的对象，以IPv4作为底层协议，表示tcp协议</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp protocol <span class="token operator">=</span> asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span><span class="token function">v4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 3. 实例化一个活动的TCP套接字对象</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>ios<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 用于存储打开套接字时发生的错误信息</span>
	boost<span class="token double-colon punctuation">::</span>system<span class="token double-colon punctuation">::</span>error_code ec<span class="token punctuation">;</span>
	<span class="token comment">// Step 4. 打开 socket</span>
	sock<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>protocol<span class="token punctuation">,</span> ec<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 打开socket失败</span>
		std<span class="token double-colon punctuation">::</span>cout
			<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Failed to open the socket! Error code = &quot;</span>
			<span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;. Message: &quot;</span> <span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端。上述socket只是通信的socket，如果是服务端，我们还需要生成一个acceptor的socket，用来接收新的连接。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">// 创建TCP Accept套接字</span>
<span class="token keyword">int</span>  <span class="token function">create_acceptor_socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Step 1. 套接字构造函数需要&#39;io_service&#39;类的实例。</span>
	asio<span class="token double-colon punctuation">::</span>io_context ios<span class="token punctuation">;</span>
	<span class="token comment">// Step 2. 创建一个tcp类的对象，表示一个tcp协议，IPv6作为底层协议。</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp protocol <span class="token operator">=</span> asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span><span class="token function">v6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 3. 实例化一个接受套接字对象。</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>acceptor <span class="token function">acceptor</span><span class="token punctuation">(</span>ios<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 用于存储打开接收方套接字时发生的错误信息。</span>
	boost<span class="token double-colon punctuation">::</span>system<span class="token double-colon punctuation">::</span>error_code ec<span class="token punctuation">;</span>
	<span class="token comment">// Step 4. 打开 acceptor socket.</span>
	acceptor<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>protocol<span class="token punctuation">,</span> ec<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 打开socket失败</span>
		std<span class="token double-colon punctuation">::</span>cout
			<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Failed to open the acceptor socket!&quot;</span>
			<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Error code = &quot;</span>
			<span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;. Message: &quot;</span> <span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="绑定acceptor" tabindex="-1"><a class="header-anchor" href="#绑定acceptor"><span>绑定acceptor</span></a></h2><p>对于acceptor类型的socket，服务器要将其绑定到指定的断点,所有连接这个端点的连接都可以被接收到。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span>  <span class="token function">bind_acceptor_socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Step 1. 这里我们假设服务器应用程序已经获得了协议端口号。</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> port_num <span class="token operator">=</span> <span class="token number">3333</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 2. 创建端点</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span>asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>address_v4<span class="token double-colon punctuation">::</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		port_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 由&#39;acceptor&#39;类构造函数使用。</span>
	asio<span class="token double-colon punctuation">::</span>io_context  ios<span class="token punctuation">;</span>
	<span class="token comment">// Step 3. 创建并打开一个接收套接字</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>acceptor <span class="token function">acceptor</span><span class="token punctuation">(</span>ios<span class="token punctuation">,</span> ep<span class="token punctuation">.</span><span class="token function">protocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	boost<span class="token double-colon punctuation">::</span>system<span class="token double-colon punctuation">::</span>error_code ec<span class="token punctuation">;</span>
	<span class="token comment">// Step 4. 绑定接收器套接字</span>
	acceptor<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> ec<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 处理错误</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 绑定接收socket失败。打破执行。</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Failed to bind the acceptor socket.&quot;</span>
			<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Error code = &quot;</span> <span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;. Message: &quot;</span>
			<span class="token operator">&lt;&lt;</span> ec<span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ec<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="完整" tabindex="-1"><a class="header-anchor" href="#完整"><span>(完整)</span></a></h2><p>流程</p><ul><li>获取IP和端口等</li><li>创建端点，<code>asio::ip::tcp::endpoint</code></li><li>创建IO上下文，<code>asio::io_context</code></li><li>创建并打开套接字 <ul><li>客户端：<code>asio::ip::tcp::socket</code>，connect</li><li>服务端：<code>asio::ip::tcp::acceptor</code>，bind，listen，sock，accept</li></ul></li></ul><p>客户端：连接指定的端点，对连接服务器指定的端点进行连接</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span>  <span class="token function">connect_to_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Step 1. 假设客户端应用程序已经获得了目标服务器的IP地址和协议端口号</span>
	std<span class="token double-colon punctuation">::</span>string raw_ip_address <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> port_num <span class="token operator">=</span> <span class="token number">3333</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{</span>
		<span class="token comment">// Step 2. 创建指定目标服务器应用程序的端点</span>
		asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span>asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>address<span class="token double-colon punctuation">::</span><span class="token function">from_string</span><span class="token punctuation">(</span>raw_ip_address<span class="token punctuation">)</span><span class="token punctuation">,</span> port_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
		asio<span class="token double-colon punctuation">::</span>io_context ios<span class="token punctuation">;</span>
		<span class="token comment">// Step 3. 创建并打开套接字</span>
		asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>ios<span class="token punctuation">,</span> ep<span class="token punctuation">.</span><span class="token function">protocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Step 4. 连接套接字</span>
		sock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 此时，套接字&#39;sock&#39;已连接到服务器应用程序，并可用于向其发送数据或从其接收数据。</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 这里使用的asio::ip::address::from_string()和asio::ip::tcp::socket::connect()的过载会在出现错误条件时抛出异常。</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span>system<span class="token double-colon punctuation">::</span>system_error<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Error occured! Error code = &quot;</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;. Message: &quot;</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务器：服务器接收连接。当有客户端连接时，服务器需要接收连接</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">accept_new_connection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 包含挂起连接请求的队列的大小。</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> BACKLOG_SIZE <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 1. 这里我们假设服务器应用程序已经获得了协议端口号。</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> port_num <span class="token operator">=</span> <span class="token number">3333</span><span class="token punctuation">;</span>
	<span class="token comment">// Step 2. 创建服务器端点。</span>
	asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span>asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>address_v4<span class="token double-colon punctuation">::</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	asio<span class="token double-colon punctuation">::</span>io_context  ios<span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{</span>
		<span class="token comment">// Step 3. 实例化并打开一个接受套接字。</span>
		asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>acceptor <span class="token function">acceptor</span><span class="token punctuation">(</span>ios<span class="token punctuation">,</span> ep<span class="token punctuation">.</span><span class="token function">protocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Step 4. 将接收方套接字绑定到服务器端。</span>
		acceptor<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Step 5. 开始监听传入的连接请求。</span>
		acceptor<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>BACKLOG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Step 6. 创建活动套接字。</span>
		asio<span class="token double-colon punctuation">::</span>ip<span class="token double-colon punctuation">::</span>tcp<span class="token double-colon punctuation">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>ios<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Step 7. 处理下一个连接请求并将活动套接字连接到客户端</span>
		acceptor<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 此时，&#39;sock&#39;套接字已连接到客户端应用程序，并可用于向其发送数据或从其接收数据</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span>system<span class="token double-colon punctuation">::</span>system_error<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Error occured! Error code = &quot;</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;. Message: &quot;</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="关于buffer" tabindex="-1"><a class="header-anchor" href="#关于buffer"><span>关于buffer</span></a></h2><p>任何网络库都有提供buffer的数据结构，所谓buffer就是接收和发送数据时缓存数据的结构。</p><p>boost::asio提供了asio::mutable_buffer 和 asio::const_buffer这两个结构，但是这两个结构都没有被asio的api直接使用</p><ul><li>asio::mutable_buffer用于写服务</li><li>asio::const_buffer用于读服务 他们是一段连续的空间，首字节存储了后续数据的长度。</li></ul><p>对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence概念，他们是由多个asio::mutable_buffer和asio::const_buffer组成的。 也就是说boost::asio为了节省空间，将一部分连续的空间组合起来，作为参数交给api使用。<br> 我们可以理解为MutableBufferSequence的数据结构为std::vector<a href="asio::mutable_buffer">asio::mutable_buffer</a></p><p>结构如下</p><blockquote><p><img src="https://cdn.llfc.club/1676257797218.jpg" alt="https://cdn.llfc.club/1676257797218.jpg" loading="lazy"></p></blockquote><p>每隔vector存储的都是mutable_buffer的地址，每个mutable_buffer的第一个字节表示数据的长度，后面跟着数据内容。<br> 这么复杂的结构交给用户使用并不合适，所以asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回asio::mutable_buffers_1 o或者asio::const_buffers_1结构的对象。<br> 如果传递给buffer()的参数是一个只读类型，则函数返回asio::const_buffers_1 类型对象。<br> 如果传递给buffer()的参数是一个可写类型，则返回asio::mutable_buffers_1 类型对象。<br> asio::const_buffers_1和asio::mutable_buffers_1是asio::mutable_buffer和asio::const_buffer的适配器，提供了符合MutableBufferSequence和ConstBufferSequence概念的接口，所以他们可以作为boost::asio的api函数的参数使用。<br> 简单概括一下，我们可以用buffer()函数生成我们要用的缓存存储数据。<br> 比如boost的发送接口send要求的参数为ConstBufferSequence类型</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ConstBufferSequence</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>size_t <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">const</span> ConstBufferSequence <span class="token operator">&amp;</span> buffers<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要将”Hello Word转化为该类型”</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">use_const_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>string buf <span class="token operator">=</span> <span class="token string">&quot;hello world!&quot;</span><span class="token punctuation">;</span>
	asio<span class="token double-colon punctuation">::</span>const_buffer  <span class="token function">asio_buf</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>asio<span class="token double-colon punctuation">::</span>const_buffer<span class="token operator">&gt;</span> buffers_sequence<span class="token punctuation">;</span>
	buffers_sequence<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>asio_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终buffers_sequence就是可以传递给发送接口send的类型。但是这太复杂了，可以直接用buffer函数转化为send需要的参数类型</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">use_buffer_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	asio<span class="token double-colon punctuation">::</span>const_buffers_1 output_buf <span class="token operator">=</span> asio<span class="token double-colon punctuation">::</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>output_buf可以直接传递给该send接口。我们也可以将数组转化为send接受的类型</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">use_buffer_array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">const</span> size_t  BUF_SIZE_BYTES <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token function">buf</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>BUF_SIZE_BYTES<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> input_buf <span class="token operator">=</span> asio<span class="token double-colon punctuation">::</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> BUF_SIZE_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于流式操作，我们可以用streambuf，将输入输出流和streambuf绑定，可以实现流式输入和输出。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">use_stream_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	asio<span class="token double-colon punctuation">::</span>streambuf buf<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>ostream <span class="token function">output</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Writing the message to the stream-based buffer.</span>
	output <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Message1\\nMessage2&quot;</span><span class="token punctuation">;</span>
	<span class="token comment">// Now we want to read all data from a streambuf</span>
	<span class="token comment">// until &#39;\\n&#39; delimiter.</span>
	<span class="token comment">// Instantiate an input stream which uses our </span>
	<span class="token comment">// stream buffer.</span>
	std<span class="token double-colon punctuation">::</span>istream <span class="token function">input</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// We&#39;ll read data into this string.</span>
	std<span class="token double-colon punctuation">::</span>string message1<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> message1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Now message1 string contains &#39;Message1&#39;.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,48))])}const v=o(u,[["render",r],["__file","03. Asio socket的创建和连接.html.vue"]]),m=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/Boost/02.%20%E7%BD%91%E7%BB%9C/Boost.Asio%20%E8%A7%86%E9%A2%91/03.%20Asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5.html","title":"","lang":"zh-CN","frontmatter":{"description":"视频：https://www.bilibili.com/video/BV1jm4y1r7AY 作者文档：https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS 传统的阻塞模型 网络编程的基本流程对于服务端是这样的 服务端 ...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/Boost/02.%20%E7%BD%91%E7%BB%9C/Boost.Asio%20%E8%A7%86%E9%A2%91/03.%20Asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:description","content":"视频：https://www.bilibili.com/video/BV1jm4y1r7AY 作者文档：https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS 传统的阻塞模型 网络编程的基本流程对于服务端是这样的 服务端 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.llfc.club/1540562-20190417002428451-62583604.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"LincZero"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://cdn.llfc.club/1540562-20190417002428451-62583604.jpg\\",\\"https://cdn.llfc.club/1676257797218.jpg\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":2,"title":"传统的阻塞模型","slug":"传统的阻塞模型","link":"#传统的阻塞模型","children":[]},{"level":2,"title":"现代化模型","slug":"现代化模型","link":"#现代化模型","children":[]},{"level":2,"title":"终端节点的创建","slug":"终端节点的创建","link":"#终端节点的创建","children":[]},{"level":2,"title":"创建socket","slug":"创建socket","link":"#创建socket","children":[]},{"level":2,"title":"绑定acceptor","slug":"绑定acceptor","link":"#绑定acceptor","children":[]},{"level":2,"title":"(完整)","slug":"完整","link":"#完整","children":[]},{"level":2,"title":"关于buffer","slug":"关于buffer","link":"#关于buffer","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":8.65,"words":2596},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/Boost/02. 网络/Boost.Asio 视频/03. Asio socket的创建和连接.md","excerpt":"<p>视频：https://www.bilibili.com/video/BV1jm4y1r7AY\\n作者文档：https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS</p>\\n<h2>传统的阻塞模型</h2>\\n<p>网络编程的基本流程对于服务端是这样的</p>\\n<p>服务端</p>\\n<ol>\\n<li>socket——创建socket对象。</li>\\n<li>bind——绑定本机ip+port。</li>\\n<li>listen——监听来电，若在监听到来电，则建立起连接。</li>\\n<li>accept——再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。</li>\\n<li>read、write——就是收发消息了。</li>\\n</ol>","autoDesc":true}');export{v as comp,m as data};
