import{_ as r,c as d,e,o as l}from"./app-CZqDObZ4.js";const a="/assets/4%E7%A7%8D%E6%95%B0-rrUYbnsl.png",s="/assets/80x86%E5%8F%AF%E8%A7%81%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84-BDSI6fIh.jpg",n="/assets/image-20211110020325687-B15YwM16.png",i="/assets/8%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8-B5vO8tPw.png",o="/assets/64%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8-WpGQPM7Y.jpg",p={};function h(c,t){return l(),d("div",null,t[0]||(t[0]=[e('<h1 id="computersystems" tabindex="-1"><a class="header-anchor" href="#computersystems"><span>ComputerSystems</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="寻址分析" tabindex="-1"><a class="header-anchor" href="#寻址分析"><span>寻址分析</span></a></h1><p>汇编代码能直接操作地址，当然只能操作CPU寻址范围内的地址 像GPU中的非共享地址则无法直接操作，但获取可以依赖编写共享内存的部分的汇编代码来间接编辑或访问</p><h2 id="寻址范围-8086-cpu" tabindex="-1"><a class="header-anchor" href="#寻址范围-8086-cpu"><span>寻址范围（8086 CPU）</span></a></h2><h3 id="几种存储单元" tabindex="-1"><a class="header-anchor" href="#几种存储单元"><span>几种存储单元</span></a></h3><p>8086处理器 (x86鼻祖)：16位处理器</p><p>寻址空间：一共20跟寻址线，2^20=1MB的空间 (按道理16位寄存器的寻址范围是2^16=64KB，这里居然超了，被拓展多了4根线。当然段寄存器和IP寄存器都依旧是16位的)</p><h4 id="存储单元之间的数据传输关系-mov" tabindex="-1"><a class="header-anchor" href="#存储单元之间的数据传输关系-mov"><span>存储单元之间的数据传输关系（mov）</span></a></h4><p><img src="'+a+'" alt="4种数" loading="lazy"></p><h3 id="内部-寻址范围" tabindex="-1"><a class="header-anchor" href="#内部-寻址范围"><span>内部 寻址范围</span></a></h3><h4 id="寄存器组" tabindex="-1"><a class="header-anchor" href="#寄存器组"><span><mark>寄存器组</mark></span></a></h4><p>8086cpu内部寄存器结构图 （注意如果是32/64位寄存器，有的会多一个前缀，例如ip-&gt;rip，sp-&gt;rsp）</p><ul><li>通用寄存器 (General Register) <ul><li>数据寄存器 (Data Register) <ul><li>AH|AL、AX累加器</li><li>BH|BL、BX基址寄存器</li><li>CH|CL、CX计数寄存器</li><li>DH|DL、DX数据寄存器</li></ul></li><li>变址/索引寄存器 (Index Register) <ul><li>SI、源变址寄存器 (Source Index)</li><li>DI、目的变址寄存器 (Destination Index)</li></ul></li><li>指针寄存器 (Pointer Register) <ul><li>BP、基址指针 (Base Pointer)</li><li>SP、堆栈指针 (Stack Pointer)</li></ul></li></ul></li><li>控制寄存器 (Control Register) <ul><li>IP、指令指针 (Index Pointer，而不是Internet Protocol)</li><li>FLAGS、标志寄存器 (Flags)</li></ul></li><li>段寄存器 (Segment Register) <ul><li>CS代码段寄存器 (Code Segment)</li><li>DS数据段寄存器 (Data Segment)</li><li>ES扩展段寄存器 (Extended Segment)</li><li>SS堆栈段寄存器 (Stack Segment)</li></ul></li></ul><img src="'+s+'" alt="80x86可见寄存器组" style="zoom:25%;"><p><img src="'+n+'" alt="image-20211110020325687" loading="lazy"></p><h4 id="通用寄存器-8086" tabindex="-1"><a class="header-anchor" href="#通用寄存器-8086"><span>通用寄存器 (8086)</span></a></h4><p>8086 16位寄存器：有8个16位通用寄存器，其中4个可以拆成2个8位寄存器</p><p><img src="'+i+'" alt="image-20211109192301811" loading="lazy"></p><h4 id="通用寄存器-64位" tabindex="-1"><a class="header-anchor" href="#通用寄存器-64位"><span>通用寄存器 (64位)</span></a></h4><p>64位通用寄存器：可以看到有很多的历史残留问题，导致命名不统一</p><img src="'+o+'" alt="IMG_20200924_063958" style="zoom:25%;"><table><thead><tr><th>8个字节</th><th>前4字节</th><th>前2字节</th><th>前1字节</th><th>含义</th><th>地址特征</th></tr></thead><tbody><tr><td>%<strong>r</strong>a<mark>x</mark></td><td>%<strong>e</strong>a<mark>x</mark></td><td>%a<mark>x</mark></td><td>%a<mark>l</mark></td><td>返回值</td><td>r?x，e?x，?x，?l【rule1】</td></tr><tr><td>%<strong>r</strong>b<mark>x</mark></td><td>%<strong>e</strong>b<mark>x</mark></td><td>%b<mark>x</mark></td><td>%b<mark>l</mark></td><td>被调用者保存</td><td>r?x，e?x，?x，?l【rule1】</td></tr><tr><td>%<strong>r</strong>c<mark>x</mark></td><td>%<strong>e</strong>c<mark>x</mark></td><td>%c<mark>x</mark></td><td>%c<mark>l</mark></td><td>第4个参数</td><td>r?x，e?x，?x，?l【rule1】</td></tr><tr><td>%<strong>r</strong>d<mark>x</mark></td><td>%<strong>e</strong>d<mark>x</mark></td><td>%d<mark>x</mark></td><td>%d<mark>l</mark></td><td>第3个参数</td><td>r?x，e?x，?x，?l【rule1】</td></tr><tr><td>%<strong>r</strong>s<strong>i</strong></td><td>%<strong>e</strong>s<strong>i</strong></td><td>%s<strong>i</strong></td><td>%si<mark>l</mark></td><td>第2个参数</td><td>r?i，e?i，?i，?l【rule2】</td></tr><tr><td>%<strong>r</strong>d<strong>i</strong></td><td>%<strong>e</strong>d<strong>i</strong></td><td>%d<strong>i</strong></td><td>%di<mark>l</mark></td><td>第1个参数</td><td>r?i，e?i，?i，?l【rule2】</td></tr><tr><td>%<strong>r</strong>b<strong>p</strong></td><td>%<strong>e</strong>b<strong>p</strong></td><td>%b<strong>p</strong></td><td>%bp<mark>l</mark></td><td>被调用者保存</td><td>r?p，e?p，?p，?l【rule3】</td></tr><tr><td>%<strong>r</strong>s<strong>p</strong></td><td>%<strong>e</strong>s<strong>p</strong></td><td>%s<strong>p</strong></td><td>%sp<mark>l</mark></td><td>栈指针（stack pointer）</td><td>r?p，e?p，?p，?l【rule3】</td></tr><tr><td>——</td><td>——</td><td>——</td><td>——</td><td>——</td><td>——（前后8行分割线）</td></tr><tr><td>%<strong>r</strong>8</td><td>%<strong>r</strong>8<mark>d</mark></td><td>%<strong>r</strong>8<mark>w</mark></td><td>%<strong>r</strong>8<mark>b</mark></td><td>第5个参数</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr><tr><td>%<strong>r</strong>9</td><td>%<strong>r</strong>9<mark>d</mark></td><td>%<strong>r</strong>9<mark>w</mark></td><td>%<strong>r</strong>9<mark>b</mark></td><td>第6个参数</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr><tr><td>%<strong>r</strong>10</td><td>%<strong>r</strong>10<mark>d</mark></td><td>%<strong>r</strong>10<mark>w</mark></td><td>%<strong>r</strong>10<mark>b</mark></td><td>调用者保存</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr><tr><td>%<strong>r</strong>11</td><td>%<strong>r</strong>11<mark>d</mark></td><td>%<strong>r</strong>11<mark>w</mark></td><td>%<strong>r</strong>11<mark>b</mark></td><td>调用者保存</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr><tr><td>%<strong>r</strong>12</td><td>%<strong>r</strong>12<mark>d</mark></td><td>%<strong>r</strong>12<mark>w</mark></td><td>%<strong>r</strong>12<mark>b</mark></td><td>被调用者保存</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr><tr><td>%<strong>r</strong>13</td><td>%<strong>r</strong>13<mark>d</mark></td><td>%<strong>r</strong>13<mark>w</mark></td><td>%<strong>r</strong>13<mark>b</mark></td><td>被调用者保存</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr><tr><td>%<strong>r</strong>14</td><td>%<strong>r</strong>14<mark>d</mark></td><td>%<strong>r</strong>14<mark>w</mark></td><td>%<strong>r</strong>14<mark>b</mark></td><td>被调用者保存</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr><tr><td>%<strong>r</strong>15</td><td>%<strong>r</strong>15<mark>d</mark></td><td>%<strong>r</strong>15<mark>w</mark></td><td>%<strong>r</strong>15<mark>b</mark></td><td>被调用者保存</td><td>r?p，r?d，r?w，r?b【rule4】</td></tr></tbody></table><blockquote><p>图表记法：（该死的，这命名好混乱，记不注，用时得查）</p><p>有含义的部分：（除了特别的几个，其他的就不记了，需要用再查，命名很混乱）</p><ul><li>8位的前8个寄存器：根据英文缩写来记</li><li>16位部分：abcd，x和l。例如：高8位ah-high，低8位是al-low，结合起来是ax</li><li>32位部分：前缀e：extended扩展</li><li>64位部分：前缀r：row行，r8~r15。_dwb分别表示_/double/word/byte，分别是四字/双字/字/字节</li></ul><p>新命名均r开头，后8个寄存器均r+数字开头</p><p>前四个寄存器均x/l结尾，前一个位为a/b/c/d</p></blockquote><p>所有16个寄存器的低位部分都可以作为自己、字(16位)、双字(32位)、四字(64位)数字来访问</p><p>那么当复制和生成1、2、4字节时，对于高位的处理有两条规则（生成8字节时：没有剩余字节）</p><ul><li>生成1、2字节时：保留前面剩下的</li><li>生成4字节时：高位的4字节置为0（该规则是作为从<code>IA32</code>到<code>x86-64</code>扩展的部分而使用的）</li></ul><h4 id="其他寄存器" tabindex="-1"><a class="header-anchor" href="#其他寄存器"><span>其他寄存器</span></a></h4><h5 id="标志寄存器-属于控制寄存器" tabindex="-1"><a class="header-anchor" href="#标志寄存器-属于控制寄存器"><span>标志寄存器（属于控制寄存器）</span></a></h5><p>调试汇编时输入r可以看到末尾的标志寄存器状态。大小写分别表示1和0</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>eflags 0x00000082: id vip vif ac vm rf nt IOPL=0 of df if tf SF zf af pf cf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>标志</th><th>单词</th><th>含义</th></tr></thead><tbody><tr><td>CF</td><td>Carry Flag</td><td>进位</td></tr><tr><td>PF</td><td>Even Flag</td><td>偶数</td></tr><tr><td>AF</td><td></td><td></td></tr><tr><td>ZF</td><td>Zero Flag</td><td>零标志</td></tr><tr><td>SF</td><td>Sign Flag</td><td>符号位，负数位</td></tr><tr><td>TF</td><td></td><td></td></tr><tr><td>IF</td><td></td><td></td></tr><tr><td>DF</td><td></td><td></td></tr><tr><td>OF</td><td>Overflow Flag</td><td>溢出位</td></tr></tbody></table><p>要结合<code>Jcc</code>（条件转移指令）来使用</p><p>jmp是直接跳转，而jcc是符合条件才会跳转</p><h3 id="外部-寻址范围" tabindex="-1"><a class="header-anchor" href="#外部-寻址范围"><span>外部 寻址范围</span></a></h3><h4 id="寻址范围-全部" tabindex="-1"><a class="header-anchor" href="#寻址范围-全部"><span>寻址范围 - 全部</span></a></h4><p>并不是显卡、BIOS等全部都映射到内存空间，只是将CPU寻址范围内的部分地址分配给其他设备</p><table><thead><tr><th>寻址范围</th><th>(共1MB)</th><th>分配给</th></tr></thead><tbody><tr><td>0x00000~0x9FFFF</td><td>64*11 = 640KB</td><td>内存 DRAM</td></tr><tr><td>0xAFFFF~0xBFFFF</td><td>64*02 = 128KB</td><td>显卡（包括文字模式、图像模式在内的显示部分）</td></tr><tr><td>0xCFFFF~0xFFFFF</td><td>64*04 = 256KB</td><td>假装内存的BIOS（ROM芯片、显卡、硬盘等的BIOS）</td></tr></tbody></table><h4 id="寻址范围-内存-ibm-pc-5150" tabindex="-1"><a class="header-anchor" href="#寻址范围-内存-ibm-pc-5150"><span>寻址范围 - 内存 (IBM PC 5150)</span></a></h4><p>IBM PC 5150中的ROM BIOS构成（历史残留）</p><table><thead><tr><th>内存范围</th><th>(共640KB)</th><th>分配给</th></tr></thead><tbody><tr><td>0x0000~0x???? (最开头)</td><td>未知</td><td>BIOS产生的<code>中断向量表以及BIOS的数据</code></td></tr><tr><td>(中间)</td><td>未知</td><td>其他</td></tr><tr><td>0x7c00~0x7FFF (最末端)</td><td>1KB</td><td>1024B大小的BootLoader</td></tr></tbody></table><p>开机时DRAM内存空间的变化</p><ul><li><p>(1) CPU收到RST信号，IP被强制定位到ROM，从ROM取指令和执行</p></li><li><p>(2) BIOS程序执行过程中，产生一个<code>中断向量表</code>的东西，DRAM被消耗了一部分</p></li><li><p>(3) BIOS执行完POST后，开始在外部存储设备中找<code>BootLoader</code>，并加载到内存里 而因为BootLoader将系统拉起来后内存就可以被释放了，所以它加载的位置在末端</p><ul><li><p>其中IBM PC 5150中支持的最小内存是32KB (0x0000~0x7FFF，8086则是64KB)</p></li><li><p>其中BootLoader的Boot扇区也就是<code>MBR扇区是512B</code>，<code>栈/数据是512B</code>，共计1KB</p></li><li><p>也就是BootLoader的位置在：32KB-1KB+1=<code>0x7c00</code></p></li></ul></li></ul><h4 id="寻址范围-内存-8086" tabindex="-1"><a class="header-anchor" href="#寻址范围-内存-8086"><span>寻址范围 - 内存 (8086)</span></a></h4><p>从IBM PC 5150的32KB，后来内存扩展到1MB到现在的数GB，这个<code>0x07c00</code>的位置也没变</p><table><thead><tr><th>内存范围</th><th>(共640KB)</th><th>分配给</th></tr></thead><tbody><tr><td>0x00000~0x07BFF (最开头)</td><td>未知</td><td>BIOS产生的<code>中断向量表以及BIOS的数据</code></td></tr><tr><td>0x07C00~0x07DFF (非最末端)</td><td>512B</td><td>1024B大小的BootLoader</td></tr><tr><td>0x07E00~0x07FFF (非最末端)</td><td>512B</td><td>1024B大小的BootLoader</td></tr><tr><td>0x08000~0x9FFFF (最末端)</td><td>未知</td><td>其他</td></tr></tbody></table><ul><li>查看内存中cpu寻址的范围 <ul><li>和下面显卡的查看方式不同，内存在设备管理器中居然是不显示的！</li><li>内存可能很大 (4/8/16/32GB)，但系统只给它分配几百MB的地址空间</li></ul></li></ul><h4 id="寻址范围-显卡" tabindex="-1"><a class="header-anchor" href="#寻址范围-显卡"><span>寻址范围 - 显卡</span></a></h4><p>这部分其实本质上就是内存，当时的显卡是集成显卡，没有独显。显然这部分的本质就是内存，可以当内存使用</p><table><thead><tr><th>显存范围</th><th>(共128KB)</th><th>分配给</th></tr></thead><tbody><tr><td>0xA0000~0xAFFFF</td><td>64KB</td><td>EGA/<strong>VGA</strong>/XGA/XVGA 彩色图形</td></tr><tr><td>0xB0000~0xB7FFF</td><td>32KB</td><td>Mono text video buffer 黑白文本</td></tr><tr><td>0xB8000~0xBFFFF</td><td>32KB</td><td>CGA/EGA + chroma text video buffer 彩色文本</td></tr></tbody></table><ul><li><p>查看显存中cpu寻址的范围</p><ul><li>Win+X &gt; 设备管理器 &gt; 显示适配器 &gt; 选择你的显卡并双击 &gt; 资源菜单 &gt; 资源设置中可以看到分配给内存的显存范围</li><li>显卡显存可能很大 (4/8/16/24GB)，但系统只给它分配几百MB的地址空间 我的电脑：显存大小24GB，专用8GB，共享16GB。分配的显存大小？？<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>16</mn><mn>6</mn></msup><mo>∗</mo><mn>4</mn><mo>+</mo><msup><mn>16</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">16^6*4+16^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> =64MB+64KB？？（应该是我算漏了，少了）</li></ul></li><li><p>显存分配原理</p><ul><li>看起来比较小，但可以作为地址映射出去</li><li>例如使用256MB来映射4GB的显存，显卡也存在自己的汇编指令（可以切换映射到地址空间的显存等。话说Shared是吗）</li></ul></li></ul><h2 id="寻址方法" tabindex="-1"><a class="header-anchor" href="#寻址方法"><span>寻址方法</span></a></h2><h3 id="寄存器寻址方法-8086分段机制" tabindex="-1"><a class="header-anchor" href="#寄存器寻址方法-8086分段机制"><span>寄存器寻址方法（8086分段机制）</span></a></h3><p>8086分段机制：解决16位寄存器无法访问全部1MB地址空间的问题，而且程序重定位也变得简单（ROM-BIOS或操作系统可以进行调度）</p><h4 id="内存偏移" tabindex="-1"><a class="header-anchor" href="#内存偏移"><span>内存偏移</span></a></h4><ul><li>代码段和数据段是分别的两段连续的内存（冯诺依曼架构）</li><li>CS寄存器：代码段的开头。CS指定代码段基准地址、IP指定代码段偏移地址</li><li>DS寄存器：数据段的开头。DS指定数据段基准地址、增加相应的偏移地址来访问数据</li><li>CPU的IP存储的不是绝对物理地址，而是相对于CS的偏移。CPU访问通过<code>段地址: 偏移地址</code>的模式来</li></ul><h4 id="段地址-偏移地址-8086中16位寄存器如何存储20位的寻址范围" tabindex="-1"><a class="header-anchor" href="#段地址-偏移地址-8086中16位寄存器如何存储20位的寻址范围"><span>段地址：偏移地址（8086中16位寄存器如何存储20位的寻址范围 )</span></a></h4><p>寻址问题</p><ul><li>8086 CPU 20位，总寻址范围：2^20=1MB</li><li>8086寄存器仅16位，能存储地址的数量：2^16=64KB</li><li>即寄存器不能存储CPU寻址范围内的所有地址？——此时需要<code>段地址：偏移地址</code>的寻址方式</li></ul><p>解决方法</p><ul><li><p>两个16位寄存器</p><ul><li>段寄存器：ds，存物理地址 16字节对齐：每个段的起始地址，都必须是16的倍数</li><li>偏移地址寄存器：ax，存逻辑地址</li></ul></li><li><p>寻址范围分段</p><ul><li>8086的1MB空间切分时</li><li>最少可分16个段，每段64KB（1MB = 16x64KB = (2^4)x64KB）</li><li>最多可分64K个段，每段16B</li><li>实际使用过程中灵活性很大，可以分为16、32、64、128......65536个段</li></ul></li><li><p>使用</p><ul><li><p>逻辑地址 = 段地址:偏移地址 = 段地址左移4位+便宜地址 = 实际物理地址</p></li><li><p>扩展思考：一个物理地址可能由多少个逻辑地址来表示？</p><ul><li><p>举例：设物理地址0x00010 (17)，此时两种</p><table><thead><tr><th>段数</th><th>逻辑地址</th></tr></thead><tbody><tr><td>16</td><td>0x0000::0x0010</td></tr><tr><td>32</td><td>0x0000::0x0010</td></tr><tr><td>......</td><td>0x0000::0x0010</td></tr><tr><td>32768</td><td>0x0000::0x0010</td></tr><tr><td>65536</td><td>0x0001::0x0000</td></tr></tbody></table></li><li><p>举例：设物理地址0xFFFFF，此时则比较麻烦，16-4+1=12种</p></li></ul></li></ul></li></ul><h4 id="代码段-汇编地址" tabindex="-1"><a class="header-anchor" href="#代码段-汇编地址"><span>代码段 - 汇编地址</span></a></h4><p>PC是如何指导程序的位置呢？</p><p>汇编地址：</p><ul><li>编译时 汇编代码通过nasm编译成bin文件时，nasm会把汇编.asm当成一整个代码段， 里面的每一条指令都会有一个相对于代码头部的偏移地址，<strong>这个偏移地址就是汇编地址</strong></li><li>加载时 bin在虚拟机或真机上运行时，ROM-BIOS程序将Start.bin加载到内存。具体加载到内存的什么位置，视程序大小和内存闲置空间而定自动分配，分配好后该这段程序有了一个起始物理地址，该地址给CS (代码段寄存器)</li><li>执行时 CPU按<code>CS:IP</code> (代码段寄存器：指令指针) 的逻辑地址去取指令</li></ul><h4 id="堆栈段-vs-数据段、代码段" tabindex="-1"><a class="header-anchor" href="#堆栈段-vs-数据段、代码段"><span>堆栈段 vs 数据段、代码段</span></a></h4><p>栈段与代码段类似的</p><ul><li>代码段：CS (代码段寄存器) 保存代码段的基址，IP (指令指针) 保存相对于基址的偏移</li><li>数据段：DS (数据段寄存器) 保存数据段的基址，ax等 (数据寄存器) 表示相对于基址的偏移</li><li>栈段：SS (堆栈段寄存器) 保存代码段的基址，SP (堆栈指针) 保存相对于基址的偏移</li></ul><p>区别</p><ul><li>内容不同 <ul><li>IP指向当前在运行的指令</li><li>SP也叫栈顶指针，指向栈顶</li></ul></li><li>方向不同 <ul><li>栈的走向跟数据段或代码段不一样</li><li>数据段和代码段：从内存低处向高处进行。例如代码从开始0x7c00，下条可能为0x7c02</li><li>栈段：从内存高处向低处进行。push操作让sp减少，pop操作让sp增大</li></ul></li></ul><h2 id="访问方式" tabindex="-1"><a class="header-anchor" href="#访问方式"><span>访问方式</span></a></h2><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>之前运行起来是在512字节的启动扇区写入，我们写的是BootLoader程序</p><ul><li>CPU与统一编址设备之间使用<code>mov</code>存入寄存器并访问</li><li>CPU与独立编址设置之间使用<code>in/out</code>指令来访问，也是通过端口来访问的。端口本质是寄存器的代号</li></ul><p>设备端口原理</p><ul><li>显卡、硬盘上都有自己的寄存器，8~16位不等</li><li>CPU读写不同的端口，实际上是在读写设备的寄存器</li><li>ICH (I/O Controler Hub)</li></ul><h3 id="使用汇编读取硬盘-寻址范围外" tabindex="-1"><a class="header-anchor" href="#使用汇编读取硬盘-寻址范围外"><span>使用汇编读取硬盘（寻址范围外）</span></a></h3><p>计算机主硬盘分配了8个端口，0x1f0~1f7</p><p>从硬盘访问数据的方式</p><ul><li>CHS (Cylinders Heads Sectors，柱面磁头扇区)：需要磁头、柱面和扇区的信息。但这种方式太过繁琐，而且像固态硬盘根本没有这些信息的也不适合</li><li>LBA (Logical Block Addressing，逻辑块寻址)：主流方式，比较快</li></ul><h2 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存"><span>虚拟内存</span></a></h2><table><thead><tr><th style="text-align:center;">虚拟地址空间</th><th>补充说明</th></tr></thead><tbody><tr><td style="text-align:center;">内核虚拟内存</td><td>【顶部区域】不允许应用程序读写和调用，必须通过调用内核来执行这些操作</td></tr><tr><td style="text-align:center;">用户栈<br>（往下增长）</td><td>运行时创建<br>【动态大小】每次调用函数栈增长，函数返回时栈会收缩</td></tr><tr><td style="text-align:center;">↕</td><td></td></tr><tr><td style="text-align:center;">共享库的内存映射区域<br>（往上增长）</td><td>【动态大小】存放像C标准库和数学库这样共享库代码和数据的地方</td></tr><tr><td style="text-align:center;">↑</td><td></td></tr><tr><td style="text-align:center;">运行时堆<br>（往上增长）</td><td>运行时由malloc创建<br>【动态大小】调用malloc和free这样的C标准库函数时可动态扩展和收缩</td></tr><tr><td style="text-align:center;">读/写数据</td><td>从hello可执行文件加载进来的程序代码和数据</td></tr><tr><td style="text-align:center;">只读的代码和数据</td><td>【开始区域】从hello可执行文件加载进来的程序代码和数据</td></tr></tbody></table>',82)]))}const g=r(p,[["render",h],["__file","01. 寻址分析.html.vue"]]),u=JSON.parse('{"path":"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/02.%20%E6%B1%87%E7%BC%96%E6%95%B0%E6%8D%AE/01.%20%E5%AF%BB%E5%9D%80%E5%88%86%E6%9E%90.html","title":"ComputerSystems","lang":"zh-CN","frontmatter":{"description":"ComputerSystems 目录 寻址分析 汇编代码能直接操作地址，当然只能操作CPU寻址范围内的地址 像GPU中的非共享地址则无法直接操作，但获取可以依赖编写共享内存的部分的汇编代码来间接编辑或访问 寻址范围（8086 CPU） 几种存储单元 8086处理器 (x86鼻祖)：16位处理器 寻址空间：一共20跟寻址线，2^20=1MB的空间 (按道...","head":[["meta",{"property":"og:url","content":"https://LincZero.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/02.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/02.%20%E6%B1%87%E7%BC%96%E6%95%B0%E6%8D%AE/01.%20%E5%AF%BB%E5%9D%80%E5%88%86%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"Linc 的小站"}],["meta",{"property":"og:title","content":"ComputerSystems"}],["meta",{"property":"og:description","content":"ComputerSystems 目录 寻址分析 汇编代码能直接操作地址，当然只能操作CPU寻址范围内的地址 像GPU中的非共享地址则无法直接操作，但获取可以依赖编写共享内存的部分的汇编代码来间接编辑或访问 寻址范围（8086 CPU） 几种存储单元 8086处理器 (x86鼻祖)：16位处理器 寻址空间：一共20跟寻址线，2^20=1MB的空间 (按道..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ComputerSystems\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\",\\"url\\":\\"https://github.com/LincZero/\\"}]}"]]},"headers":[{"level":1,"title":"ComputerSystems","slug":"computersystems","link":"#computersystems","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"寻址分析","slug":"寻址分析","link":"#寻址分析","children":[{"level":2,"title":"寻址范围（8086 CPU）","slug":"寻址范围-8086-cpu","link":"#寻址范围-8086-cpu","children":[{"level":3,"title":"几种存储单元","slug":"几种存储单元","link":"#几种存储单元","children":[{"level":4,"title":"存储单元之间的数据传输关系（mov）","slug":"存储单元之间的数据传输关系-mov","link":"#存储单元之间的数据传输关系-mov","children":[]}]},{"level":3,"title":"内部 寻址范围","slug":"内部-寻址范围","link":"#内部-寻址范围","children":[{"level":4,"title":"寄存器组","slug":"寄存器组","link":"#寄存器组","children":[]},{"level":4,"title":"通用寄存器 (8086)","slug":"通用寄存器-8086","link":"#通用寄存器-8086","children":[]},{"level":4,"title":"通用寄存器 (64位)","slug":"通用寄存器-64位","link":"#通用寄存器-64位","children":[]},{"level":4,"title":"其他寄存器","slug":"其他寄存器","link":"#其他寄存器","children":[{"level":5,"title":"标志寄存器（属于控制寄存器）","slug":"标志寄存器-属于控制寄存器","link":"#标志寄存器-属于控制寄存器","children":[]}]}]},{"level":3,"title":"外部 寻址范围","slug":"外部-寻址范围","link":"#外部-寻址范围","children":[{"level":4,"title":"寻址范围 - 全部","slug":"寻址范围-全部","link":"#寻址范围-全部","children":[]},{"level":4,"title":"寻址范围 - 内存 (IBM PC 5150)","slug":"寻址范围-内存-ibm-pc-5150","link":"#寻址范围-内存-ibm-pc-5150","children":[]},{"level":4,"title":"寻址范围 - 内存 (8086)","slug":"寻址范围-内存-8086","link":"#寻址范围-内存-8086","children":[]},{"level":4,"title":"寻址范围 - 显卡","slug":"寻址范围-显卡","link":"#寻址范围-显卡","children":[]}]}]},{"level":2,"title":"寻址方法","slug":"寻址方法","link":"#寻址方法","children":[{"level":3,"title":"寄存器寻址方法（8086分段机制）","slug":"寄存器寻址方法-8086分段机制","link":"#寄存器寻址方法-8086分段机制","children":[{"level":4,"title":"内存偏移","slug":"内存偏移","link":"#内存偏移","children":[]},{"level":4,"title":"段地址：偏移地址（8086中16位寄存器如何存储20位的寻址范围 )","slug":"段地址-偏移地址-8086中16位寄存器如何存储20位的寻址范围","link":"#段地址-偏移地址-8086中16位寄存器如何存储20位的寻址范围","children":[]},{"level":4,"title":"代码段 - 汇编地址","slug":"代码段-汇编地址","link":"#代码段-汇编地址","children":[]},{"level":4,"title":"堆栈段 vs 数据段、代码段","slug":"堆栈段-vs-数据段、代码段","link":"#堆栈段-vs-数据段、代码段","children":[]}]}]},{"level":2,"title":"访问方式","slug":"访问方式","link":"#访问方式","children":[{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"使用汇编读取硬盘（寻址范围外）","slug":"使用汇编读取硬盘-寻址范围外","link":"#使用汇编读取硬盘-寻址范围外","children":[]}]},{"level":2,"title":"虚拟内存","slug":"虚拟内存","link":"#虚拟内存","children":[]}]}],"git":{},"readingTime":{"minutes":12.01,"words":3603},"filePathRelative":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/02. 汇编数据/01. 寻址分析.md","excerpt":"\\n<h1>目录</h1>\\n<h1>寻址分析</h1>\\n<p>汇编代码能直接操作地址，当然只能操作CPU寻址范围内的地址\\n像GPU中的非共享地址则无法直接操作，但获取可以依赖编写共享内存的部分的汇编代码来间接编辑或访问</p>\\n<h2>寻址范围（8086 CPU）</h2>\\n<h3>几种存储单元</h3>\\n<p>8086处理器 (x86鼻祖)：16位处理器</p>\\n<p>寻址空间：一共20跟寻址线，2^20=1MB的空间\\n(按道理16位寄存器的寻址范围是2^16=64KB，这里居然超了，被拓展多了4根线。当然段寄存器和IP寄存器都依旧是16位的)</p>\\n<h4>存储单元之间的数据传输关系（mov）</h4>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/02. 汇编数据/01. 寻址分析.md","value":{"title":"01. 寻址分析","path":"MdNote_Public/01. DesignAndDevelop/Develop/02. Theory/Computer/02. 计算机指令/02. 汇编数据/01. 寻址分析.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{g as comp,u as data};
